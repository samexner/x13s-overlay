diff -Nrup linux-6.16.7/arch/arm/boot/dts/allwinner/sun8i-a23-ippo-q8h-v1.2.dts linux-lenovo-x13s-linux-6.16.y/arch/arm/boot/dts/allwinner/sun8i-a23-ippo-q8h-v1.2.dts
--- linux-6.16.7/arch/arm/boot/dts/allwinner/sun8i-a23-ippo-q8h-v1.2.dts	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm/boot/dts/allwinner/sun8i-a23-ippo-q8h-v1.2.dts	2025-09-11 09:47:42.000000000 -0600
@@ -1,73 +1 @@
-/*
- * Copyright 2015 Hans de Goede <hdegoede@redhat.com>
- *
- * This file is dual-licensed: you can use it either under the terms
- * of the GPL or the X11 license, at your option. Note that this dual
- * licensing only applies to this file, and not this project as a
- * whole.
- *
- *  a) This file is free software; you can redistribute it and/or
- *     modify it under the terms of the GNU General Public License as
- *     published by the Free Software Foundation; either version 2 of the
- *     License, or (at your option) any later version.
- *
- *     This file is distributed in the hope that it will be useful,
- *     but WITHOUT ANY WARRANTY; without even the implied warranty of
- *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *     GNU General Public License for more details.
- *
- * Or, alternatively,
- *
- *  b) Permission is hereby granted, free of charge, to any person
- *     obtaining a copy of this software and associated documentation
- *     files (the "Software"), to deal in the Software without
- *     restriction, including without limitation the rights to use,
- *     copy, modify, merge, publish, distribute, sublicense, and/or
- *     sell copies of the Software, and to permit persons to whom the
- *     Software is furnished to do so, subject to the following
- *     conditions:
- *
- *     The above copyright notice and this permission notice shall be
- *     included in all copies or substantial portions of the Software.
- *
- *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
- *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
- *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- *     OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/dts-v1/;
-#include "sun8i-a23.dtsi"
-#include "sun8i-q8-common.dtsi"
-
-/ {
-	model = "Q8 A23 Tablet";
-	compatible = "allwinner,q8-a23", "allwinner,sun8i-a23";
-};
-
-&codec {
-	allwinner,pa-gpios = <&pio 7 9 GPIO_ACTIVE_HIGH>; /* PH9 */
-	allwinner,audio-routing =
-		"Headphone", "HP",
-		"Headphone", "HPCOM",
-		"Speaker", "HP",
-		"MIC1", "Mic",
-		"MIC2", "Headset Mic",
-		"Mic",  "MBIAS",
-		"Headset Mic", "HBIAS";
-	status = "okay";
-};
-
-&panel {
-	compatible = "bananapi,s070wv20-ct16";
-};
-
-&tcon0_out {
-	tcon0_out_lcd: endpoint {
-		remote-endpoint = <&panel_input>;
-	};
-};
+sun8i-a23-q8-tablet.dts
\ No newline at end of file
diff -Nrup linux-6.16.7/arch/arm/boot/dts/allwinner/sun8i-a23-ippo-q8h-v5.dts linux-lenovo-x13s-linux-6.16.y/arch/arm/boot/dts/allwinner/sun8i-a23-ippo-q8h-v5.dts
--- linux-6.16.7/arch/arm/boot/dts/allwinner/sun8i-a23-ippo-q8h-v5.dts	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm/boot/dts/allwinner/sun8i-a23-ippo-q8h-v5.dts	2025-09-11 09:47:42.000000000 -0600
@@ -1,73 +1 @@
-/*
- * Copyright 2015 Hans de Goede <hdegoede@redhat.com>
- *
- * This file is dual-licensed: you can use it either under the terms
- * of the GPL or the X11 license, at your option. Note that this dual
- * licensing only applies to this file, and not this project as a
- * whole.
- *
- *  a) This file is free software; you can redistribute it and/or
- *     modify it under the terms of the GNU General Public License as
- *     published by the Free Software Foundation; either version 2 of the
- *     License, or (at your option) any later version.
- *
- *     This file is distributed in the hope that it will be useful,
- *     but WITHOUT ANY WARRANTY; without even the implied warranty of
- *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *     GNU General Public License for more details.
- *
- * Or, alternatively,
- *
- *  b) Permission is hereby granted, free of charge, to any person
- *     obtaining a copy of this software and associated documentation
- *     files (the "Software"), to deal in the Software without
- *     restriction, including without limitation the rights to use,
- *     copy, modify, merge, publish, distribute, sublicense, and/or
- *     sell copies of the Software, and to permit persons to whom the
- *     Software is furnished to do so, subject to the following
- *     conditions:
- *
- *     The above copyright notice and this permission notice shall be
- *     included in all copies or substantial portions of the Software.
- *
- *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
- *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
- *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- *     OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/dts-v1/;
-#include "sun8i-a23.dtsi"
-#include "sun8i-q8-common.dtsi"
-
-/ {
-	model = "Q8 A23 Tablet";
-	compatible = "allwinner,q8-a23", "allwinner,sun8i-a23";
-};
-
-&codec {
-	allwinner,pa-gpios = <&pio 7 9 GPIO_ACTIVE_HIGH>; /* PH9 */
-	allwinner,audio-routing =
-		"Headphone", "HP",
-		"Headphone", "HPCOM",
-		"Speaker", "HP",
-		"MIC1", "Mic",
-		"MIC2", "Headset Mic",
-		"Mic",  "MBIAS",
-		"Headset Mic", "HBIAS";
-	status = "okay";
-};
-
-&panel {
-	compatible = "bananapi,s070wv20-ct16";
-};
-
-&tcon0_out {
-	tcon0_out_lcd: endpoint {
-		remote-endpoint = <&panel_input>;
-	};
-};
+sun8i-a23-q8-tablet.dts
\ No newline at end of file
diff -Nrup linux-6.16.7/arch/arm/boot/dts/allwinner/sun8i-a33-et-q8-v1.6.dts linux-lenovo-x13s-linux-6.16.y/arch/arm/boot/dts/allwinner/sun8i-a33-et-q8-v1.6.dts
--- linux-6.16.7/arch/arm/boot/dts/allwinner/sun8i-a33-et-q8-v1.6.dts	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm/boot/dts/allwinner/sun8i-a33-et-q8-v1.6.dts	2025-09-11 09:47:42.000000000 -0600
@@ -1,57 +1 @@
-/*
- * Copyright 2015 Hans de Goede <hdegoede@redhat.com>
- *
- * This file is dual-licensed: you can use it either under the terms
- * of the GPL or the X11 license, at your option. Note that this dual
- * licensing only applies to this file, and not this project as a
- * whole.
- *
- *  a) This file is free software; you can redistribute it and/or
- *     modify it under the terms of the GNU General Public License as
- *     published by the Free Software Foundation; either version 2 of the
- *     License, or (at your option) any later version.
- *
- *     This file is distributed in the hope that it will be useful,
- *     but WITHOUT ANY WARRANTY; without even the implied warranty of
- *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *     GNU General Public License for more details.
- *
- * Or, alternatively,
- *
- *  b) Permission is hereby granted, free of charge, to any person
- *     obtaining a copy of this software and associated documentation
- *     files (the "Software"), to deal in the Software without
- *     restriction, including without limitation the rights to use,
- *     copy, modify, merge, publish, distribute, sublicense, and/or
- *     sell copies of the Software, and to permit persons to whom the
- *     Software is furnished to do so, subject to the following
- *     conditions:
- *
- *     The above copyright notice and this permission notice shall be
- *     included in all copies or substantial portions of the Software.
- *
- *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
- *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
- *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- *     OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/dts-v1/;
-#include "sun8i-a33.dtsi"
-#include "sun8i-q8-common.dtsi"
-
-/ {
-	model = "Q8 A33 Tablet";
-	compatible = "allwinner,q8-a33", "allwinner,sun8i-a33";
-};
-
-&tcon0_out {
-	tcon0_out_lcd: endpoint@0 {
-		reg = <0>;
-		remote-endpoint = <&panel_input>;
-	};
-};
+sun8i-a33-q8-tablet.dts
\ No newline at end of file
diff -Nrup linux-6.16.7/arch/arm/boot/dts/allwinner/sun8i-a33-ippo-q8h-v1.2.dts linux-lenovo-x13s-linux-6.16.y/arch/arm/boot/dts/allwinner/sun8i-a33-ippo-q8h-v1.2.dts
--- linux-6.16.7/arch/arm/boot/dts/allwinner/sun8i-a33-ippo-q8h-v1.2.dts	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm/boot/dts/allwinner/sun8i-a33-ippo-q8h-v1.2.dts	2025-09-11 09:47:42.000000000 -0600
@@ -1,57 +1 @@
-/*
- * Copyright 2015 Hans de Goede <hdegoede@redhat.com>
- *
- * This file is dual-licensed: you can use it either under the terms
- * of the GPL or the X11 license, at your option. Note that this dual
- * licensing only applies to this file, and not this project as a
- * whole.
- *
- *  a) This file is free software; you can redistribute it and/or
- *     modify it under the terms of the GNU General Public License as
- *     published by the Free Software Foundation; either version 2 of the
- *     License, or (at your option) any later version.
- *
- *     This file is distributed in the hope that it will be useful,
- *     but WITHOUT ANY WARRANTY; without even the implied warranty of
- *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *     GNU General Public License for more details.
- *
- * Or, alternatively,
- *
- *  b) Permission is hereby granted, free of charge, to any person
- *     obtaining a copy of this software and associated documentation
- *     files (the "Software"), to deal in the Software without
- *     restriction, including without limitation the rights to use,
- *     copy, modify, merge, publish, distribute, sublicense, and/or
- *     sell copies of the Software, and to permit persons to whom the
- *     Software is furnished to do so, subject to the following
- *     conditions:
- *
- *     The above copyright notice and this permission notice shall be
- *     included in all copies or substantial portions of the Software.
- *
- *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
- *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
- *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- *     OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/dts-v1/;
-#include "sun8i-a33.dtsi"
-#include "sun8i-q8-common.dtsi"
-
-/ {
-	model = "Q8 A33 Tablet";
-	compatible = "allwinner,q8-a33", "allwinner,sun8i-a33";
-};
-
-&tcon0_out {
-	tcon0_out_lcd: endpoint@0 {
-		reg = <0>;
-		remote-endpoint = <&panel_input>;
-	};
-};
+sun8i-a33-q8-tablet.dts
\ No newline at end of file
diff -Nrup linux-6.16.7/arch/arm/configs/qcom_defconfig linux-lenovo-x13s-linux-6.16.y/arch/arm/configs/qcom_defconfig
--- linux-6.16.7/arch/arm/configs/qcom_defconfig	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm/configs/qcom_defconfig	2025-09-11 09:47:42.000000000 -0600
@@ -57,7 +57,7 @@ CONFIG_MAC80211=m
 CONFIG_RFKILL=y
 CONFIG_PCI=y
 CONFIG_PCI_MSI=y
-CONFIG_PCIE_QCOM=y
+CONFIG_PCIE_QCOM=m
 CONFIG_DEVTMPFS=y
 CONFIG_DEVTMPFS_MOUNT=y
 CONFIG_MTD=y
diff -Nrup linux-6.16.7/arch/arm64/boot/dts/qcom/sa8295p-adp.dts linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sa8295p-adp.dts
--- linux-6.16.7/arch/arm64/boot/dts/qcom/sa8295p-adp.dts	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sa8295p-adp.dts	2025-09-11 09:47:42.000000000 -0600
@@ -631,12 +631,10 @@
 };
 
 &usb_0 {
-	status = "okay";
-};
-
-&usb_0_dwc3 {
 	/* TODO: Define USB-C connector properly */
 	dr_mode = "peripheral";
+
+	status = "okay";
 };
 
 &usb_0_hsphy {
@@ -655,12 +653,10 @@
 };
 
 &usb_1 {
-	status = "okay";
-};
-
-&usb_1_dwc3 {
 	/* TODO: Define USB-C connector properly */
 	dr_mode = "host";
+
+	status = "okay";
 };
 
 &usb_1_hsphy {
diff -Nrup linux-6.16.7/arch/arm64/boot/dts/qcom/sa8540p-ride.dts linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sa8540p-ride.dts
--- linux-6.16.7/arch/arm64/boot/dts/qcom/sa8540p-ride.dts	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sa8540p-ride.dts	2025-09-11 09:47:42.000000000 -0600
@@ -462,11 +462,8 @@
 };
 
 &usb_0 {
-	status = "okay";
-};
-
-&usb_0_dwc3 {
 	dr_mode = "peripheral";
+	status = "okay";
 };
 
 &usb_0_hsphy {
diff -Nrup linux-6.16.7/arch/arm64/boot/dts/qcom/sc8280xp-crd.dts linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sc8280xp-crd.dts
--- linux-6.16.7/arch/arm64/boot/dts/qcom/sc8280xp-crd.dts	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sc8280xp-crd.dts	2025-09-11 09:47:42.000000000 -0600
@@ -815,11 +815,9 @@
 };
 
 &usb_0 {
-	status = "okay";
-};
-
-&usb_0_dwc3 {
 	dr_mode = "host";
+
+	status = "okay";
 };
 
 &usb_0_dwc3_hs {
@@ -852,11 +850,9 @@
 };
 
 &usb_1 {
-	status = "okay";
-};
-
-&usb_1_dwc3 {
 	dr_mode = "host";
+
+	status = "okay";
 };
 
 &usb_1_dwc3_hs {
diff -Nrup linux-6.16.7/arch/arm64/boot/dts/qcom/sc8280xp.dtsi linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sc8280xp.dtsi
--- linux-6.16.7/arch/arm64/boot/dts/qcom/sc8280xp.dtsi	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sc8280xp.dtsi	2025-09-11 09:47:42.000000000 -0600
@@ -10,6 +10,7 @@
 #include <dt-bindings/clock/qcom,rpmh.h>
 #include <dt-bindings/clock/qcom,sc8280xp-camcc.h>
 #include <dt-bindings/clock/qcom,sc8280xp-lpasscc.h>
+#include <dt-bindings/clock/qcom,sm8350-videocc.h>
 #include <dt-bindings/interconnect/qcom,osm-l3.h>
 #include <dt-bindings/interconnect/qcom,sc8280xp.h>
 #include <dt-bindings/interrupt-controller/arm-gic.h>
@@ -390,6 +391,15 @@
 		reg = <0x0 0x80000000 0x0 0x0>;
 	};
 
+	cci_opp_table: opp-table-cci {
+		compatible = "operating-points-v2";
+
+		opp-37500000 {
+			opp-hz = /bits/ 64 <37500000>;
+			required-opps = <&rpmhpd_opp_low_svs>;
+		};
+	};
+
 	cpu0_opp_table: opp-table-cpu0 {
 		compatible = "operating-points-v2";
 		opp-shared;
@@ -690,6 +700,11 @@
 			no-map;
 		};
 
+		pil_video_mem: pil_video_region@86700000 {
+			reg = <0 0x86700000 0 0x500000>;
+			no-map;
+		};
+
 		pil_adsp_mem: adsp-region@86c00000 {
 			reg = <0 0x86c00000 0 0x2000000>;
 			no-map;
@@ -3556,12 +3571,9 @@
 			interrupts = <GIC_SPI 582 IRQ_TYPE_LEVEL_HIGH>;
 		};
 
-		usb_2: usb@a4f8800 {
-			compatible = "qcom,sc8280xp-dwc3-mp", "qcom,dwc3";
-			reg = <0 0x0a4f8800 0 0x400>;
-			#address-cells = <2>;
-			#size-cells = <2>;
-			ranges;
+		usb_2: usb@a400000 {
+			compatible = "qcom,sc8280xp-dwc3-mp", "qcom,snps-dwc3";
+			reg = <0 0x0a400000 0 0x10000>;
 
 			clocks = <&gcc GCC_CFG_NOC_USB3_MP_AXI_CLK>,
 				 <&gcc GCC_USB30_MP_MASTER_CLK>,
@@ -3579,7 +3591,8 @@
 					  <&gcc GCC_USB30_MP_MASTER_CLK>;
 			assigned-clock-rates = <19200000>, <200000000>;
 
-			interrupts-extended = <&intc GIC_SPI 130 IRQ_TYPE_LEVEL_HIGH>,
+			interrupts-extended = <&intc GIC_SPI 133 IRQ_TYPE_LEVEL_HIGH>,
+					      <&intc GIC_SPI 130 IRQ_TYPE_LEVEL_HIGH>,
 					      <&intc GIC_SPI 135 IRQ_TYPE_LEVEL_HIGH>,
 					      <&intc GIC_SPI 857 IRQ_TYPE_LEVEL_HIGH>,
 					      <&intc GIC_SPI 856 IRQ_TYPE_LEVEL_HIGH>,
@@ -3598,7 +3611,8 @@
 					      <&pdc 16 IRQ_TYPE_LEVEL_HIGH>,
 					      <&pdc 17 IRQ_TYPE_LEVEL_HIGH>;
 
-			interrupt-names = "pwr_event_1", "pwr_event_2",
+			interrupt-names = "dwc_usb3",
+					  "pwr_event_1", "pwr_event_2",
 					  "pwr_event_3", "pwr_event_4",
 					  "hs_phy_1",	 "hs_phy_2",
 					  "hs_phy_3",	 "hs_phy_4",
@@ -3608,6 +3622,7 @@
 					  "dp_hs_phy_4", "dm_hs_phy_4",
 					  "ss_phy_1",	 "ss_phy_2";
 
+			iommus = <&apps_smmu 0x800 0x0>;
 			power-domains = <&gcc USB30_MP_GDSC>;
 			required-opps = <&rpmhpd_opp_nom>;
 
@@ -3617,35 +3632,28 @@
 					<&gem_noc MASTER_APPSS_PROC 0 &config_noc SLAVE_USB3_MP 0>;
 			interconnect-names = "usb-ddr", "apps-usb";
 
+			phys = <&usb_2_hsphy0>, <&usb_2_qmpphy0>,
+			       <&usb_2_hsphy1>, <&usb_2_qmpphy1>,
+			       <&usb_2_hsphy2>,
+			       <&usb_2_hsphy3>;
+			phy-names = "usb2-0", "usb3-0",
+				    "usb2-1", "usb3-1",
+				    "usb2-2",
+				    "usb2-3";
+
 			wakeup-source;
 
-			status = "disabled";
+			dr_mode = "host";
 
-			usb_2_dwc3: usb@a400000 {
-				compatible = "snps,dwc3";
-				reg = <0 0x0a400000 0 0xcd00>;
-				interrupts = <GIC_SPI 133 IRQ_TYPE_LEVEL_HIGH>;
-				iommus = <&apps_smmu 0x800 0x0>;
-				phys = <&usb_2_hsphy0>, <&usb_2_qmpphy0>,
-				       <&usb_2_hsphy1>, <&usb_2_qmpphy1>,
-				       <&usb_2_hsphy2>,
-				       <&usb_2_hsphy3>;
-				phy-names = "usb2-0", "usb3-0",
-					    "usb2-1", "usb3-1",
-					    "usb2-2",
-					    "usb2-3";
-				dr_mode = "host";
-				snps,dis-u1-entry-quirk;
-				snps,dis-u2-entry-quirk;
-			};
+			snps,dis-u1-entry-quirk;
+			snps,dis-u2-entry-quirk;
+
+			status = "disabled";
 		};
 
-		usb_0: usb@a6f8800 {
-			compatible = "qcom,sc8280xp-dwc3", "qcom,dwc3";
-			reg = <0 0x0a6f8800 0 0x400>;
-			#address-cells = <2>;
-			#size-cells = <2>;
-			ranges;
+		usb_0: usb@a600000 {
+			compatible = "qcom,sc8280xp-dwc3", "qcom,snps-dwc3";
+			reg = <0 0x0a600000 0 0x10000>;
 
 			clocks = <&gcc GCC_CFG_NOC_USB3_PRIM_AXI_CLK>,
 				 <&gcc GCC_USB30_PRIM_MASTER_CLK>,
@@ -3663,17 +3671,20 @@
 					  <&gcc GCC_USB30_PRIM_MASTER_CLK>;
 			assigned-clock-rates = <19200000>, <200000000>;
 
-			interrupts-extended = <&intc GIC_SPI 804 IRQ_TYPE_LEVEL_HIGH>,
+			interrupts-extended = <&intc GIC_SPI 803 IRQ_TYPE_LEVEL_HIGH>,
+					      <&intc GIC_SPI 804 IRQ_TYPE_LEVEL_HIGH>,
 					      <&intc GIC_SPI 805 IRQ_TYPE_LEVEL_HIGH>,
 					      <&pdc 14 IRQ_TYPE_EDGE_BOTH>,
 					      <&pdc 15 IRQ_TYPE_EDGE_BOTH>,
 					      <&pdc 138 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "pwr_event",
+			interrupt-names = "dwc_usb3",
+					  "pwr_event",
 					  "hs_phy_irq",
 					  "dp_hs_phy_irq",
 					  "dm_hs_phy_irq",
 					  "ss_phy_irq";
 
+			iommus = <&apps_smmu 0x820 0x0>;
 			power-domains = <&gcc USB30_PRIM_GDSC>;
 			required-opps = <&rpmhpd_opp_nom>;
 
@@ -3683,45 +3694,40 @@
 					<&gem_noc MASTER_APPSS_PROC 0 &config_noc SLAVE_USB3_0 0>;
 			interconnect-names = "usb-ddr", "apps-usb";
 
+			phys = <&usb_0_hsphy>, <&usb_0_qmpphy QMP_USB43DP_USB3_PHY>;
+			phy-names = "usb2-phy", "usb3-phy";
+
 			wakeup-source;
 
-			status = "disabled";
+			snps,dis-u1-entry-quirk;
+			snps,dis-u2-entry-quirk;
 
-			usb_0_dwc3: usb@a600000 {
-				compatible = "snps,dwc3";
-				reg = <0 0x0a600000 0 0xcd00>;
-				interrupts = <GIC_SPI 803 IRQ_TYPE_LEVEL_HIGH>;
-				iommus = <&apps_smmu 0x820 0x0>;
-				phys = <&usb_0_hsphy>, <&usb_0_qmpphy QMP_USB43DP_USB3_PHY>;
-				phy-names = "usb2-phy", "usb3-phy";
-				snps,dis-u1-entry-quirk;
-				snps,dis-u2-entry-quirk;
+			status = "disabled";
 
-				ports {
-					#address-cells = <1>;
-					#size-cells = <0>;
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
 
-					port@0 {
-						reg = <0>;
+				port@0 {
+					reg = <0>;
 
-						usb_0_dwc3_hs: endpoint {
-						};
+					usb_0_dwc3_hs: endpoint {
 					};
+				};
 
-					port@1 {
-						reg = <1>;
+				port@1 {
+					reg = <1>;
 
-						usb_0_dwc3_ss: endpoint {
-							remote-endpoint = <&usb_0_qmpphy_usb_ss_in>;
-						};
+					usb_0_dwc3_ss: endpoint {
+						remote-endpoint = <&usb_0_qmpphy_usb_ss_in>;
 					};
 				};
 			};
 		};
 
-		usb_1: usb@a8f8800 {
-			compatible = "qcom,sc8280xp-dwc3", "qcom,dwc3";
-			reg = <0 0x0a8f8800 0 0x400>;
+		usb_1: usb@a800000 {
+			compatible = "qcom,sc8280xp-dwc3", "qcom,snps-dwc3";
+			reg = <0 0x0a800000 0 0x10000>;
 			#address-cells = <2>;
 			#size-cells = <2>;
 			ranges;
@@ -3742,17 +3748,20 @@
 					  <&gcc GCC_USB30_SEC_MASTER_CLK>;
 			assigned-clock-rates = <19200000>, <200000000>;
 
-			interrupts-extended = <&intc GIC_SPI 811 IRQ_TYPE_LEVEL_HIGH>,
+			interrupts-extended = <&intc GIC_SPI 810 IRQ_TYPE_LEVEL_HIGH>,
+					      <&intc GIC_SPI 811 IRQ_TYPE_LEVEL_HIGH>,
 					      <&intc GIC_SPI 790 IRQ_TYPE_LEVEL_HIGH>,
 					      <&pdc 12 IRQ_TYPE_EDGE_BOTH>,
 					      <&pdc 13 IRQ_TYPE_EDGE_BOTH>,
 					      <&pdc 136 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "pwr_event",
+			interrupt-names = "dwc_usb3",
+					  "pwr_event",
 					  "hs_phy_irq",
 					  "dp_hs_phy_irq",
 					  "dm_hs_phy_irq",
 					  "ss_phy_irq";
 
+			iommus = <&apps_smmu 0x860 0x0>;
 			power-domains = <&gcc USB30_SEC_GDSC>;
 			required-opps = <&rpmhpd_opp_nom>;
 
@@ -3762,42 +3771,109 @@
 					<&gem_noc MASTER_APPSS_PROC 0 &config_noc SLAVE_USB3_1 0>;
 			interconnect-names = "usb-ddr", "apps-usb";
 
+			phys = <&usb_1_hsphy>, <&usb_1_qmpphy QMP_USB43DP_USB3_PHY>;
+			phy-names = "usb2-phy", "usb3-phy";
+
 			wakeup-source;
 
-			status = "disabled";
+			snps,dis-u1-entry-quirk;
+			snps,dis-u2-entry-quirk;
 
-			usb_1_dwc3: usb@a800000 {
-				compatible = "snps,dwc3";
-				reg = <0 0x0a800000 0 0xcd00>;
-				interrupts = <GIC_SPI 810 IRQ_TYPE_LEVEL_HIGH>;
-				iommus = <&apps_smmu 0x860 0x0>;
-				phys = <&usb_1_hsphy>, <&usb_1_qmpphy QMP_USB43DP_USB3_PHY>;
-				phy-names = "usb2-phy", "usb3-phy";
-				snps,dis-u1-entry-quirk;
-				snps,dis-u2-entry-quirk;
+			status = "disabled";
 
-				ports {
-					#address-cells = <1>;
-					#size-cells = <0>;
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
 
-					port@0 {
-						reg = <0>;
+				port@0 {
+					reg = <0>;
 
-						usb_1_dwc3_hs: endpoint {
-						};
+					usb_1_dwc3_hs: endpoint {
 					};
+				};
 
-					port@1 {
-						reg = <1>;
+				port@1 {
+					reg = <1>;
 
-						usb_1_dwc3_ss: endpoint {
-							remote-endpoint = <&usb_1_qmpphy_usb_ss_in>;
-						};
+					usb_1_dwc3_ss: endpoint {
+						remote-endpoint = <&usb_1_qmpphy_usb_ss_in>;
 					};
 				};
 			};
 		};
 
+		venus: video-codec@aa00000 {
+			compatible = "qcom,sm8350-venus";
+			reg = <0 0x0aa00000 0 0x100000>;
+			interrupts = <GIC_SPI 174 IRQ_TYPE_LEVEL_HIGH>;
+
+			clocks = <&gcc GCC_VIDEO_AXI0_CLK>,
+				 <&videocc VIDEO_CC_MVS0C_CLK>,
+				 <&videocc VIDEO_CC_MVS0_CLK>;
+			clock-names = "iface",
+				      "core",
+				      "vcodec0_core";
+			power-domains = <&videocc MVS0C_GDSC>,
+					<&videocc MVS0_GDSC>,
+					<&rpmhpd SC8280XP_MX>;
+			power-domain-names = "venus",
+					     "vcodec0",
+					     "mx";
+
+			resets = <&gcc GCC_VIDEO_AXI0_CLK_ARES>;
+			reset-names = "core";
+
+			interconnects = <&gem_noc MASTER_APPSS_PROC 0 &config_noc SLAVE_VENUS_CFG 0>,
+					<&mmss_noc MASTER_VIDEO_P0 0 &mc_virt SLAVE_EBI1 0>,
+					<&mmss_noc MASTER_VIDEO_P0 0 &gem_noc SLAVE_LLCC 0>;
+			interconnect-names = "cpu-cfg",
+					     "video-mem",
+					     "video-llcc";
+
+			operating-points-v2 = <&venus_opp_table>;
+			iommus = <&apps_smmu 0x2e00 0x400>;
+			memory-region = <&pil_video_mem>;
+
+			status = "disabled";
+
+			venus_opp_table: opp-table {
+				compatible = "operating-points-v2";
+
+				opp-720000000 {
+					opp-hz = /bits/ 64 <720000000>;
+					required-opps = <&rpmhpd_opp_low_svs>;
+				};
+
+				opp-1014000000 {
+					opp-hz = /bits/ 64 <1014000000>;
+					required-opps = <&rpmhpd_opp_svs>;
+				};
+
+				opp-1098000000 {
+					opp-hz = /bits/ 64 <1098000000>;
+					required-opps = <&rpmhpd_opp_svs_l1>;
+				};
+
+				opp-1332000000 {
+					opp-hz = /bits/ 64 <1332000000>;
+					required-opps = <&rpmhpd_opp_nom>;
+				};
+			};
+		};
+
+		videocc: clock-controller@abf0000 {
+			compatible = "qcom,sc8280xp-videocc";
+			reg = <0 0x0abf0000 0 0x10000>;
+			clocks = <&rpmhcc RPMH_CXO_CLK>,
+				 <&rpmhcc RPMH_CXO_CLK_A>,
+				 <&sleep_clk>;
+			power-domains = <&rpmhpd SC8280XP_MMCX>;
+			required-opps = <&rpmhpd_opp_low_svs>;
+			#clock-cells = <1>;
+			#reset-cells = <1>;
+			#power-domain-cells = <1>;
+		};
+
 		cci0: cci@ac4a000 {
 			compatible = "qcom,sc8280xp-cci", "qcom,msm8996-cci";
 			reg = <0 0x0ac4a000 0 0x1000>;
@@ -3813,6 +3889,7 @@
 				      "cpas_ahb",
 				      "cci";
 
+			operating-points-v2 = <&cci_opp_table>;
 			power-domains = <&camcc TITAN_TOP_GDSC>;
 
 			pinctrl-0 = <&cci0_default>;
@@ -3854,6 +3931,7 @@
 				      "cpas_ahb",
 				      "cci";
 
+			operating-points-v2 = <&cci_opp_table>;
 			power-domains = <&camcc TITAN_TOP_GDSC>;
 
 			pinctrl-0 = <&cci1_default>;
@@ -3894,6 +3972,8 @@
 				      "slow_ahb_src",
 				      "cpas_ahb",
 				      "cci";
+
+			operating-points-v2 = <&cci_opp_table>;
 			power-domains = <&camcc TITAN_TOP_GDSC>;
 
 			pinctrl-0 = <&cci2_default>;
@@ -3924,7 +4004,7 @@
 			compatible = "qcom,sc8280xp-cci", "qcom,msm8996-cci";
 			reg = <0 0x0ac4d000 0 0x1000>;
 
-			interrupts = <GIC_SPI 650 IRQ_TYPE_EDGE_RISING>;
+			interrupts = <GIC_SPI 771 IRQ_TYPE_EDGE_RISING>;
 
 			clocks = <&camcc CAMCC_CAMNOC_AXI_CLK>,
 				 <&camcc CAMCC_SLOW_AHB_CLK_SRC>,
@@ -3935,6 +4015,7 @@
 				      "cpas_ahb",
 				      "cci";
 
+			operating-points-v2 = <&cci_opp_table>;
 			power-domains = <&camcc TITAN_TOP_GDSC>;
 
 			pinctrl-0 = <&cci3_default>;
diff -Nrup linux-6.16.7/arch/arm64/boot/dts/qcom/sc8280xp-huawei-gaokun3.dts linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sc8280xp-huawei-gaokun3.dts
--- linux-6.16.7/arch/arm64/boot/dts/qcom/sc8280xp-huawei-gaokun3.dts	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sc8280xp-huawei-gaokun3.dts	2025-09-11 09:47:42.000000000 -0600
@@ -1123,11 +1123,8 @@
 };
 
 &usb_0 {
-	status = "okay";
-};
-
-&usb_0_dwc3 {
 	dr_mode = "host";
+	status = "okay";
 };
 
 &usb_0_dwc3_hs {
@@ -1160,11 +1157,8 @@
 };
 
 &usb_1 {
-	status = "okay";
-};
-
-&usb_1_dwc3 {
 	dr_mode = "host";
+	status = "okay";
 };
 
 &usb_1_dwc3_hs {
diff -Nrup linux-6.16.7/arch/arm64/boot/dts/qcom/sc8280xp-lenovo-thinkpad-x13s.dts linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sc8280xp-lenovo-thinkpad-x13s.dts
--- linux-6.16.7/arch/arm64/boot/dts/qcom/sc8280xp-lenovo-thinkpad-x13s.dts	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sc8280xp-lenovo-thinkpad-x13s.dts	2025-09-11 09:47:42.000000000 -0600
@@ -83,14 +83,11 @@
 		pinctrl-names = "default";
 		pinctrl-0 = <&cam_indicator_en>;
 
-		led-camera-indicator {
-			label = "white:camera-indicator";
+		privacy_led: privacy-led {
 			function = LED_FUNCTION_INDICATOR;
 			color = <LED_COLOR_ID_WHITE>;
 			gpios = <&tlmm 28 GPIO_ACTIVE_HIGH>;
-			linux,default-trigger = "none";
 			default-state = "off";
-			/* Reuse as a panic indicator until we get a "camera on" trigger */
 			panic-indicator;
 		};
 	};
@@ -685,6 +682,9 @@
 		pinctrl-names = "default";
 		pinctrl-0 = <&cam_rgb_default>;
 
+		leds = <&privacy_led>;
+		led-names = "privacy";
+
 		clocks = <&camcc CAMCC_MCLK3_CLK>;
 
 		orientation = <0>;	/* Front facing */
@@ -726,7 +726,7 @@
 };
 
 &mdss0_dp0_out {
-	data-lanes = <0 1>;
+	data-lanes = <0 1 2 3>;
 	remote-endpoint = <&usb_0_qmpphy_dp_in>;
 };
 
@@ -735,7 +735,7 @@
 };
 
 &mdss0_dp1_out {
-	data-lanes = <0 1>;
+	data-lanes = <0 1 2 3>;
 	remote-endpoint = <&usb_1_qmpphy_dp_in>;
 };
 
@@ -1337,11 +1337,9 @@
 };
 
 &usb_0 {
-	status = "okay";
-};
-
-&usb_0_dwc3 {
 	dr_mode = "host";
+
+	status = "okay";
 };
 
 &usb_0_dwc3_hs {
@@ -1360,6 +1358,7 @@
 	vdda-phy-supply = <&vreg_l9d>;
 	vdda-pll-supply = <&vreg_l4d>;
 
+	mode-switch;
 	orientation-switch;
 
 	status = "okay";
@@ -1374,11 +1373,8 @@
 };
 
 &usb_1 {
-	status = "okay";
-};
-
-&usb_1_dwc3 {
 	dr_mode = "host";
+	status = "okay";
 };
 
 &usb_1_dwc3_hs {
@@ -1397,6 +1393,7 @@
 	vdda-phy-supply = <&vreg_l4b>;
 	vdda-pll-supply = <&vreg_l3b>;
 
+	mode-switch;
 	orientation-switch;
 
 	status = "okay";
@@ -1471,6 +1468,11 @@
 	status = "okay";
 };
 
+&venus {
+	firmware-name = "qcom/sc8280xp/LENOVO/21BX/qcvss8280.mbn";
+	status = "okay";
+};
+
 &wsamacro {
 	status = "okay";
 };
diff -Nrup linux-6.16.7/arch/arm64/boot/dts/qcom/sc8280xp-microsoft-arcata.dts linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sc8280xp-microsoft-arcata.dts
--- linux-6.16.7/arch/arm64/boot/dts/qcom/sc8280xp-microsoft-arcata.dts	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sc8280xp-microsoft-arcata.dts	2025-09-11 09:47:42.000000000 -0600
@@ -749,11 +749,8 @@
 };
 
 &usb_0 {
-	status = "okay";
-};
-
-&usb_0_dwc3 {
 	dr_mode = "host";
+	status = "okay";
 };
 
 &usb_0_dwc3_hs {
@@ -786,11 +783,8 @@
 };
 
 &usb_1 {
-	status = "okay";
-};
-
-&usb_1_dwc3 {
 	dr_mode = "host";
+	status = "okay";
 };
 
 &usb_1_dwc3_hs {
diff -Nrup linux-6.16.7/arch/arm64/boot/dts/qcom/sc8280xp-microsoft-blackrock.dts linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sc8280xp-microsoft-blackrock.dts
--- linux-6.16.7/arch/arm64/boot/dts/qcom/sc8280xp-microsoft-blackrock.dts	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sc8280xp-microsoft-blackrock.dts	2025-09-11 09:47:42.000000000 -0600
@@ -982,11 +982,9 @@
 };
 
 &usb_0 {
-	status = "okay";
-};
-
-&usb_0_dwc3 {
 	dr_mode = "host";
+
+	status = "okay";
 };
 
 &usb_0_dwc3_hs {
@@ -1019,11 +1017,9 @@
 };
 
 &usb_1 {
-	status = "okay";
-};
-
-&usb_1_dwc3 {
 	dr_mode = "host";
+
+	status = "okay";
 };
 
 &usb_1_dwc3_hs {
@@ -1059,12 +1055,10 @@
 	pinctrl-0 = <&usb2_en_state>;
 	pinctrl-names = "default";
 
-	status = "okay";
-};
-
-&usb_2_dwc3 {
 	phys = <&usb_2_hsphy0>, <&usb_2_qmpphy0>;
 	phy-names = "usb2-0", "usb3-0";
+
+	status = "okay";
 };
 
 &usb_2_hsphy0 {
diff -Nrup linux-6.16.7/arch/arm64/boot/dts/qcom/x1-crd.dtsi linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/x1-crd.dtsi
--- linux-6.16.7/arch/arm64/boot/dts/qcom/x1-crd.dtsi	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/x1-crd.dtsi	2025-09-11 09:47:42.000000000 -0600
@@ -17,6 +17,7 @@
 
 	aliases {
 		serial0 = &uart21;
+		serial1 = &uart14;
 	};
 
 	wcd938x: audio-codec {
@@ -491,6 +492,48 @@
 		regulator-boot-on;
 	};
 
+	vreg_wcn_3p3: regulator-wcn-3p3 {
+		compatible = "regulator-fixed";
+
+		regulator-name = "VREG_WCN_3P3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+
+		gpio = <&tlmm 214 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		pinctrl-0 = <&wcn_sw_en>;
+		pinctrl-names = "default";
+
+		regulator-boot-on;
+	};
+
+	/*
+	 * TODO: These two regulators are actually part of the removable M.2
+	 * card and not the CRD mainboard. Need to describe this differently.
+	 * Functionally it works correctly, because all we need to do is to
+	 * turn on the actual 3.3V supply above.
+	 */
+	vreg_wcn_0p95: regulator-wcn-0p95 {
+		compatible = "regulator-fixed";
+
+		regulator-name = "VREG_WCN_0P95";
+		regulator-min-microvolt = <950000>;
+		regulator-max-microvolt = <950000>;
+
+		vin-supply = <&vreg_wcn_3p3>;
+	};
+
+	vreg_wcn_1p9: regulator-wcn-1p9 {
+		compatible = "regulator-fixed";
+
+		regulator-name = "VREG_WCN_1P9";
+		regulator-min-microvolt = <1900000>;
+		regulator-max-microvolt = <1900000>;
+
+		vin-supply = <&vreg_wcn_3p3>;
+	};
+
 	vreg_wwan: regulator-wwan {
 		compatible = "regulator-fixed";
 
@@ -506,6 +549,65 @@
 
 		regulator-boot-on;
 	};
+
+	wcn7850-pmu {
+		compatible = "qcom,wcn7850-pmu";
+
+		vdd-supply = <&vreg_wcn_0p95>;
+		vddio-supply = <&vreg_l15b_1p8>;
+		vddaon-supply = <&vreg_wcn_0p95>;
+		vdddig-supply = <&vreg_wcn_0p95>;
+		vddrfa1p2-supply = <&vreg_wcn_1p9>;
+		vddrfa1p8-supply = <&vreg_wcn_1p9>;
+
+		wlan-enable-gpios = <&tlmm 117 GPIO_ACTIVE_HIGH>;
+		bt-enable-gpios = <&tlmm 116 GPIO_ACTIVE_HIGH>;
+
+		pinctrl-0 = <&wcn_wlan_bt_en>;
+		pinctrl-names = "default";
+
+		regulators {
+			vreg_pmu_rfa_cmn: ldo0 {
+				regulator-name = "vreg_pmu_rfa_cmn";
+			};
+
+			vreg_pmu_aon_0p59: ldo1 {
+				regulator-name = "vreg_pmu_aon_0p59";
+			};
+
+			vreg_pmu_wlcx_0p8: ldo2 {
+				regulator-name = "vreg_pmu_wlcx_0p8";
+			};
+
+			vreg_pmu_wlmx_0p85: ldo3 {
+				regulator-name = "vreg_pmu_wlmx_0p85";
+			};
+
+			vreg_pmu_btcmx_0p85: ldo4 {
+				regulator-name = "vreg_pmu_btcmx_0p85";
+			};
+
+			vreg_pmu_rfa_0p8: ldo5 {
+				regulator-name = "vreg_pmu_rfa_0p8";
+			};
+
+			vreg_pmu_rfa_1p2: ldo6 {
+				regulator-name = "vreg_pmu_rfa_1p2";
+			};
+
+			vreg_pmu_rfa_1p8: ldo7 {
+				regulator-name = "vreg_pmu_rfa_1p8";
+			};
+
+			vreg_pmu_pcie_0p9: ldo8 {
+				regulator-name = "vreg_pmu_pcie_0p9";
+			};
+
+			vreg_pmu_pcie_1p8: ldo9 {
+				regulator-name = "vreg_pmu_pcie_1p8";
+			};
+		};
+	};
 };
 
 &apps_rsc {
@@ -1016,6 +1118,27 @@
 	};
 };
 
+&i2c5 {
+	clock-frequency = <400000>;
+
+	status = "okay";
+
+	eusb6_repeater: redriver@4f {
+		compatible = "nxp,ptn3222";
+		reg = <0x4f>;
+
+		vdd1v8-supply = <&vreg_l4b_1p8>;
+		vdd3v3-supply = <&vreg_l13b_3p0>;
+
+		reset-gpios = <&tlmm 184 GPIO_ACTIVE_LOW>;
+
+		pinctrl-0 = <&eusb6_reset_n>;
+		pinctrl-names = "default";
+
+		#phy-cells = <0>;
+	};
+};
+
 &i2c7 {
 	clock-frequency = <400000>;
 
@@ -1206,6 +1329,23 @@
 	status = "okay";
 };
 
+&pcie4_port0 {
+	wifi@0 {
+		compatible = "pci17cb,1107";
+		reg = <0x10000 0x0 0x0 0x0 0x0>;
+
+		vddaon-supply = <&vreg_pmu_aon_0p59>;
+		vddwlcx-supply = <&vreg_pmu_wlcx_0p8>;
+		vddwlmx-supply = <&vreg_pmu_wlmx_0p85>;
+		vddrfacmn-supply = <&vreg_pmu_rfa_cmn>;
+		vddrfa0p8-supply = <&vreg_pmu_rfa_0p8>;
+		vddrfa1p2-supply = <&vreg_pmu_rfa_1p2>;
+		vddrfa1p8-supply = <&vreg_pmu_rfa_1p8>;
+		vddpcie0p9-supply = <&vreg_pmu_pcie_0p9>;
+		vddpcie1p8-supply = <&vreg_pmu_pcie_1p8>;
+	};
+};
+
 &pcie5 {
 	perst-gpios = <&tlmm 149 GPIO_ACTIVE_LOW>;
 	wake-gpios = <&tlmm 151 GPIO_ACTIVE_LOW>;
@@ -1466,6 +1606,14 @@
 		bias-disable;
 	};
 
+	eusb6_reset_n: eusb6-reset-n-state {
+		pins = "gpio184";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+		output-low;
+	};
+
 	hall_int_n_default: hall-int-n-state {
 		pins = "gpio92";
 		function = "gpio";
@@ -1639,6 +1787,20 @@
 		output-low;
 	};
 
+	wcn_sw_en: wcn-sw-en-state {
+		pins = "gpio214";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	wcn_wlan_bt_en: wcn-wlan-bt-en-state {
+		pins = "gpio116", "gpio117";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
 	wwan_sw_en: wwan-sw-en-state {
 		pins = "gpio221";
 		function = "gpio";
@@ -1647,6 +1809,23 @@
 	};
 };
 
+&uart14 {
+	status = "okay";
+
+	bluetooth {
+		compatible = "qcom,wcn7850-bt";
+		max-speed = <3200000>;
+
+		vddaon-supply = <&vreg_pmu_aon_0p59>;
+		vddwlcx-supply = <&vreg_pmu_wlcx_0p8>;
+		vddwlmx-supply = <&vreg_pmu_wlmx_0p85>;
+		vddrfacmn-supply = <&vreg_pmu_rfa_cmn>;
+		vddrfa0p8-supply = <&vreg_pmu_rfa_0p8>;
+		vddrfa1p2-supply = <&vreg_pmu_rfa_1p2>;
+		vddrfa1p8-supply = <&vreg_pmu_rfa_1p8>;
+	};
+};
+
 &uart21 {
 	compatible = "qcom,geni-debug-uart";
 	status = "okay";
@@ -1747,3 +1926,38 @@
 &usb_1_ss2_qmpphy_out {
 	remote-endpoint = <&retimer_ss2_ss_in>;
 };
+
+&usb_mp {
+	/* Only second port is used with USB 2.0 maximum speed */
+	status = "okay";
+};
+
+&usb_mp_hsphy0 {
+	vdd-supply = <&vreg_l2e_0p8>;
+	vdda12-supply = <&vreg_l3e_1p2>;
+
+	status = "okay";
+};
+
+&usb_mp_hsphy1 {
+	vdd-supply = <&vreg_l2e_0p8>;
+	vdda12-supply = <&vreg_l3e_1p2>;
+
+	phys = <&eusb6_repeater>;
+
+	status = "okay";
+};
+
+&usb_mp_qmpphy0 {
+	vdda-phy-supply = <&vreg_l3e_1p2>;
+	vdda-pll-supply = <&vreg_l3c_0p8>;
+
+	status = "okay";
+};
+
+&usb_mp_qmpphy1 {
+	vdda-phy-supply = <&vreg_l3e_1p2>;
+	vdda-pll-supply = <&vreg_l3c_0p8>;
+
+	status = "okay";
+};
diff -Nrup linux-6.16.7/arch/arm64/boot/dts/qcom/x1e78100-lenovo-thinkpad-t14s.dtsi linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/x1e78100-lenovo-thinkpad-t14s.dtsi
--- linux-6.16.7/arch/arm64/boot/dts/qcom/x1e78100-lenovo-thinkpad-t14s.dtsi	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/x1e78100-lenovo-thinkpad-t14s.dtsi	2025-09-11 09:47:42.000000000 -0600
@@ -20,6 +20,10 @@
 	compatible = "lenovo,thinkpad-t14s", "qcom,x1e78100", "qcom,x1e80100";
 	chassis-type = "laptop";
 
+	aliases {
+		serial1 = &uart14;
+	};
+
 	wcd938x: audio-codec {
 		compatible = "qcom,wcd9385-codec";
 
@@ -321,6 +325,48 @@
 		regulator-boot-on;
 	};
 
+	vreg_wcn_3p3: regulator-wcn-3p3 {
+		compatible = "regulator-fixed";
+
+		regulator-name = "VREG_WCN_3P3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+
+		gpio = <&tlmm 214 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		pinctrl-0 = <&wcn_sw_en>;
+		pinctrl-names = "default";
+
+		regulator-boot-on;
+	};
+
+	/*
+	 * TODO: These two regulators are actually part of the removable M.2
+	 * card and not the CRD mainboard. Need to describe this differently.
+	 * Functionally it works correctly, because all we need to do is to
+	 * turn on the actual 3.3V supply above.
+	 */
+	vreg_wcn_0p95: regulator-wcn-0p95 {
+		compatible = "regulator-fixed";
+
+		regulator-name = "VREG_WCN_0P95";
+		regulator-min-microvolt = <950000>;
+		regulator-max-microvolt = <950000>;
+
+		vin-supply = <&vreg_wcn_3p3>;
+	};
+
+	vreg_wcn_1p9: regulator-wcn-1p9 {
+		compatible = "regulator-fixed";
+
+		regulator-name = "VREG_WCN_1P9";
+		regulator-min-microvolt = <1900000>;
+		regulator-max-microvolt = <1900000>;
+
+		vin-supply = <&vreg_wcn_3p3>;
+	};
+
 	vreg_wwan: regulator-wwan {
 		compatible = "regulator-fixed";
 
@@ -415,6 +461,65 @@
 			};
 		};
 	};
+
+	wcn7850-pmu {
+		compatible = "qcom,wcn7850-pmu";
+
+		vdd-supply = <&vreg_wcn_0p95>;
+		vddio-supply = <&vreg_l15b_1p8>;
+		vddaon-supply = <&vreg_wcn_0p95>;
+		vdddig-supply = <&vreg_wcn_0p95>;
+		vddrfa1p2-supply = <&vreg_wcn_1p9>;
+		vddrfa1p8-supply = <&vreg_wcn_1p9>;
+
+		wlan-enable-gpios = <&tlmm 117 GPIO_ACTIVE_HIGH>;
+		bt-enable-gpios = <&tlmm 116 GPIO_ACTIVE_HIGH>;
+
+		pinctrl-0 = <&wcn_wlan_bt_en>;
+		pinctrl-names = "default";
+
+		regulators {
+			vreg_pmu_rfa_cmn: ldo0 {
+				regulator-name = "vreg_pmu_rfa_cmn";
+			};
+
+			vreg_pmu_aon_0p59: ldo1 {
+				regulator-name = "vreg_pmu_aon_0p59";
+			};
+
+			vreg_pmu_wlcx_0p8: ldo2 {
+				regulator-name = "vreg_pmu_wlcx_0p8";
+			};
+
+			vreg_pmu_wlmx_0p85: ldo3 {
+				regulator-name = "vreg_pmu_wlmx_0p85";
+			};
+
+			vreg_pmu_btcmx_0p85: ldo4 {
+				regulator-name = "vreg_pmu_btcmx_0p85";
+			};
+
+			vreg_pmu_rfa_0p8: ldo5 {
+				regulator-name = "vreg_pmu_rfa_0p8";
+			};
+
+			vreg_pmu_rfa_1p2: ldo6 {
+				regulator-name = "vreg_pmu_rfa_1p2";
+			};
+
+			vreg_pmu_rfa_1p8: ldo7 {
+				regulator-name = "vreg_pmu_rfa_1p8";
+			};
+
+			vreg_pmu_pcie_0p9: ldo8 {
+				regulator-name = "vreg_pmu_pcie_0p9";
+			};
+
+			vreg_pmu_pcie_1p8: ldo9 {
+				regulator-name = "vreg_pmu_pcie_1p8";
+			};
+		};
+	};
 };
 
 &apps_rsc {
@@ -1061,6 +1166,23 @@
 	status = "okay";
 };
 
+&pcie4_port0 {
+	wifi@0 {
+		compatible = "pci17cb,1107";
+		reg = <0x10000 0x0 0x0 0x0 0x0>;
+
+		vddaon-supply = <&vreg_pmu_aon_0p59>;
+		vddwlcx-supply = <&vreg_pmu_wlcx_0p8>;
+		vddwlmx-supply = <&vreg_pmu_wlmx_0p85>;
+		vddrfacmn-supply = <&vreg_pmu_rfa_cmn>;
+		vddrfa0p8-supply = <&vreg_pmu_rfa_0p8>;
+		vddrfa1p2-supply = <&vreg_pmu_rfa_1p2>;
+		vddrfa1p8-supply = <&vreg_pmu_rfa_1p8>;
+		vddpcie0p9-supply = <&vreg_pmu_pcie_0p9>;
+		vddpcie1p8-supply = <&vreg_pmu_pcie_1p8>;
+	};
+};
+
 &pcie5 {
 	perst-gpios = <&tlmm 149 GPIO_ACTIVE_LOW>;
 	wake-gpios = <&tlmm 151 GPIO_ACTIVE_LOW>;
@@ -1450,6 +1572,20 @@
 		output-low;
 	};
 
+	wcn_sw_en: wcn-sw-en-state {
+		pins = "gpio214";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	wcn_wlan_bt_en: wcn-wlan-bt-en-state {
+		pins = "gpio116", "gpio117";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
 	wwan_sw_en: wwan-sw-en-state {
 		pins = "gpio221";
 		function = "gpio";
@@ -1458,6 +1594,23 @@
 	};
 };
 
+&uart14 {
+	status = "okay";
+
+	bluetooth {
+		compatible = "qcom,wcn7850-bt";
+		max-speed = <3200000>;
+
+		vddaon-supply = <&vreg_pmu_aon_0p59>;
+		vddwlcx-supply = <&vreg_pmu_wlcx_0p8>;
+		vddwlmx-supply = <&vreg_pmu_wlmx_0p85>;
+		vddrfacmn-supply = <&vreg_pmu_rfa_cmn>;
+		vddrfa0p8-supply = <&vreg_pmu_rfa_0p8>;
+		vddrfa1p2-supply = <&vreg_pmu_rfa_1p2>;
+		vddrfa1p8-supply = <&vreg_pmu_rfa_1p8>;
+	};
+};
+
 &usb_1_ss0_hsphy {
 	vdd-supply = <&vreg_l3j_0p8>;
 	vdda12-supply = <&vreg_l2j_1p2>;
diff -Nrup linux-6.16.7/arch/arm64/boot/dts/qcom/x1e78100-lenovo-thinkpad-t14s-oled.dts linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/x1e78100-lenovo-thinkpad-t14s-oled.dts
--- linux-6.16.7/arch/arm64/boot/dts/qcom/x1e78100-lenovo-thinkpad-t14s-oled.dts	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/x1e78100-lenovo-thinkpad-t14s-oled.dts	2025-09-11 09:47:42.000000000 -0600
@@ -10,3 +10,11 @@
 	compatible = "lenovo,thinkpad-t14s-oled", "lenovo,thinkpad-t14s",
 		     "qcom,x1e78100", "qcom,x1e80100";
 };
+
+&panel {
+	compatible = "samsung,atna40yk20", "samsung,atna33xc20";
+	enable-gpios = <&pmc8380_3_gpios 4 GPIO_ACTIVE_HIGH>;
+
+	pinctrl-0 = <&edp_bl_en>;
+	pinctrl-names = "default";
+};
diff -Nrup linux-6.16.7/arch/arm64/boot/dts/qcom/x1e80100-dell-xps13-9345.dts linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/x1e80100-dell-xps13-9345.dts
--- linux-6.16.7/arch/arm64/boot/dts/qcom/x1e80100-dell-xps13-9345.dts	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/x1e80100-dell-xps13-9345.dts	2025-09-11 09:47:42.000000000 -0600
@@ -22,6 +22,7 @@
 
 	aliases {
 		serial0 = &uart21;
+		serial1 = &uart14;
 	};
 
 	gpio-keys {
@@ -288,6 +289,101 @@
 		regulator-always-on;
 		regulator-boot-on;
 	};
+
+	vreg_wcn_0p95: regulator-wcn-0p95 {
+		compatible = "regulator-fixed";
+
+		regulator-name = "VREG_WCN_0P95";
+		regulator-min-microvolt = <950000>;
+		regulator-max-microvolt = <950000>;
+
+		vin-supply = <&vreg_wcn_3p3>;
+	};
+
+	vreg_wcn_1p9: regulator-wcn-1p9 {
+		compatible = "regulator-fixed";
+
+		regulator-name = "VREG_WCN_1P9";
+		regulator-min-microvolt = <1900000>;
+		regulator-max-microvolt = <1900000>;
+
+		vin-supply = <&vreg_wcn_3p3>;
+	};
+
+	vreg_wcn_3p3: regulator-wcn-3p3 {
+		compatible = "regulator-fixed";
+
+		regulator-name = "VREG_WCN_3P3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+
+		gpio = <&tlmm 214 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		pinctrl-0 = <&wcn_sw_en>;
+		pinctrl-names = "default";
+
+		regulator-boot-on;
+	};
+
+	wcn7850-pmu {
+		compatible = "qcom,wcn7850-pmu";
+
+		vdd-supply = <&vreg_wcn_0p95>;
+		vddio-supply = <&vreg_l15b_1p8>;
+		vddaon-supply = <&vreg_wcn_0p95>;
+		vdddig-supply = <&vreg_wcn_0p95>;
+		vddrfa1p2-supply = <&vreg_wcn_1p9>;
+		vddrfa1p8-supply = <&vreg_wcn_1p9>;
+
+		wlan-enable-gpios = <&tlmm 117 GPIO_ACTIVE_HIGH>;
+		bt-enable-gpios = <&tlmm 116 GPIO_ACTIVE_HIGH>;
+
+		pinctrl-0 = <&wcn_wlan_bt_en>;
+		pinctrl-names = "default";
+
+		regulators {
+			vreg_pmu_rfa_cmn: ldo0 {
+				regulator-name = "vreg_pmu_rfa_cmn";
+			};
+
+			vreg_pmu_aon_0p59: ldo1 {
+				regulator-name = "vreg_pmu_aon_0p59";
+			};
+
+			vreg_pmu_wlcx_0p8: ldo2 {
+				regulator-name = "vreg_pmu_wlcx_0p8";
+			};
+
+			vreg_pmu_wlmx_0p85: ldo3 {
+				regulator-name = "vreg_pmu_wlmx_0p85";
+			};
+
+			vreg_pmu_btcmx_0p85: ldo4 {
+				regulator-name = "vreg_pmu_btcmx_0p85";
+			};
+
+			vreg_pmu_rfa_0p8: ldo5 {
+				regulator-name = "vreg_pmu_rfa_0p8";
+			};
+
+			vreg_pmu_rfa_1p2: ldo6 {
+				regulator-name = "vreg_pmu_rfa_1p2";
+			};
+
+			vreg_pmu_rfa_1p8: ldo7 {
+				regulator-name = "vreg_pmu_rfa_1p8";
+			};
+
+			vreg_pmu_pcie_0p9: ldo8 {
+				regulator-name = "vreg_pmu_pcie_0p9";
+			};
+
+			vreg_pmu_pcie_1p8: ldo9 {
+				regulator-name = "vreg_pmu_pcie_1p8";
+			};
+		};
+	};
 };
 
 &apps_rsc {
@@ -848,6 +944,23 @@
 	status = "okay";
 };
 
+&pcie4_port0 {
+	wifi@0 {
+		compatible = "pci17cb,1107";
+		reg = <0x10000 0x0 0x0 0x0 0x0>;
+
+		vddaon-supply = <&vreg_pmu_aon_0p59>;
+		vddwlcx-supply = <&vreg_pmu_wlcx_0p8>;
+		vddwlmx-supply = <&vreg_pmu_wlmx_0p85>;
+		vddrfacmn-supply = <&vreg_pmu_rfa_cmn>;
+		vddrfa0p8-supply = <&vreg_pmu_rfa_0p8>;
+		vddrfa1p2-supply = <&vreg_pmu_rfa_1p2>;
+		vddrfa1p8-supply = <&vreg_pmu_rfa_1p8>;
+		vddpcie0p9-supply = <&vreg_pmu_pcie_0p9>;
+		vddpcie1p8-supply = <&vreg_pmu_pcie_1p8>;
+	};
+};
+
 &pcie6a {
 	perst-gpios = <&tlmm 152 GPIO_ACTIVE_LOW>;
 	wake-gpios = <&tlmm 154 GPIO_ACTIVE_LOW>;
@@ -1102,6 +1215,37 @@
 			drive-strength = <2>;
 		};
 	};
+
+	wcn_sw_en: wcn-sw-en-state {
+		pins = "gpio214";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	wcn_wlan_bt_en: wcn-wlan-bt-en-state {
+		pins = "gpio116", "gpio117";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+};
+
+&uart14 {
+	status = "okay";
+
+	bluetooth {
+		compatible = "qcom,wcn7850-bt";
+		max-speed = <3200000>;
+
+		vddaon-supply = <&vreg_pmu_aon_0p59>;
+		vddwlcx-supply = <&vreg_pmu_wlcx_0p8>;
+		vddwlmx-supply = <&vreg_pmu_wlmx_0p85>;
+		vddrfacmn-supply = <&vreg_pmu_rfa_cmn>;
+		vddrfa0p8-supply = <&vreg_pmu_rfa_0p8>;
+		vddrfa1p2-supply = <&vreg_pmu_rfa_1p2>;
+		vddrfa1p8-supply = <&vreg_pmu_rfa_1p8>;
+	};
 };
 
 &uart21 {
diff -Nrup linux-6.16.7/arch/arm64/boot/dts/qcom/x1e80100-pmics.dtsi linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/x1e80100-pmics.dtsi
--- linux-6.16.7/arch/arm64/boot/dts/qcom/x1e80100-pmics.dtsi	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/x1e80100-pmics.dtsi	2025-09-11 09:47:42.000000000 -0600
@@ -475,6 +475,8 @@
 		#address-cells = <1>;
 		#size-cells = <0>;
 
+		status = "disabled";
+
 		pm8010_temp_alarm: temp-alarm@2400 {
 			compatible = "qcom,spmi-temp-alarm";
 			reg = <0x2400>;
diff -Nrup linux-6.16.7/arch/arm64/boot/dts/renesas/r9a07g054l2-smarc-cru-csi-ov5645.dtso linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/renesas/r9a07g054l2-smarc-cru-csi-ov5645.dtso
--- linux-6.16.7/arch/arm64/boot/dts/renesas/r9a07g054l2-smarc-cru-csi-ov5645.dtso	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/renesas/r9a07g054l2-smarc-cru-csi-ov5645.dtso	2025-09-11 09:47:42.000000000 -0600
@@ -1,21 +1 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Device Tree overlay for the RZ/{G2L, V2L} SMARC EVK with OV5645 camera
- * connected to CSI and CRU enabled.
- *
- * Copyright (C) 2023 Renesas Electronics Corp.
- */
-
-/dts-v1/;
-/plugin/;
-
-#include <dt-bindings/gpio/gpio.h>
-#include <dt-bindings/pinctrl/rzg2l-pinctrl.h>
-
-#define OV5645_PARENT_I2C i2c0
-#include "rz-smarc-cru-csi-ov5645.dtsi"
-
-&ov5645 {
-	enable-gpios = <&pinctrl RZG2L_GPIO(2, 0) GPIO_ACTIVE_HIGH>;
-	reset-gpios = <&pinctrl RZG2L_GPIO(40, 2) GPIO_ACTIVE_LOW>;
-};
+r9a07g044l2-smarc-cru-csi-ov5645.dtso
\ No newline at end of file
diff -Nrup linux-6.16.7/arch/arm64/configs/defconfig linux-lenovo-x13s-linux-6.16.y/arch/arm64/configs/defconfig
--- linux-6.16.7/arch/arm64/configs/defconfig	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/configs/defconfig	2025-09-11 09:47:42.000000000 -0600
@@ -236,7 +236,7 @@ CONFIG_PCIE_HISI_STB=y
 CONFIG_PCIE_ARMADA_8K=y
 CONFIG_PCIE_TEGRA194_HOST=m
 CONFIG_PCIE_TEGRA194_EP=m
-CONFIG_PCIE_QCOM=y
+CONFIG_PCIE_QCOM=m
 CONFIG_PCIE_RCAR_GEN4_HOST=m
 CONFIG_PCIE_RCAR_GEN4_EP=m
 CONFIG_PCIE_ROCKCHIP_DW_HOST=y
diff -Nrup linux-6.16.7/arch/arm64/configs/johan_defconfig linux-lenovo-x13s-linux-6.16.y/arch/arm64/configs/johan_defconfig
--- linux-6.16.7/arch/arm64/configs/johan_defconfig	1969-12-31 17:00:00.000000000 -0700
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/configs/johan_defconfig	2025-09-11 09:47:42.000000000 -0600
@@ -0,0 +1,429 @@
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_AUDIT=y
+CONFIG_NO_HZ_IDLE=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_BPF_SYSCALL=y
+CONFIG_BPF_JIT=y
+CONFIG_PREEMPT=y
+CONFIG_IRQ_TIME_ACCOUNTING=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_NUMA_BALANCING=y
+CONFIG_MEMCG=y
+CONFIG_BLK_CGROUP=y
+CONFIG_CGROUP_PIDS=y
+CONFIG_CGROUP_HUGETLB=y
+CONFIG_CPUSETS=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_CGROUP_PERF=y
+CONFIG_CGROUP_BPF=y
+CONFIG_USER_NS=y
+CONFIG_SCHED_AUTOGROUP=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_PROFILING=y
+CONFIG_ARCH_QCOM=y
+# CONFIG_AMPERE_ERRATUM_AC04_CPU_23 is not set
+# CONFIG_ARM64_ERRATUM_2077057 is not set
+# CONFIG_ARM64_ERRATUM_3194386 is not set
+# CONFIG_ROCKCHIP_ERRATUM_3568002 is not set
+# CONFIG_ROCKCHIP_ERRATUM_3588001 is not set
+CONFIG_ARM64_VA_BITS_48=y
+CONFIG_SCHED_MC=y
+CONFIG_SCHED_SMT=y
+CONFIG_NUMA=y
+CONFIG_COMPAT=y
+# CONFIG_ARM64_POE is not set
+CONFIG_RANDOMIZE_BASE=y
+CONFIG_HIBERNATION=y
+CONFIG_WQ_POWER_EFFICIENT_DEFAULT=y
+CONFIG_ENERGY_MODEL=y
+CONFIG_CPU_IDLE=y
+CONFIG_ARM_PSCI_CPUIDLE=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=m
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=m
+CONFIG_CPUFREQ_DT_PLATDEV=y
+CONFIG_ARM_QCOM_CPUFREQ_HW=y
+CONFIG_ARM_SCMI_CPUFREQ=y
+CONFIG_JUMP_LABEL=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_BLOCK_LEGACY_AUTOLOAD is not set
+# CONFIG_IOSCHED_BFQ is not set
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_BINFMT_MISC=m
+CONFIG_KSM=y
+CONFIG_MEMORY_FAILURE=y
+CONFIG_TRANSPARENT_HUGEPAGE=y
+CONFIG_CMA=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IPV6=m
+CONFIG_IPV6_MULTIPLE_TABLES=y
+CONFIG_NETFILTER=y
+CONFIG_NF_CONNTRACK=m
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NETFILTER_XTABLES_COMPAT=y
+CONFIG_NETFILTER_XT_MARK=m
+CONFIG_NETFILTER_XT_TARGET_LOG=m
+CONFIG_NETFILTER_XT_MATCH_ADDRTYPE=m
+CONFIG_NETFILTER_XT_MATCH_COMMENT=m
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=m
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=m
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_IP_NF_RAW=m
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_TARGET_REJECT=m
+CONFIG_IP6_NF_MANGLE=m
+CONFIG_IP6_NF_RAW=m
+CONFIG_QRTR_SMD=m
+CONFIG_QRTR_TUN=m
+CONFIG_BT=m
+CONFIG_BT_RFCOMM=m
+CONFIG_BT_HIDP=m
+CONFIG_BT_HCIUART=m
+CONFIG_BT_HCIUART_QCA=y
+CONFIG_CFG80211=m
+CONFIG_MAC80211=m
+CONFIG_MAC80211_LEDS=y
+CONFIG_RFKILL=m
+CONFIG_PCI=y
+CONFIG_PCIEPORTBUS=y
+CONFIG_PCIEAER=y
+CONFIG_PCIE_QCOM=m
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_FW_LOADER_USER_HELPER=y
+CONFIG_FW_LOADER_COMPRESS=y
+CONFIG_FW_LOADER_COMPRESS_ZSTD=y
+# CONFIG_QCOM_EBI2 is not set
+CONFIG_MHI_BUS_PCI_GENERIC=m
+CONFIG_ARM_SCMI_PROTOCOL=y
+CONFIG_EFI_CAPSULE_LOADER=y
+CONFIG_QCOM_QSEECOM=y
+CONFIG_QCOM_QSEECOM_UEFISECAPP=y
+CONFIG_ZRAM=m
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_NVME=m
+CONFIG_QCOM_FASTRPC=m
+CONFIG_SCSI=y
+# CONFIG_SCSI_PROC_FS is not set
+CONFIG_BLK_DEV_SD=y
+# CONFIG_SCSI_LOWLEVEL is not set
+CONFIG_MD=y
+CONFIG_BLK_DEV_DM=m
+CONFIG_DM_CRYPT=m
+CONFIG_NETDEVICES=y
+CONFIG_WIREGUARD=m
+CONFIG_TUN=y
+CONFIG_VETH=m
+CONFIG_MHI_NET=m
+# CONFIG_ETHERNET is not set
+CONFIG_USB_NET_DRIVERS=m
+CONFIG_USB_RTL8152=m
+# CONFIG_WLAN_VENDOR_ADMTEK is not set
+CONFIG_ATH11K=m
+CONFIG_ATH11K_PCI=m
+CONFIG_ATH12K=m
+# CONFIG_WLAN_VENDOR_ATMEL is not set
+# CONFIG_WLAN_VENDOR_BROADCOM is not set
+# CONFIG_WLAN_VENDOR_INTEL is not set
+# CONFIG_WLAN_VENDOR_INTERSIL is not set
+# CONFIG_WLAN_VENDOR_MARVELL is not set
+# CONFIG_WLAN_VENDOR_MEDIATEK is not set
+# CONFIG_WLAN_VENDOR_MICROCHIP is not set
+# CONFIG_WLAN_VENDOR_PURELIFI is not set
+# CONFIG_WLAN_VENDOR_RALINK is not set
+# CONFIG_WLAN_VENDOR_REALTEK is not set
+# CONFIG_WLAN_VENDOR_RSI is not set
+# CONFIG_WLAN_VENDOR_SILABS is not set
+# CONFIG_WLAN_VENDOR_ST is not set
+# CONFIG_WLAN_VENDOR_TI is not set
+# CONFIG_WLAN_VENDOR_ZYDAS is not set
+# CONFIG_WLAN_VENDOR_QUANTENNA is not set
+CONFIG_WWAN=m
+CONFIG_MHI_WWAN_CTRL=m
+CONFIG_MHI_WWAN_MBIM=m
+CONFIG_INPUT_EVDEV=y
+# CONFIG_KEYBOARD_ATKBD is not set
+CONFIG_KEYBOARD_GPIO=y
+# CONFIG_INPUT_MOUSE is not set
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_PM8941_PWRKEY=y
+# CONFIG_SERIO is not set
+CONFIG_LEGACY_PTY_COUNT=16
+CONFIG_SERIAL_QCOM_GENI=y
+CONFIG_SERIAL_QCOM_GENI_CONSOLE=y
+CONFIG_SERIAL_DEV_BUS=y
+# CONFIG_DEVPORT is not set
+CONFIG_I2C_CHARDEV=m
+CONFIG_I2C_QCOM_CCI=m
+CONFIG_I2C_QCOM_GENI=m
+CONFIG_SPI=y
+CONFIG_SPI_QCOM_GENI=m
+CONFIG_SPMI=y
+CONFIG_PINCTRL_SINGLE=y
+CONFIG_PINCTRL_MSM=y
+CONFIG_PINCTRL_SC8280XP=y
+CONFIG_PINCTRL_X1E80100=y
+CONFIG_PINCTRL_QCOM_SPMI_PMIC=y
+CONFIG_PINCTRL_LPASS_LPI=m
+CONFIG_PINCTRL_SC8280XP_LPASS_LPI=m
+CONFIG_PINCTRL_SM8550_LPASS_LPI=m
+CONFIG_POWER_RESET_QCOM_PON=m
+CONFIG_BATTERY_QCOM_BATTMGR=m
+CONFIG_THERMAL=y
+CONFIG_THERMAL_GOV_POWER_ALLOCATOR=y
+CONFIG_CPU_THERMAL=y
+CONFIG_DEVFREQ_THERMAL=y
+CONFIG_THERMAL_EMULATION=y
+CONFIG_QCOM_TSENS=y
+CONFIG_QCOM_SPMI_ADC_TM5=m
+CONFIG_QCOM_SPMI_TEMP_ALARM=m
+CONFIG_QCOM_LMH=m
+CONFIG_WATCHDOG=y
+CONFIG_ARM_SBSA_WATCHDOG=y
+CONFIG_QCOM_WDT=m
+CONFIG_MFD_SPMI_PMIC=y
+CONFIG_MFD_QCOM_PM8008=m
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_REGULATOR_QCOM_PM8008=m
+CONFIG_REGULATOR_QCOM_RPMH=y
+CONFIG_MEDIA_SUPPORT=m
+CONFIG_MEDIA_CAMERA_SUPPORT=y
+CONFIG_MEDIA_PLATFORM_SUPPORT=y
+CONFIG_MEDIA_USB_SUPPORT=y
+CONFIG_USB_VIDEO_CLASS=m
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_V4L_MEM2MEM_DRIVERS=y
+CONFIG_VIDEO_QCOM_CAMSS=m
+CONFIG_VIDEO_QCOM_VENUS=m
+CONFIG_VIDEO_OV5675=m
+CONFIG_DRM=m
+CONFIG_DRM_MALI_DISPLAY=m
+CONFIG_DRM_MSM=m
+# CONFIG_DRM_MSM_MDP4 is not set
+# CONFIG_DRM_MSM_MDP5 is not set
+# CONFIG_DRM_MSM_DSI is not set
+# CONFIG_DRM_MSM_HDMI is not set
+CONFIG_DRM_PANEL_SAMSUNG_ATNA33XC20=m
+CONFIG_DRM_PANEL_EDP=m
+CONFIG_DRM_DISPLAY_CONNECTOR=m
+CONFIG_FB=y
+CONFIG_FB_EFI=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_PWM=m
+CONFIG_SOUND=m
+CONFIG_SND=m
+# CONFIG_SND_SUPPORT_OLD_API is not set
+# CONFIG_SND_DRIVERS is not set
+# CONFIG_SND_PCI is not set
+# CONFIG_SND_SPI is not set
+CONFIG_SND_USB_AUDIO=m
+CONFIG_SND_SOC=m
+CONFIG_SND_SOC_QCOM=m
+CONFIG_SND_SOC_SC8280XP=m
+CONFIG_SND_SOC_X1E80100=m
+CONFIG_SND_SOC_WCD938X_SDW=m
+CONFIG_SND_SOC_WSA883X=m
+CONFIG_SND_SOC_WSA884X=m
+CONFIG_SND_SOC_LPASS_WSA_MACRO=m
+CONFIG_SND_SOC_LPASS_VA_MACRO=m
+CONFIG_SND_SOC_LPASS_RX_MACRO=m
+CONFIG_SND_SOC_LPASS_TX_MACRO=m
+CONFIG_UHID=m
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_ITE is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_REDRAGON is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+CONFIG_HID_MULTITOUCH=m
+CONFIG_I2C_HID_OF=m
+CONFIG_I2C_HID_OF_ELAN=m
+CONFIG_USB=y
+# CONFIG_USB_PCI is not set
+CONFIG_USB_OTG=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_STORAGE=m
+CONFIG_USB_DWC3=y
+# CONFIG_USB_DWC3_OF_SIMPLE is not set
+CONFIG_USB_SERIAL=m
+CONFIG_USB_SERIAL_FTDI_SIO=m
+CONFIG_USB_GADGET=y
+CONFIG_USB_CONFIGFS=m
+CONFIG_USB_CONFIGFS_SERIAL=y
+CONFIG_TYPEC=m
+CONFIG_TYPEC_TCPM=m
+CONFIG_TYPEC_TCPCI=m
+CONFIG_TYPEC_UCSI=m
+CONFIG_UCSI_PMIC_GLINK=m
+CONFIG_TYPEC_MUX_GPIO_SBU=m
+CONFIG_TYPEC_MUX_PS883X=m
+CONFIG_MMC=m
+CONFIG_MMC_SDHCI=m
+CONFIG_MMC_SDHCI_PLTFM=m
+CONFIG_MMC_SDHCI_MSM=m
+CONFIG_SCSI_UFSHCD=y
+CONFIG_SCSI_UFSHCD_PLATFORM=y
+CONFIG_SCSI_UFS_QCOM=m
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=m
+CONFIG_LEDS_CLASS_MULTICOLOR=m
+CONFIG_LEDS_GPIO=m
+CONFIG_LEDS_QCOM_LPG=m
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_LEDS_TRIGGER_CPU=y
+CONFIG_LEDS_TRIGGER_DEFAULT_ON=y
+CONFIG_LEDS_TRIGGER_PANIC=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_PM8XXX=m
+CONFIG_DMADEVICES=y
+CONFIG_UDMABUF=y
+# CONFIG_VIRTIO_MENU is not set
+# CONFIG_VHOST_MENU is not set
+# CONFIG_SURFACE_PLATFORMS is not set
+CONFIG_COMMON_CLK_QCOM=y
+CONFIG_CLK_X1E80100_CAMCC=y
+CONFIG_CLK_X1E80100_DISPCC=m
+CONFIG_CLK_X1E80100_GPUCC=m
+CONFIG_CLK_X1E80100_TCSRCC=m
+CONFIG_QCOM_CLK_RPMH=y
+CONFIG_SC_CAMCC_8280XP=m
+CONFIG_SC_DISPCC_8280XP=m
+CONFIG_SC_GCC_8280XP=y
+CONFIG_SC_GPUCC_8280XP=m
+CONFIG_SC_LPASSCC_8280XP=m
+CONFIG_SM_VIDEOCC_8350=m
+CONFIG_HWSPINLOCK=y
+CONFIG_HWSPINLOCK_QCOM=y
+# CONFIG_FSL_ERRATUM_A008585 is not set
+# CONFIG_HISILICON_ERRATUM_161010101 is not set
+CONFIG_MAILBOX=y
+CONFIG_QCOM_CPUCP_MBOX=m
+CONFIG_QCOM_IPCC=y
+CONFIG_ARM_SMMU=y
+CONFIG_ARM_SMMU_V3=y
+CONFIG_QCOM_IOMMU=y
+CONFIG_REMOTEPROC=y
+CONFIG_QCOM_Q6V5_ADSP=m
+CONFIG_QCOM_Q6V5_PAS=m
+CONFIG_QCOM_SYSMON=m
+CONFIG_RPMSG_CHAR=m
+CONFIG_RPMSG_CTRL=m
+CONFIG_RPMSG_QCOM_GLINK_SMEM=m
+CONFIG_SOUNDWIRE=m
+CONFIG_SOUNDWIRE_QCOM=m
+CONFIG_QCOM_AOSS_QMP=y
+CONFIG_QCOM_COMMAND_DB=y
+CONFIG_QCOM_GENI_SE=y
+CONFIG_QCOM_LLCC=m
+CONFIG_QCOM_PMIC_GLINK=m
+CONFIG_QCOM_RPMH=y
+CONFIG_QCOM_SMEM=y
+CONFIG_QCOM_SMP2P=y
+CONFIG_QCOM_SOCINFO=m
+CONFIG_QCOM_STATS=m
+CONFIG_QCOM_APR=m
+CONFIG_QCOM_ICC_BWMON=m
+CONFIG_QCOM_RPMHPD=y
+CONFIG_IIO=m
+CONFIG_QCOM_SPMI_ADC5=m
+CONFIG_PWM=y
+CONFIG_QCOM_PDC=y
+CONFIG_RESET_GPIO=m
+CONFIG_RESET_QCOM_AOSS=y
+CONFIG_RESET_QCOM_PDC=m
+CONFIG_PHY_SNPS_EUSB2=m
+CONFIG_PHY_NXP_PTN3222=m
+CONFIG_PHY_QCOM_EDP=m
+CONFIG_PHY_QCOM_QMP=m
+# CONFIG_PHY_QCOM_QMP_PCIE_8996 is not set
+CONFIG_PHY_QCOM_EUSB2_REPEATER=m
+CONFIG_PHY_QCOM_USB_SNPS_FEMTO_V2=m
+CONFIG_NVMEM_QCOM_QFPROM=y
+CONFIG_NVMEM_SPMI_SDAM=m
+CONFIG_MUX_GPIO=m
+# CONFIG_SLIMBUS is not set
+CONFIG_INTERCONNECT_QCOM=y
+CONFIG_INTERCONNECT_QCOM_OSM_L3=m
+CONFIG_INTERCONNECT_QCOM_SC8280XP=y
+CONFIG_INTERCONNECT_QCOM_X1E80100=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_FANOTIFY=y
+CONFIG_QUOTA=y
+CONFIG_AUTOFS_FS=m
+CONFIG_FUSE_FS=m
+CONFIG_OVERLAY_FS=m
+CONFIG_VFAT_FS=y
+CONFIG_NTFS_FS=m
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_HUGETLBFS=y
+CONFIG_CONFIGFS_FS=y
+CONFIG_EFIVAR_FS=y
+# CONFIG_NETWORK_FILESYSTEMS is not set
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_SECURITY=y
+CONFIG_SECURITY_LANDLOCK=y
+# CONFIG_INTEGRITY is not set
+CONFIG_LSM="landlock,lockdown,yama,loadpin,safesetid,integrity,bpf"
+CONFIG_CRYPTO_NULL=y
+CONFIG_CRYPTO_DES=m
+CONFIG_CRYPTO_SHA256=y
+CONFIG_CRYPTO_CRC32C=y
+CONFIG_CRYPTO_ANSI_CPRNG=y
+CONFIG_CRYPTO_DRBG_MENU=y
+CONFIG_CRYPTO_USER_API_HASH=m
+CONFIG_CRYPTO_USER_API_SKCIPHER=m
+CONFIG_CRYPTO_GHASH_ARM64_CE=y
+CONFIG_CRYPTO_SHA1_ARM64_CE=y
+CONFIG_CRYPTO_SHA512_ARM64_CE=m
+CONFIG_CRYPTO_SHA3_ARM64=m
+CONFIG_CRYPTO_SM3_ARM64_CE=m
+CONFIG_CRYPTO_AES_ARM64_BS=m
+CONFIG_CRYPTO_AES_ARM64_CE_CCM=y
+CONFIG_CRYPTO_DEV_QCOM_RNG=m
+CONFIG_CRYPTO_DEV_CCREE=m
+CONFIG_DMA_CMA=y
+CONFIG_CMA_SIZE_MBYTES=128
+CONFIG_PRINTK_TIME=y
+CONFIG_DYNAMIC_DEBUG=y
+CONFIG_DEBUG_KERNEL=y
+CONFIG_DEBUG_FS=y
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_FTRACE is not set
+# CONFIG_RUNTIME_TESTING_MENU is not set
diff -Nrup linux-6.16.7/arch/arm64/tools/syscall_64.tbl linux-lenovo-x13s-linux-6.16.y/arch/arm64/tools/syscall_64.tbl
--- linux-6.16.7/arch/arm64/tools/syscall_64.tbl	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/tools/syscall_64.tbl	2025-09-11 09:47:42.000000000 -0600
@@ -1,410 +1 @@
-# SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note
-#
-# This file contains the system call numbers for all of the
-# more recently added architectures.
-#
-# As a basic principle, no duplication of functionality
-# should be added, e.g. we don't use lseek when llseek
-# is present. New architectures should use this file
-# and implement the less feature-full calls in user space.
-#
-0	common	io_setup			sys_io_setup			compat_sys_io_setup
-1	common	io_destroy			sys_io_destroy
-2	common	io_submit			sys_io_submit			compat_sys_io_submit
-3	common	io_cancel			sys_io_cancel
-4	time32	io_getevents			sys_io_getevents_time32
-4	64	io_getevents			sys_io_getevents
-5	common	setxattr			sys_setxattr
-6	common	lsetxattr			sys_lsetxattr
-7	common	fsetxattr			sys_fsetxattr
-8	common	getxattr			sys_getxattr
-9	common	lgetxattr			sys_lgetxattr
-10	common	fgetxattr			sys_fgetxattr
-11	common	listxattr			sys_listxattr
-12	common	llistxattr			sys_llistxattr
-13	common	flistxattr			sys_flistxattr
-14	common	removexattr			sys_removexattr
-15	common	lremovexattr			sys_lremovexattr
-16	common	fremovexattr			sys_fremovexattr
-17	common	getcwd				sys_getcwd
-18	common	lookup_dcookie			sys_ni_syscall
-19	common	eventfd2			sys_eventfd2
-20	common	epoll_create1			sys_epoll_create1
-21	common	epoll_ctl			sys_epoll_ctl
-22	common	epoll_pwait			sys_epoll_pwait			compat_sys_epoll_pwait
-23	common	dup				sys_dup
-24	common	dup3				sys_dup3
-25	32	fcntl64				sys_fcntl64			compat_sys_fcntl64
-25	64	fcntl				sys_fcntl
-26	common	inotify_init1			sys_inotify_init1
-27	common	inotify_add_watch		sys_inotify_add_watch
-28	common	inotify_rm_watch		sys_inotify_rm_watch
-29	common	ioctl				sys_ioctl			compat_sys_ioctl
-30	common	ioprio_set			sys_ioprio_set
-31	common	ioprio_get			sys_ioprio_get
-32	common	flock				sys_flock
-33	common	mknodat				sys_mknodat
-34	common	mkdirat				sys_mkdirat
-35	common	unlinkat			sys_unlinkat
-36	common	symlinkat			sys_symlinkat
-37	common	linkat				sys_linkat
-# renameat is superseded with flags by renameat2
-38	renameat renameat			sys_renameat
-39	common	umount2				sys_umount
-40	common	mount				sys_mount
-41	common	pivot_root			sys_pivot_root
-42	common	nfsservctl			sys_ni_syscall
-43	32	statfs64			sys_statfs64			compat_sys_statfs64
-43	64	statfs				sys_statfs
-44	32	fstatfs64			sys_fstatfs64			compat_sys_fstatfs64
-44	64	fstatfs				sys_fstatfs
-45	32	truncate64			sys_truncate64			compat_sys_truncate64
-45	64	truncate			sys_truncate
-46	32	ftruncate64			sys_ftruncate64			compat_sys_ftruncate64
-46	64	ftruncate			sys_ftruncate
-47	common	fallocate			sys_fallocate			compat_sys_fallocate
-48	common	faccessat			sys_faccessat
-49	common	chdir				sys_chdir
-50	common	fchdir				sys_fchdir
-51	common	chroot				sys_chroot
-52	common	fchmod				sys_fchmod
-53	common	fchmodat			sys_fchmodat
-54	common	fchownat			sys_fchownat
-55	common	fchown				sys_fchown
-56	common	openat				sys_openat
-57	common	close				sys_close
-58	common	vhangup				sys_vhangup
-59	common	pipe2				sys_pipe2
-60	common	quotactl			sys_quotactl
-61	common	getdents64			sys_getdents64
-62	32	llseek				sys_llseek
-62	64	lseek				sys_lseek
-63	common	read				sys_read
-64	common	write				sys_write
-65	common	readv				sys_readv			sys_readv
-66	common	writev				sys_writev			sys_writev
-67	common	pread64				sys_pread64			compat_sys_pread64
-68	common	pwrite64			sys_pwrite64			compat_sys_pwrite64
-69	common	preadv				sys_preadv			compat_sys_preadv
-70	common	pwritev				sys_pwritev			compat_sys_pwritev
-71	32	sendfile64			sys_sendfile64
-71	64	sendfile			sys_sendfile64
-72	time32	pselect6			sys_pselect6_time32		compat_sys_pselect6_time32
-72	64	pselect6			sys_pselect6
-73	time32	ppoll				sys_ppoll_time32		compat_sys_ppoll_time32
-73	64	ppoll				sys_ppoll
-74	common	signalfd4			sys_signalfd4			compat_sys_signalfd4
-75	common	vmsplice			sys_vmsplice
-76	common	splice				sys_splice
-77	common	tee				sys_tee
-78	common	readlinkat			sys_readlinkat
-79	stat64	fstatat64			sys_fstatat64
-79	64	newfstatat			sys_newfstatat
-80	stat64	fstat64				sys_fstat64
-80	64	fstat				sys_newfstat
-81	common	sync				sys_sync
-82	common	fsync				sys_fsync
-83	common	fdatasync			sys_fdatasync
-84	common	sync_file_range			sys_sync_file_range		compat_sys_sync_file_range
-85	common	timerfd_create			sys_timerfd_create
-86	time32	timerfd_settime			sys_timerfd_settime32
-86	64	timerfd_settime			sys_timerfd_settime
-87	time32	timerfd_gettime			sys_timerfd_gettime32
-87	64	timerfd_gettime			sys_timerfd_gettime
-88	time32	utimensat			sys_utimensat_time32
-88	64	utimensat			sys_utimensat
-89	common	acct				sys_acct
-90	common	capget				sys_capget
-91	common	capset				sys_capset
-92	common	personality			sys_personality
-93	common	exit				sys_exit
-94	common	exit_group			sys_exit_group
-95	common	waitid				sys_waitid			compat_sys_waitid
-96	common	set_tid_address			sys_set_tid_address
-97	common	unshare				sys_unshare
-98	time32	futex				sys_futex_time32
-98	64	futex				sys_futex
-99	common	set_robust_list			sys_set_robust_list		compat_sys_set_robust_list
-100	common	get_robust_list			sys_get_robust_list		compat_sys_get_robust_list
-101	time32	nanosleep			sys_nanosleep_time32
-101	64	nanosleep			sys_nanosleep
-102	common	getitimer			sys_getitimer			compat_sys_getitimer
-103	common	setitimer			sys_setitimer			compat_sys_setitimer
-104	common	kexec_load			sys_kexec_load			compat_sys_kexec_load
-105	common	init_module			sys_init_module
-106	common	delete_module			sys_delete_module
-107	common	timer_create			sys_timer_create		compat_sys_timer_create
-108	time32	timer_gettime			sys_timer_gettime32
-108	64	timer_gettime			sys_timer_gettime
-109	common	timer_getoverrun		sys_timer_getoverrun
-110	time32	timer_settime			sys_timer_settime32
-110	64	timer_settime			sys_timer_settime
-111	common	timer_delete			sys_timer_delete
-112	time32	clock_settime			sys_clock_settime32
-112	64	clock_settime			sys_clock_settime
-113	time32	clock_gettime			sys_clock_gettime32
-113	64	clock_gettime			sys_clock_gettime
-114	time32	clock_getres			sys_clock_getres_time32
-114	64	clock_getres			sys_clock_getres
-115	time32	clock_nanosleep			sys_clock_nanosleep_time32
-115	64	clock_nanosleep			sys_clock_nanosleep
-116	common	syslog				sys_syslog
-117	common	ptrace				sys_ptrace			compat_sys_ptrace
-118	common	sched_setparam			sys_sched_setparam
-119	common	sched_setscheduler		sys_sched_setscheduler
-120	common	sched_getscheduler		sys_sched_getscheduler
-121	common	sched_getparam			sys_sched_getparam
-122	common	sched_setaffinity		sys_sched_setaffinity		compat_sys_sched_setaffinity
-123	common	sched_getaffinity		sys_sched_getaffinity		compat_sys_sched_getaffinity
-124	common	sched_yield			sys_sched_yield
-125	common	sched_get_priority_max		sys_sched_get_priority_max
-126	common	sched_get_priority_min		sys_sched_get_priority_min
-127	time32	sched_rr_get_interval		sys_sched_rr_get_interval_time32
-127	64	sched_rr_get_interval		sys_sched_rr_get_interval
-128	common	restart_syscall			sys_restart_syscall
-129	common	kill				sys_kill
-130	common	tkill				sys_tkill
-131	common	tgkill				sys_tgkill
-132	common	sigaltstack			sys_sigaltstack			compat_sys_sigaltstack
-133	common	rt_sigsuspend			sys_rt_sigsuspend		compat_sys_rt_sigsuspend
-134	common	rt_sigaction			sys_rt_sigaction		compat_sys_rt_sigaction
-135	common	rt_sigprocmask			sys_rt_sigprocmask		compat_sys_rt_sigprocmask
-136	common	rt_sigpending			sys_rt_sigpending		compat_sys_rt_sigpending
-137	time32	rt_sigtimedwait			sys_rt_sigtimedwait_time32	compat_sys_rt_sigtimedwait_time32
-137	64	rt_sigtimedwait			sys_rt_sigtimedwait
-138	common	rt_sigqueueinfo			sys_rt_sigqueueinfo		compat_sys_rt_sigqueueinfo
-139	common	rt_sigreturn			sys_rt_sigreturn		compat_sys_rt_sigreturn
-140	common	setpriority			sys_setpriority
-141	common	getpriority			sys_getpriority
-142	common	reboot				sys_reboot
-143	common	setregid			sys_setregid
-144	common	setgid				sys_setgid
-145	common	setreuid			sys_setreuid
-146	common	setuid				sys_setuid
-147	common	setresuid			sys_setresuid
-148	common	getresuid			sys_getresuid
-149	common	setresgid			sys_setresgid
-150	common	getresgid			sys_getresgid
-151	common	setfsuid			sys_setfsuid
-152	common	setfsgid			sys_setfsgid
-153	common	times				sys_times			compat_sys_times
-154	common	setpgid				sys_setpgid
-155	common	getpgid				sys_getpgid
-156	common	getsid				sys_getsid
-157	common	setsid				sys_setsid
-158	common	getgroups			sys_getgroups
-159	common	setgroups			sys_setgroups
-160	common	uname				sys_newuname
-161	common	sethostname			sys_sethostname
-162	common	setdomainname			sys_setdomainname
-# getrlimit and setrlimit are superseded with prlimit64
-163	rlimit	getrlimit			sys_getrlimit			compat_sys_getrlimit
-164	rlimit	setrlimit			sys_setrlimit			compat_sys_setrlimit
-165	common	getrusage			sys_getrusage			compat_sys_getrusage
-166	common	umask				sys_umask
-167	common	prctl				sys_prctl
-168	common	getcpu				sys_getcpu
-169	time32	gettimeofday			sys_gettimeofday		compat_sys_gettimeofday
-169	64	gettimeofday			sys_gettimeofday
-170	time32	settimeofday			sys_settimeofday		compat_sys_settimeofday
-170	64	settimeofday			sys_settimeofday
-171	time32	adjtimex			sys_adjtimex_time32
-171	64	adjtimex			sys_adjtimex
-172	common	getpid				sys_getpid
-173	common	getppid				sys_getppid
-174	common	getuid				sys_getuid
-175	common	geteuid				sys_geteuid
-176	common	getgid				sys_getgid
-177	common	getegid				sys_getegid
-178	common	gettid				sys_gettid
-179	common	sysinfo				sys_sysinfo			compat_sys_sysinfo
-180	common	mq_open				sys_mq_open			compat_sys_mq_open
-181	common	mq_unlink			sys_mq_unlink
-182	time32	mq_timedsend			sys_mq_timedsend_time32
-182	64	mq_timedsend			sys_mq_timedsend
-183	time32	mq_timedreceive			sys_mq_timedreceive_time32
-183	64	mq_timedreceive			sys_mq_timedreceive
-184	common	mq_notify			sys_mq_notify			compat_sys_mq_notify
-185	common	mq_getsetattr			sys_mq_getsetattr		compat_sys_mq_getsetattr
-186	common	msgget				sys_msgget
-187	common	msgctl				sys_msgctl			compat_sys_msgctl
-188	common	msgrcv				sys_msgrcv			compat_sys_msgrcv
-189	common	msgsnd				sys_msgsnd			compat_sys_msgsnd
-190	common	semget				sys_semget
-191	common	semctl				sys_semctl			compat_sys_semctl
-192	time32	semtimedop			sys_semtimedop_time32
-192	64	semtimedop			sys_semtimedop
-193	common	semop				sys_semop
-194	common	shmget				sys_shmget
-195	common	shmctl				sys_shmctl			compat_sys_shmctl
-196	common	shmat				sys_shmat			compat_sys_shmat
-197	common	shmdt				sys_shmdt
-198	common	socket				sys_socket
-199	common	socketpair			sys_socketpair
-200	common	bind				sys_bind
-201	common	listen				sys_listen
-202	common	accept				sys_accept
-203	common	connect				sys_connect
-204	common	getsockname			sys_getsockname
-205	common	getpeername			sys_getpeername
-206	common	sendto				sys_sendto
-207	common	recvfrom			sys_recvfrom			compat_sys_recvfrom
-208	common	setsockopt			sys_setsockopt			sys_setsockopt
-209	common	getsockopt			sys_getsockopt			sys_getsockopt
-210	common	shutdown			sys_shutdown
-211	common	sendmsg				sys_sendmsg			compat_sys_sendmsg
-212	common	recvmsg				sys_recvmsg			compat_sys_recvmsg
-213	common	readahead			sys_readahead			compat_sys_readahead
-214	common	brk				sys_brk
-215	common	munmap				sys_munmap
-216	common	mremap				sys_mremap
-217	common	add_key				sys_add_key
-218	common	request_key			sys_request_key
-219	common	keyctl				sys_keyctl			compat_sys_keyctl
-220	common	clone				sys_clone
-221	common	execve				sys_execve			compat_sys_execve
-222	32	mmap2				sys_mmap2
-222	64	mmap				sys_mmap
-223	32	fadvise64_64			sys_fadvise64_64		compat_sys_fadvise64_64
-223	64	fadvise64			sys_fadvise64_64
-224	common	swapon				sys_swapon
-225	common	swapoff				sys_swapoff
-226	common	mprotect			sys_mprotect
-227	common	msync				sys_msync
-228	common	mlock				sys_mlock
-229	common	munlock				sys_munlock
-230	common	mlockall			sys_mlockall
-231	common	munlockall			sys_munlockall
-232	common	mincore				sys_mincore
-233	common	madvise				sys_madvise
-234	common	remap_file_pages		sys_remap_file_pages
-235	common	mbind				sys_mbind
-236	common	get_mempolicy			sys_get_mempolicy
-237	common	set_mempolicy			sys_set_mempolicy
-238	common	migrate_pages			sys_migrate_pages
-239	common	move_pages			sys_move_pages
-240	common	rt_tgsigqueueinfo		sys_rt_tgsigqueueinfo		compat_sys_rt_tgsigqueueinfo
-241	common	perf_event_open			sys_perf_event_open
-242	common	accept4				sys_accept4
-243	time32	recvmmsg			sys_recvmmsg_time32		compat_sys_recvmmsg_time32
-243	64	recvmmsg			sys_recvmmsg
-# Architectures may provide up to 16 syscalls of their own between 244 and 259
-244	arc	cacheflush			sys_cacheflush
-245	arc	arc_settls			sys_arc_settls
-246	arc	arc_gettls			sys_arc_gettls
-247	arc	sysfs				sys_sysfs
-248	arc	arc_usr_cmpxchg			sys_arc_usr_cmpxchg
-
-244	csky	set_thread_area			sys_set_thread_area
-245	csky	cacheflush			sys_cacheflush
-
-244	nios2	cacheflush			sys_cacheflush
-
-244	or1k	or1k_atomic			sys_or1k_atomic
-
-258	riscv	riscv_hwprobe			sys_riscv_hwprobe
-259	riscv	riscv_flush_icache		sys_riscv_flush_icache
-
-260	time32	wait4				sys_wait4			compat_sys_wait4
-260	64	wait4				sys_wait4
-261	common	prlimit64			sys_prlimit64
-262	common	fanotify_init			sys_fanotify_init
-263	common	fanotify_mark			sys_fanotify_mark
-264	common	name_to_handle_at		sys_name_to_handle_at
-265	common	open_by_handle_at		sys_open_by_handle_at
-266	time32	clock_adjtime			sys_clock_adjtime32
-266	64	clock_adjtime			sys_clock_adjtime
-267	common	syncfs				sys_syncfs
-268	common	setns				sys_setns
-269	common	sendmmsg			sys_sendmmsg			compat_sys_sendmmsg
-270	common	process_vm_readv		sys_process_vm_readv
-271	common	process_vm_writev		sys_process_vm_writev
-272	common	kcmp				sys_kcmp
-273	common	finit_module			sys_finit_module
-274	common	sched_setattr			sys_sched_setattr
-275	common	sched_getattr			sys_sched_getattr
-276	common	renameat2			sys_renameat2
-277	common	seccomp				sys_seccomp
-278	common	getrandom			sys_getrandom
-279	common	memfd_create			sys_memfd_create
-280	common	bpf				sys_bpf
-281	common	execveat			sys_execveat			compat_sys_execveat
-282	common	userfaultfd			sys_userfaultfd
-283	common	membarrier			sys_membarrier
-284	common	mlock2				sys_mlock2
-285	common	copy_file_range			sys_copy_file_range
-286	common	preadv2				sys_preadv2			compat_sys_preadv2
-287	common	pwritev2			sys_pwritev2			compat_sys_pwritev2
-288	common	pkey_mprotect			sys_pkey_mprotect
-289	common	pkey_alloc			sys_pkey_alloc
-290	common	pkey_free			sys_pkey_free
-291	common	statx				sys_statx
-292	time32	io_pgetevents			sys_io_pgetevents_time32	compat_sys_io_pgetevents
-292	64	io_pgetevents			sys_io_pgetevents
-293	common	rseq				sys_rseq
-294	common	kexec_file_load			sys_kexec_file_load
-# 295 through 402 are unassigned to sync up with generic numbers don't use
-403	32	clock_gettime64			sys_clock_gettime
-404	32	clock_settime64			sys_clock_settime
-405	32	clock_adjtime64			sys_clock_adjtime
-406	32	clock_getres_time64		sys_clock_getres
-407	32	clock_nanosleep_time64		sys_clock_nanosleep
-408	32	timer_gettime64			sys_timer_gettime
-409	32	timer_settime64			sys_timer_settime
-410	32	timerfd_gettime64		sys_timerfd_gettime
-411	32	timerfd_settime64		sys_timerfd_settime
-412	32	utimensat_time64		sys_utimensat
-413	32	pselect6_time64			sys_pselect6			compat_sys_pselect6_time64
-414	32	ppoll_time64			sys_ppoll			compat_sys_ppoll_time64
-416	32	io_pgetevents_time64		sys_io_pgetevents		compat_sys_io_pgetevents_time64
-417	32	recvmmsg_time64			sys_recvmmsg			compat_sys_recvmmsg_time64
-418	32	mq_timedsend_time64		sys_mq_timedsend
-419	32	mq_timedreceive_time64		sys_mq_timedreceive
-420	32	semtimedop_time64		sys_semtimedop
-421	32	rt_sigtimedwait_time64		sys_rt_sigtimedwait		compat_sys_rt_sigtimedwait_time64
-422	32	futex_time64			sys_futex
-423	32	sched_rr_get_interval_time64	sys_sched_rr_get_interval
-424	common	pidfd_send_signal		sys_pidfd_send_signal
-425	common	io_uring_setup			sys_io_uring_setup
-426	common	io_uring_enter			sys_io_uring_enter
-427	common	io_uring_register		sys_io_uring_register
-428	common	open_tree			sys_open_tree
-429	common	move_mount			sys_move_mount
-430	common	fsopen				sys_fsopen
-431	common	fsconfig			sys_fsconfig
-432	common	fsmount				sys_fsmount
-433	common	fspick				sys_fspick
-434	common	pidfd_open			sys_pidfd_open
-435	common	clone3				sys_clone3
-436	common	close_range			sys_close_range
-437	common	openat2				sys_openat2
-438	common	pidfd_getfd			sys_pidfd_getfd
-439	common	faccessat2			sys_faccessat2
-440	common	process_madvise			sys_process_madvise
-441	common	epoll_pwait2			sys_epoll_pwait2		compat_sys_epoll_pwait2
-442	common	mount_setattr			sys_mount_setattr
-443	common	quotactl_fd			sys_quotactl_fd
-444	common	landlock_create_ruleset		sys_landlock_create_ruleset
-445	common	landlock_add_rule		sys_landlock_add_rule
-446	common	landlock_restrict_self		sys_landlock_restrict_self
-447	memfd_secret	memfd_secret		sys_memfd_secret
-448	common	process_mrelease		sys_process_mrelease
-449	common	futex_waitv			sys_futex_waitv
-450	common	set_mempolicy_home_node		sys_set_mempolicy_home_node
-451	common	cachestat			sys_cachestat
-452	common	fchmodat2			sys_fchmodat2
-453	common	map_shadow_stack		sys_map_shadow_stack
-454	common	futex_wake			sys_futex_wake
-455	common	futex_wait			sys_futex_wait
-456	common	futex_requeue			sys_futex_requeue
-457	common	statmount			sys_statmount
-458	common	listmount			sys_listmount
-459	common	lsm_get_self_attr		sys_lsm_get_self_attr
-460	common	lsm_set_self_attr		sys_lsm_set_self_attr
-461	common	lsm_list_modules		sys_lsm_list_modules
-462	common	mseal				sys_mseal
-463	common	setxattrat			sys_setxattrat
-464	common	getxattrat			sys_getxattrat
-465	common	listxattrat			sys_listxattrat
-466	common	removexattrat			sys_removexattrat
-467	common	open_tree_attr			sys_open_tree_attr
+../../../scripts/syscall.tbl
\ No newline at end of file
diff -Nrup linux-6.16.7/arch/powerpc/configs/kvm_guest.config linux-lenovo-x13s-linux-6.16.y/arch/powerpc/configs/kvm_guest.config
--- linux-6.16.7/arch/powerpc/configs/kvm_guest.config	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/powerpc/configs/kvm_guest.config	2025-09-11 09:47:42.000000000 -0600
@@ -1,35 +1 @@
-# Help: Bootable as a KVM guest
-CONFIG_NET=y
-CONFIG_NET_CORE=y
-CONFIG_NETDEVICES=y
-CONFIG_BLOCK=y
-CONFIG_BLK_DEV=y
-CONFIG_NETWORK_FILESYSTEMS=y
-CONFIG_INET=y
-CONFIG_TTY=y
-CONFIG_SERIAL_8250=y
-CONFIG_SERIAL_8250_CONSOLE=y
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-CONFIG_BINFMT_ELF=y
-CONFIG_PCI=y
-CONFIG_PCI_MSI=y
-CONFIG_DEBUG_KERNEL=y
-CONFIG_VIRTUALIZATION=y
-CONFIG_HYPERVISOR_GUEST=y
-CONFIG_PARAVIRT=y
-CONFIG_KVM_GUEST=y
-CONFIG_S390_GUEST=y
-CONFIG_VIRTIO=y
-CONFIG_VIRTIO_MENU=y
-CONFIG_VIRTIO_PCI=y
-CONFIG_VIRTIO_BLK=y
-CONFIG_VIRTIO_CONSOLE=y
-CONFIG_VIRTIO_NET=y
-CONFIG_9P_FS=y
-CONFIG_NET_9P=y
-CONFIG_NET_9P_VIRTIO=y
-CONFIG_SCSI_LOWLEVEL=y
-CONFIG_SCSI_VIRTIO=y
-CONFIG_VIRTIO_INPUT=y
-CONFIG_DRM_VIRTIO_GPU=y
+../../../kernel/configs/kvm_guest.config
\ No newline at end of file
diff -Nrup linux-6.16.7/arch/sparc/mm/init_64.c linux-lenovo-x13s-linux-6.16.y/arch/sparc/mm/init_64.c
--- linux-6.16.7/arch/sparc/mm/init_64.c	2025-09-13 16:15:37.959497541 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/sparc/mm/init_64.c	2025-09-11 09:47:42.000000000 -0600
@@ -3068,11 +3068,11 @@ static inline resource_size_t compute_ke
 static void __init kernel_lds_init(void)
 {
 	code_resource.start = compute_kern_paddr(_text);
-	code_resource.end   = compute_kern_paddr(_etext) - 1;
+	code_resource.end   = compute_kern_paddr(_etext - 1);
 	data_resource.start = compute_kern_paddr(_etext);
-	data_resource.end   = compute_kern_paddr(_edata) - 1;
+	data_resource.end   = compute_kern_paddr(_edata - 1);
 	bss_resource.start  = compute_kern_paddr(__bss_start);
-	bss_resource.end    = compute_kern_paddr(_end) - 1;
+	bss_resource.end    = compute_kern_paddr(_end - 1);
 }
 
 static int __init report_memory(void)
diff -Nrup linux-6.16.7/arch/sparc/mm/init_64.c.orig linux-lenovo-x13s-linux-6.16.y/arch/sparc/mm/init_64.c.orig
--- linux-6.16.7/arch/sparc/mm/init_64.c.orig	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/sparc/mm/init_64.c.orig	1969-12-31 17:00:00.000000000 -0700
@@ -1,3214 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- *  arch/sparc64/mm/init.c
- *
- *  Copyright (C) 1996-1999 David S. Miller (davem@caip.rutgers.edu)
- *  Copyright (C) 1997-1999 Jakub Jelinek (jj@sunsite.mff.cuni.cz)
- */
- 
-#include <linux/extable.h>
-#include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/string.h>
-#include <linux/init.h>
-#include <linux/memblock.h>
-#include <linux/mm.h>
-#include <linux/hugetlb.h>
-#include <linux/initrd.h>
-#include <linux/swap.h>
-#include <linux/pagemap.h>
-#include <linux/poison.h>
-#include <linux/fs.h>
-#include <linux/seq_file.h>
-#include <linux/kprobes.h>
-#include <linux/cache.h>
-#include <linux/sort.h>
-#include <linux/ioport.h>
-#include <linux/percpu.h>
-#include <linux/mmzone.h>
-#include <linux/gfp.h>
-#include <linux/bootmem_info.h>
-
-#include <asm/head.h>
-#include <asm/page.h>
-#include <asm/pgalloc.h>
-#include <asm/oplib.h>
-#include <asm/iommu.h>
-#include <asm/io.h>
-#include <linux/uaccess.h>
-#include <asm/mmu_context.h>
-#include <asm/tlbflush.h>
-#include <asm/dma.h>
-#include <asm/starfire.h>
-#include <asm/tlb.h>
-#include <asm/spitfire.h>
-#include <asm/sections.h>
-#include <asm/tsb.h>
-#include <asm/hypervisor.h>
-#include <asm/prom.h>
-#include <asm/mdesc.h>
-#include <asm/cpudata.h>
-#include <asm/setup.h>
-#include <asm/irq.h>
-
-#include "init_64.h"
-
-unsigned long kern_linear_pte_xor[4] __read_mostly;
-static unsigned long page_cache4v_flag;
-
-/* A bitmap, two bits for every 256MB of physical memory.  These two
- * bits determine what page size we use for kernel linear
- * translations.  They form an index into kern_linear_pte_xor[].  The
- * value in the indexed slot is XOR'd with the TLB miss virtual
- * address to form the resulting TTE.  The mapping is:
- *
- *	0	==>	4MB
- *	1	==>	256MB
- *	2	==>	2GB
- *	3	==>	16GB
- *
- * All sun4v chips support 256MB pages.  Only SPARC-T4 and later
- * support 2GB pages, and hopefully future cpus will support the 16GB
- * pages as well.  For slots 2 and 3, we encode a 256MB TTE xor there
- * if these larger page sizes are not supported by the cpu.
- *
- * It would be nice to determine this from the machine description
- * 'cpu' properties, but we need to have this table setup before the
- * MDESC is initialized.
- */
-
-#ifndef CONFIG_DEBUG_PAGEALLOC
-/* A special kernel TSB for 4MB, 256MB, 2GB and 16GB linear mappings.
- * Space is allocated for this right after the trap table in
- * arch/sparc64/kernel/head.S
- */
-extern struct tsb swapper_4m_tsb[KERNEL_TSB4M_NENTRIES];
-#endif
-extern struct tsb swapper_tsb[KERNEL_TSB_NENTRIES];
-
-static unsigned long cpu_pgsz_mask;
-
-#define MAX_BANKS	1024
-
-static struct linux_prom64_registers pavail[MAX_BANKS];
-static int pavail_ents;
-
-u64 numa_latency[MAX_NUMNODES][MAX_NUMNODES];
-
-static int cmp_p64(const void *a, const void *b)
-{
-	const struct linux_prom64_registers *x = a, *y = b;
-
-	if (x->phys_addr > y->phys_addr)
-		return 1;
-	if (x->phys_addr < y->phys_addr)
-		return -1;
-	return 0;
-}
-
-static void __init read_obp_memory(const char *property,
-				   struct linux_prom64_registers *regs,
-				   int *num_ents)
-{
-	phandle node = prom_finddevice("/memory");
-	int prop_size = prom_getproplen(node, property);
-	int ents, ret, i;
-
-	ents = prop_size / sizeof(struct linux_prom64_registers);
-	if (ents > MAX_BANKS) {
-		prom_printf("The machine has more %s property entries than "
-			    "this kernel can support (%d).\n",
-			    property, MAX_BANKS);
-		prom_halt();
-	}
-
-	ret = prom_getproperty(node, property, (char *) regs, prop_size);
-	if (ret == -1) {
-		prom_printf("Couldn't get %s property from /memory.\n",
-				property);
-		prom_halt();
-	}
-
-	/* Sanitize what we got from the firmware, by page aligning
-	 * everything.
-	 */
-	for (i = 0; i < ents; i++) {
-		unsigned long base, size;
-
-		base = regs[i].phys_addr;
-		size = regs[i].reg_size;
-
-		size &= PAGE_MASK;
-		if (base & ~PAGE_MASK) {
-			unsigned long new_base = PAGE_ALIGN(base);
-
-			size -= new_base - base;
-			if ((long) size < 0L)
-				size = 0UL;
-			base = new_base;
-		}
-		if (size == 0UL) {
-			/* If it is empty, simply get rid of it.
-			 * This simplifies the logic of the other
-			 * functions that process these arrays.
-			 */
-			memmove(&regs[i], &regs[i + 1],
-				(ents - i - 1) * sizeof(regs[0]));
-			i--;
-			ents--;
-			continue;
-		}
-		regs[i].phys_addr = base;
-		regs[i].reg_size = size;
-	}
-
-	*num_ents = ents;
-
-	sort(regs, ents, sizeof(struct linux_prom64_registers),
-	     cmp_p64, NULL);
-}
-
-/* Kernel physical address base and size in bytes.  */
-unsigned long kern_base __read_mostly;
-unsigned long kern_size __read_mostly;
-
-/* Initial ramdisk setup */
-extern unsigned long sparc_ramdisk_image64;
-extern unsigned int sparc_ramdisk_image;
-extern unsigned int sparc_ramdisk_size;
-
-struct page *mem_map_zero __read_mostly;
-EXPORT_SYMBOL(mem_map_zero);
-
-unsigned int sparc64_highest_unlocked_tlb_ent __read_mostly;
-
-unsigned long sparc64_kern_pri_context __read_mostly;
-unsigned long sparc64_kern_pri_nuc_bits __read_mostly;
-unsigned long sparc64_kern_sec_context __read_mostly;
-
-int num_kernel_image_mappings;
-
-#ifdef CONFIG_DEBUG_DCFLUSH
-atomic_t dcpage_flushes = ATOMIC_INIT(0);
-#ifdef CONFIG_SMP
-atomic_t dcpage_flushes_xcall = ATOMIC_INIT(0);
-#endif
-#endif
-
-inline void flush_dcache_folio_impl(struct folio *folio)
-{
-	unsigned int i, nr = folio_nr_pages(folio);
-
-	BUG_ON(tlb_type == hypervisor);
-#ifdef CONFIG_DEBUG_DCFLUSH
-	atomic_inc(&dcpage_flushes);
-#endif
-
-#ifdef DCACHE_ALIASING_POSSIBLE
-	for (i = 0; i < nr; i++)
-		__flush_dcache_page(folio_address(folio) + i * PAGE_SIZE,
-				    ((tlb_type == spitfire) &&
-				     folio_flush_mapping(folio) != NULL));
-#else
-	if (folio_flush_mapping(folio) != NULL &&
-	    tlb_type == spitfire) {
-		for (i = 0; i < nr; i++)
-			__flush_icache_page((pfn + i) * PAGE_SIZE);
-	}
-#endif
-}
-
-#define PG_dcache_dirty		PG_arch_1
-#define PG_dcache_cpu_shift	32UL
-#define PG_dcache_cpu_mask	\
-	((1UL<<ilog2(roundup_pow_of_two(NR_CPUS)))-1UL)
-
-#define dcache_dirty_cpu(folio) \
-	(((folio)->flags >> PG_dcache_cpu_shift) & PG_dcache_cpu_mask)
-
-static inline void set_dcache_dirty(struct folio *folio, int this_cpu)
-{
-	unsigned long mask = this_cpu;
-	unsigned long non_cpu_bits;
-
-	non_cpu_bits = ~(PG_dcache_cpu_mask << PG_dcache_cpu_shift);
-	mask = (mask << PG_dcache_cpu_shift) | (1UL << PG_dcache_dirty);
-
-	__asm__ __volatile__("1:\n\t"
-			     "ldx	[%2], %%g7\n\t"
-			     "and	%%g7, %1, %%g1\n\t"
-			     "or	%%g1, %0, %%g1\n\t"
-			     "casx	[%2], %%g7, %%g1\n\t"
-			     "cmp	%%g7, %%g1\n\t"
-			     "bne,pn	%%xcc, 1b\n\t"
-			     " nop"
-			     : /* no outputs */
-			     : "r" (mask), "r" (non_cpu_bits), "r" (&folio->flags)
-			     : "g1", "g7");
-}
-
-static inline void clear_dcache_dirty_cpu(struct folio *folio, unsigned long cpu)
-{
-	unsigned long mask = (1UL << PG_dcache_dirty);
-
-	__asm__ __volatile__("! test_and_clear_dcache_dirty\n"
-			     "1:\n\t"
-			     "ldx	[%2], %%g7\n\t"
-			     "srlx	%%g7, %4, %%g1\n\t"
-			     "and	%%g1, %3, %%g1\n\t"
-			     "cmp	%%g1, %0\n\t"
-			     "bne,pn	%%icc, 2f\n\t"
-			     " andn	%%g7, %1, %%g1\n\t"
-			     "casx	[%2], %%g7, %%g1\n\t"
-			     "cmp	%%g7, %%g1\n\t"
-			     "bne,pn	%%xcc, 1b\n\t"
-			     " nop\n"
-			     "2:"
-			     : /* no outputs */
-			     : "r" (cpu), "r" (mask), "r" (&folio->flags),
-			       "i" (PG_dcache_cpu_mask),
-			       "i" (PG_dcache_cpu_shift)
-			     : "g1", "g7");
-}
-
-static inline void tsb_insert(struct tsb *ent, unsigned long tag, unsigned long pte)
-{
-	unsigned long tsb_addr = (unsigned long) ent;
-
-	if (tlb_type == cheetah_plus || tlb_type == hypervisor)
-		tsb_addr = __pa(tsb_addr);
-
-	__tsb_insert(tsb_addr, tag, pte);
-}
-
-unsigned long _PAGE_ALL_SZ_BITS __read_mostly;
-
-static void flush_dcache(unsigned long pfn)
-{
-	struct page *page;
-
-	page = pfn_to_page(pfn);
-	if (page) {
-		struct folio *folio = page_folio(page);
-		unsigned long pg_flags;
-
-		pg_flags = folio->flags;
-		if (pg_flags & (1UL << PG_dcache_dirty)) {
-			int cpu = ((pg_flags >> PG_dcache_cpu_shift) &
-				   PG_dcache_cpu_mask);
-			int this_cpu = get_cpu();
-
-			/* This is just to optimize away some function calls
-			 * in the SMP case.
-			 */
-			if (cpu == this_cpu)
-				flush_dcache_folio_impl(folio);
-			else
-				smp_flush_dcache_folio_impl(folio, cpu);
-
-			clear_dcache_dirty_cpu(folio, cpu);
-
-			put_cpu();
-		}
-	}
-}
-
-/* mm->context.lock must be held */
-static void __update_mmu_tsb_insert(struct mm_struct *mm, unsigned long tsb_index,
-				    unsigned long tsb_hash_shift, unsigned long address,
-				    unsigned long tte)
-{
-	struct tsb *tsb = mm->context.tsb_block[tsb_index].tsb;
-	unsigned long tag;
-
-	if (unlikely(!tsb))
-		return;
-
-	tsb += ((address >> tsb_hash_shift) &
-		(mm->context.tsb_block[tsb_index].tsb_nentries - 1UL));
-	tag = (address >> 22UL);
-	tsb_insert(tsb, tag, tte);
-}
-
-#ifdef CONFIG_HUGETLB_PAGE
-static int __init hugetlbpage_init(void)
-{
-	hugetlb_add_hstate(HPAGE_64K_SHIFT - PAGE_SHIFT);
-	hugetlb_add_hstate(HPAGE_SHIFT - PAGE_SHIFT);
-	hugetlb_add_hstate(HPAGE_256MB_SHIFT - PAGE_SHIFT);
-	hugetlb_add_hstate(HPAGE_2GB_SHIFT - PAGE_SHIFT);
-
-	return 0;
-}
-
-arch_initcall(hugetlbpage_init);
-
-static void __init pud_huge_patch(void)
-{
-	struct pud_huge_patch_entry *p;
-	unsigned long addr;
-
-	p = &__pud_huge_patch;
-	addr = p->addr;
-	*(unsigned int *)addr = p->insn;
-
-	__asm__ __volatile__("flush %0" : : "r" (addr));
-}
-
-bool __init arch_hugetlb_valid_size(unsigned long size)
-{
-	unsigned int hugepage_shift = ilog2(size);
-	unsigned short hv_pgsz_idx;
-	unsigned int hv_pgsz_mask;
-
-	switch (hugepage_shift) {
-	case HPAGE_16GB_SHIFT:
-		hv_pgsz_mask = HV_PGSZ_MASK_16GB;
-		hv_pgsz_idx = HV_PGSZ_IDX_16GB;
-		pud_huge_patch();
-		break;
-	case HPAGE_2GB_SHIFT:
-		hv_pgsz_mask = HV_PGSZ_MASK_2GB;
-		hv_pgsz_idx = HV_PGSZ_IDX_2GB;
-		break;
-	case HPAGE_256MB_SHIFT:
-		hv_pgsz_mask = HV_PGSZ_MASK_256MB;
-		hv_pgsz_idx = HV_PGSZ_IDX_256MB;
-		break;
-	case HPAGE_SHIFT:
-		hv_pgsz_mask = HV_PGSZ_MASK_4MB;
-		hv_pgsz_idx = HV_PGSZ_IDX_4MB;
-		break;
-	case HPAGE_64K_SHIFT:
-		hv_pgsz_mask = HV_PGSZ_MASK_64K;
-		hv_pgsz_idx = HV_PGSZ_IDX_64K;
-		break;
-	default:
-		hv_pgsz_mask = 0;
-	}
-
-	if ((hv_pgsz_mask & cpu_pgsz_mask) == 0U)
-		return false;
-
-	return true;
-}
-#endif	/* CONFIG_HUGETLB_PAGE */
-
-void update_mmu_cache_range(struct vm_fault *vmf, struct vm_area_struct *vma,
-		unsigned long address, pte_t *ptep, unsigned int nr)
-{
-	struct mm_struct *mm;
-	unsigned long flags;
-	bool is_huge_tsb;
-	pte_t pte = *ptep;
-	unsigned int i;
-
-	if (tlb_type != hypervisor) {
-		unsigned long pfn = pte_pfn(pte);
-
-		if (pfn_valid(pfn))
-			flush_dcache(pfn);
-	}
-
-	mm = vma->vm_mm;
-
-	/* Don't insert a non-valid PTE into the TSB, we'll deadlock.  */
-	if (!pte_accessible(mm, pte))
-		return;
-
-	spin_lock_irqsave(&mm->context.lock, flags);
-
-	is_huge_tsb = false;
-#if defined(CONFIG_HUGETLB_PAGE) || defined(CONFIG_TRANSPARENT_HUGEPAGE)
-	if (mm->context.hugetlb_pte_count || mm->context.thp_pte_count) {
-		unsigned long hugepage_size = PAGE_SIZE;
-
-		if (is_vm_hugetlb_page(vma))
-			hugepage_size = huge_page_size(hstate_vma(vma));
-
-		if (hugepage_size >= PUD_SIZE) {
-			unsigned long mask = 0x1ffc00000UL;
-
-			/* Transfer bits [32:22] from address to resolve
-			 * at 4M granularity.
-			 */
-			pte_val(pte) &= ~mask;
-			pte_val(pte) |= (address & mask);
-		} else if (hugepage_size >= PMD_SIZE) {
-			/* We are fabricating 8MB pages using 4MB
-			 * real hw pages.
-			 */
-			pte_val(pte) |= (address & (1UL << REAL_HPAGE_SHIFT));
-		}
-
-		if (hugepage_size >= PMD_SIZE) {
-			__update_mmu_tsb_insert(mm, MM_TSB_HUGE,
-				REAL_HPAGE_SHIFT, address, pte_val(pte));
-			is_huge_tsb = true;
-		}
-	}
-#endif
-	if (!is_huge_tsb) {
-		for (i = 0; i < nr; i++) {
-			__update_mmu_tsb_insert(mm, MM_TSB_BASE, PAGE_SHIFT,
-						address, pte_val(pte));
-			address += PAGE_SIZE;
-			pte_val(pte) += PAGE_SIZE;
-		}
-	}
-
-	spin_unlock_irqrestore(&mm->context.lock, flags);
-}
-
-void flush_dcache_folio(struct folio *folio)
-{
-	unsigned long pfn = folio_pfn(folio);
-	struct address_space *mapping;
-	int this_cpu;
-
-	if (tlb_type == hypervisor)
-		return;
-
-	/* Do not bother with the expensive D-cache flush if it
-	 * is merely the zero page.  The 'bigcore' testcase in GDB
-	 * causes this case to run millions of times.
-	 */
-	if (is_zero_pfn(pfn))
-		return;
-
-	this_cpu = get_cpu();
-
-	mapping = folio_flush_mapping(folio);
-	if (mapping && !mapping_mapped(mapping)) {
-		bool dirty = test_bit(PG_dcache_dirty, &folio->flags);
-		if (dirty) {
-			int dirty_cpu = dcache_dirty_cpu(folio);
-
-			if (dirty_cpu == this_cpu)
-				goto out;
-			smp_flush_dcache_folio_impl(folio, dirty_cpu);
-		}
-		set_dcache_dirty(folio, this_cpu);
-	} else {
-		/* We could delay the flush for the !folio_mapping
-		 * case too.  But that case is for exec env/arg
-		 * pages and those are %99 certainly going to get
-		 * faulted into the tlb (and thus flushed) anyways.
-		 */
-		flush_dcache_folio_impl(folio);
-	}
-
-out:
-	put_cpu();
-}
-EXPORT_SYMBOL(flush_dcache_folio);
-
-void __kprobes flush_icache_range(unsigned long start, unsigned long end)
-{
-	/* Cheetah and Hypervisor platform cpus have coherent I-cache. */
-	if (tlb_type == spitfire) {
-		unsigned long kaddr;
-
-		/* This code only runs on Spitfire cpus so this is
-		 * why we can assume _PAGE_PADDR_4U.
-		 */
-		for (kaddr = start; kaddr < end; kaddr += PAGE_SIZE) {
-			unsigned long paddr, mask = _PAGE_PADDR_4U;
-
-			if (kaddr >= PAGE_OFFSET)
-				paddr = kaddr & mask;
-			else {
-				pte_t *ptep = virt_to_kpte(kaddr);
-
-				paddr = pte_val(*ptep) & mask;
-			}
-			__flush_icache_page(paddr);
-		}
-	}
-}
-EXPORT_SYMBOL(flush_icache_range);
-
-void mmu_info(struct seq_file *m)
-{
-	static const char *pgsz_strings[] = {
-		"8K", "64K", "512K", "4MB", "32MB",
-		"256MB", "2GB", "16GB",
-	};
-	int i, printed;
-
-	if (tlb_type == cheetah)
-		seq_printf(m, "MMU Type\t: Cheetah\n");
-	else if (tlb_type == cheetah_plus)
-		seq_printf(m, "MMU Type\t: Cheetah+\n");
-	else if (tlb_type == spitfire)
-		seq_printf(m, "MMU Type\t: Spitfire\n");
-	else if (tlb_type == hypervisor)
-		seq_printf(m, "MMU Type\t: Hypervisor (sun4v)\n");
-	else
-		seq_printf(m, "MMU Type\t: ???\n");
-
-	seq_printf(m, "MMU PGSZs\t: ");
-	printed = 0;
-	for (i = 0; i < ARRAY_SIZE(pgsz_strings); i++) {
-		if (cpu_pgsz_mask & (1UL << i)) {
-			seq_printf(m, "%s%s",
-				   printed ? "," : "", pgsz_strings[i]);
-			printed++;
-		}
-	}
-	seq_putc(m, '\n');
-
-#ifdef CONFIG_DEBUG_DCFLUSH
-	seq_printf(m, "DCPageFlushes\t: %d\n",
-		   atomic_read(&dcpage_flushes));
-#ifdef CONFIG_SMP
-	seq_printf(m, "DCPageFlushesXC\t: %d\n",
-		   atomic_read(&dcpage_flushes_xcall));
-#endif /* CONFIG_SMP */
-#endif /* CONFIG_DEBUG_DCFLUSH */
-}
-
-struct linux_prom_translation prom_trans[512] __read_mostly;
-unsigned int prom_trans_ents __read_mostly;
-
-unsigned long kern_locked_tte_data;
-
-/* The obp translations are saved based on 8k pagesize, since obp can
- * use a mixture of pagesizes. Misses to the LOW_OBP_ADDRESS ->
- * HI_OBP_ADDRESS range are handled in ktlb.S.
- */
-static inline int in_obp_range(unsigned long vaddr)
-{
-	return (vaddr >= LOW_OBP_ADDRESS &&
-		vaddr < HI_OBP_ADDRESS);
-}
-
-static int cmp_ptrans(const void *a, const void *b)
-{
-	const struct linux_prom_translation *x = a, *y = b;
-
-	if (x->virt > y->virt)
-		return 1;
-	if (x->virt < y->virt)
-		return -1;
-	return 0;
-}
-
-/* Read OBP translations property into 'prom_trans[]'.  */
-static void __init read_obp_translations(void)
-{
-	int n, node, ents, first, last, i;
-
-	node = prom_finddevice("/virtual-memory");
-	n = prom_getproplen(node, "translations");
-	if (unlikely(n == 0 || n == -1)) {
-		prom_printf("prom_mappings: Couldn't get size.\n");
-		prom_halt();
-	}
-	if (unlikely(n > sizeof(prom_trans))) {
-		prom_printf("prom_mappings: Size %d is too big.\n", n);
-		prom_halt();
-	}
-
-	if ((n = prom_getproperty(node, "translations",
-				  (char *)&prom_trans[0],
-				  sizeof(prom_trans))) == -1) {
-		prom_printf("prom_mappings: Couldn't get property.\n");
-		prom_halt();
-	}
-
-	n = n / sizeof(struct linux_prom_translation);
-
-	ents = n;
-
-	sort(prom_trans, ents, sizeof(struct linux_prom_translation),
-	     cmp_ptrans, NULL);
-
-	/* Now kick out all the non-OBP entries.  */
-	for (i = 0; i < ents; i++) {
-		if (in_obp_range(prom_trans[i].virt))
-			break;
-	}
-	first = i;
-	for (; i < ents; i++) {
-		if (!in_obp_range(prom_trans[i].virt))
-			break;
-	}
-	last = i;
-
-	for (i = 0; i < (last - first); i++) {
-		struct linux_prom_translation *src = &prom_trans[i + first];
-		struct linux_prom_translation *dest = &prom_trans[i];
-
-		*dest = *src;
-	}
-	for (; i < ents; i++) {
-		struct linux_prom_translation *dest = &prom_trans[i];
-		dest->virt = dest->size = dest->data = 0x0UL;
-	}
-
-	prom_trans_ents = last - first;
-
-	if (tlb_type == spitfire) {
-		/* Clear diag TTE bits. */
-		for (i = 0; i < prom_trans_ents; i++)
-			prom_trans[i].data &= ~0x0003fe0000000000UL;
-	}
-
-	/* Force execute bit on.  */
-	for (i = 0; i < prom_trans_ents; i++)
-		prom_trans[i].data |= (tlb_type == hypervisor ?
-				       _PAGE_EXEC_4V : _PAGE_EXEC_4U);
-}
-
-static void __init hypervisor_tlb_lock(unsigned long vaddr,
-				       unsigned long pte,
-				       unsigned long mmu)
-{
-	unsigned long ret = sun4v_mmu_map_perm_addr(vaddr, 0, pte, mmu);
-
-	if (ret != 0) {
-		prom_printf("hypervisor_tlb_lock[%lx:%x:%lx:%lx]: "
-			    "errors with %lx\n", vaddr, 0, pte, mmu, ret);
-		prom_halt();
-	}
-}
-
-static unsigned long kern_large_tte(unsigned long paddr);
-
-static void __init remap_kernel(void)
-{
-	unsigned long phys_page, tte_vaddr, tte_data;
-	int i, tlb_ent = sparc64_highest_locked_tlbent();
-
-	tte_vaddr = (unsigned long) KERNBASE;
-	phys_page = (prom_boot_mapping_phys_low >> ILOG2_4MB) << ILOG2_4MB;
-	tte_data = kern_large_tte(phys_page);
-
-	kern_locked_tte_data = tte_data;
-
-	/* Now lock us into the TLBs via Hypervisor or OBP. */
-	if (tlb_type == hypervisor) {
-		for (i = 0; i < num_kernel_image_mappings; i++) {
-			hypervisor_tlb_lock(tte_vaddr, tte_data, HV_MMU_DMMU);
-			hypervisor_tlb_lock(tte_vaddr, tte_data, HV_MMU_IMMU);
-			tte_vaddr += 0x400000;
-			tte_data += 0x400000;
-		}
-	} else {
-		for (i = 0; i < num_kernel_image_mappings; i++) {
-			prom_dtlb_load(tlb_ent - i, tte_data, tte_vaddr);
-			prom_itlb_load(tlb_ent - i, tte_data, tte_vaddr);
-			tte_vaddr += 0x400000;
-			tte_data += 0x400000;
-		}
-		sparc64_highest_unlocked_tlb_ent = tlb_ent - i;
-	}
-	if (tlb_type == cheetah_plus) {
-		sparc64_kern_pri_context = (CTX_CHEETAH_PLUS_CTX0 |
-					    CTX_CHEETAH_PLUS_NUC);
-		sparc64_kern_pri_nuc_bits = CTX_CHEETAH_PLUS_NUC;
-		sparc64_kern_sec_context = CTX_CHEETAH_PLUS_CTX0;
-	}
-}
-
-
-static void __init inherit_prom_mappings(void)
-{
-	/* Now fixup OBP's idea about where we really are mapped. */
-	printk("Remapping the kernel... ");
-	remap_kernel();
-	printk("done.\n");
-}
-
-void prom_world(int enter)
-{
-	/*
-	 * No need to change the address space any more, just flush
-	 * the register windows
-	 */
-	__asm__ __volatile__("flushw");
-}
-
-void __flush_dcache_range(unsigned long start, unsigned long end)
-{
-	unsigned long va;
-
-	if (tlb_type == spitfire) {
-		int n = 0;
-
-		for (va = start; va < end; va += 32) {
-			spitfire_put_dcache_tag(va & 0x3fe0, 0x0);
-			if (++n >= 512)
-				break;
-		}
-	} else if (tlb_type == cheetah || tlb_type == cheetah_plus) {
-		start = __pa(start);
-		end = __pa(end);
-		for (va = start; va < end; va += 32)
-			__asm__ __volatile__("stxa %%g0, [%0] %1\n\t"
-					     "membar #Sync"
-					     : /* no outputs */
-					     : "r" (va),
-					       "i" (ASI_DCACHE_INVALIDATE));
-	}
-}
-EXPORT_SYMBOL(__flush_dcache_range);
-
-/* get_new_mmu_context() uses "cache + 1".  */
-DEFINE_SPINLOCK(ctx_alloc_lock);
-unsigned long tlb_context_cache = CTX_FIRST_VERSION;
-#define MAX_CTX_NR	(1UL << CTX_NR_BITS)
-#define CTX_BMAP_SLOTS	BITS_TO_LONGS(MAX_CTX_NR)
-DECLARE_BITMAP(mmu_context_bmap, MAX_CTX_NR);
-DEFINE_PER_CPU(struct mm_struct *, per_cpu_secondary_mm) = {0};
-
-static void mmu_context_wrap(void)
-{
-	unsigned long old_ver = tlb_context_cache & CTX_VERSION_MASK;
-	unsigned long new_ver, new_ctx, old_ctx;
-	struct mm_struct *mm;
-	int cpu;
-
-	bitmap_zero(mmu_context_bmap, 1 << CTX_NR_BITS);
-
-	/* Reserve kernel context */
-	set_bit(0, mmu_context_bmap);
-
-	new_ver = (tlb_context_cache & CTX_VERSION_MASK) + CTX_FIRST_VERSION;
-	if (unlikely(new_ver == 0))
-		new_ver = CTX_FIRST_VERSION;
-	tlb_context_cache = new_ver;
-
-	/*
-	 * Make sure that any new mm that are added into per_cpu_secondary_mm,
-	 * are going to go through get_new_mmu_context() path.
-	 */
-	mb();
-
-	/*
-	 * Updated versions to current on those CPUs that had valid secondary
-	 * contexts
-	 */
-	for_each_online_cpu(cpu) {
-		/*
-		 * If a new mm is stored after we took this mm from the array,
-		 * it will go into get_new_mmu_context() path, because we
-		 * already bumped the version in tlb_context_cache.
-		 */
-		mm = per_cpu(per_cpu_secondary_mm, cpu);
-
-		if (unlikely(!mm || mm == &init_mm))
-			continue;
-
-		old_ctx = mm->context.sparc64_ctx_val;
-		if (likely((old_ctx & CTX_VERSION_MASK) == old_ver)) {
-			new_ctx = (old_ctx & ~CTX_VERSION_MASK) | new_ver;
-			set_bit(new_ctx & CTX_NR_MASK, mmu_context_bmap);
-			mm->context.sparc64_ctx_val = new_ctx;
-		}
-	}
-}
-
-/* Caller does TLB context flushing on local CPU if necessary.
- * The caller also ensures that CTX_VALID(mm->context) is false.
- *
- * We must be careful about boundary cases so that we never
- * let the user have CTX 0 (nucleus) or we ever use a CTX
- * version of zero (and thus NO_CONTEXT would not be caught
- * by version mis-match tests in mmu_context.h).
- *
- * Always invoked with interrupts disabled.
- */
-void get_new_mmu_context(struct mm_struct *mm)
-{
-	unsigned long ctx, new_ctx;
-	unsigned long orig_pgsz_bits;
-
-	spin_lock(&ctx_alloc_lock);
-retry:
-	/* wrap might have happened, test again if our context became valid */
-	if (unlikely(CTX_VALID(mm->context)))
-		goto out;
-	orig_pgsz_bits = (mm->context.sparc64_ctx_val & CTX_PGSZ_MASK);
-	ctx = (tlb_context_cache + 1) & CTX_NR_MASK;
-	new_ctx = find_next_zero_bit(mmu_context_bmap, 1 << CTX_NR_BITS, ctx);
-	if (new_ctx >= (1 << CTX_NR_BITS)) {
-		new_ctx = find_next_zero_bit(mmu_context_bmap, ctx, 1);
-		if (new_ctx >= ctx) {
-			mmu_context_wrap();
-			goto retry;
-		}
-	}
-	if (mm->context.sparc64_ctx_val)
-		cpumask_clear(mm_cpumask(mm));
-	mmu_context_bmap[new_ctx>>6] |= (1UL << (new_ctx & 63));
-	new_ctx |= (tlb_context_cache & CTX_VERSION_MASK);
-	tlb_context_cache = new_ctx;
-	mm->context.sparc64_ctx_val = new_ctx | orig_pgsz_bits;
-out:
-	spin_unlock(&ctx_alloc_lock);
-}
-
-static int numa_enabled = 1;
-static int numa_debug;
-
-static int __init early_numa(char *p)
-{
-	if (!p)
-		return 0;
-
-	if (strstr(p, "off"))
-		numa_enabled = 0;
-
-	if (strstr(p, "debug"))
-		numa_debug = 1;
-
-	return 0;
-}
-early_param("numa", early_numa);
-
-#define numadbg(f, a...) \
-do {	if (numa_debug) \
-		printk(KERN_INFO f, ## a); \
-} while (0)
-
-static void __init find_ramdisk(unsigned long phys_base)
-{
-#ifdef CONFIG_BLK_DEV_INITRD
-	if (sparc_ramdisk_image || sparc_ramdisk_image64) {
-		unsigned long ramdisk_image;
-
-		/* Older versions of the bootloader only supported a
-		 * 32-bit physical address for the ramdisk image
-		 * location, stored at sparc_ramdisk_image.  Newer
-		 * SILO versions set sparc_ramdisk_image to zero and
-		 * provide a full 64-bit physical address at
-		 * sparc_ramdisk_image64.
-		 */
-		ramdisk_image = sparc_ramdisk_image;
-		if (!ramdisk_image)
-			ramdisk_image = sparc_ramdisk_image64;
-
-		/* Another bootloader quirk.  The bootloader normalizes
-		 * the physical address to KERNBASE, so we have to
-		 * factor that back out and add in the lowest valid
-		 * physical page address to get the true physical address.
-		 */
-		ramdisk_image -= KERNBASE;
-		ramdisk_image += phys_base;
-
-		numadbg("Found ramdisk at physical address 0x%lx, size %u\n",
-			ramdisk_image, sparc_ramdisk_size);
-
-		initrd_start = ramdisk_image;
-		initrd_end = ramdisk_image + sparc_ramdisk_size;
-
-		memblock_reserve(initrd_start, sparc_ramdisk_size);
-
-		initrd_start += PAGE_OFFSET;
-		initrd_end += PAGE_OFFSET;
-	}
-#endif
-}
-
-struct node_mem_mask {
-	unsigned long mask;
-	unsigned long match;
-};
-static struct node_mem_mask node_masks[MAX_NUMNODES];
-static int num_node_masks;
-
-#ifdef CONFIG_NUMA
-
-struct mdesc_mlgroup {
-	u64	node;
-	u64	latency;
-	u64	match;
-	u64	mask;
-};
-
-static struct mdesc_mlgroup *mlgroups;
-static int num_mlgroups;
-
-int numa_cpu_lookup_table[NR_CPUS];
-cpumask_t numa_cpumask_lookup_table[MAX_NUMNODES];
-
-struct mdesc_mblock {
-	u64	base;
-	u64	size;
-	u64	offset; /* RA-to-PA */
-};
-static struct mdesc_mblock *mblocks;
-static int num_mblocks;
-
-static struct mdesc_mblock * __init addr_to_mblock(unsigned long addr)
-{
-	struct mdesc_mblock *m = NULL;
-	int i;
-
-	for (i = 0; i < num_mblocks; i++) {
-		m = &mblocks[i];
-
-		if (addr >= m->base &&
-		    addr < (m->base + m->size)) {
-			break;
-		}
-	}
-
-	return m;
-}
-
-static u64 __init memblock_nid_range_sun4u(u64 start, u64 end, int *nid)
-{
-	int prev_nid, new_nid;
-
-	prev_nid = NUMA_NO_NODE;
-	for ( ; start < end; start += PAGE_SIZE) {
-		for (new_nid = 0; new_nid < num_node_masks; new_nid++) {
-			struct node_mem_mask *p = &node_masks[new_nid];
-
-			if ((start & p->mask) == p->match) {
-				if (prev_nid == NUMA_NO_NODE)
-					prev_nid = new_nid;
-				break;
-			}
-		}
-
-		if (new_nid == num_node_masks) {
-			prev_nid = 0;
-			WARN_ONCE(1, "addr[%Lx] doesn't match a NUMA node rule. Some memory will be owned by node 0.",
-				  start);
-			break;
-		}
-
-		if (prev_nid != new_nid)
-			break;
-	}
-	*nid = prev_nid;
-
-	return start > end ? end : start;
-}
-
-static u64 __init memblock_nid_range(u64 start, u64 end, int *nid)
-{
-	u64 ret_end, pa_start, m_mask, m_match, m_end;
-	struct mdesc_mblock *mblock;
-	int _nid, i;
-
-	if (tlb_type != hypervisor)
-		return memblock_nid_range_sun4u(start, end, nid);
-
-	mblock = addr_to_mblock(start);
-	if (!mblock) {
-		WARN_ONCE(1, "memblock_nid_range: Can't find mblock addr[%Lx]",
-			  start);
-
-		_nid = 0;
-		ret_end = end;
-		goto done;
-	}
-
-	pa_start = start + mblock->offset;
-	m_match = 0;
-	m_mask = 0;
-
-	for (_nid = 0; _nid < num_node_masks; _nid++) {
-		struct node_mem_mask *const m = &node_masks[_nid];
-
-		if ((pa_start & m->mask) == m->match) {
-			m_match = m->match;
-			m_mask = m->mask;
-			break;
-		}
-	}
-
-	if (num_node_masks == _nid) {
-		/* We could not find NUMA group, so default to 0, but lets
-		 * search for latency group, so we could calculate the correct
-		 * end address that we return
-		 */
-		_nid = 0;
-
-		for (i = 0; i < num_mlgroups; i++) {
-			struct mdesc_mlgroup *const m = &mlgroups[i];
-
-			if ((pa_start & m->mask) == m->match) {
-				m_match = m->match;
-				m_mask = m->mask;
-				break;
-			}
-		}
-
-		if (i == num_mlgroups) {
-			WARN_ONCE(1, "memblock_nid_range: Can't find latency group addr[%Lx]",
-				  start);
-
-			ret_end = end;
-			goto done;
-		}
-	}
-
-	/*
-	 * Each latency group has match and mask, and each memory block has an
-	 * offset.  An address belongs to a latency group if its address matches
-	 * the following formula: ((addr + offset) & mask) == match
-	 * It is, however, slow to check every single page if it matches a
-	 * particular latency group. As optimization we calculate end value by
-	 * using bit arithmetics.
-	 */
-	m_end = m_match + (1ul << __ffs(m_mask)) - mblock->offset;
-	m_end += pa_start & ~((1ul << fls64(m_mask)) - 1);
-	ret_end = m_end > end ? end : m_end;
-
-done:
-	*nid = _nid;
-	return ret_end;
-}
-#endif
-
-/* This must be invoked after performing all of the necessary
- * memblock_set_node() calls for 'nid'.  We need to be able to get
- * correct data from get_pfn_range_for_nid().
- */
-static void __init allocate_node_data(int nid)
-{
-	struct pglist_data *p;
-	unsigned long start_pfn, end_pfn;
-
-#ifdef CONFIG_NUMA
-	alloc_node_data(nid);
-
-	NODE_DATA(nid)->node_id = nid;
-#endif
-
-	p = NODE_DATA(nid);
-
-	get_pfn_range_for_nid(nid, &start_pfn, &end_pfn);
-	p->node_start_pfn = start_pfn;
-	p->node_spanned_pages = end_pfn - start_pfn;
-}
-
-static void init_node_masks_nonnuma(void)
-{
-#ifdef CONFIG_NUMA
-	int i;
-#endif
-
-	numadbg("Initializing tables for non-numa.\n");
-
-	node_masks[0].mask = 0;
-	node_masks[0].match = 0;
-	num_node_masks = 1;
-
-#ifdef CONFIG_NUMA
-	for (i = 0; i < NR_CPUS; i++)
-		numa_cpu_lookup_table[i] = 0;
-
-	cpumask_setall(&numa_cpumask_lookup_table[0]);
-#endif
-}
-
-#ifdef CONFIG_NUMA
-
-EXPORT_SYMBOL(numa_cpu_lookup_table);
-EXPORT_SYMBOL(numa_cpumask_lookup_table);
-
-static int scan_pio_for_cfg_handle(struct mdesc_handle *md, u64 pio,
-				   u32 cfg_handle)
-{
-	u64 arc;
-
-	mdesc_for_each_arc(arc, md, pio, MDESC_ARC_TYPE_FWD) {
-		u64 target = mdesc_arc_target(md, arc);
-		const u64 *val;
-
-		val = mdesc_get_property(md, target,
-					 "cfg-handle", NULL);
-		if (val && *val == cfg_handle)
-			return 0;
-	}
-	return -ENODEV;
-}
-
-static int scan_arcs_for_cfg_handle(struct mdesc_handle *md, u64 grp,
-				    u32 cfg_handle)
-{
-	u64 arc, candidate, best_latency = ~(u64)0;
-
-	candidate = MDESC_NODE_NULL;
-	mdesc_for_each_arc(arc, md, grp, MDESC_ARC_TYPE_FWD) {
-		u64 target = mdesc_arc_target(md, arc);
-		const char *name = mdesc_node_name(md, target);
-		const u64 *val;
-
-		if (strcmp(name, "pio-latency-group"))
-			continue;
-
-		val = mdesc_get_property(md, target, "latency", NULL);
-		if (!val)
-			continue;
-
-		if (*val < best_latency) {
-			candidate = target;
-			best_latency = *val;
-		}
-	}
-
-	if (candidate == MDESC_NODE_NULL)
-		return -ENODEV;
-
-	return scan_pio_for_cfg_handle(md, candidate, cfg_handle);
-}
-
-int of_node_to_nid(struct device_node *dp)
-{
-	const struct linux_prom64_registers *regs;
-	struct mdesc_handle *md;
-	u32 cfg_handle;
-	int count, nid;
-	u64 grp;
-
-	/* This is the right thing to do on currently supported
-	 * SUN4U NUMA platforms as well, as the PCI controller does
-	 * not sit behind any particular memory controller.
-	 */
-	if (!mlgroups)
-		return -1;
-
-	regs = of_get_property(dp, "reg", NULL);
-	if (!regs)
-		return -1;
-
-	cfg_handle = (regs->phys_addr >> 32UL) & 0x0fffffff;
-
-	md = mdesc_grab();
-
-	count = 0;
-	nid = NUMA_NO_NODE;
-	mdesc_for_each_node_by_name(md, grp, "group") {
-		if (!scan_arcs_for_cfg_handle(md, grp, cfg_handle)) {
-			nid = count;
-			break;
-		}
-		count++;
-	}
-
-	mdesc_release(md);
-
-	return nid;
-}
-
-static void __init add_node_ranges(void)
-{
-	phys_addr_t start, end;
-	unsigned long prev_max;
-	u64 i;
-
-memblock_resized:
-	prev_max = memblock.memory.max;
-
-	for_each_mem_range(i, &start, &end) {
-		while (start < end) {
-			unsigned long this_end;
-			int nid;
-
-			this_end = memblock_nid_range(start, end, &nid);
-
-			numadbg("Setting memblock NUMA node nid[%d] "
-				"start[%llx] end[%lx]\n",
-				nid, start, this_end);
-
-			memblock_set_node(start, this_end - start,
-					  &memblock.memory, nid);
-			if (memblock.memory.max != prev_max)
-				goto memblock_resized;
-			start = this_end;
-		}
-	}
-}
-
-static int __init grab_mlgroups(struct mdesc_handle *md)
-{
-	unsigned long paddr;
-	int count = 0;
-	u64 node;
-
-	mdesc_for_each_node_by_name(md, node, "memory-latency-group")
-		count++;
-	if (!count)
-		return -ENOENT;
-
-	paddr = memblock_phys_alloc(count * sizeof(struct mdesc_mlgroup),
-				    SMP_CACHE_BYTES);
-	if (!paddr)
-		return -ENOMEM;
-
-	mlgroups = __va(paddr);
-	num_mlgroups = count;
-
-	count = 0;
-	mdesc_for_each_node_by_name(md, node, "memory-latency-group") {
-		struct mdesc_mlgroup *m = &mlgroups[count++];
-		const u64 *val;
-
-		m->node = node;
-
-		val = mdesc_get_property(md, node, "latency", NULL);
-		m->latency = *val;
-		val = mdesc_get_property(md, node, "address-match", NULL);
-		m->match = *val;
-		val = mdesc_get_property(md, node, "address-mask", NULL);
-		m->mask = *val;
-
-		numadbg("MLGROUP[%d]: node[%llx] latency[%llx] "
-			"match[%llx] mask[%llx]\n",
-			count - 1, m->node, m->latency, m->match, m->mask);
-	}
-
-	return 0;
-}
-
-static int __init grab_mblocks(struct mdesc_handle *md)
-{
-	unsigned long paddr;
-	int count = 0;
-	u64 node;
-
-	mdesc_for_each_node_by_name(md, node, "mblock")
-		count++;
-	if (!count)
-		return -ENOENT;
-
-	paddr = memblock_phys_alloc(count * sizeof(struct mdesc_mblock),
-				    SMP_CACHE_BYTES);
-	if (!paddr)
-		return -ENOMEM;
-
-	mblocks = __va(paddr);
-	num_mblocks = count;
-
-	count = 0;
-	mdesc_for_each_node_by_name(md, node, "mblock") {
-		struct mdesc_mblock *m = &mblocks[count++];
-		const u64 *val;
-
-		val = mdesc_get_property(md, node, "base", NULL);
-		m->base = *val;
-		val = mdesc_get_property(md, node, "size", NULL);
-		m->size = *val;
-		val = mdesc_get_property(md, node,
-					 "address-congruence-offset", NULL);
-
-		/* The address-congruence-offset property is optional.
-		 * Explicity zero it be identifty this.
-		 */
-		if (val)
-			m->offset = *val;
-		else
-			m->offset = 0UL;
-
-		numadbg("MBLOCK[%d]: base[%llx] size[%llx] offset[%llx]\n",
-			count - 1, m->base, m->size, m->offset);
-	}
-
-	return 0;
-}
-
-static void __init numa_parse_mdesc_group_cpus(struct mdesc_handle *md,
-					       u64 grp, cpumask_t *mask)
-{
-	u64 arc;
-
-	cpumask_clear(mask);
-
-	mdesc_for_each_arc(arc, md, grp, MDESC_ARC_TYPE_BACK) {
-		u64 target = mdesc_arc_target(md, arc);
-		const char *name = mdesc_node_name(md, target);
-		const u64 *id;
-
-		if (strcmp(name, "cpu"))
-			continue;
-		id = mdesc_get_property(md, target, "id", NULL);
-		if (*id < nr_cpu_ids)
-			cpumask_set_cpu(*id, mask);
-	}
-}
-
-static struct mdesc_mlgroup * __init find_mlgroup(u64 node)
-{
-	int i;
-
-	for (i = 0; i < num_mlgroups; i++) {
-		struct mdesc_mlgroup *m = &mlgroups[i];
-		if (m->node == node)
-			return m;
-	}
-	return NULL;
-}
-
-int __node_distance(int from, int to)
-{
-	if ((from >= MAX_NUMNODES) || (to >= MAX_NUMNODES)) {
-		pr_warn("Returning default NUMA distance value for %d->%d\n",
-			from, to);
-		return (from == to) ? LOCAL_DISTANCE : REMOTE_DISTANCE;
-	}
-	return numa_latency[from][to];
-}
-EXPORT_SYMBOL(__node_distance);
-
-static int __init find_best_numa_node_for_mlgroup(struct mdesc_mlgroup *grp)
-{
-	int i;
-
-	for (i = 0; i < MAX_NUMNODES; i++) {
-		struct node_mem_mask *n = &node_masks[i];
-
-		if ((grp->mask == n->mask) && (grp->match == n->match))
-			break;
-	}
-	return i;
-}
-
-static void __init find_numa_latencies_for_group(struct mdesc_handle *md,
-						 u64 grp, int index)
-{
-	u64 arc;
-
-	mdesc_for_each_arc(arc, md, grp, MDESC_ARC_TYPE_FWD) {
-		int tnode;
-		u64 target = mdesc_arc_target(md, arc);
-		struct mdesc_mlgroup *m = find_mlgroup(target);
-
-		if (!m)
-			continue;
-		tnode = find_best_numa_node_for_mlgroup(m);
-		if (tnode == MAX_NUMNODES)
-			continue;
-		numa_latency[index][tnode] = m->latency;
-	}
-}
-
-static int __init numa_attach_mlgroup(struct mdesc_handle *md, u64 grp,
-				      int index)
-{
-	struct mdesc_mlgroup *candidate = NULL;
-	u64 arc, best_latency = ~(u64)0;
-	struct node_mem_mask *n;
-
-	mdesc_for_each_arc(arc, md, grp, MDESC_ARC_TYPE_FWD) {
-		u64 target = mdesc_arc_target(md, arc);
-		struct mdesc_mlgroup *m = find_mlgroup(target);
-		if (!m)
-			continue;
-		if (m->latency < best_latency) {
-			candidate = m;
-			best_latency = m->latency;
-		}
-	}
-	if (!candidate)
-		return -ENOENT;
-
-	if (num_node_masks != index) {
-		printk(KERN_ERR "Inconsistent NUMA state, "
-		       "index[%d] != num_node_masks[%d]\n",
-		       index, num_node_masks);
-		return -EINVAL;
-	}
-
-	n = &node_masks[num_node_masks++];
-
-	n->mask = candidate->mask;
-	n->match = candidate->match;
-
-	numadbg("NUMA NODE[%d]: mask[%lx] match[%lx] (latency[%llx])\n",
-		index, n->mask, n->match, candidate->latency);
-
-	return 0;
-}
-
-static int __init numa_parse_mdesc_group(struct mdesc_handle *md, u64 grp,
-					 int index)
-{
-	cpumask_t mask;
-	int cpu;
-
-	numa_parse_mdesc_group_cpus(md, grp, &mask);
-
-	for_each_cpu(cpu, &mask)
-		numa_cpu_lookup_table[cpu] = index;
-	cpumask_copy(&numa_cpumask_lookup_table[index], &mask);
-
-	if (numa_debug) {
-		printk(KERN_INFO "NUMA GROUP[%d]: cpus [ ", index);
-		for_each_cpu(cpu, &mask)
-			printk("%d ", cpu);
-		printk("]\n");
-	}
-
-	return numa_attach_mlgroup(md, grp, index);
-}
-
-static int __init numa_parse_mdesc(void)
-{
-	struct mdesc_handle *md = mdesc_grab();
-	int i, j, err, count;
-	u64 node;
-
-	node = mdesc_node_by_name(md, MDESC_NODE_NULL, "latency-groups");
-	if (node == MDESC_NODE_NULL) {
-		mdesc_release(md);
-		return -ENOENT;
-	}
-
-	err = grab_mblocks(md);
-	if (err < 0)
-		goto out;
-
-	err = grab_mlgroups(md);
-	if (err < 0)
-		goto out;
-
-	count = 0;
-	mdesc_for_each_node_by_name(md, node, "group") {
-		err = numa_parse_mdesc_group(md, node, count);
-		if (err < 0)
-			break;
-		count++;
-	}
-
-	count = 0;
-	mdesc_for_each_node_by_name(md, node, "group") {
-		find_numa_latencies_for_group(md, node, count);
-		count++;
-	}
-
-	/* Normalize numa latency matrix according to ACPI SLIT spec. */
-	for (i = 0; i < MAX_NUMNODES; i++) {
-		u64 self_latency = numa_latency[i][i];
-
-		for (j = 0; j < MAX_NUMNODES; j++) {
-			numa_latency[i][j] =
-				(numa_latency[i][j] * LOCAL_DISTANCE) /
-				self_latency;
-		}
-	}
-
-	add_node_ranges();
-
-	for (i = 0; i < num_node_masks; i++) {
-		allocate_node_data(i);
-		node_set_online(i);
-	}
-
-	err = 0;
-out:
-	mdesc_release(md);
-	return err;
-}
-
-static int __init numa_parse_jbus(void)
-{
-	unsigned long cpu, index;
-
-	/* NUMA node id is encoded in bits 36 and higher, and there is
-	 * a 1-to-1 mapping from CPU ID to NUMA node ID.
-	 */
-	index = 0;
-	for_each_present_cpu(cpu) {
-		numa_cpu_lookup_table[cpu] = index;
-		cpumask_copy(&numa_cpumask_lookup_table[index], cpumask_of(cpu));
-		node_masks[index].mask = ~((1UL << 36UL) - 1UL);
-		node_masks[index].match = cpu << 36UL;
-
-		index++;
-	}
-	num_node_masks = index;
-
-	add_node_ranges();
-
-	for (index = 0; index < num_node_masks; index++) {
-		allocate_node_data(index);
-		node_set_online(index);
-	}
-
-	return 0;
-}
-
-static int __init numa_parse_sun4u(void)
-{
-	if (tlb_type == cheetah || tlb_type == cheetah_plus) {
-		unsigned long ver;
-
-		__asm__ ("rdpr %%ver, %0" : "=r" (ver));
-		if ((ver >> 32UL) == __JALAPENO_ID ||
-		    (ver >> 32UL) == __SERRANO_ID)
-			return numa_parse_jbus();
-	}
-	return -1;
-}
-
-static int __init bootmem_init_numa(void)
-{
-	int i, j;
-	int err = -1;
-
-	numadbg("bootmem_init_numa()\n");
-
-	/* Some sane defaults for numa latency values */
-	for (i = 0; i < MAX_NUMNODES; i++) {
-		for (j = 0; j < MAX_NUMNODES; j++)
-			numa_latency[i][j] = (i == j) ?
-				LOCAL_DISTANCE : REMOTE_DISTANCE;
-	}
-
-	if (numa_enabled) {
-		if (tlb_type == hypervisor)
-			err = numa_parse_mdesc();
-		else
-			err = numa_parse_sun4u();
-	}
-	return err;
-}
-
-#else
-
-static int bootmem_init_numa(void)
-{
-	return -1;
-}
-
-#endif
-
-static void __init bootmem_init_nonnuma(void)
-{
-	unsigned long top_of_ram = memblock_end_of_DRAM();
-	unsigned long total_ram = memblock_phys_mem_size();
-
-	numadbg("bootmem_init_nonnuma()\n");
-
-	printk(KERN_INFO "Top of RAM: 0x%lx, Total RAM: 0x%lx\n",
-	       top_of_ram, total_ram);
-	printk(KERN_INFO "Memory hole size: %ldMB\n",
-	       (top_of_ram - total_ram) >> 20);
-
-	init_node_masks_nonnuma();
-	memblock_set_node(0, PHYS_ADDR_MAX, &memblock.memory, 0);
-	allocate_node_data(0);
-	node_set_online(0);
-}
-
-static unsigned long __init bootmem_init(unsigned long phys_base)
-{
-	unsigned long end_pfn;
-
-	end_pfn = memblock_end_of_DRAM() >> PAGE_SHIFT;
-	max_pfn = max_low_pfn = end_pfn;
-	min_low_pfn = (phys_base >> PAGE_SHIFT);
-
-	if (bootmem_init_numa() < 0)
-		bootmem_init_nonnuma();
-
-	/* Dump memblock with node info. */
-	memblock_dump_all();
-
-	/* XXX cpu notifier XXX */
-
-	sparse_init();
-
-	return end_pfn;
-}
-
-static struct linux_prom64_registers pall[MAX_BANKS] __initdata;
-static int pall_ents __initdata;
-
-static unsigned long max_phys_bits = 40;
-
-bool kern_addr_valid(unsigned long addr)
-{
-	pgd_t *pgd;
-	p4d_t *p4d;
-	pud_t *pud;
-	pmd_t *pmd;
-	pte_t *pte;
-
-	if ((long)addr < 0L) {
-		unsigned long pa = __pa(addr);
-
-		if ((pa >> max_phys_bits) != 0UL)
-			return false;
-
-		return pfn_valid(pa >> PAGE_SHIFT);
-	}
-
-	if (addr >= (unsigned long) KERNBASE &&
-	    addr < (unsigned long)&_end)
-		return true;
-
-	pgd = pgd_offset_k(addr);
-	if (pgd_none(*pgd))
-		return false;
-
-	p4d = p4d_offset(pgd, addr);
-	if (p4d_none(*p4d))
-		return false;
-
-	pud = pud_offset(p4d, addr);
-	if (pud_none(*pud))
-		return false;
-
-	if (pud_leaf(*pud))
-		return pfn_valid(pud_pfn(*pud));
-
-	pmd = pmd_offset(pud, addr);
-	if (pmd_none(*pmd))
-		return false;
-
-	if (pmd_leaf(*pmd))
-		return pfn_valid(pmd_pfn(*pmd));
-
-	pte = pte_offset_kernel(pmd, addr);
-	if (pte_none(*pte))
-		return false;
-
-	return pfn_valid(pte_pfn(*pte));
-}
-
-static unsigned long __ref kernel_map_hugepud(unsigned long vstart,
-					      unsigned long vend,
-					      pud_t *pud)
-{
-	const unsigned long mask16gb = (1UL << 34) - 1UL;
-	u64 pte_val = vstart;
-
-	/* Each PUD is 8GB */
-	if ((vstart & mask16gb) ||
-	    (vend - vstart <= mask16gb)) {
-		pte_val ^= kern_linear_pte_xor[2];
-		pud_val(*pud) = pte_val | _PAGE_PUD_HUGE;
-
-		return vstart + PUD_SIZE;
-	}
-
-	pte_val ^= kern_linear_pte_xor[3];
-	pte_val |= _PAGE_PUD_HUGE;
-
-	vend = vstart + mask16gb + 1UL;
-	while (vstart < vend) {
-		pud_val(*pud) = pte_val;
-
-		pte_val += PUD_SIZE;
-		vstart += PUD_SIZE;
-		pud++;
-	}
-	return vstart;
-}
-
-static bool kernel_can_map_hugepud(unsigned long vstart, unsigned long vend,
-				   bool guard)
-{
-	if (guard && !(vstart & ~PUD_MASK) && (vend - vstart) >= PUD_SIZE)
-		return true;
-
-	return false;
-}
-
-static unsigned long __ref kernel_map_hugepmd(unsigned long vstart,
-					      unsigned long vend,
-					      pmd_t *pmd)
-{
-	const unsigned long mask256mb = (1UL << 28) - 1UL;
-	const unsigned long mask2gb = (1UL << 31) - 1UL;
-	u64 pte_val = vstart;
-
-	/* Each PMD is 8MB */
-	if ((vstart & mask256mb) ||
-	    (vend - vstart <= mask256mb)) {
-		pte_val ^= kern_linear_pte_xor[0];
-		pmd_val(*pmd) = pte_val | _PAGE_PMD_HUGE;
-
-		return vstart + PMD_SIZE;
-	}
-
-	if ((vstart & mask2gb) ||
-	    (vend - vstart <= mask2gb)) {
-		pte_val ^= kern_linear_pte_xor[1];
-		pte_val |= _PAGE_PMD_HUGE;
-		vend = vstart + mask256mb + 1UL;
-	} else {
-		pte_val ^= kern_linear_pte_xor[2];
-		pte_val |= _PAGE_PMD_HUGE;
-		vend = vstart + mask2gb + 1UL;
-	}
-
-	while (vstart < vend) {
-		pmd_val(*pmd) = pte_val;
-
-		pte_val += PMD_SIZE;
-		vstart += PMD_SIZE;
-		pmd++;
-	}
-
-	return vstart;
-}
-
-static bool kernel_can_map_hugepmd(unsigned long vstart, unsigned long vend,
-				   bool guard)
-{
-	if (guard && !(vstart & ~PMD_MASK) && (vend - vstart) >= PMD_SIZE)
-		return true;
-
-	return false;
-}
-
-static unsigned long __ref kernel_map_range(unsigned long pstart,
-					    unsigned long pend, pgprot_t prot,
-					    bool use_huge)
-{
-	unsigned long vstart = PAGE_OFFSET + pstart;
-	unsigned long vend = PAGE_OFFSET + pend;
-	unsigned long alloc_bytes = 0UL;
-
-	if ((vstart & ~PAGE_MASK) || (vend & ~PAGE_MASK)) {
-		prom_printf("kernel_map: Unaligned physmem[%lx:%lx]\n",
-			    vstart, vend);
-		prom_halt();
-	}
-
-	while (vstart < vend) {
-		unsigned long this_end, paddr = __pa(vstart);
-		pgd_t *pgd = pgd_offset_k(vstart);
-		p4d_t *p4d;
-		pud_t *pud;
-		pmd_t *pmd;
-		pte_t *pte;
-
-		if (pgd_none(*pgd)) {
-			pud_t *new;
-
-			new = memblock_alloc_from(PAGE_SIZE, PAGE_SIZE,
-						  PAGE_SIZE);
-			if (!new)
-				goto err_alloc;
-			alloc_bytes += PAGE_SIZE;
-			pgd_populate(&init_mm, pgd, new);
-		}
-
-		p4d = p4d_offset(pgd, vstart);
-		if (p4d_none(*p4d)) {
-			pud_t *new;
-
-			new = memblock_alloc_from(PAGE_SIZE, PAGE_SIZE,
-						  PAGE_SIZE);
-			if (!new)
-				goto err_alloc;
-			alloc_bytes += PAGE_SIZE;
-			p4d_populate(&init_mm, p4d, new);
-		}
-
-		pud = pud_offset(p4d, vstart);
-		if (pud_none(*pud)) {
-			pmd_t *new;
-
-			if (kernel_can_map_hugepud(vstart, vend, use_huge)) {
-				vstart = kernel_map_hugepud(vstart, vend, pud);
-				continue;
-			}
-			new = memblock_alloc_from(PAGE_SIZE, PAGE_SIZE,
-						  PAGE_SIZE);
-			if (!new)
-				goto err_alloc;
-			alloc_bytes += PAGE_SIZE;
-			pud_populate(&init_mm, pud, new);
-		}
-
-		pmd = pmd_offset(pud, vstart);
-		if (pmd_none(*pmd)) {
-			pte_t *new;
-
-			if (kernel_can_map_hugepmd(vstart, vend, use_huge)) {
-				vstart = kernel_map_hugepmd(vstart, vend, pmd);
-				continue;
-			}
-			new = memblock_alloc_from(PAGE_SIZE, PAGE_SIZE,
-						  PAGE_SIZE);
-			if (!new)
-				goto err_alloc;
-			alloc_bytes += PAGE_SIZE;
-			pmd_populate_kernel(&init_mm, pmd, new);
-		}
-
-		pte = pte_offset_kernel(pmd, vstart);
-		this_end = (vstart + PMD_SIZE) & PMD_MASK;
-		if (this_end > vend)
-			this_end = vend;
-
-		while (vstart < this_end) {
-			pte_val(*pte) = (paddr | pgprot_val(prot));
-
-			vstart += PAGE_SIZE;
-			paddr += PAGE_SIZE;
-			pte++;
-		}
-	}
-
-	return alloc_bytes;
-
-err_alloc:
-	panic("%s: Failed to allocate %lu bytes align=%lx from=%lx\n",
-	      __func__, PAGE_SIZE, PAGE_SIZE, PAGE_SIZE);
-	return -ENOMEM;
-}
-
-static void __init flush_all_kernel_tsbs(void)
-{
-	int i;
-
-	for (i = 0; i < KERNEL_TSB_NENTRIES; i++) {
-		struct tsb *ent = &swapper_tsb[i];
-
-		ent->tag = (1UL << TSB_TAG_INVALID_BIT);
-	}
-#ifndef CONFIG_DEBUG_PAGEALLOC
-	for (i = 0; i < KERNEL_TSB4M_NENTRIES; i++) {
-		struct tsb *ent = &swapper_4m_tsb[i];
-
-		ent->tag = (1UL << TSB_TAG_INVALID_BIT);
-	}
-#endif
-}
-
-extern unsigned int kvmap_linear_patch[1];
-
-static void __init kernel_physical_mapping_init(void)
-{
-	unsigned long i, mem_alloced = 0UL;
-	bool use_huge = true;
-
-#ifdef CONFIG_DEBUG_PAGEALLOC
-	use_huge = false;
-#endif
-	for (i = 0; i < pall_ents; i++) {
-		unsigned long phys_start, phys_end;
-
-		phys_start = pall[i].phys_addr;
-		phys_end = phys_start + pall[i].reg_size;
-
-		mem_alloced += kernel_map_range(phys_start, phys_end,
-						PAGE_KERNEL, use_huge);
-	}
-
-	printk("Allocated %ld bytes for kernel page tables.\n",
-	       mem_alloced);
-
-	kvmap_linear_patch[0] = 0x01000000; /* nop */
-	flushi(&kvmap_linear_patch[0]);
-
-	flush_all_kernel_tsbs();
-
-	__flush_tlb_all();
-}
-
-#ifdef CONFIG_DEBUG_PAGEALLOC
-void __kernel_map_pages(struct page *page, int numpages, int enable)
-{
-	unsigned long phys_start = page_to_pfn(page) << PAGE_SHIFT;
-	unsigned long phys_end = phys_start + (numpages * PAGE_SIZE);
-
-	kernel_map_range(phys_start, phys_end,
-			 (enable ? PAGE_KERNEL : __pgprot(0)), false);
-
-	flush_tsb_kernel_range(PAGE_OFFSET + phys_start,
-			       PAGE_OFFSET + phys_end);
-
-	/* we should perform an IPI and flush all tlbs,
-	 * but that can deadlock->flush only current cpu.
-	 */
-	__flush_tlb_kernel_range(PAGE_OFFSET + phys_start,
-				 PAGE_OFFSET + phys_end);
-}
-#endif
-
-unsigned long __init find_ecache_flush_span(unsigned long size)
-{
-	int i;
-
-	for (i = 0; i < pavail_ents; i++) {
-		if (pavail[i].reg_size >= size)
-			return pavail[i].phys_addr;
-	}
-
-	return ~0UL;
-}
-
-unsigned long PAGE_OFFSET;
-EXPORT_SYMBOL(PAGE_OFFSET);
-
-unsigned long VMALLOC_END   = 0x0000010000000000UL;
-EXPORT_SYMBOL(VMALLOC_END);
-
-unsigned long sparc64_va_hole_top =    0xfffff80000000000UL;
-unsigned long sparc64_va_hole_bottom = 0x0000080000000000UL;
-
-static void __init setup_page_offset(void)
-{
-	if (tlb_type == cheetah || tlb_type == cheetah_plus) {
-		/* Cheetah/Panther support a full 64-bit virtual
-		 * address, so we can use all that our page tables
-		 * support.
-		 */
-		sparc64_va_hole_top =    0xfff0000000000000UL;
-		sparc64_va_hole_bottom = 0x0010000000000000UL;
-
-		max_phys_bits = 42;
-	} else if (tlb_type == hypervisor) {
-		switch (sun4v_chip_type) {
-		case SUN4V_CHIP_NIAGARA1:
-		case SUN4V_CHIP_NIAGARA2:
-			/* T1 and T2 support 48-bit virtual addresses.  */
-			sparc64_va_hole_top =    0xffff800000000000UL;
-			sparc64_va_hole_bottom = 0x0000800000000000UL;
-
-			max_phys_bits = 39;
-			break;
-		case SUN4V_CHIP_NIAGARA3:
-			/* T3 supports 48-bit virtual addresses.  */
-			sparc64_va_hole_top =    0xffff800000000000UL;
-			sparc64_va_hole_bottom = 0x0000800000000000UL;
-
-			max_phys_bits = 43;
-			break;
-		case SUN4V_CHIP_NIAGARA4:
-		case SUN4V_CHIP_NIAGARA5:
-		case SUN4V_CHIP_SPARC64X:
-		case SUN4V_CHIP_SPARC_M6:
-			/* T4 and later support 52-bit virtual addresses.  */
-			sparc64_va_hole_top =    0xfff8000000000000UL;
-			sparc64_va_hole_bottom = 0x0008000000000000UL;
-			max_phys_bits = 47;
-			break;
-		case SUN4V_CHIP_SPARC_M7:
-		case SUN4V_CHIP_SPARC_SN:
-			/* M7 and later support 52-bit virtual addresses.  */
-			sparc64_va_hole_top =    0xfff8000000000000UL;
-			sparc64_va_hole_bottom = 0x0008000000000000UL;
-			max_phys_bits = 49;
-			break;
-		case SUN4V_CHIP_SPARC_M8:
-		default:
-			/* M8 and later support 54-bit virtual addresses.
-			 * However, restricting M8 and above VA bits to 53
-			 * as 4-level page table cannot support more than
-			 * 53 VA bits.
-			 */
-			sparc64_va_hole_top =    0xfff0000000000000UL;
-			sparc64_va_hole_bottom = 0x0010000000000000UL;
-			max_phys_bits = 51;
-			break;
-		}
-	}
-
-	if (max_phys_bits > MAX_PHYS_ADDRESS_BITS) {
-		prom_printf("MAX_PHYS_ADDRESS_BITS is too small, need %lu\n",
-			    max_phys_bits);
-		prom_halt();
-	}
-
-	PAGE_OFFSET = sparc64_va_hole_top;
-	VMALLOC_END = ((sparc64_va_hole_bottom >> 1) +
-		       (sparc64_va_hole_bottom >> 2));
-
-	pr_info("MM: PAGE_OFFSET is 0x%016lx (max_phys_bits == %lu)\n",
-		PAGE_OFFSET, max_phys_bits);
-	pr_info("MM: VMALLOC [0x%016lx --> 0x%016lx]\n",
-		VMALLOC_START, VMALLOC_END);
-	pr_info("MM: VMEMMAP [0x%016lx --> 0x%016lx]\n",
-		VMEMMAP_BASE, VMEMMAP_BASE << 1);
-}
-
-static void __init tsb_phys_patch(void)
-{
-	struct tsb_ldquad_phys_patch_entry *pquad;
-	struct tsb_phys_patch_entry *p;
-
-	pquad = &__tsb_ldquad_phys_patch;
-	while (pquad < &__tsb_ldquad_phys_patch_end) {
-		unsigned long addr = pquad->addr;
-
-		if (tlb_type == hypervisor)
-			*(unsigned int *) addr = pquad->sun4v_insn;
-		else
-			*(unsigned int *) addr = pquad->sun4u_insn;
-		wmb();
-		__asm__ __volatile__("flush	%0"
-				     : /* no outputs */
-				     : "r" (addr));
-
-		pquad++;
-	}
-
-	p = &__tsb_phys_patch;
-	while (p < &__tsb_phys_patch_end) {
-		unsigned long addr = p->addr;
-
-		*(unsigned int *) addr = p->insn;
-		wmb();
-		__asm__ __volatile__("flush	%0"
-				     : /* no outputs */
-				     : "r" (addr));
-
-		p++;
-	}
-}
-
-/* Don't mark as init, we give this to the Hypervisor.  */
-#ifndef CONFIG_DEBUG_PAGEALLOC
-#define NUM_KTSB_DESCR	2
-#else
-#define NUM_KTSB_DESCR	1
-#endif
-static struct hv_tsb_descr ktsb_descr[NUM_KTSB_DESCR];
-
-/* The swapper TSBs are loaded with a base sequence of:
- *
- *	sethi	%uhi(SYMBOL), REG1
- *	sethi	%hi(SYMBOL), REG2
- *	or	REG1, %ulo(SYMBOL), REG1
- *	or	REG2, %lo(SYMBOL), REG2
- *	sllx	REG1, 32, REG1
- *	or	REG1, REG2, REG1
- *
- * When we use physical addressing for the TSB accesses, we patch the
- * first four instructions in the above sequence.
- */
-
-static void patch_one_ktsb_phys(unsigned int *start, unsigned int *end, unsigned long pa)
-{
-	unsigned long high_bits, low_bits;
-
-	high_bits = (pa >> 32) & 0xffffffff;
-	low_bits = (pa >> 0) & 0xffffffff;
-
-	while (start < end) {
-		unsigned int *ia = (unsigned int *)(unsigned long)*start;
-
-		ia[0] = (ia[0] & ~0x3fffff) | (high_bits >> 10);
-		__asm__ __volatile__("flush	%0" : : "r" (ia));
-
-		ia[1] = (ia[1] & ~0x3fffff) | (low_bits >> 10);
-		__asm__ __volatile__("flush	%0" : : "r" (ia + 1));
-
-		ia[2] = (ia[2] & ~0x1fff) | (high_bits & 0x3ff);
-		__asm__ __volatile__("flush	%0" : : "r" (ia + 2));
-
-		ia[3] = (ia[3] & ~0x1fff) | (low_bits & 0x3ff);
-		__asm__ __volatile__("flush	%0" : : "r" (ia + 3));
-
-		start++;
-	}
-}
-
-static void ktsb_phys_patch(void)
-{
-	extern unsigned int __swapper_tsb_phys_patch;
-	extern unsigned int __swapper_tsb_phys_patch_end;
-	unsigned long ktsb_pa;
-
-	ktsb_pa = kern_base + ((unsigned long)&swapper_tsb[0] - KERNBASE);
-	patch_one_ktsb_phys(&__swapper_tsb_phys_patch,
-			    &__swapper_tsb_phys_patch_end, ktsb_pa);
-#ifndef CONFIG_DEBUG_PAGEALLOC
-	{
-	extern unsigned int __swapper_4m_tsb_phys_patch;
-	extern unsigned int __swapper_4m_tsb_phys_patch_end;
-	ktsb_pa = (kern_base +
-		   ((unsigned long)&swapper_4m_tsb[0] - KERNBASE));
-	patch_one_ktsb_phys(&__swapper_4m_tsb_phys_patch,
-			    &__swapper_4m_tsb_phys_patch_end, ktsb_pa);
-	}
-#endif
-}
-
-static void __init sun4v_ktsb_init(void)
-{
-	unsigned long ktsb_pa;
-
-	/* First KTSB for PAGE_SIZE mappings.  */
-	ktsb_pa = kern_base + ((unsigned long)&swapper_tsb[0] - KERNBASE);
-
-	switch (PAGE_SIZE) {
-	case 8 * 1024:
-	default:
-		ktsb_descr[0].pgsz_idx = HV_PGSZ_IDX_8K;
-		ktsb_descr[0].pgsz_mask = HV_PGSZ_MASK_8K;
-		break;
-
-	case 64 * 1024:
-		ktsb_descr[0].pgsz_idx = HV_PGSZ_IDX_64K;
-		ktsb_descr[0].pgsz_mask = HV_PGSZ_MASK_64K;
-		break;
-
-	case 512 * 1024:
-		ktsb_descr[0].pgsz_idx = HV_PGSZ_IDX_512K;
-		ktsb_descr[0].pgsz_mask = HV_PGSZ_MASK_512K;
-		break;
-
-	case 4 * 1024 * 1024:
-		ktsb_descr[0].pgsz_idx = HV_PGSZ_IDX_4MB;
-		ktsb_descr[0].pgsz_mask = HV_PGSZ_MASK_4MB;
-		break;
-	}
-
-	ktsb_descr[0].assoc = 1;
-	ktsb_descr[0].num_ttes = KERNEL_TSB_NENTRIES;
-	ktsb_descr[0].ctx_idx = 0;
-	ktsb_descr[0].tsb_base = ktsb_pa;
-	ktsb_descr[0].resv = 0;
-
-#ifndef CONFIG_DEBUG_PAGEALLOC
-	/* Second KTSB for 4MB/256MB/2GB/16GB mappings.  */
-	ktsb_pa = (kern_base +
-		   ((unsigned long)&swapper_4m_tsb[0] - KERNBASE));
-
-	ktsb_descr[1].pgsz_idx = HV_PGSZ_IDX_4MB;
-	ktsb_descr[1].pgsz_mask = ((HV_PGSZ_MASK_4MB |
-				    HV_PGSZ_MASK_256MB |
-				    HV_PGSZ_MASK_2GB |
-				    HV_PGSZ_MASK_16GB) &
-				   cpu_pgsz_mask);
-	ktsb_descr[1].assoc = 1;
-	ktsb_descr[1].num_ttes = KERNEL_TSB4M_NENTRIES;
-	ktsb_descr[1].ctx_idx = 0;
-	ktsb_descr[1].tsb_base = ktsb_pa;
-	ktsb_descr[1].resv = 0;
-#endif
-}
-
-void sun4v_ktsb_register(void)
-{
-	unsigned long pa, ret;
-
-	pa = kern_base + ((unsigned long)&ktsb_descr[0] - KERNBASE);
-
-	ret = sun4v_mmu_tsb_ctx0(NUM_KTSB_DESCR, pa);
-	if (ret != 0) {
-		prom_printf("hypervisor_mmu_tsb_ctx0[%lx]: "
-			    "errors with %lx\n", pa, ret);
-		prom_halt();
-	}
-}
-
-static void __init sun4u_linear_pte_xor_finalize(void)
-{
-#ifndef CONFIG_DEBUG_PAGEALLOC
-	/* This is where we would add Panther support for
-	 * 32MB and 256MB pages.
-	 */
-#endif
-}
-
-static void __init sun4v_linear_pte_xor_finalize(void)
-{
-	unsigned long pagecv_flag;
-
-	/* Bit 9 of TTE is no longer CV bit on M7 processor and it instead
-	 * enables MCD error. Do not set bit 9 on M7 processor.
-	 */
-	switch (sun4v_chip_type) {
-	case SUN4V_CHIP_SPARC_M7:
-	case SUN4V_CHIP_SPARC_M8:
-	case SUN4V_CHIP_SPARC_SN:
-		pagecv_flag = 0x00;
-		break;
-	default:
-		pagecv_flag = _PAGE_CV_4V;
-		break;
-	}
-#ifndef CONFIG_DEBUG_PAGEALLOC
-	if (cpu_pgsz_mask & HV_PGSZ_MASK_256MB) {
-		kern_linear_pte_xor[1] = (_PAGE_VALID | _PAGE_SZ256MB_4V) ^
-			PAGE_OFFSET;
-		kern_linear_pte_xor[1] |= (_PAGE_CP_4V | pagecv_flag |
-					   _PAGE_P_4V | _PAGE_W_4V);
-	} else {
-		kern_linear_pte_xor[1] = kern_linear_pte_xor[0];
-	}
-
-	if (cpu_pgsz_mask & HV_PGSZ_MASK_2GB) {
-		kern_linear_pte_xor[2] = (_PAGE_VALID | _PAGE_SZ2GB_4V) ^
-			PAGE_OFFSET;
-		kern_linear_pte_xor[2] |= (_PAGE_CP_4V | pagecv_flag |
-					   _PAGE_P_4V | _PAGE_W_4V);
-	} else {
-		kern_linear_pte_xor[2] = kern_linear_pte_xor[1];
-	}
-
-	if (cpu_pgsz_mask & HV_PGSZ_MASK_16GB) {
-		kern_linear_pte_xor[3] = (_PAGE_VALID | _PAGE_SZ16GB_4V) ^
-			PAGE_OFFSET;
-		kern_linear_pte_xor[3] |= (_PAGE_CP_4V | pagecv_flag |
-					   _PAGE_P_4V | _PAGE_W_4V);
-	} else {
-		kern_linear_pte_xor[3] = kern_linear_pte_xor[2];
-	}
-#endif
-}
-
-/* paging_init() sets up the page tables */
-
-static unsigned long last_valid_pfn;
-
-static void sun4u_pgprot_init(void);
-static void sun4v_pgprot_init(void);
-
-#define _PAGE_CACHE_4U	(_PAGE_CP_4U | _PAGE_CV_4U)
-#define _PAGE_CACHE_4V	(_PAGE_CP_4V | _PAGE_CV_4V)
-#define __DIRTY_BITS_4U	 (_PAGE_MODIFIED_4U | _PAGE_WRITE_4U | _PAGE_W_4U)
-#define __DIRTY_BITS_4V	 (_PAGE_MODIFIED_4V | _PAGE_WRITE_4V | _PAGE_W_4V)
-#define __ACCESS_BITS_4U (_PAGE_ACCESSED_4U | _PAGE_READ_4U | _PAGE_R)
-#define __ACCESS_BITS_4V (_PAGE_ACCESSED_4V | _PAGE_READ_4V | _PAGE_R)
-
-/* We need to exclude reserved regions. This exclusion will include
- * vmlinux and initrd. To be more precise the initrd size could be used to
- * compute a new lower limit because it is freed later during initialization.
- */
-static void __init reduce_memory(phys_addr_t limit_ram)
-{
-	limit_ram += memblock_reserved_size();
-	memblock_enforce_memory_limit(limit_ram);
-}
-
-void __init paging_init(void)
-{
-	unsigned long end_pfn, shift, phys_base;
-	unsigned long real_end, i;
-
-	setup_page_offset();
-
-	/* These build time checkes make sure that the dcache_dirty_cpu()
-	 * folio->flags usage will work.
-	 *
-	 * When a page gets marked as dcache-dirty, we store the
-	 * cpu number starting at bit 32 in the folio->flags.  Also,
-	 * functions like clear_dcache_dirty_cpu use the cpu mask
-	 * in 13-bit signed-immediate instruction fields.
-	 */
-
-	/*
-	 * Page flags must not reach into upper 32 bits that are used
-	 * for the cpu number
-	 */
-	BUILD_BUG_ON(NR_PAGEFLAGS > 32);
-
-	/*
-	 * The bit fields placed in the high range must not reach below
-	 * the 32 bit boundary. Otherwise we cannot place the cpu field
-	 * at the 32 bit boundary.
-	 */
-	BUILD_BUG_ON(SECTIONS_WIDTH + NODES_WIDTH + ZONES_WIDTH +
-		ilog2(roundup_pow_of_two(NR_CPUS)) > 32);
-
-	BUILD_BUG_ON(NR_CPUS > 4096);
-
-	kern_base = (prom_boot_mapping_phys_low >> ILOG2_4MB) << ILOG2_4MB;
-	kern_size = (unsigned long)&_end - (unsigned long)KERNBASE;
-
-	/* Invalidate both kernel TSBs.  */
-	memset(swapper_tsb, 0x40, sizeof(swapper_tsb));
-#ifndef CONFIG_DEBUG_PAGEALLOC
-	memset(swapper_4m_tsb, 0x40, sizeof(swapper_4m_tsb));
-#endif
-
-	/* TTE.cv bit on sparc v9 occupies the same position as TTE.mcde
-	 * bit on M7 processor. This is a conflicting usage of the same
-	 * bit. Enabling TTE.cv on M7 would turn on Memory Corruption
-	 * Detection error on all pages and this will lead to problems
-	 * later. Kernel does not run with MCD enabled and hence rest
-	 * of the required steps to fully configure memory corruption
-	 * detection are not taken. We need to ensure TTE.mcde is not
-	 * set on M7 processor. Compute the value of cacheability
-	 * flag for use later taking this into consideration.
-	 */
-	switch (sun4v_chip_type) {
-	case SUN4V_CHIP_SPARC_M7:
-	case SUN4V_CHIP_SPARC_M8:
-	case SUN4V_CHIP_SPARC_SN:
-		page_cache4v_flag = _PAGE_CP_4V;
-		break;
-	default:
-		page_cache4v_flag = _PAGE_CACHE_4V;
-		break;
-	}
-
-	if (tlb_type == hypervisor)
-		sun4v_pgprot_init();
-	else
-		sun4u_pgprot_init();
-
-	if (tlb_type == cheetah_plus ||
-	    tlb_type == hypervisor) {
-		tsb_phys_patch();
-		ktsb_phys_patch();
-	}
-
-	if (tlb_type == hypervisor)
-		sun4v_patch_tlb_handlers();
-
-	/* Find available physical memory...
-	 *
-	 * Read it twice in order to work around a bug in openfirmware.
-	 * The call to grab this table itself can cause openfirmware to
-	 * allocate memory, which in turn can take away some space from
-	 * the list of available memory.  Reading it twice makes sure
-	 * we really do get the final value.
-	 */
-	read_obp_translations();
-	read_obp_memory("reg", &pall[0], &pall_ents);
-	read_obp_memory("available", &pavail[0], &pavail_ents);
-	read_obp_memory("available", &pavail[0], &pavail_ents);
-
-	phys_base = 0xffffffffffffffffUL;
-	for (i = 0; i < pavail_ents; i++) {
-		phys_base = min(phys_base, pavail[i].phys_addr);
-		memblock_add(pavail[i].phys_addr, pavail[i].reg_size);
-	}
-
-	memblock_reserve(kern_base, kern_size);
-
-	find_ramdisk(phys_base);
-
-	if (cmdline_memory_size)
-		reduce_memory(cmdline_memory_size);
-
-	memblock_allow_resize();
-	memblock_dump_all();
-
-	set_bit(0, mmu_context_bmap);
-
-	shift = kern_base + PAGE_OFFSET - ((unsigned long)KERNBASE);
-
-	real_end = (unsigned long)_end;
-	num_kernel_image_mappings = DIV_ROUND_UP(real_end - KERNBASE, 1 << ILOG2_4MB);
-	printk("Kernel: Using %d locked TLB entries for main kernel image.\n",
-	       num_kernel_image_mappings);
-
-	/* Set kernel pgd to upper alias so physical page computations
-	 * work.
-	 */
-	init_mm.pgd += ((shift) / (sizeof(pgd_t)));
-	
-	memset(swapper_pg_dir, 0, sizeof(swapper_pg_dir));
-
-	inherit_prom_mappings();
-	
-	/* Ok, we can use our TLB miss and window trap handlers safely.  */
-	setup_tba();
-
-	__flush_tlb_all();
-
-	prom_build_devicetree();
-	of_populate_present_mask();
-#ifndef CONFIG_SMP
-	of_fill_in_cpu_data();
-#endif
-
-	if (tlb_type == hypervisor) {
-		sun4v_mdesc_init();
-		mdesc_populate_present_mask(cpu_all_mask);
-#ifndef CONFIG_SMP
-		mdesc_fill_in_cpu_data(cpu_all_mask);
-#endif
-		mdesc_get_page_sizes(cpu_all_mask, &cpu_pgsz_mask);
-
-		sun4v_linear_pte_xor_finalize();
-
-		sun4v_ktsb_init();
-		sun4v_ktsb_register();
-	} else {
-		unsigned long impl, ver;
-
-		cpu_pgsz_mask = (HV_PGSZ_MASK_8K | HV_PGSZ_MASK_64K |
-				 HV_PGSZ_MASK_512K | HV_PGSZ_MASK_4MB);
-
-		__asm__ __volatile__("rdpr %%ver, %0" : "=r" (ver));
-		impl = ((ver >> 32) & 0xffff);
-		if (impl == PANTHER_IMPL)
-			cpu_pgsz_mask |= (HV_PGSZ_MASK_32MB |
-					  HV_PGSZ_MASK_256MB);
-
-		sun4u_linear_pte_xor_finalize();
-	}
-
-	/* Flush the TLBs and the 4M TSB so that the updated linear
-	 * pte XOR settings are realized for all mappings.
-	 */
-	__flush_tlb_all();
-#ifndef CONFIG_DEBUG_PAGEALLOC
-	memset(swapper_4m_tsb, 0x40, sizeof(swapper_4m_tsb));
-#endif
-	__flush_tlb_all();
-
-	/* Setup bootmem... */
-	last_valid_pfn = end_pfn = bootmem_init(phys_base);
-
-	kernel_physical_mapping_init();
-
-	{
-		unsigned long max_zone_pfns[MAX_NR_ZONES];
-
-		memset(max_zone_pfns, 0, sizeof(max_zone_pfns));
-
-		max_zone_pfns[ZONE_NORMAL] = end_pfn;
-
-		free_area_init(max_zone_pfns);
-	}
-
-	printk("Booting Linux...\n");
-}
-
-int page_in_phys_avail(unsigned long paddr)
-{
-	int i;
-
-	paddr &= PAGE_MASK;
-
-	for (i = 0; i < pavail_ents; i++) {
-		unsigned long start, end;
-
-		start = pavail[i].phys_addr;
-		end = start + pavail[i].reg_size;
-
-		if (paddr >= start && paddr < end)
-			return 1;
-	}
-	if (paddr >= kern_base && paddr < (kern_base + kern_size))
-		return 1;
-#ifdef CONFIG_BLK_DEV_INITRD
-	if (paddr >= __pa(initrd_start) &&
-	    paddr < __pa(PAGE_ALIGN(initrd_end)))
-		return 1;
-#endif
-
-	return 0;
-}
-
-static void __init register_page_bootmem_info(void)
-{
-#ifdef CONFIG_NUMA
-	int i;
-
-	for_each_online_node(i)
-		if (NODE_DATA(i)->node_spanned_pages)
-			register_page_bootmem_info_node(NODE_DATA(i));
-#endif
-}
-void __init mem_init(void)
-{
-	/*
-	 * Must be done after boot memory is put on freelist, because here we
-	 * might set fields in deferred struct pages that have not yet been
-	 * initialized, and memblock_free_all() initializes all the reserved
-	 * deferred pages for us.
-	 */
-	register_page_bootmem_info();
-
-	/*
-	 * Set up the zero page, mark it reserved, so that page count
-	 * is not manipulated when freeing the page from user ptes.
-	 */
-	mem_map_zero = alloc_pages(GFP_KERNEL|__GFP_ZERO, 0);
-	if (mem_map_zero == NULL) {
-		prom_printf("paging_init: Cannot alloc zero page.\n");
-		prom_halt();
-	}
-	mark_page_reserved(mem_map_zero);
-
-
-	if (tlb_type == cheetah || tlb_type == cheetah_plus)
-		cheetah_ecache_flush_init();
-}
-
-void free_initmem(void)
-{
-	unsigned long addr, initend;
-	int do_free = 1;
-
-	/* If the physical memory maps were trimmed by kernel command
-	 * line options, don't even try freeing this initmem stuff up.
-	 * The kernel image could have been in the trimmed out region
-	 * and if so the freeing below will free invalid page structs.
-	 */
-	if (cmdline_memory_size)
-		do_free = 0;
-
-	/*
-	 * The init section is aligned to 8k in vmlinux.lds. Page align for >8k pagesizes.
-	 */
-	addr = PAGE_ALIGN((unsigned long)(__init_begin));
-	initend = (unsigned long)(__init_end) & PAGE_MASK;
-	for (; addr < initend; addr += PAGE_SIZE) {
-		unsigned long page;
-
-		page = (addr +
-			((unsigned long) __va(kern_base)) -
-			((unsigned long) KERNBASE));
-		memset((void *)addr, POISON_FREE_INITMEM, PAGE_SIZE);
-
-		if (do_free)
-			free_reserved_page(virt_to_page(page));
-	}
-}
-
-pgprot_t PAGE_KERNEL __read_mostly;
-EXPORT_SYMBOL(PAGE_KERNEL);
-
-pgprot_t PAGE_KERNEL_LOCKED __read_mostly;
-pgprot_t PAGE_COPY __read_mostly;
-
-pgprot_t PAGE_SHARED __read_mostly;
-EXPORT_SYMBOL(PAGE_SHARED);
-
-unsigned long pg_iobits __read_mostly;
-
-unsigned long _PAGE_IE __read_mostly;
-EXPORT_SYMBOL(_PAGE_IE);
-
-unsigned long _PAGE_E __read_mostly;
-EXPORT_SYMBOL(_PAGE_E);
-
-unsigned long _PAGE_CACHE __read_mostly;
-EXPORT_SYMBOL(_PAGE_CACHE);
-
-#ifdef CONFIG_SPARSEMEM_VMEMMAP
-int __meminit vmemmap_populate(unsigned long vstart, unsigned long vend,
-			       int node, struct vmem_altmap *altmap)
-{
-	unsigned long pte_base;
-
-	pte_base = (_PAGE_VALID | _PAGE_SZ4MB_4U |
-		    _PAGE_CP_4U | _PAGE_CV_4U |
-		    _PAGE_P_4U | _PAGE_W_4U);
-	if (tlb_type == hypervisor)
-		pte_base = (_PAGE_VALID | _PAGE_SZ4MB_4V |
-			    page_cache4v_flag | _PAGE_P_4V | _PAGE_W_4V);
-
-	pte_base |= _PAGE_PMD_HUGE;
-
-	vstart = vstart & PMD_MASK;
-	vend = ALIGN(vend, PMD_SIZE);
-	for (; vstart < vend; vstart += PMD_SIZE) {
-		pgd_t *pgd = vmemmap_pgd_populate(vstart, node);
-		unsigned long pte;
-		p4d_t *p4d;
-		pud_t *pud;
-		pmd_t *pmd;
-
-		if (!pgd)
-			return -ENOMEM;
-
-		p4d = vmemmap_p4d_populate(pgd, vstart, node);
-		if (!p4d)
-			return -ENOMEM;
-
-		pud = vmemmap_pud_populate(p4d, vstart, node);
-		if (!pud)
-			return -ENOMEM;
-
-		pmd = pmd_offset(pud, vstart);
-		pte = pmd_val(*pmd);
-		if (!(pte & _PAGE_VALID)) {
-			void *block = vmemmap_alloc_block(PMD_SIZE, node);
-
-			if (!block)
-				return -ENOMEM;
-
-			pmd_val(*pmd) = pte_base | __pa(block);
-		}
-	}
-
-	return 0;
-}
-#endif /* CONFIG_SPARSEMEM_VMEMMAP */
-
-/* These are actually filled in at boot time by sun4{u,v}_pgprot_init() */
-static pgprot_t protection_map[16] __ro_after_init;
-
-static void prot_init_common(unsigned long page_none,
-			     unsigned long page_shared,
-			     unsigned long page_copy,
-			     unsigned long page_readonly,
-			     unsigned long page_exec_bit)
-{
-	PAGE_COPY = __pgprot(page_copy);
-	PAGE_SHARED = __pgprot(page_shared);
-
-	protection_map[0x0] = __pgprot(page_none);
-	protection_map[0x1] = __pgprot(page_readonly & ~page_exec_bit);
-	protection_map[0x2] = __pgprot(page_copy & ~page_exec_bit);
-	protection_map[0x3] = __pgprot(page_copy & ~page_exec_bit);
-	protection_map[0x4] = __pgprot(page_readonly);
-	protection_map[0x5] = __pgprot(page_readonly);
-	protection_map[0x6] = __pgprot(page_copy);
-	protection_map[0x7] = __pgprot(page_copy);
-	protection_map[0x8] = __pgprot(page_none);
-	protection_map[0x9] = __pgprot(page_readonly & ~page_exec_bit);
-	protection_map[0xa] = __pgprot(page_shared & ~page_exec_bit);
-	protection_map[0xb] = __pgprot(page_shared & ~page_exec_bit);
-	protection_map[0xc] = __pgprot(page_readonly);
-	protection_map[0xd] = __pgprot(page_readonly);
-	protection_map[0xe] = __pgprot(page_shared);
-	protection_map[0xf] = __pgprot(page_shared);
-}
-
-static void __init sun4u_pgprot_init(void)
-{
-	unsigned long page_none, page_shared, page_copy, page_readonly;
-	unsigned long page_exec_bit;
-	int i;
-
-	PAGE_KERNEL = __pgprot (_PAGE_PRESENT_4U | _PAGE_VALID |
-				_PAGE_CACHE_4U | _PAGE_P_4U |
-				__ACCESS_BITS_4U | __DIRTY_BITS_4U |
-				_PAGE_EXEC_4U);
-	PAGE_KERNEL_LOCKED = __pgprot (_PAGE_PRESENT_4U | _PAGE_VALID |
-				       _PAGE_CACHE_4U | _PAGE_P_4U |
-				       __ACCESS_BITS_4U | __DIRTY_BITS_4U |
-				       _PAGE_EXEC_4U | _PAGE_L_4U);
-
-	_PAGE_IE = _PAGE_IE_4U;
-	_PAGE_E = _PAGE_E_4U;
-	_PAGE_CACHE = _PAGE_CACHE_4U;
-
-	pg_iobits = (_PAGE_VALID | _PAGE_PRESENT_4U | __DIRTY_BITS_4U |
-		     __ACCESS_BITS_4U | _PAGE_E_4U);
-
-#ifdef CONFIG_DEBUG_PAGEALLOC
-	kern_linear_pte_xor[0] = _PAGE_VALID ^ PAGE_OFFSET;
-#else
-	kern_linear_pte_xor[0] = (_PAGE_VALID | _PAGE_SZ4MB_4U) ^
-		PAGE_OFFSET;
-#endif
-	kern_linear_pte_xor[0] |= (_PAGE_CP_4U | _PAGE_CV_4U |
-				   _PAGE_P_4U | _PAGE_W_4U);
-
-	for (i = 1; i < 4; i++)
-		kern_linear_pte_xor[i] = kern_linear_pte_xor[0];
-
-	_PAGE_ALL_SZ_BITS =  (_PAGE_SZ4MB_4U | _PAGE_SZ512K_4U |
-			      _PAGE_SZ64K_4U | _PAGE_SZ8K_4U |
-			      _PAGE_SZ32MB_4U | _PAGE_SZ256MB_4U);
-
-
-	page_none = _PAGE_PRESENT_4U | _PAGE_ACCESSED_4U | _PAGE_CACHE_4U;
-	page_shared = (_PAGE_VALID | _PAGE_PRESENT_4U | _PAGE_CACHE_4U |
-		       __ACCESS_BITS_4U | _PAGE_WRITE_4U | _PAGE_EXEC_4U);
-	page_copy   = (_PAGE_VALID | _PAGE_PRESENT_4U | _PAGE_CACHE_4U |
-		       __ACCESS_BITS_4U | _PAGE_EXEC_4U);
-	page_readonly   = (_PAGE_VALID | _PAGE_PRESENT_4U | _PAGE_CACHE_4U |
-			   __ACCESS_BITS_4U | _PAGE_EXEC_4U);
-
-	page_exec_bit = _PAGE_EXEC_4U;
-
-	prot_init_common(page_none, page_shared, page_copy, page_readonly,
-			 page_exec_bit);
-}
-
-static void __init sun4v_pgprot_init(void)
-{
-	unsigned long page_none, page_shared, page_copy, page_readonly;
-	unsigned long page_exec_bit;
-	int i;
-
-	PAGE_KERNEL = __pgprot (_PAGE_PRESENT_4V | _PAGE_VALID |
-				page_cache4v_flag | _PAGE_P_4V |
-				__ACCESS_BITS_4V | __DIRTY_BITS_4V |
-				_PAGE_EXEC_4V);
-	PAGE_KERNEL_LOCKED = PAGE_KERNEL;
-
-	_PAGE_IE = _PAGE_IE_4V;
-	_PAGE_E = _PAGE_E_4V;
-	_PAGE_CACHE = page_cache4v_flag;
-
-#ifdef CONFIG_DEBUG_PAGEALLOC
-	kern_linear_pte_xor[0] = _PAGE_VALID ^ PAGE_OFFSET;
-#else
-	kern_linear_pte_xor[0] = (_PAGE_VALID | _PAGE_SZ4MB_4V) ^
-		PAGE_OFFSET;
-#endif
-	kern_linear_pte_xor[0] |= (page_cache4v_flag | _PAGE_P_4V |
-				   _PAGE_W_4V);
-
-	for (i = 1; i < 4; i++)
-		kern_linear_pte_xor[i] = kern_linear_pte_xor[0];
-
-	pg_iobits = (_PAGE_VALID | _PAGE_PRESENT_4V | __DIRTY_BITS_4V |
-		     __ACCESS_BITS_4V | _PAGE_E_4V);
-
-	_PAGE_ALL_SZ_BITS = (_PAGE_SZ16GB_4V | _PAGE_SZ2GB_4V |
-			     _PAGE_SZ256MB_4V | _PAGE_SZ32MB_4V |
-			     _PAGE_SZ4MB_4V | _PAGE_SZ512K_4V |
-			     _PAGE_SZ64K_4V | _PAGE_SZ8K_4V);
-
-	page_none = _PAGE_PRESENT_4V | _PAGE_ACCESSED_4V | page_cache4v_flag;
-	page_shared = (_PAGE_VALID | _PAGE_PRESENT_4V | page_cache4v_flag |
-		       __ACCESS_BITS_4V | _PAGE_WRITE_4V | _PAGE_EXEC_4V);
-	page_copy   = (_PAGE_VALID | _PAGE_PRESENT_4V | page_cache4v_flag |
-		       __ACCESS_BITS_4V | _PAGE_EXEC_4V);
-	page_readonly = (_PAGE_VALID | _PAGE_PRESENT_4V | page_cache4v_flag |
-			 __ACCESS_BITS_4V | _PAGE_EXEC_4V);
-
-	page_exec_bit = _PAGE_EXEC_4V;
-
-	prot_init_common(page_none, page_shared, page_copy, page_readonly,
-			 page_exec_bit);
-}
-
-unsigned long pte_sz_bits(unsigned long sz)
-{
-	if (tlb_type == hypervisor) {
-		switch (sz) {
-		case 8 * 1024:
-		default:
-			return _PAGE_SZ8K_4V;
-		case 64 * 1024:
-			return _PAGE_SZ64K_4V;
-		case 512 * 1024:
-			return _PAGE_SZ512K_4V;
-		case 4 * 1024 * 1024:
-			return _PAGE_SZ4MB_4V;
-		}
-	} else {
-		switch (sz) {
-		case 8 * 1024:
-		default:
-			return _PAGE_SZ8K_4U;
-		case 64 * 1024:
-			return _PAGE_SZ64K_4U;
-		case 512 * 1024:
-			return _PAGE_SZ512K_4U;
-		case 4 * 1024 * 1024:
-			return _PAGE_SZ4MB_4U;
-		}
-	}
-}
-
-pte_t mk_pte_io(unsigned long page, pgprot_t prot, int space, unsigned long page_size)
-{
-	pte_t pte;
-
-	pte_val(pte)  = page | pgprot_val(pgprot_noncached(prot));
-	pte_val(pte) |= (((unsigned long)space) << 32);
-	pte_val(pte) |= pte_sz_bits(page_size);
-
-	return pte;
-}
-
-static unsigned long kern_large_tte(unsigned long paddr)
-{
-	unsigned long val;
-
-	val = (_PAGE_VALID | _PAGE_SZ4MB_4U |
-	       _PAGE_CP_4U | _PAGE_CV_4U | _PAGE_P_4U |
-	       _PAGE_EXEC_4U | _PAGE_L_4U | _PAGE_W_4U);
-	if (tlb_type == hypervisor)
-		val = (_PAGE_VALID | _PAGE_SZ4MB_4V |
-		       page_cache4v_flag | _PAGE_P_4V |
-		       _PAGE_EXEC_4V | _PAGE_W_4V);
-
-	return val | paddr;
-}
-
-/* If not locked, zap it. */
-void __flush_tlb_all(void)
-{
-	unsigned long pstate;
-	int i;
-
-	__asm__ __volatile__("flushw\n\t"
-			     "rdpr	%%pstate, %0\n\t"
-			     "wrpr	%0, %1, %%pstate"
-			     : "=r" (pstate)
-			     : "i" (PSTATE_IE));
-	if (tlb_type == hypervisor) {
-		sun4v_mmu_demap_all();
-	} else if (tlb_type == spitfire) {
-		for (i = 0; i < 64; i++) {
-			/* Spitfire Errata #32 workaround */
-			/* NOTE: Always runs on spitfire, so no
-			 *       cheetah+ page size encodings.
-			 */
-			__asm__ __volatile__("stxa	%0, [%1] %2\n\t"
-					     "flush	%%g6"
-					     : /* No outputs */
-					     : "r" (0),
-					     "r" (PRIMARY_CONTEXT), "i" (ASI_DMMU));
-
-			if (!(spitfire_get_dtlb_data(i) & _PAGE_L_4U)) {
-				__asm__ __volatile__("stxa %%g0, [%0] %1\n\t"
-						     "membar #Sync"
-						     : /* no outputs */
-						     : "r" (TLB_TAG_ACCESS), "i" (ASI_DMMU));
-				spitfire_put_dtlb_data(i, 0x0UL);
-			}
-
-			/* Spitfire Errata #32 workaround */
-			/* NOTE: Always runs on spitfire, so no
-			 *       cheetah+ page size encodings.
-			 */
-			__asm__ __volatile__("stxa	%0, [%1] %2\n\t"
-					     "flush	%%g6"
-					     : /* No outputs */
-					     : "r" (0),
-					     "r" (PRIMARY_CONTEXT), "i" (ASI_DMMU));
-
-			if (!(spitfire_get_itlb_data(i) & _PAGE_L_4U)) {
-				__asm__ __volatile__("stxa %%g0, [%0] %1\n\t"
-						     "membar #Sync"
-						     : /* no outputs */
-						     : "r" (TLB_TAG_ACCESS), "i" (ASI_IMMU));
-				spitfire_put_itlb_data(i, 0x0UL);
-			}
-		}
-	} else if (tlb_type == cheetah || tlb_type == cheetah_plus) {
-		cheetah_flush_dtlb_all();
-		cheetah_flush_itlb_all();
-	}
-	__asm__ __volatile__("wrpr	%0, 0, %%pstate"
-			     : : "r" (pstate));
-}
-
-static pte_t *__pte_alloc_one(struct mm_struct *mm)
-{
-	struct ptdesc *ptdesc = pagetable_alloc(GFP_KERNEL | __GFP_ZERO, 0);
-
-	if (!ptdesc)
-		return NULL;
-	if (!pagetable_pte_ctor(mm, ptdesc)) {
-		pagetable_free(ptdesc);
-		return NULL;
-	}
-	return ptdesc_address(ptdesc);
-}
-
-pte_t *pte_alloc_one_kernel(struct mm_struct *mm)
-{
-	return __pte_alloc_one(mm);
-}
-
-pgtable_t pte_alloc_one(struct mm_struct *mm)
-{
-	return __pte_alloc_one(mm);
-}
-
-static void __pte_free(pgtable_t pte)
-{
-	struct ptdesc *ptdesc = virt_to_ptdesc(pte);
-
-	pagetable_dtor(ptdesc);
-	pagetable_free(ptdesc);
-}
-
-void pte_free_kernel(struct mm_struct *mm, pte_t *pte)
-{
-	__pte_free(pte);
-}
-
-void pte_free(struct mm_struct *mm, pgtable_t pte)
-{
-	__pte_free(pte);
-}
-
-void pgtable_free(void *table, bool is_page)
-{
-	if (is_page)
-		__pte_free(table);
-	else
-		kmem_cache_free(pgtable_cache, table);
-}
-
-#ifdef CONFIG_TRANSPARENT_HUGEPAGE
-static void pte_free_now(struct rcu_head *head)
-{
-	struct page *page;
-
-	page = container_of(head, struct page, rcu_head);
-	__pte_free((pgtable_t)page_address(page));
-}
-
-void pte_free_defer(struct mm_struct *mm, pgtable_t pgtable)
-{
-	struct page *page;
-
-	page = virt_to_page(pgtable);
-	call_rcu(&page->rcu_head, pte_free_now);
-}
-
-void update_mmu_cache_pmd(struct vm_area_struct *vma, unsigned long addr,
-			  pmd_t *pmd)
-{
-	unsigned long pte, flags;
-	struct mm_struct *mm;
-	pmd_t entry = *pmd;
-
-	if (!pmd_leaf(entry) || !pmd_young(entry))
-		return;
-
-	pte = pmd_val(entry);
-
-	/* Don't insert a non-valid PMD into the TSB, we'll deadlock.  */
-	if (!(pte & _PAGE_VALID))
-		return;
-
-	/* We are fabricating 8MB pages using 4MB real hw pages.  */
-	pte |= (addr & (1UL << REAL_HPAGE_SHIFT));
-
-	mm = vma->vm_mm;
-
-	spin_lock_irqsave(&mm->context.lock, flags);
-
-	if (mm->context.tsb_block[MM_TSB_HUGE].tsb != NULL)
-		__update_mmu_tsb_insert(mm, MM_TSB_HUGE, REAL_HPAGE_SHIFT,
-					addr, pte);
-
-	spin_unlock_irqrestore(&mm->context.lock, flags);
-}
-#endif /* CONFIG_TRANSPARENT_HUGEPAGE */
-
-#if defined(CONFIG_HUGETLB_PAGE) || defined(CONFIG_TRANSPARENT_HUGEPAGE)
-static void context_reload(void *__data)
-{
-	struct mm_struct *mm = __data;
-
-	if (mm == current->mm)
-		load_secondary_context(mm);
-}
-
-void hugetlb_setup(struct pt_regs *regs)
-{
-	struct mm_struct *mm = current->mm;
-	struct tsb_config *tp;
-
-	if (faulthandler_disabled() || !mm) {
-		const struct exception_table_entry *entry;
-
-		entry = search_exception_tables(regs->tpc);
-		if (entry) {
-			regs->tpc = entry->fixup;
-			regs->tnpc = regs->tpc + 4;
-			return;
-		}
-		pr_alert("Unexpected HugeTLB setup in atomic context.\n");
-		die_if_kernel("HugeTSB in atomic", regs);
-	}
-
-	tp = &mm->context.tsb_block[MM_TSB_HUGE];
-	if (likely(tp->tsb == NULL))
-		tsb_grow(mm, MM_TSB_HUGE, 0);
-
-	tsb_context_switch(mm);
-	smp_tsb_sync(mm);
-
-	/* On UltraSPARC-III+ and later, configure the second half of
-	 * the Data-TLB for huge pages.
-	 */
-	if (tlb_type == cheetah_plus) {
-		bool need_context_reload = false;
-		unsigned long ctx;
-
-		spin_lock_irq(&ctx_alloc_lock);
-		ctx = mm->context.sparc64_ctx_val;
-		ctx &= ~CTX_PGSZ_MASK;
-		ctx |= CTX_PGSZ_BASE << CTX_PGSZ0_SHIFT;
-		ctx |= CTX_PGSZ_HUGE << CTX_PGSZ1_SHIFT;
-
-		if (ctx != mm->context.sparc64_ctx_val) {
-			/* When changing the page size fields, we
-			 * must perform a context flush so that no
-			 * stale entries match.  This flush must
-			 * occur with the original context register
-			 * settings.
-			 */
-			do_flush_tlb_mm(mm);
-
-			/* Reload the context register of all processors
-			 * also executing in this address space.
-			 */
-			mm->context.sparc64_ctx_val = ctx;
-			need_context_reload = true;
-		}
-		spin_unlock_irq(&ctx_alloc_lock);
-
-		if (need_context_reload)
-			on_each_cpu(context_reload, mm, 0);
-	}
-}
-#endif
-
-static struct resource code_resource = {
-	.name	= "Kernel code",
-	.flags	= IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM
-};
-
-static struct resource data_resource = {
-	.name	= "Kernel data",
-	.flags	= IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM
-};
-
-static struct resource bss_resource = {
-	.name	= "Kernel bss",
-	.flags	= IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM
-};
-
-static inline resource_size_t compute_kern_paddr(void *addr)
-{
-	return (resource_size_t) (addr - KERNBASE + kern_base);
-}
-
-static void __init kernel_lds_init(void)
-{
-	code_resource.start = compute_kern_paddr(_text);
-	code_resource.end   = compute_kern_paddr(_etext - 1);
-	data_resource.start = compute_kern_paddr(_etext);
-	data_resource.end   = compute_kern_paddr(_edata - 1);
-	bss_resource.start  = compute_kern_paddr(__bss_start);
-	bss_resource.end    = compute_kern_paddr(_end - 1);
-}
-
-static int __init report_memory(void)
-{
-	int i;
-	struct resource *res;
-
-	kernel_lds_init();
-
-	for (i = 0; i < pavail_ents; i++) {
-		res = kzalloc(sizeof(struct resource), GFP_KERNEL);
-
-		if (!res) {
-			pr_warn("Failed to allocate source.\n");
-			break;
-		}
-
-		res->name = "System RAM";
-		res->start = pavail[i].phys_addr;
-		res->end = pavail[i].phys_addr + pavail[i].reg_size - 1;
-		res->flags = IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM;
-
-		if (insert_resource(&iomem_resource, res) < 0) {
-			pr_warn("Resource insertion failed.\n");
-			break;
-		}
-
-		insert_resource(res, &code_resource);
-		insert_resource(res, &data_resource);
-		insert_resource(res, &bss_resource);
-	}
-
-	return 0;
-}
-arch_initcall(report_memory);
-
-#ifdef CONFIG_SMP
-#define do_flush_tlb_kernel_range	smp_flush_tlb_kernel_range
-#else
-#define do_flush_tlb_kernel_range	__flush_tlb_kernel_range
-#endif
-
-void flush_tlb_kernel_range(unsigned long start, unsigned long end)
-{
-	if (start < HI_OBP_ADDRESS && end > LOW_OBP_ADDRESS) {
-		if (start < LOW_OBP_ADDRESS) {
-			flush_tsb_kernel_range(start, LOW_OBP_ADDRESS);
-			do_flush_tlb_kernel_range(start, LOW_OBP_ADDRESS);
-		}
-		if (end > HI_OBP_ADDRESS) {
-			flush_tsb_kernel_range(HI_OBP_ADDRESS, end);
-			do_flush_tlb_kernel_range(HI_OBP_ADDRESS, end);
-		}
-	} else {
-		flush_tsb_kernel_range(start, end);
-		do_flush_tlb_kernel_range(start, end);
-	}
-}
-
-void copy_user_highpage(struct page *to, struct page *from,
-	unsigned long vaddr, struct vm_area_struct *vma)
-{
-	char *vfrom, *vto;
-
-	vfrom = kmap_atomic(from);
-	vto = kmap_atomic(to);
-	copy_user_page(vto, vfrom, vaddr, to);
-	kunmap_atomic(vto);
-	kunmap_atomic(vfrom);
-
-	/* If this page has ADI enabled, copy over any ADI tags
-	 * as well
-	 */
-	if (vma->vm_flags & VM_SPARC_ADI) {
-		unsigned long pfrom, pto, i, adi_tag;
-
-		pfrom = page_to_phys(from);
-		pto = page_to_phys(to);
-
-		for (i = pfrom; i < (pfrom + PAGE_SIZE); i += adi_blksize()) {
-			asm volatile("ldxa [%1] %2, %0\n\t"
-					: "=r" (adi_tag)
-					:  "r" (i), "i" (ASI_MCD_REAL));
-			asm volatile("stxa %0, [%1] %2\n\t"
-					:
-					: "r" (adi_tag), "r" (pto),
-					  "i" (ASI_MCD_REAL));
-			pto += adi_blksize();
-		}
-		asm volatile("membar #Sync\n\t");
-	}
-}
-EXPORT_SYMBOL(copy_user_highpage);
-
-void copy_highpage(struct page *to, struct page *from)
-{
-	char *vfrom, *vto;
-
-	vfrom = kmap_atomic(from);
-	vto = kmap_atomic(to);
-	copy_page(vto, vfrom);
-	kunmap_atomic(vto);
-	kunmap_atomic(vfrom);
-
-	/* If this platform is ADI enabled, copy any ADI tags
-	 * as well
-	 */
-	if (adi_capable()) {
-		unsigned long pfrom, pto, i, adi_tag;
-
-		pfrom = page_to_phys(from);
-		pto = page_to_phys(to);
-
-		for (i = pfrom; i < (pfrom + PAGE_SIZE); i += adi_blksize()) {
-			asm volatile("ldxa [%1] %2, %0\n\t"
-					: "=r" (adi_tag)
-					:  "r" (i), "i" (ASI_MCD_REAL));
-			asm volatile("stxa %0, [%1] %2\n\t"
-					:
-					: "r" (adi_tag), "r" (pto),
-					  "i" (ASI_MCD_REAL));
-			pto += adi_blksize();
-		}
-		asm volatile("membar #Sync\n\t");
-	}
-}
-EXPORT_SYMBOL(copy_highpage);
-
-pgprot_t vm_get_page_prot(unsigned long vm_flags)
-{
-	unsigned long prot = pgprot_val(protection_map[vm_flags &
-					(VM_READ|VM_WRITE|VM_EXEC|VM_SHARED)]);
-
-	if (vm_flags & VM_SPARC_ADI)
-		prot |= _PAGE_MCD_4V;
-
-	return __pgprot(prot);
-}
-EXPORT_SYMBOL(vm_get_page_prot);
diff -Nrup linux-6.16.7/arch/x86/include/asm/cpufeatures.h linux-lenovo-x13s-linux-6.16.y/arch/x86/include/asm/cpufeatures.h
--- linux-6.16.7/arch/x86/include/asm/cpufeatures.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/x86/include/asm/cpufeatures.h	2025-09-11 09:47:42.000000000 -0600
@@ -492,7 +492,6 @@
 #define X86_FEATURE_TSA_SQ_NO		(21*32+11) /* AMD CPU not vulnerable to TSA-SQ */
 #define X86_FEATURE_TSA_L1_NO		(21*32+12) /* AMD CPU not vulnerable to TSA-L1 */
 #define X86_FEATURE_CLEAR_CPU_BUF_VM	(21*32+13) /* Clear CPU buffers using VERW before VMRUN */
-#define X86_FEATURE_IBPB_EXIT_TO_USER	(21*32+14) /* Use IBPB on exit-to-userspace, see VMSCAPE bug */
 
 /*
  * BUG word(s)
@@ -549,5 +548,4 @@
 #define X86_BUG_ITS			X86_BUG( 1*32+ 7) /* "its" CPU is affected by Indirect Target Selection */
 #define X86_BUG_ITS_NATIVE_ONLY		X86_BUG( 1*32+ 8) /* "its_native_only" CPU is affected by ITS, VMX is not affected */
 #define X86_BUG_TSA			X86_BUG( 1*32+ 9) /* "tsa" CPU is affected by Transient Scheduler Attacks */
-#define X86_BUG_VMSCAPE			X86_BUG( 1*32+10) /* "vmscape" CPU is affected by VMSCAPE attacks from guests */
 #endif /* _ASM_X86_CPUFEATURES_H */
diff -Nrup linux-6.16.7/arch/x86/include/asm/entry-common.h linux-lenovo-x13s-linux-6.16.y/arch/x86/include/asm/entry-common.h
--- linux-6.16.7/arch/x86/include/asm/entry-common.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/x86/include/asm/entry-common.h	2025-09-11 09:47:42.000000000 -0600
@@ -93,13 +93,6 @@ static inline void arch_exit_to_user_mod
 	 * 8 (ia32) bits.
 	 */
 	choose_random_kstack_offset(rdtsc());
-
-	/* Avoid unnecessary reads of 'x86_ibpb_exit_to_user' */
-	if (cpu_feature_enabled(X86_FEATURE_IBPB_EXIT_TO_USER) &&
-	    this_cpu_read(x86_ibpb_exit_to_user)) {
-		indirect_branch_prediction_barrier();
-		this_cpu_write(x86_ibpb_exit_to_user, false);
-	}
 }
 #define arch_exit_to_user_mode_prepare arch_exit_to_user_mode_prepare
 
diff -Nrup linux-6.16.7/arch/x86/include/asm/nospec-branch.h linux-lenovo-x13s-linux-6.16.y/arch/x86/include/asm/nospec-branch.h
--- linux-6.16.7/arch/x86/include/asm/nospec-branch.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/x86/include/asm/nospec-branch.h	2025-09-11 09:47:42.000000000 -0600
@@ -530,8 +530,6 @@ void alternative_msr_write(unsigned int
 		: "memory");
 }
 
-DECLARE_PER_CPU(bool, x86_ibpb_exit_to_user);
-
 static inline void indirect_branch_prediction_barrier(void)
 {
 	asm_inline volatile(ALTERNATIVE("", "call write_ibpb", X86_FEATURE_IBPB)
diff -Nrup linux-6.16.7/arch/x86/Kconfig linux-lenovo-x13s-linux-6.16.y/arch/x86/Kconfig
--- linux-6.16.7/arch/x86/Kconfig	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/x86/Kconfig	2025-09-11 09:47:42.000000000 -0600
@@ -2704,15 +2704,6 @@ config MITIGATION_TSA
 	  security vulnerability on AMD CPUs which can lead to forwarding of
 	  invalid info to subsequent instructions and thus can affect their
 	  timing and thereby cause a leakage.
-
-config MITIGATION_VMSCAPE
-	bool "Mitigate VMSCAPE"
-	depends on KVM
-	default y
-	help
-	  Enable mitigation for VMSCAPE attacks. VMSCAPE is a hardware security
-	  vulnerability on Intel and AMD CPUs that may allow a guest to do
-	  Spectre v2 style attacks on userspace hypervisor.
 endif
 
 config ARCH_HAS_ADD_PAGES
diff -Nrup linux-6.16.7/arch/x86/kernel/cpu/bugs.c linux-lenovo-x13s-linux-6.16.y/arch/x86/kernel/cpu/bugs.c
--- linux-6.16.7/arch/x86/kernel/cpu/bugs.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/x86/kernel/cpu/bugs.c	2025-09-11 09:47:42.000000000 -0600
@@ -96,9 +96,6 @@ static void __init its_update_mitigation
 static void __init its_apply_mitigation(void);
 static void __init tsa_select_mitigation(void);
 static void __init tsa_apply_mitigation(void);
-static void __init vmscape_select_mitigation(void);
-static void __init vmscape_update_mitigation(void);
-static void __init vmscape_apply_mitigation(void);
 
 /* The base value of the SPEC_CTRL MSR without task-specific bits set */
 u64 x86_spec_ctrl_base;
@@ -108,14 +105,6 @@ EXPORT_SYMBOL_GPL(x86_spec_ctrl_base);
 DEFINE_PER_CPU(u64, x86_spec_ctrl_current);
 EXPORT_PER_CPU_SYMBOL_GPL(x86_spec_ctrl_current);
 
-/*
- * Set when the CPU has run a potentially malicious guest. An IBPB will
- * be needed to before running userspace. That IBPB will flush the branch
- * predictor content.
- */
-DEFINE_PER_CPU(bool, x86_ibpb_exit_to_user);
-EXPORT_PER_CPU_SYMBOL_GPL(x86_ibpb_exit_to_user);
-
 u64 x86_pred_cmd __ro_after_init = PRED_CMD_IBPB;
 
 static u64 __ro_after_init x86_arch_cap_msr;
@@ -238,7 +227,6 @@ void __init cpu_select_mitigations(void)
 	its_select_mitigation();
 	bhi_select_mitigation();
 	tsa_select_mitigation();
-	vmscape_select_mitigation();
 
 	/*
 	 * After mitigations are selected, some may need to update their
@@ -270,7 +258,6 @@ void __init cpu_select_mitigations(void)
 	bhi_update_mitigation();
 	/* srso_update_mitigation() depends on retbleed_update_mitigation(). */
 	srso_update_mitigation();
-	vmscape_update_mitigation();
 
 	spectre_v1_apply_mitigation();
 	spectre_v2_apply_mitigation();
@@ -288,7 +275,6 @@ void __init cpu_select_mitigations(void)
 	its_apply_mitigation();
 	bhi_apply_mitigation();
 	tsa_apply_mitigation();
-	vmscape_apply_mitigation();
 }
 
 /*
@@ -2369,6 +2355,88 @@ static void update_mds_branch_idle(void)
 	}
 }
 
+#define MDS_MSG_SMT "MDS CPU bug present and SMT on, data leak possible. See https://www.kernel.org/doc/html/latest/admin-guide/hw-vuln/mds.html for more details.\n"
+#define TAA_MSG_SMT "TAA CPU bug present and SMT on, data leak possible. See https://www.kernel.org/doc/html/latest/admin-guide/hw-vuln/tsx_async_abort.html for more details.\n"
+#define MMIO_MSG_SMT "MMIO Stale Data CPU bug present and SMT on, data leak possible. See https://www.kernel.org/doc/html/latest/admin-guide/hw-vuln/processor_mmio_stale_data.html for more details.\n"
+
+void cpu_bugs_smt_update(void)
+{
+	mutex_lock(&spec_ctrl_mutex);
+
+	if (sched_smt_active() && unprivileged_ebpf_enabled() &&
+	    spectre_v2_enabled == SPECTRE_V2_EIBRS_LFENCE)
+		pr_warn_once(SPECTRE_V2_EIBRS_LFENCE_EBPF_SMT_MSG);
+
+	switch (spectre_v2_user_stibp) {
+	case SPECTRE_V2_USER_NONE:
+		break;
+	case SPECTRE_V2_USER_STRICT:
+	case SPECTRE_V2_USER_STRICT_PREFERRED:
+		update_stibp_strict();
+		break;
+	case SPECTRE_V2_USER_PRCTL:
+	case SPECTRE_V2_USER_SECCOMP:
+		update_indir_branch_cond();
+		break;
+	}
+
+	switch (mds_mitigation) {
+	case MDS_MITIGATION_FULL:
+	case MDS_MITIGATION_AUTO:
+	case MDS_MITIGATION_VMWERV:
+		if (sched_smt_active() && !boot_cpu_has(X86_BUG_MSBDS_ONLY))
+			pr_warn_once(MDS_MSG_SMT);
+		update_mds_branch_idle();
+		break;
+	case MDS_MITIGATION_OFF:
+		break;
+	}
+
+	switch (taa_mitigation) {
+	case TAA_MITIGATION_VERW:
+	case TAA_MITIGATION_AUTO:
+	case TAA_MITIGATION_UCODE_NEEDED:
+		if (sched_smt_active())
+			pr_warn_once(TAA_MSG_SMT);
+		break;
+	case TAA_MITIGATION_TSX_DISABLED:
+	case TAA_MITIGATION_OFF:
+		break;
+	}
+
+	switch (mmio_mitigation) {
+	case MMIO_MITIGATION_VERW:
+	case MMIO_MITIGATION_AUTO:
+	case MMIO_MITIGATION_UCODE_NEEDED:
+		if (sched_smt_active())
+			pr_warn_once(MMIO_MSG_SMT);
+		break;
+	case MMIO_MITIGATION_OFF:
+		break;
+	}
+
+	switch (tsa_mitigation) {
+	case TSA_MITIGATION_USER_KERNEL:
+	case TSA_MITIGATION_VM:
+	case TSA_MITIGATION_AUTO:
+	case TSA_MITIGATION_FULL:
+		/*
+		 * TSA-SQ can potentially lead to info leakage between
+		 * SMT threads.
+		 */
+		if (sched_smt_active())
+			static_branch_enable(&cpu_buf_idle_clear);
+		else
+			static_branch_disable(&cpu_buf_idle_clear);
+		break;
+	case TSA_MITIGATION_NONE:
+	case TSA_MITIGATION_UCODE_NEEDED:
+		break;
+	}
+
+	mutex_unlock(&spec_ctrl_mutex);
+}
+
 #undef pr_fmt
 #define pr_fmt(fmt)	"Speculative Store Bypass: " fmt
 
@@ -3070,184 +3138,8 @@ static void __init srso_apply_mitigation
 }
 
 #undef pr_fmt
-#define pr_fmt(fmt)	"VMSCAPE: " fmt
-
-enum vmscape_mitigations {
-	VMSCAPE_MITIGATION_NONE,
-	VMSCAPE_MITIGATION_AUTO,
-	VMSCAPE_MITIGATION_IBPB_EXIT_TO_USER,
-	VMSCAPE_MITIGATION_IBPB_ON_VMEXIT,
-};
-
-static const char * const vmscape_strings[] = {
-	[VMSCAPE_MITIGATION_NONE]		= "Vulnerable",
-	/* [VMSCAPE_MITIGATION_AUTO] */
-	[VMSCAPE_MITIGATION_IBPB_EXIT_TO_USER]	= "Mitigation: IBPB before exit to userspace",
-	[VMSCAPE_MITIGATION_IBPB_ON_VMEXIT]	= "Mitigation: IBPB on VMEXIT",
-};
-
-static enum vmscape_mitigations vmscape_mitigation __ro_after_init =
-	IS_ENABLED(CONFIG_MITIGATION_VMSCAPE) ? VMSCAPE_MITIGATION_AUTO : VMSCAPE_MITIGATION_NONE;
-
-static int __init vmscape_parse_cmdline(char *str)
-{
-	if (!str)
-		return -EINVAL;
-
-	if (!strcmp(str, "off")) {
-		vmscape_mitigation = VMSCAPE_MITIGATION_NONE;
-	} else if (!strcmp(str, "ibpb")) {
-		vmscape_mitigation = VMSCAPE_MITIGATION_IBPB_EXIT_TO_USER;
-	} else if (!strcmp(str, "force")) {
-		setup_force_cpu_bug(X86_BUG_VMSCAPE);
-		vmscape_mitigation = VMSCAPE_MITIGATION_AUTO;
-	} else {
-		pr_err("Ignoring unknown vmscape=%s option.\n", str);
-	}
-
-	return 0;
-}
-early_param("vmscape", vmscape_parse_cmdline);
-
-static void __init vmscape_select_mitigation(void)
-{
-	if (cpu_mitigations_off() ||
-	    !boot_cpu_has_bug(X86_BUG_VMSCAPE) ||
-	    !boot_cpu_has(X86_FEATURE_IBPB)) {
-		vmscape_mitigation = VMSCAPE_MITIGATION_NONE;
-		return;
-	}
-
-	if (vmscape_mitigation == VMSCAPE_MITIGATION_AUTO)
-		vmscape_mitigation = VMSCAPE_MITIGATION_IBPB_EXIT_TO_USER;
-}
-
-static void __init vmscape_update_mitigation(void)
-{
-	if (!boot_cpu_has_bug(X86_BUG_VMSCAPE))
-		return;
-
-	if (retbleed_mitigation == RETBLEED_MITIGATION_IBPB ||
-	    srso_mitigation == SRSO_MITIGATION_IBPB_ON_VMEXIT)
-		vmscape_mitigation = VMSCAPE_MITIGATION_IBPB_ON_VMEXIT;
-
-	pr_info("%s\n", vmscape_strings[vmscape_mitigation]);
-}
-
-static void __init vmscape_apply_mitigation(void)
-{
-	if (vmscape_mitigation == VMSCAPE_MITIGATION_IBPB_EXIT_TO_USER)
-		setup_force_cpu_cap(X86_FEATURE_IBPB_EXIT_TO_USER);
-}
-
-#undef pr_fmt
 #define pr_fmt(fmt) fmt
 
-#define MDS_MSG_SMT "MDS CPU bug present and SMT on, data leak possible. See https://www.kernel.org/doc/html/latest/admin-guide/hw-vuln/mds.html for more details.\n"
-#define TAA_MSG_SMT "TAA CPU bug present and SMT on, data leak possible. See https://www.kernel.org/doc/html/latest/admin-guide/hw-vuln/tsx_async_abort.html for more details.\n"
-#define MMIO_MSG_SMT "MMIO Stale Data CPU bug present and SMT on, data leak possible. See https://www.kernel.org/doc/html/latest/admin-guide/hw-vuln/processor_mmio_stale_data.html for more details.\n"
-#define VMSCAPE_MSG_SMT "VMSCAPE: SMT on, STIBP is required for full protection. See https://www.kernel.org/doc/html/latest/admin-guide/hw-vuln/vmscape.html for more details.\n"
-
-void cpu_bugs_smt_update(void)
-{
-	mutex_lock(&spec_ctrl_mutex);
-
-	if (sched_smt_active() && unprivileged_ebpf_enabled() &&
-	    spectre_v2_enabled == SPECTRE_V2_EIBRS_LFENCE)
-		pr_warn_once(SPECTRE_V2_EIBRS_LFENCE_EBPF_SMT_MSG);
-
-	switch (spectre_v2_user_stibp) {
-	case SPECTRE_V2_USER_NONE:
-		break;
-	case SPECTRE_V2_USER_STRICT:
-	case SPECTRE_V2_USER_STRICT_PREFERRED:
-		update_stibp_strict();
-		break;
-	case SPECTRE_V2_USER_PRCTL:
-	case SPECTRE_V2_USER_SECCOMP:
-		update_indir_branch_cond();
-		break;
-	}
-
-	switch (mds_mitigation) {
-	case MDS_MITIGATION_FULL:
-	case MDS_MITIGATION_AUTO:
-	case MDS_MITIGATION_VMWERV:
-		if (sched_smt_active() && !boot_cpu_has(X86_BUG_MSBDS_ONLY))
-			pr_warn_once(MDS_MSG_SMT);
-		update_mds_branch_idle();
-		break;
-	case MDS_MITIGATION_OFF:
-		break;
-	}
-
-	switch (taa_mitigation) {
-	case TAA_MITIGATION_VERW:
-	case TAA_MITIGATION_AUTO:
-	case TAA_MITIGATION_UCODE_NEEDED:
-		if (sched_smt_active())
-			pr_warn_once(TAA_MSG_SMT);
-		break;
-	case TAA_MITIGATION_TSX_DISABLED:
-	case TAA_MITIGATION_OFF:
-		break;
-	}
-
-	switch (mmio_mitigation) {
-	case MMIO_MITIGATION_VERW:
-	case MMIO_MITIGATION_AUTO:
-	case MMIO_MITIGATION_UCODE_NEEDED:
-		if (sched_smt_active())
-			pr_warn_once(MMIO_MSG_SMT);
-		break;
-	case MMIO_MITIGATION_OFF:
-		break;
-	}
-
-	switch (tsa_mitigation) {
-	case TSA_MITIGATION_USER_KERNEL:
-	case TSA_MITIGATION_VM:
-	case TSA_MITIGATION_AUTO:
-	case TSA_MITIGATION_FULL:
-		/*
-		 * TSA-SQ can potentially lead to info leakage between
-		 * SMT threads.
-		 */
-		if (sched_smt_active())
-			static_branch_enable(&cpu_buf_idle_clear);
-		else
-			static_branch_disable(&cpu_buf_idle_clear);
-		break;
-	case TSA_MITIGATION_NONE:
-	case TSA_MITIGATION_UCODE_NEEDED:
-		break;
-	}
-
-	switch (vmscape_mitigation) {
-	case VMSCAPE_MITIGATION_NONE:
-	case VMSCAPE_MITIGATION_AUTO:
-		break;
-	case VMSCAPE_MITIGATION_IBPB_ON_VMEXIT:
-	case VMSCAPE_MITIGATION_IBPB_EXIT_TO_USER:
-		/*
-		 * Hypervisors can be attacked across-threads, warn for SMT when
-		 * STIBP is not already enabled system-wide.
-		 *
-		 * Intel eIBRS (!AUTOIBRS) implies STIBP on.
-		 */
-		if (!sched_smt_active() ||
-		    spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT ||
-		    spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT_PREFERRED ||
-		    (spectre_v2_in_eibrs_mode(spectre_v2_enabled) &&
-		     !boot_cpu_has(X86_FEATURE_AUTOIBRS)))
-			break;
-		pr_warn_once(VMSCAPE_MSG_SMT);
-		break;
-	}
-
-	mutex_unlock(&spec_ctrl_mutex);
-}
-
 #ifdef CONFIG_SYSFS
 
 #define L1TF_DEFAULT_MSG "Mitigation: PTE Inversion"
@@ -3496,11 +3388,6 @@ static ssize_t tsa_show_state(char *buf)
 	return sysfs_emit(buf, "%s\n", tsa_strings[tsa_mitigation]);
 }
 
-static ssize_t vmscape_show_state(char *buf)
-{
-	return sysfs_emit(buf, "%s\n", vmscape_strings[vmscape_mitigation]);
-}
-
 static ssize_t cpu_show_common(struct device *dev, struct device_attribute *attr,
 			       char *buf, unsigned int bug)
 {
@@ -3567,9 +3454,6 @@ static ssize_t cpu_show_common(struct de
 	case X86_BUG_TSA:
 		return tsa_show_state(buf);
 
-	case X86_BUG_VMSCAPE:
-		return vmscape_show_state(buf);
-
 	default:
 		break;
 	}
@@ -3661,11 +3545,6 @@ ssize_t cpu_show_tsa(struct device *dev,
 {
 	return cpu_show_common(dev, attr, buf, X86_BUG_TSA);
 }
-
-ssize_t cpu_show_vmscape(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	return cpu_show_common(dev, attr, buf, X86_BUG_VMSCAPE);
-}
 #endif
 
 void __warn_thunk(void)
diff -Nrup linux-6.16.7/arch/x86/kernel/cpu/common.c linux-lenovo-x13s-linux-6.16.y/arch/x86/kernel/cpu/common.c
--- linux-6.16.7/arch/x86/kernel/cpu/common.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/x86/kernel/cpu/common.c	2025-09-11 09:47:42.000000000 -0600
@@ -1235,71 +1235,55 @@ static const __initconst struct x86_cpu_
 #define ITS_NATIVE_ONLY	BIT(9)
 /* CPU is affected by Transient Scheduler Attacks */
 #define TSA		BIT(10)
-/* CPU is affected by VMSCAPE */
-#define VMSCAPE		BIT(11)
 
 static const struct x86_cpu_id cpu_vuln_blacklist[] __initconst = {
-	VULNBL_INTEL_STEPS(INTEL_SANDYBRIDGE_X,	     X86_STEP_MAX,	VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_SANDYBRIDGE,	     X86_STEP_MAX,	VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_IVYBRIDGE_X,	     X86_STEP_MAX,	VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_IVYBRIDGE,	     X86_STEP_MAX,	SRBDS | VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_HASWELL,	     X86_STEP_MAX,	SRBDS | VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_HASWELL_L,	     X86_STEP_MAX,	SRBDS | VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_HASWELL_G,	     X86_STEP_MAX,	SRBDS | VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_HASWELL_X,	     X86_STEP_MAX,	MMIO | VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_BROADWELL_D,	     X86_STEP_MAX,	MMIO | VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_BROADWELL_X,	     X86_STEP_MAX,	MMIO | VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_BROADWELL_G,	     X86_STEP_MAX,	SRBDS | VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_BROADWELL,	     X86_STEP_MAX,	SRBDS | VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_SKYLAKE_X,		      0x5,	MMIO | RETBLEED | GDS | VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_SKYLAKE_X,	     X86_STEP_MAX,	MMIO | RETBLEED | GDS | ITS | VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_SKYLAKE_L,	     X86_STEP_MAX,	MMIO | RETBLEED | GDS | SRBDS | VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_SKYLAKE,	     X86_STEP_MAX,	MMIO | RETBLEED | GDS | SRBDS | VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_KABYLAKE_L,		      0xb,	MMIO | RETBLEED | GDS | SRBDS | VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_KABYLAKE_L,	     X86_STEP_MAX,	MMIO | RETBLEED | GDS | SRBDS | ITS | VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_KABYLAKE,		      0xc,	MMIO | RETBLEED | GDS | SRBDS | VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_KABYLAKE,	     X86_STEP_MAX,	MMIO | RETBLEED | GDS | SRBDS | ITS | VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_CANNONLAKE_L,	     X86_STEP_MAX,	RETBLEED | VMSCAPE),
+	VULNBL_INTEL_STEPS(INTEL_IVYBRIDGE,	     X86_STEP_MAX,	SRBDS),
+	VULNBL_INTEL_STEPS(INTEL_HASWELL,	     X86_STEP_MAX,	SRBDS),
+	VULNBL_INTEL_STEPS(INTEL_HASWELL_L,	     X86_STEP_MAX,	SRBDS),
+	VULNBL_INTEL_STEPS(INTEL_HASWELL_G,	     X86_STEP_MAX,	SRBDS),
+	VULNBL_INTEL_STEPS(INTEL_HASWELL_X,	     X86_STEP_MAX,	MMIO),
+	VULNBL_INTEL_STEPS(INTEL_BROADWELL_D,	     X86_STEP_MAX,	MMIO),
+	VULNBL_INTEL_STEPS(INTEL_BROADWELL_G,	     X86_STEP_MAX,	SRBDS),
+	VULNBL_INTEL_STEPS(INTEL_BROADWELL_X,	     X86_STEP_MAX,	MMIO),
+	VULNBL_INTEL_STEPS(INTEL_BROADWELL,	     X86_STEP_MAX,	SRBDS),
+	VULNBL_INTEL_STEPS(INTEL_SKYLAKE_X,		      0x5,	MMIO | RETBLEED | GDS),
+	VULNBL_INTEL_STEPS(INTEL_SKYLAKE_X,	     X86_STEP_MAX,	MMIO | RETBLEED | GDS | ITS),
+	VULNBL_INTEL_STEPS(INTEL_SKYLAKE_L,	     X86_STEP_MAX,	MMIO | RETBLEED | GDS | SRBDS),
+	VULNBL_INTEL_STEPS(INTEL_SKYLAKE,	     X86_STEP_MAX,	MMIO | RETBLEED | GDS | SRBDS),
+	VULNBL_INTEL_STEPS(INTEL_KABYLAKE_L,		      0xb,	MMIO | RETBLEED | GDS | SRBDS),
+	VULNBL_INTEL_STEPS(INTEL_KABYLAKE_L,	     X86_STEP_MAX,	MMIO | RETBLEED | GDS | SRBDS | ITS),
+	VULNBL_INTEL_STEPS(INTEL_KABYLAKE,		      0xc,	MMIO | RETBLEED | GDS | SRBDS),
+	VULNBL_INTEL_STEPS(INTEL_KABYLAKE,	     X86_STEP_MAX,	MMIO | RETBLEED | GDS | SRBDS | ITS),
+	VULNBL_INTEL_STEPS(INTEL_CANNONLAKE_L,	     X86_STEP_MAX,	RETBLEED),
 	VULNBL_INTEL_STEPS(INTEL_ICELAKE_L,	     X86_STEP_MAX,	MMIO | MMIO_SBDS | RETBLEED | GDS | ITS | ITS_NATIVE_ONLY),
 	VULNBL_INTEL_STEPS(INTEL_ICELAKE_D,	     X86_STEP_MAX,	MMIO | GDS | ITS | ITS_NATIVE_ONLY),
 	VULNBL_INTEL_STEPS(INTEL_ICELAKE_X,	     X86_STEP_MAX,	MMIO | GDS | ITS | ITS_NATIVE_ONLY),
-	VULNBL_INTEL_STEPS(INTEL_COMETLAKE,	     X86_STEP_MAX,	MMIO | MMIO_SBDS | RETBLEED | GDS | ITS | VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_COMETLAKE_L,		      0x0,	MMIO | RETBLEED | ITS | VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_COMETLAKE_L,	     X86_STEP_MAX,	MMIO | MMIO_SBDS | RETBLEED | GDS | ITS | VMSCAPE),
+	VULNBL_INTEL_STEPS(INTEL_COMETLAKE,	     X86_STEP_MAX,	MMIO | MMIO_SBDS | RETBLEED | GDS | ITS),
+	VULNBL_INTEL_STEPS(INTEL_COMETLAKE_L,		      0x0,	MMIO | RETBLEED | ITS),
+	VULNBL_INTEL_STEPS(INTEL_COMETLAKE_L,	     X86_STEP_MAX,	MMIO | MMIO_SBDS | RETBLEED | GDS | ITS),
 	VULNBL_INTEL_STEPS(INTEL_TIGERLAKE_L,	     X86_STEP_MAX,	GDS | ITS | ITS_NATIVE_ONLY),
 	VULNBL_INTEL_STEPS(INTEL_TIGERLAKE,	     X86_STEP_MAX,	GDS | ITS | ITS_NATIVE_ONLY),
 	VULNBL_INTEL_STEPS(INTEL_LAKEFIELD,	     X86_STEP_MAX,	MMIO | MMIO_SBDS | RETBLEED),
 	VULNBL_INTEL_STEPS(INTEL_ROCKETLAKE,	     X86_STEP_MAX,	MMIO | RETBLEED | GDS | ITS | ITS_NATIVE_ONLY),
-	VULNBL_INTEL_TYPE(INTEL_ALDERLAKE,		     ATOM,	RFDS | VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_ALDERLAKE,	     X86_STEP_MAX,	VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_ALDERLAKE_L,	     X86_STEP_MAX,	RFDS | VMSCAPE),
-	VULNBL_INTEL_TYPE(INTEL_RAPTORLAKE,		     ATOM,	RFDS | VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_RAPTORLAKE,	     X86_STEP_MAX,	VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_RAPTORLAKE_P,	     X86_STEP_MAX,	RFDS | VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_RAPTORLAKE_S,	     X86_STEP_MAX,	RFDS | VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_METEORLAKE_L,	     X86_STEP_MAX,	VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_ARROWLAKE_H,	     X86_STEP_MAX,	VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_ARROWLAKE,	     X86_STEP_MAX,	VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_ARROWLAKE_U,	     X86_STEP_MAX,	VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_LUNARLAKE_M,	     X86_STEP_MAX,	VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_SAPPHIRERAPIDS_X,   X86_STEP_MAX,	VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_GRANITERAPIDS_X,    X86_STEP_MAX,	VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_EMERALDRAPIDS_X,    X86_STEP_MAX,	VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_ATOM_GRACEMONT,     X86_STEP_MAX,	RFDS | VMSCAPE),
+	VULNBL_INTEL_TYPE(INTEL_ALDERLAKE,		     ATOM,	RFDS),
+	VULNBL_INTEL_STEPS(INTEL_ALDERLAKE_L,	     X86_STEP_MAX,	RFDS),
+	VULNBL_INTEL_TYPE(INTEL_RAPTORLAKE,		     ATOM,	RFDS),
+	VULNBL_INTEL_STEPS(INTEL_RAPTORLAKE_P,	     X86_STEP_MAX,	RFDS),
+	VULNBL_INTEL_STEPS(INTEL_RAPTORLAKE_S,	     X86_STEP_MAX,	RFDS),
+	VULNBL_INTEL_STEPS(INTEL_ATOM_GRACEMONT,     X86_STEP_MAX,	RFDS),
 	VULNBL_INTEL_STEPS(INTEL_ATOM_TREMONT,	     X86_STEP_MAX,	MMIO | MMIO_SBDS | RFDS),
 	VULNBL_INTEL_STEPS(INTEL_ATOM_TREMONT_D,     X86_STEP_MAX,	MMIO | RFDS),
 	VULNBL_INTEL_STEPS(INTEL_ATOM_TREMONT_L,     X86_STEP_MAX,	MMIO | MMIO_SBDS | RFDS),
 	VULNBL_INTEL_STEPS(INTEL_ATOM_GOLDMONT,      X86_STEP_MAX,	RFDS),
 	VULNBL_INTEL_STEPS(INTEL_ATOM_GOLDMONT_D,    X86_STEP_MAX,	RFDS),
 	VULNBL_INTEL_STEPS(INTEL_ATOM_GOLDMONT_PLUS, X86_STEP_MAX,	RFDS),
-	VULNBL_INTEL_STEPS(INTEL_ATOM_CRESTMONT_X,   X86_STEP_MAX,	VMSCAPE),
 
 	VULNBL_AMD(0x15, RETBLEED),
 	VULNBL_AMD(0x16, RETBLEED),
-	VULNBL_AMD(0x17, RETBLEED | SMT_RSB | SRSO | VMSCAPE),
-	VULNBL_HYGON(0x18, RETBLEED | SMT_RSB | SRSO | VMSCAPE),
-	VULNBL_AMD(0x19, SRSO | TSA | VMSCAPE),
-	VULNBL_AMD(0x1a, SRSO | VMSCAPE),
+	VULNBL_AMD(0x17, RETBLEED | SMT_RSB | SRSO),
+	VULNBL_HYGON(0x18, RETBLEED | SMT_RSB | SRSO),
+	VULNBL_AMD(0x19, SRSO | TSA),
+	VULNBL_AMD(0x1a, SRSO),
 	{}
 };
 
@@ -1558,14 +1542,6 @@ static void __init cpu_set_bug_bits(stru
 		}
 	}
 
-	/*
-	 * Set the bug only on bare-metal. A nested hypervisor should already be
-	 * deploying IBPB to isolate itself from nested guests.
-	 */
-	if (cpu_matches(cpu_vuln_blacklist, VMSCAPE) &&
-	    !boot_cpu_has(X86_FEATURE_HYPERVISOR))
-		setup_force_cpu_bug(X86_BUG_VMSCAPE);
-
 	if (cpu_matches(cpu_vuln_whitelist, NO_MELTDOWN))
 		return;
 
diff -Nrup linux-6.16.7/arch/x86/kvm/x86.c linux-lenovo-x13s-linux-6.16.y/arch/x86/kvm/x86.c
--- linux-6.16.7/arch/x86/kvm/x86.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/x86/kvm/x86.c	2025-09-11 09:47:42.000000000 -0600
@@ -11146,15 +11146,6 @@ static int vcpu_enter_guest(struct kvm_v
 		wrmsrq(MSR_IA32_XFD_ERR, 0);
 
 	/*
-	 * Mark this CPU as needing a branch predictor flush before running
-	 * userspace. Must be done before enabling preemption to ensure it gets
-	 * set for the CPU that actually ran the guest, and not the CPU that it
-	 * may migrate to.
-	 */
-	if (cpu_feature_enabled(X86_FEATURE_IBPB_EXIT_TO_USER))
-		this_cpu_write(x86_ibpb_exit_to_user, true);
-
-	/*
 	 * Consume any pending interrupts, including the possible source of
 	 * VM-Exit on SVM and any ticks that occur between VM-Exit and now.
 	 * An instruction is required after local_irq_enable() to fully unblock
diff -Nrup linux-6.16.7/distro/Kconfig linux-lenovo-x13s-linux-6.16.y/distro/Kconfig
--- linux-6.16.7/distro/Kconfig	2025-09-13 16:15:46.057136000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/distro/Kconfig	1969-12-31 17:00:00.000000000 -0700
@@ -1,310 +0,0 @@
-menu "Gentoo Linux"
-
-config GENTOO_LINUX
-	bool "Gentoo Linux support"
-
-	default y
-
-	select CPU_FREQ_DEFAULT_GOV_SCHEDUTIL
-
-	help
-		In order to boot Gentoo Linux a minimal set of config settings needs to
-		be enabled in the kernel; to avoid the users from having to enable them
-		manually as part of a Gentoo Linux installation or a new clean config,
-		we enable these config settings by default for convenience.
-
-		See the settings that become available for more details and fine-tuning.
-
-config GENTOO_LINUX_UDEV
-	bool "Linux dynamic and persistent device naming (userspace devfs) support"
-
-	depends on GENTOO_LINUX
-	default y if GENTOO_LINUX
-
-	select DEVTMPFS
-	select TMPFS
-	select UNIX
-
-	select MMU
-	select SHMEM
-
-	help
-		In order to boot Gentoo Linux a minimal set of config settings needs to
-		be enabled in the kernel; to avoid the users from having to enable them
-		manually as part of a Gentoo Linux installation or a new clean config,
-		we enable these config settings by default for convenience.
-
-		Currently this only selects TMPFS, DEVTMPFS and their dependencies.
-		TMPFS is enabled to maintain a tmpfs file system at /dev/shm, /run and
-		/sys/fs/cgroup; DEVTMPFS to maintain a devtmpfs file system at /dev.
-
-		Some of these are critical files that need to be available early in the
-		boot process; if not available, it causes sysfs and udev to malfunction.
-
-		To ensure Gentoo Linux boots, it is best to leave this setting enabled;
-		if you run a custom setup, you could consider whether to disable this.
-
-config GENTOO_LINUX_PORTAGE
-	bool "Select options required by Portage features"
-
-	depends on GENTOO_LINUX
-	default y if GENTOO_LINUX
-
-	select CGROUPS
-	select NAMESPACES
-	select IPC_NS
-	select NET_NS
-	select PID_NS
-	select SYSVIPC
-	select USER_NS
-	select UTS_NS
-
-	help
-		This enables options required by various Portage FEATURES.
-		Currently this selects:
-
-		CGROUPS     (required for FEATURES=cgroup)
-		IPC_NS      (required for FEATURES=ipc-sandbox)
-		NET_NS      (required for FEATURES=network-sandbox)
-		PID_NS		(required for FEATURES=pid-sandbox)
-		SYSVIPC     (required by IPC_NS)
-   
-
-		It is highly recommended that you leave this enabled as these FEATURES
-		are, or will soon be, enabled by default.
-
-menu "Support for init systems, system and service managers"
-	visible if GENTOO_LINUX
-
-config GENTOO_LINUX_INIT_SCRIPT
-	bool "OpenRC, runit and other script based systems and managers"
-
-	default y if GENTOO_LINUX
-
-	depends on GENTOO_LINUX
-
-	select BINFMT_SCRIPT
-	select CGROUPS
-	select EPOLL
-	select FILE_LOCKING
-	select INOTIFY_USER
-	select SIGNALFD
-	select TIMERFD
-
-	help
-		The init system is the first thing that loads after the kernel booted.
-
-		These config settings allow you to select which init systems to support;
-		instead of having to select all the individual settings all over the
-		place, these settings allows you to select all the settings at once.
-
-		This particular setting enables all the known requirements for OpenRC,
-		runit and similar script based systems and managers.
-
-		If you are unsure about this, it is best to leave this setting enabled.
-
-config GENTOO_LINUX_INIT_SYSTEMD
-	bool "systemd"
-
-	default n
-
-	depends on GENTOO_LINUX && GENTOO_LINUX_UDEV
-
-	select AUTOFS_FS
-	select BLK_DEV_BSG if SCSI
-	select BPF_SYSCALL
-	select CGROUP_BPF
-	select CGROUPS
-	select CRYPTO_HMAC 
-	select CRYPTO_SHA256
-	select CRYPTO_USER_API_HASH
-	select DEVPTS_MULTIPLE_INSTANCES
-	select DMIID if X86_32 || X86_64 || X86
-	select EPOLL
-	select FANOTIFY
-	select FHANDLE
-	select FILE_LOCKING
-	select INOTIFY_USER
-	select IPV6
-	select KCMP
-	select NET
-	select NET_NS
-	select PROC_FS
-	select SECCOMP if HAVE_ARCH_SECCOMP
-	select SECCOMP_FILTER if HAVE_ARCH_SECCOMP_FILTER
-	select SIGNALFD
-	select SYSFS
-	select TIMERFD
-	select TMPFS_POSIX_ACL
-	select TMPFS_XATTR
-
-	select ANON_INODES
-	select BLOCK
-	select EVENTFD
-	select FSNOTIFY
-	select INET
-	select NLATTR
-
-	help
-		The init system is the first thing that loads after the kernel booted.
-
-		These config settings allow you to select which init systems to support;
-		instead of having to select all the individual settings all over the
-		place, these settings allows you to select all the settings at once.
-
-		This particular setting enables all the known requirements for systemd;
-		it also enables suggested optional settings, as the package suggests to.
-
-endmenu
-
-menuconfig GENTOO_KERNEL_SELF_PROTECTION
-	bool "Kernel Self Protection Project"
-	depends on GENTOO_LINUX
-	help
-		Recommended Kernel settings based on the suggestions from the Kernel Self Protection Project
-		See: https://kernsec.org/wiki/index.php/Kernel_Self_Protection_Project/Recommended_Settings
-		Note, there may be additional settings for which the CONFIG_ setting is invisible in menuconfig due 
-		to unmet dependencies. Search for GENTOO_KERNEL_SELF_PROTECTION_COMMON and search for 
-		GENTOO_KERNEL_SELF_PROTECTION_{X86_64, ARM64, X86_32, ARM} for dependency information on your 
-		specific architecture.
-		Note 2: Please see the URL above for numeric settings, e.g. CONFIG_DEFAULT_MMAP_MIN_ADDR=65536
-		for X86_64
-
-if GENTOO_KERNEL_SELF_PROTECTION
-config GENTOO_KERNEL_SELF_PROTECTION_COMMON
-	bool "Enable Kernel Self Protection Project Recommendations"
-
-	depends on GENTOO_LINUX && !ACPI_CUSTOM_METHOD && !COMPAT_BRK && !PROC_KCORE && !COMPAT_VDSO && !KEXEC && !HIBERNATION && !LEGACY_PTYS && !X86_X32_ABI && !MODIFY_LDT_SYSCALL && GCC_PLUGINS && !IOMMU_DEFAULT_DMA_LAZY && !IOMMU_DEFAULT_PASSTHROUGH && IOMMU_DEFAULT_DMA_STRICT && SECURITY && !ARCH_EPHEMERAL_INODES  && RANDSTRUCT_PERFORMANCE
-
-	select BUG
-	select STRICT_KERNEL_RWX
-	select DEBUG_WX
-	select STACKPROTECTOR
-	select STACKPROTECTOR_STRONG
-	select STRICT_DEVMEM if DEVMEM=y
-	select IO_STRICT_DEVMEM if DEVMEM=y
-	select SYN_COOKIES
-	select DEBUG_CREDENTIALS
-	select DEBUG_NOTIFIERS
-	select DEBUG_LIST
-	select DEBUG_SG
-	select HARDENED_USERCOPY if HAVE_HARDENED_USERCOPY_ALLOCATOR=y
-	select KFENCE if HAVE_ARCH_KFENCE && (!SLAB || SLUB)
-	select PAGE_TABLE_CHECK if ARCH_SUPPORTS_PAGE_TABLE_CHECK=y && EXCLUSIVE_SYSTEM_RAM=y  
-	select PAGE_TABLE_CHECK_ENFORCED if PAGE_TABLE_CHECK=y
-	select RANDOMIZE_KSTACK_OFFSET_DEFAULT if HAVE_ARCH_RANDOMIZE_KSTACK_OFFSET && (INIT_STACK_NONE || !CC_IS_CLANG || CLANG_VERSION>=140000)
-	select SECURITY_LANDLOCK
-	select SCHED_CORE if SCHED_SMT
-	select BUG_ON_DATA_CORRUPTION
-	select RANDOM_KMALLOC_CACHES if SLUB_TINY=n
-	select SCHED_STACK_END_CHECK
-	select SECCOMP if HAVE_ARCH_SECCOMP
-	select SECCOMP_FILTER if HAVE_ARCH_SECCOMP_FILTER
-	select SECURITY_YAMA
-	select SLAB_FREELIST_RANDOM
-	select SLAB_FREELIST_HARDENED
-	select SHUFFLE_PAGE_ALLOCATOR
-	select SLUB_DEBUG
-	select UBSAN
-	select CC_HAS_UBSAN_BOUNDS_STRICT if !CC_HAS_UBSAN_ARRAY_BOUNDS
-	select UBSAN_BOUNDS
-	select UBSAN_SHIFT
-	select PAGE_POISONING
-	select PAGE_POISONING_NO_SANITY
-	select PAGE_POISONING_ZERO
-	select INIT_ON_ALLOC_DEFAULT_ON
-	select INIT_ON_FREE_DEFAULT_ON
-	select REFCOUNT_FULL
-	select FORTIFY_SOURCE
-	select SECURITY_DMESG_RESTRICT
-	select PANIC_ON_OOPS
-	select GCC_PLUGIN_LATENT_ENTROPY
-	select GCC_PLUGIN_STRUCTLEAK
-	select GCC_PLUGIN_STRUCTLEAK_BYREF_ALL
-	select GCC_PLUGIN_RANDSTRUCT 
-	select GCC_PLUGIN_RANDSTRUCT_PERFORMANCE
-	select ZERO_CALL_USED_REGS if CC_HAS_ZERO_CALL_USED_REGS
-
-	help
-		Search for GENTOO_KERNEL_SELF_PROTECTION_{X86_64, ARM64, X86_32, ARM} for dependency 
-		information on your specific architecture.  Note 2: Please see the URL above for 
-		numeric settings, e.g. CONFIG_DEFAULT_MMAP_MIN_ADDR=65536 for X86_64
-
-config GENTOO_KERNEL_SELF_PROTECTION_X86_64
-	bool "X86_64 KSPP Settings" if GENTOO_KERNEL_SELF_PROTECTION_COMMON
-
-	depends on !X86_MSR && X86_64 && GENTOO_KERNEL_SELF_PROTECTION
-	default n
-	
-	select GCC_PLUGIN_STACKLEAK
-	select X86_KERNEL_IBT if CC_HAS_IBT=y && HAVE_OBJTOOL=y && (!LD_IS_LLD=n || LLD_VERSION>=140000) 
-	select LEGACY_VSYSCALL_NONE
- 	select PAGE_TABLE_ISOLATION
-	select RANDOMIZE_BASE
-	select RANDOMIZE_MEMORY
-	select RELOCATABLE
-	select X86_USER_SHADOW_STACK if AS_WRUSS=y
-	select VMAP_STACK
-
-
-config GENTOO_KERNEL_SELF_PROTECTION_ARM64
-	bool "ARM64 KSPP Settings"
-
-	depends on ARM64
-	default n
-
-	select ARM64_BTI
-	select ARM64_E0PD
-	select ARM64_EPAN if ARM64_PAN=y
-	select ARM64_MTE if (ARM64_AS_HAS_MTE=y && ARM64_TAGGED_ADDR_ABI=y ) && ( AS_HAS_ARMV8_5=y ) && ( AS_HAS_LSE_ATOMICS=y )
-	select ARM64_PTR_AUTH
-	select ARM64_PTR_AUTH_KERNEL if ( ARM64_PTR_AUTH=y ) && (( CC_HAS_SIGN_RETURN_ADDRESS=y || CC_HAS_BRANCH_PROT_PAC_RET=y ) && AS_HAS_ARMV8_3=y ) && ( LD_IS_LLD=y || LD_VERSION >= 23301 || ( CC_IS_GCC=y && GCC_VERSION < 90100 )) && (CC_IS_CLANG=n || AS_HAS_CFI_NEGATE_RA_STATE=y ) && ((FUNCTION_GRAPH_TRACER=n || DYNAMIC_FTRACE_WITH_ARGS=y ))
-	select ARM64_BTI_KERNEL if ( ARM64_BTI=y ) && ( ARM64_PTR_AUTH_KERNEL=y ) && ( CC_HAS_BRANCH_PROT_PAC_RET_BTI=y ) && (CC_IS_GCC=n || GCC_VERSION >= 100100 ) && (CC_IS_GCC=n ) && ((FUNCTION_GRAPH_TRACE=n || DYNAMIC_FTRACE_WITH_ARG=y ))
-	select ARM64_SW_TTBR0_PAN
-	select CONFIG_UNMAP_KERNEL_AT_EL0
-	select GCC_PLUGIN_STACKLEAK
-	select KASAN_HW_TAGS if HAVE_ARCH_KASAN_HW_TAGS=y
-	select RANDOMIZE_BASE
-	select RELOCATABLE
-	select SHADOW_CALL_STACK if ARCH_SUPPORTS_SHADOW_CALL_STACK=y && (DYNAMIC_FTRACE_WITH_ARGS=y || DYNAMIC_FTRACE_WITH_REGS=y || FUNCTION_GRAPH_TRACER=n) && MMU=y 
-	select UNWIND_PATCH_PAC_INTO_SCS if (CC_IS_CLANG=y && CLANG_VERSION >= CONFIG_150000 ) && ( ARM64_PTR_AUTH_KERNEL=y && CC_HAS_BRANCH_PROT_PAC_RET=y ) && ( SHADOW_CALL_STACK=y )
-	select VMAP_STACK
-
-config GENTOO_KERNEL_SELF_PROTECTION_X86_32
-	bool "X86_32 KSPP Settings"
-
-	depends on !X86_MSR && !MODIFY_LDT_SYSCALL && !M486 && X86_32
-	default n
-
-	select HIGHMEM64G
-	select X86_PAE
-	select RANDOMIZE_BASE
-	select RELOCATABLE
-	select PAGE_TABLE_ISOLATION
-
-config GENTOO_KERNEL_SELF_PROTECTION_ARM
-	bool "ARM KSPP Settings"
-
-	depends on !OABI_COMPAT && ARM
-	default n
-
-	select VMSPLIT_3G
-	select STRICT_MEMORY_RWX
-	select CPU_SW_DOMAIN_PAN
-
-endif
-
-config GENTOO_PRINT_FIRMWARE_INFO
-	bool "Print firmware information that the kernel attempts to load"
-
-	depends on GENTOO_LINUX
-	default y
-
-	help
-		Enable this option to print information about firmware that the kernel
-		is attempting to load.  This information can be accessible via the
-		dmesg command-line utility
-
-		See the settings that become available for more details and fine-tuning.
-
-endmenu
diff -Nrup linux-6.16.7/Documentation/ABI/testing/sysfs-devices-system-cpu linux-lenovo-x13s-linux-6.16.y/Documentation/ABI/testing/sysfs-devices-system-cpu
--- linux-6.16.7/Documentation/ABI/testing/sysfs-devices-system-cpu	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/Documentation/ABI/testing/sysfs-devices-system-cpu	2025-09-11 09:47:42.000000000 -0600
@@ -586,7 +586,6 @@ What:		/sys/devices/system/cpu/vulnerabi
 		/sys/devices/system/cpu/vulnerabilities/srbds
 		/sys/devices/system/cpu/vulnerabilities/tsa
 		/sys/devices/system/cpu/vulnerabilities/tsx_async_abort
-		/sys/devices/system/cpu/vulnerabilities/vmscape
 Date:		January 2018
 Contact:	Linux kernel mailing list <linux-kernel@vger.kernel.org>
 Description:	Information about CPU vulnerabilities
diff -Nrup linux-6.16.7/Documentation/admin-guide/hw-vuln/index.rst linux-lenovo-x13s-linux-6.16.y/Documentation/admin-guide/hw-vuln/index.rst
--- linux-6.16.7/Documentation/admin-guide/hw-vuln/index.rst	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/Documentation/admin-guide/hw-vuln/index.rst	2025-09-11 09:47:42.000000000 -0600
@@ -25,4 +25,3 @@ are configurable at compile, boot or run
    rsb
    old_microcode
    indirect-target-selection
-   vmscape
diff -Nrup linux-6.16.7/Documentation/admin-guide/hw-vuln/vmscape.rst linux-lenovo-x13s-linux-6.16.y/Documentation/admin-guide/hw-vuln/vmscape.rst
--- linux-6.16.7/Documentation/admin-guide/hw-vuln/vmscape.rst	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/Documentation/admin-guide/hw-vuln/vmscape.rst	1969-12-31 17:00:00.000000000 -0700
@@ -1,110 +0,0 @@
-.. SPDX-License-Identifier: GPL-2.0
-
-VMSCAPE
-=======
-
-VMSCAPE is a vulnerability that may allow a guest to influence the branch
-prediction in host userspace. It particularly affects hypervisors like QEMU.
-
-Even if a hypervisor may not have any sensitive data like disk encryption keys,
-guest-userspace may be able to attack the guest-kernel using the hypervisor as
-a confused deputy.
-
-Affected processors
--------------------
-
-The following CPU families are affected by VMSCAPE:
-
-**Intel processors:**
-  - Skylake generation (Parts without Enhanced-IBRS)
-  - Cascade Lake generation - (Parts affected by ITS guest/host separation)
-  - Alder Lake and newer (Parts affected by BHI)
-
-Note that, BHI affected parts that use BHB clearing software mitigation e.g.
-Icelake are not vulnerable to VMSCAPE.
-
-**AMD processors:**
-  - Zen series (families 0x17, 0x19, 0x1a)
-
-** Hygon processors:**
- - Family 0x18
-
-Mitigation
-----------
-
-Conditional IBPB
-----------------
-
-Kernel tracks when a CPU has run a potentially malicious guest and issues an
-IBPB before the first exit to userspace after VM-exit. If userspace did not run
-between VM-exit and the next VM-entry, no IBPB is issued.
-
-Note that the existing userspace mitigation against Spectre-v2 is effective in
-protecting the userspace. They are insufficient to protect the userspace VMMs
-from a malicious guest. This is because Spectre-v2 mitigations are applied at
-context switch time, while the userspace VMM can run after a VM-exit without a
-context switch.
-
-Vulnerability enumeration and mitigation is not applied inside a guest. This is
-because nested hypervisors should already be deploying IBPB to isolate
-themselves from nested guests.
-
-SMT considerations
-------------------
-
-When Simultaneous Multi-Threading (SMT) is enabled, hypervisors can be
-vulnerable to cross-thread attacks. For complete protection against VMSCAPE
-attacks in SMT environments, STIBP should be enabled.
-
-The kernel will issue a warning if SMT is enabled without adequate STIBP
-protection. Warning is not issued when:
-
-- SMT is disabled
-- STIBP is enabled system-wide
-- Intel eIBRS is enabled (which implies STIBP protection)
-
-System information and options
-------------------------------
-
-The sysfs file showing VMSCAPE mitigation status is:
-
-  /sys/devices/system/cpu/vulnerabilities/vmscape
-
-The possible values in this file are:
-
- * 'Not affected':
-
-   The processor is not vulnerable to VMSCAPE attacks.
-
- * 'Vulnerable':
-
-   The processor is vulnerable and no mitigation has been applied.
-
- * 'Mitigation: IBPB before exit to userspace':
-
-   Conditional IBPB mitigation is enabled. The kernel tracks when a CPU has
-   run a potentially malicious guest and issues an IBPB before the first
-   exit to userspace after VM-exit.
-
- * 'Mitigation: IBPB on VMEXIT':
-
-   IBPB is issued on every VM-exit. This occurs when other mitigations like
-   RETBLEED or SRSO are already issuing IBPB on VM-exit.
-
-Mitigation control on the kernel command line
-----------------------------------------------
-
-The mitigation can be controlled via the ``vmscape=`` command line parameter:
-
- * ``vmscape=off``:
-
-   Disable the VMSCAPE mitigation.
-
- * ``vmscape=ibpb``:
-
-   Enable conditional IBPB mitigation (default when CONFIG_MITIGATION_VMSCAPE=y).
-
- * ``vmscape=force``:
-
-   Force vulnerability detection and mitigation even on processors that are
-   not known to be affected.
diff -Nrup linux-6.16.7/Documentation/admin-guide/kernel-parameters.txt linux-lenovo-x13s-linux-6.16.y/Documentation/admin-guide/kernel-parameters.txt
--- linux-6.16.7/Documentation/admin-guide/kernel-parameters.txt	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/Documentation/admin-guide/kernel-parameters.txt	2025-09-11 09:47:42.000000000 -0600
@@ -3774,7 +3774,6 @@
 					       srbds=off [X86,INTEL]
 					       ssbd=force-off [ARM64]
 					       tsx_async_abort=off [X86]
-					       vmscape=off [X86]
 
 				Exceptions:
 					       This does not have any effect on
@@ -7938,16 +7937,6 @@
 	vmpoff=		[KNL,S390] Perform z/VM CP command after power off.
 			Format: <command>
 
-	vmscape=	[X86] Controls mitigation for VMscape attacks.
-			VMscape attacks can leak information from a userspace
-			hypervisor to a guest via speculative side-channels.
-
-			off		- disable the mitigation
-			ibpb		- use Indirect Branch Prediction Barrier
-					  (IBPB) mitigation (default)
-			force		- force vulnerability detection even on
-					  unaffected processors
-
 	vsyscall=	[X86-64,EARLY]
 			Controls the behavior of vsyscalls (i.e. calls to
 			fixed addresses of 0xffffffffff600x00 from legacy
diff -Nrup linux-6.16.7/Documentation/Changes linux-lenovo-x13s-linux-6.16.y/Documentation/Changes
--- linux-6.16.7/Documentation/Changes	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/Documentation/Changes	2025-09-11 09:47:42.000000000 -0600
@@ -1,575 +1 @@
-.. _changes:
-
-Minimal requirements to compile the Kernel
-++++++++++++++++++++++++++++++++++++++++++
-
-Intro
-=====
-
-This document is designed to provide a list of the minimum levels of
-software necessary to run the current kernel version.
-
-This document is originally based on my "Changes" file for 2.0.x kernels
-and therefore owes credit to the same people as that file (Jared Mauch,
-Axel Boldt, Alessandro Sigala, and countless other users all over the
-'net).
-
-Current Minimal Requirements
-****************************
-
-Upgrade to at **least** these software revisions before thinking you've
-encountered a bug!  If you're unsure what version you're currently
-running, the suggested command should tell you.
-
-Again, keep in mind that this list assumes you are already functionally
-running a Linux kernel.  Also, not all tools are necessary on all
-systems; obviously, if you don't have any PC Card hardware, for example,
-you probably needn't concern yourself with pcmciautils.
-
-====================== ===============  ========================================
-        Program        Minimal version       Command to check the version
-====================== ===============  ========================================
-GNU C                  8.1              gcc --version
-Clang/LLVM (optional)  13.0.1           clang --version
-Rust (optional)        1.78.0           rustc --version
-bindgen (optional)     0.65.1           bindgen --version
-GNU make               4.0              make --version
-bash                   4.2              bash --version
-binutils               2.30             ld -v
-flex                   2.5.35           flex --version
-bison                  2.0              bison --version
-pahole                 1.16             pahole --version
-util-linux             2.10o            mount --version
-kmod                   13               depmod -V
-e2fsprogs              1.41.4           e2fsck -V
-jfsutils               1.1.3            fsck.jfs -V
-reiserfsprogs          3.6.3            reiserfsck -V
-xfsprogs               2.6.0            xfs_db -V
-squashfs-tools         4.0              mksquashfs -version
-btrfs-progs            0.18             btrfs --version
-pcmciautils            004              pccardctl -V
-quota-tools            3.09             quota -V
-PPP                    2.4.0            pppd --version
-nfs-utils              1.0.5            showmount --version
-procps                 3.2.0            ps --version
-udev                   081              udevd --version
-grub                   0.93             grub --version || grub-install --version
-mcelog                 0.6              mcelog --version
-iptables               1.4.2            iptables -V
-openssl & libcrypto    1.0.0            openssl version
-bc                     1.06.95          bc --version
-Sphinx\ [#f1]_         3.4.3            sphinx-build --version
-GNU tar                1.28             tar --version
-gtags (optional)       6.6.5            gtags --version
-mkimage (optional)     2017.01          mkimage --version
-Python (optional)      3.9.x            python3 --version
-GNU AWK (optional)     5.1.0            gawk --version
-====================== ===============  ========================================
-
-.. [#f1] Sphinx is needed only to build the Kernel documentation
-
-Kernel compilation
-******************
-
-GCC
----
-
-The gcc version requirements may vary depending on the type of CPU in your
-computer.
-
-Clang/LLVM (optional)
----------------------
-
-The latest formal release of clang and LLVM utils (according to
-`releases.llvm.org <https://releases.llvm.org>`_) are supported for building
-kernels. Older releases aren't guaranteed to work, and we may drop workarounds
-from the kernel that were used to support older versions. Please see additional
-docs on :ref:`Building Linux with Clang/LLVM <kbuild_llvm>`.
-
-Rust (optional)
----------------
-
-A recent version of the Rust compiler is required.
-
-Please see Documentation/rust/quick-start.rst for instructions on how to
-satisfy the build requirements of Rust support. In particular, the ``Makefile``
-target ``rustavailable`` is useful to check why the Rust toolchain may not
-be detected.
-
-bindgen (optional)
-------------------
-
-``bindgen`` is used to generate the Rust bindings to the C side of the kernel.
-It depends on ``libclang``.
-
-Make
-----
-
-You will need GNU make 4.0 or later to build the kernel.
-
-Bash
-----
-
-Some bash scripts are used for the kernel build.
-Bash 4.2 or newer is needed.
-
-Binutils
---------
-
-Binutils 2.30 or newer is needed to build the kernel.
-
-pkg-config
-----------
-
-The build system, as of 4.18, requires pkg-config to check for installed
-kconfig tools and to determine flags settings for use in
-'make {g,x}config'.  Previously pkg-config was being used but not
-verified or documented.
-
-Flex
-----
-
-Since Linux 4.16, the build system generates lexical analyzers
-during build.  This requires flex 2.5.35 or later.
-
-
-Bison
------
-
-Since Linux 4.16, the build system generates parsers
-during build.  This requires bison 2.0 or later.
-
-pahole
-------
-
-Since Linux 5.2, if CONFIG_DEBUG_INFO_BTF is selected, the build system
-generates BTF (BPF Type Format) from DWARF in vmlinux, a bit later from kernel
-modules as well.  This requires pahole v1.16 or later.
-
-It is found in the 'dwarves' or 'pahole' distro packages or from
-https://fedorapeople.org/~acme/dwarves/.
-
-Perl
-----
-
-You will need perl 5 and the following modules: ``Getopt::Long``,
-``Getopt::Std``, ``File::Basename``, and ``File::Find`` to build the kernel.
-
-BC
---
-
-You will need bc to build kernels 3.10 and higher
-
-
-OpenSSL
--------
-
-Module signing and external certificate handling use the OpenSSL program and
-crypto library to do key creation and signature generation.
-
-You will need openssl to build kernels 3.7 and higher if module signing is
-enabled.  You will also need openssl development packages to build kernels 4.3
-and higher.
-
-Tar
----
-
-GNU tar is needed if you want to enable access to the kernel headers via sysfs
-(CONFIG_IKHEADERS).
-
-gtags / GNU GLOBAL (optional)
------------------------------
-
-The kernel build requires GNU GLOBAL version 6.6.5 or later to generate
-tag files through ``make gtags``.  This is due to its use of the gtags
-``-C (--directory)`` flag.
-
-mkimage
--------
-
-This tool is used when building a Flat Image Tree (FIT), commonly used on ARM
-platforms. The tool is available via the ``u-boot-tools`` package or can be
-built from the U-Boot source code. See the instructions at
-https://docs.u-boot.org/en/latest/build/tools.html#building-tools-for-linux
-
-GNU AWK
--------
-
-GNU AWK is needed if you want kernel builds to generate address range data for
-builtin modules (CONFIG_BUILTIN_MODULE_RANGES).
-
-System utilities
-****************
-
-Architectural changes
----------------------
-
-DevFS has been obsoleted in favour of udev
-(https://www.kernel.org/pub/linux/utils/kernel/hotplug/)
-
-32-bit UID support is now in place.  Have fun!
-
-Linux documentation for functions is transitioning to inline
-documentation via specially-formatted comments near their
-definitions in the source.  These comments can be combined with ReST
-files the Documentation/ directory to make enriched documentation, which can
-then be converted to PostScript, HTML, LaTex, ePUB and PDF files.
-In order to convert from ReST format to a format of your choice, you'll need
-Sphinx.
-
-Util-linux
-----------
-
-New versions of util-linux provide ``fdisk`` support for larger disks,
-support new options to mount, recognize more supported partition
-types, and similar goodies.
-You'll probably want to upgrade.
-
-Ksymoops
---------
-
-If the unthinkable happens and your kernel oopses, you may need the
-ksymoops tool to decode it, but in most cases you don't.
-It is generally preferred to build the kernel with ``CONFIG_KALLSYMS`` so
-that it produces readable dumps that can be used as-is (this also
-produces better output than ksymoops).  If for some reason your kernel
-is not build with ``CONFIG_KALLSYMS`` and you have no way to rebuild and
-reproduce the Oops with that option, then you can still decode that Oops
-with ksymoops.
-
-Mkinitrd
---------
-
-These changes to the ``/lib/modules`` file tree layout also require that
-mkinitrd be upgraded.
-
-E2fsprogs
----------
-
-The latest version of ``e2fsprogs`` fixes several bugs in fsck and
-debugfs.  Obviously, it's a good idea to upgrade.
-
-JFSutils
---------
-
-The ``jfsutils`` package contains the utilities for the file system.
-The following utilities are available:
-
-- ``fsck.jfs`` - initiate replay of the transaction log, and check
-  and repair a JFS formatted partition.
-
-- ``mkfs.jfs`` - create a JFS formatted partition.
-
-- other file system utilities are also available in this package.
-
-Reiserfsprogs
--------------
-
-The reiserfsprogs package should be used for reiserfs-3.6.x
-(Linux kernels 2.4.x). It is a combined package and contains working
-versions of ``mkreiserfs``, ``resize_reiserfs``, ``debugreiserfs`` and
-``reiserfsck``. These utils work on both i386 and alpha platforms.
-
-Xfsprogs
---------
-
-The latest version of ``xfsprogs`` contains ``mkfs.xfs``, ``xfs_db``, and the
-``xfs_repair`` utilities, among others, for the XFS filesystem.  It is
-architecture independent and any version from 2.0.0 onward should
-work correctly with this version of the XFS kernel code (2.6.0 or
-later is recommended, due to some significant improvements).
-
-PCMCIAutils
------------
-
-PCMCIAutils replaces ``pcmcia-cs``. It properly sets up
-PCMCIA sockets at system startup and loads the appropriate modules
-for 16-bit PCMCIA devices if the kernel is modularized and the hotplug
-subsystem is used.
-
-Quota-tools
------------
-
-Support for 32 bit uid's and gid's is required if you want to use
-the newer version 2 quota format.  Quota-tools version 3.07 and
-newer has this support.  Use the recommended version or newer
-from the table above.
-
-Intel IA32 microcode
---------------------
-
-A driver has been added to allow updating of Intel IA32 microcode,
-accessible as a normal (misc) character device.  If you are not using
-udev you may need to::
-
-  mkdir /dev/cpu
-  mknod /dev/cpu/microcode c 10 184
-  chmod 0644 /dev/cpu/microcode
-
-as root before you can use this.  You'll probably also want to
-get the user-space microcode_ctl utility to use with this.
-
-udev
-----
-
-``udev`` is a userspace application for populating ``/dev`` dynamically with
-only entries for devices actually present. ``udev`` replaces the basic
-functionality of devfs, while allowing persistent device naming for
-devices.
-
-FUSE
-----
-
-Needs libfuse 2.4.0 or later.  Absolute minimum is 2.3.0 but mount
-options ``direct_io`` and ``kernel_cache`` won't work.
-
-Networking
-**********
-
-General changes
----------------
-
-If you have advanced network configuration needs, you should probably
-consider using the network tools from ip-route2.
-
-Packet Filter / NAT
--------------------
-The packet filtering and NAT code uses the same tools like the previous 2.4.x
-kernel series (iptables).  It still includes backwards-compatibility modules
-for 2.2.x-style ipchains and 2.0.x-style ipfwadm.
-
-PPP
----
-
-The PPP driver has been restructured to support multilink and to
-enable it to operate over diverse media layers.  If you use PPP,
-upgrade pppd to at least 2.4.0.
-
-If you are not using udev, you must have the device file /dev/ppp
-which can be made by::
-
-  mknod /dev/ppp c 108 0
-
-as root.
-
-NFS-utils
----------
-
-In ancient (2.4 and earlier) kernels, the nfs server needed to know
-about any client that expected to be able to access files via NFS.  This
-information would be given to the kernel by ``mountd`` when the client
-mounted the filesystem, or by ``exportfs`` at system startup.  exportfs
-would take information about active clients from ``/var/lib/nfs/rmtab``.
-
-This approach is quite fragile as it depends on rmtab being correct
-which is not always easy, particularly when trying to implement
-fail-over.  Even when the system is working well, ``rmtab`` suffers from
-getting lots of old entries that never get removed.
-
-With modern kernels we have the option of having the kernel tell mountd
-when it gets a request from an unknown host, and mountd can give
-appropriate export information to the kernel.  This removes the
-dependency on ``rmtab`` and means that the kernel only needs to know about
-currently active clients.
-
-To enable this new functionality, you need to::
-
-  mount -t nfsd nfsd /proc/fs/nfsd
-
-before running exportfs or mountd.  It is recommended that all NFS
-services be protected from the internet-at-large by a firewall where
-that is possible.
-
-mcelog
-------
-
-On x86 kernels the mcelog utility is needed to process and log machine check
-events when ``CONFIG_X86_MCE`` is enabled. Machine check events are errors
-reported by the CPU. Processing them is strongly encouraged.
-
-Kernel documentation
-********************
-
-Sphinx
-------
-
-Please see :ref:`sphinx_install` in :ref:`Documentation/doc-guide/sphinx.rst <sphinxdoc>`
-for details about Sphinx requirements.
-
-rustdoc
--------
-
-``rustdoc`` is used to generate the documentation for Rust code. Please see
-Documentation/rust/general-information.rst for more information.
-
-Getting updated software
-========================
-
-Kernel compilation
-******************
-
-gcc
----
-
-- <ftp://ftp.gnu.org/gnu/gcc/>
-
-Clang/LLVM
-----------
-
-- :ref:`Getting LLVM <getting_llvm>`.
-
-Rust
-----
-
-- Documentation/rust/quick-start.rst.
-
-bindgen
--------
-
-- Documentation/rust/quick-start.rst.
-
-Make
-----
-
-- <ftp://ftp.gnu.org/gnu/make/>
-
-Bash
-----
-
-- <ftp://ftp.gnu.org/gnu/bash/>
-
-Binutils
---------
-
-- <https://www.kernel.org/pub/linux/devel/binutils/>
-
-Flex
-----
-
-- <https://github.com/westes/flex/releases>
-
-Bison
------
-
-- <ftp://ftp.gnu.org/gnu/bison/>
-
-OpenSSL
--------
-
-- <https://www.openssl.org/>
-
-System utilities
-****************
-
-Util-linux
-----------
-
-- <https://www.kernel.org/pub/linux/utils/util-linux/>
-
-Kmod
-----
-
-- <https://www.kernel.org/pub/linux/utils/kernel/kmod/>
-- <https://git.kernel.org/pub/scm/utils/kernel/kmod/kmod.git>
-
-Ksymoops
---------
-
-- <https://www.kernel.org/pub/linux/utils/kernel/ksymoops/v2.4/>
-
-Mkinitrd
---------
-
-- <https://code.launchpad.net/initrd-tools/main>
-
-E2fsprogs
----------
-
-- <https://www.kernel.org/pub/linux/kernel/people/tytso/e2fsprogs/>
-- <https://git.kernel.org/pub/scm/fs/ext2/e2fsprogs.git/>
-
-JFSutils
---------
-
-- <https://jfs.sourceforge.net/>
-
-Reiserfsprogs
--------------
-
-- <https://git.kernel.org/pub/scm/linux/kernel/git/jeffm/reiserfsprogs.git/>
-
-Xfsprogs
---------
-
-- <https://git.kernel.org/pub/scm/fs/xfs/xfsprogs-dev.git>
-- <https://www.kernel.org/pub/linux/utils/fs/xfs/xfsprogs/>
-
-Pcmciautils
------------
-
-- <https://www.kernel.org/pub/linux/utils/kernel/pcmcia/>
-
-Quota-tools
------------
-
-- <https://sourceforge.net/projects/linuxquota/>
-
-
-Intel P6 microcode
-------------------
-
-- <https://downloadcenter.intel.com/>
-
-udev
-----
-
-- <https://www.freedesktop.org/software/systemd/man/udev.html>
-
-FUSE
-----
-
-- <https://github.com/libfuse/libfuse/releases>
-
-mcelog
-------
-
-- <https://www.mcelog.org/>
-
-Networking
-**********
-
-PPP
----
-
-- <https://download.samba.org/pub/ppp/>
-- <https://git.ozlabs.org/?p=ppp.git>
-- <https://github.com/paulusmack/ppp/>
-
-NFS-utils
----------
-
-- <https://sourceforge.net/project/showfiles.php?group_id=14>
-- <https://nfs.sourceforge.net/>
-
-Iptables
---------
-
-- <https://netfilter.org/projects/iptables/index.html>
-
-Ip-route2
----------
-
-- <https://www.kernel.org/pub/linux/utils/net/iproute2/>
-
-OProfile
---------
-
-- <https://oprofile.sf.net/download/>
-
-Kernel documentation
-********************
-
-Sphinx
-------
-
-- <https://www.sphinx-doc.org/>
+process/changes.rst
\ No newline at end of file
diff -Nrup linux-6.16.7/Documentation/devicetree/bindings/arm/psci.yaml linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/arm/psci.yaml
--- linux-6.16.7/Documentation/devicetree/bindings/arm/psci.yaml	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/arm/psci.yaml	2025-09-11 09:47:42.000000000 -0600
@@ -98,6 +98,12 @@ properties:
       [1] Kernel documentation - ARM idle states bindings
         Documentation/devicetree/bindings/cpu/idle-states.yaml
 
+  arm,psci-s2ram-param:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      power_state parameter denoting the S2RAM/S3-like system suspend state
+    maxItems: 1
+
 patternProperties:
   "^power-domain-":
     $ref: /schemas/power/power-domain.yaml#
diff -Nrup linux-6.16.7/Documentation/devicetree/bindings/i2c/qcom,i2c-cci.yaml linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/i2c/qcom,i2c-cci.yaml
--- linux-6.16.7/Documentation/devicetree/bindings/i2c/qcom,i2c-cci.yaml	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/i2c/qcom,i2c-cci.yaml	2025-09-11 09:47:42.000000000 -0600
@@ -54,6 +54,8 @@ properties:
   interrupts:
     maxItems: 1
 
+  operating-points-v2: true
+
   power-domains:
     maxItems: 1
 
diff -Nrup linux-6.16.7/Documentation/devicetree/bindings/leds/backlight/led-backlight.yaml linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/leds/backlight/led-backlight.yaml
--- linux-6.16.7/Documentation/devicetree/bindings/leds/backlight/led-backlight.yaml	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/leds/backlight/led-backlight.yaml	2025-09-11 09:47:42.000000000 -0600
@@ -23,11 +23,7 @@ properties:
   compatible:
     const: led-backlight
 
-  leds:
-    description: A list of LED nodes
-    $ref: /schemas/types.yaml#/definitions/phandle-array
-    items:
-      maxItems: 1
+  leds: true
 
 required:
   - compatible
diff -Nrup linux-6.16.7/Documentation/devicetree/bindings/leds/leds-consumer.yaml linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/leds/leds-consumer.yaml
--- linux-6.16.7/Documentation/devicetree/bindings/leds/leds-consumer.yaml	1969-12-31 17:00:00.000000000 -0700
+++ linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/leds/leds-consumer.yaml	2025-09-11 09:47:42.000000000 -0600
@@ -0,0 +1,67 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/leds/leds-consumer.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Common leds consumer
+
+maintainers:
+  - Aleksandrs Vinarskis <alex@vinarskis.com>
+
+description:
+  Some LED defined in DT are required by other DT consumers, for example
+  v4l2 subnode may require privacy or flash LED. Unlike trigger-source
+  approach which is typically used as 'soft' binding, referencing LED
+  devices by phandle makes things simpler when 'hard' binding is desired.
+
+  Document LED properties that its consumers may define.
+
+select: true
+
+properties:
+  leds:
+    oneOf:
+      - type: object
+      - $ref: /schemas/types.yaml#/definitions/phandle-array
+        description:
+          A list of LED device(s) required by a particular consumer.
+        items:
+          maxItems: 1
+
+  led-names:
+    description:
+      A list of device name(s). Used to map LED devices to their respective
+      functions, when consumer requires more than one LED.
+
+additionalProperties: true
+
+examples:
+  - |
+    #include <dt-bindings/gpio/gpio.h>
+    #include <dt-bindings/leds/common.h>
+
+    leds {
+        compatible = "gpio-leds";
+
+        privacy_led: privacy-led {
+            color = <LED_COLOR_ID_RED>;
+            default-state = "off";
+            function = LED_FUNCTION_INDICATOR;
+            gpios = <&tlmm 110 GPIO_ACTIVE_HIGH>;
+        };
+    };
+
+    i2c {
+      #address-cells = <1>;
+      #size-cells = <0>;
+
+      v4l2_node: camera@36 {
+        reg = <0x36>;
+
+        leds = <&privacy_led>;
+        led-names = "privacy";
+      };
+    };
+
+...
diff -Nrup linux-6.16.7/Documentation/devicetree/bindings/leds/leds-group-multicolor.yaml linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/leds/leds-group-multicolor.yaml
--- linux-6.16.7/Documentation/devicetree/bindings/leds/leds-group-multicolor.yaml	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/leds/leds-group-multicolor.yaml	2025-09-11 09:47:42.000000000 -0600
@@ -17,10 +17,7 @@ properties:
   compatible:
     const: leds-group-multicolor
 
-  leds:
-    description:
-      An aray of monochromatic leds
-    $ref: /schemas/types.yaml#/definitions/phandle-array
+  leds: true
 
 required:
   - leds
diff -Nrup linux-6.16.7/Documentation/devicetree/bindings/media/qcom,sm8350-venus.yaml linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/media/qcom,sm8350-venus.yaml
--- linux-6.16.7/Documentation/devicetree/bindings/media/qcom,sm8350-venus.yaml	1969-12-31 17:00:00.000000000 -0700
+++ linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/media/qcom,sm8350-venus.yaml	2025-09-11 09:47:42.000000000 -0600
@@ -0,0 +1,149 @@
+# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/media/qcom,sm8350-venus.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Qualcomm SM8350 Venus video encode and decode accelerators
+
+maintainers:
+  - Konrad Dybcio <konradybcio@kernel.org>
+
+description: |
+  The Venus Iris2 IP is a video encode and decode accelerator present
+  on Qualcomm platforms
+
+allOf:
+  - $ref: qcom,venus-common.yaml#
+
+properties:
+  compatible:
+    enum:
+      - qcom,sc8280xp-venus
+      - qcom,sm8350-venus
+
+  clocks:
+    maxItems: 3
+
+  clock-names:
+    items:
+      - const: iface
+      - const: core
+      - const: vcodec0_core
+
+  resets:
+    maxItems: 1
+
+  reset-names:
+    items:
+      - const: core
+
+  power-domains:
+    maxItems: 3
+
+  power-domain-names:
+    items:
+      - const: venus
+      - const: vcodec0
+      - const: mx
+
+  interconnects:
+    maxItems: 3
+
+  interconnect-names:
+    items:
+      - const: cpu-cfg
+      - const: video-mem
+      - const: video-llcc
+
+  operating-points-v2: true
+  opp-table:
+    type: object
+
+  iommus:
+    maxItems: 1
+
+  video-decoder:
+    type: object
+
+    properties:
+      compatible:
+        const: venus-decoder
+
+    required:
+      - compatible
+
+    additionalProperties: false
+
+  video-encoder:
+    type: object
+
+    properties:
+      compatible:
+        const: venus-encoder
+
+    required:
+      - compatible
+
+    additionalProperties: false
+
+required:
+  - compatible
+  - power-domain-names
+  - iommus
+  - video-decoder
+  - video-encoder
+
+unevaluatedProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/interrupt-controller/arm-gic.h>
+    #include <dt-bindings/clock/qcom,gcc-sm8350.h>
+    #include <dt-bindings/clock/qcom,sm8350-videocc.h>
+    #include <dt-bindings/interconnect/qcom,sm8350.h>
+    #include <dt-bindings/power/qcom-rpmpd.h>
+
+    venus: video-codec@aa00000 {
+        compatible = "qcom,sm8350-venus";
+        reg = <0x0aa00000 0x100000>;
+        interrupts = <GIC_SPI 174 IRQ_TYPE_LEVEL_HIGH>;
+
+        clocks = <&gcc GCC_VIDEO_AXI0_CLK>,
+                 <&videocc VIDEO_CC_MVS0C_CLK>,
+                 <&videocc VIDEO_CC_MVS0_CLK>;
+        clock-names = "iface",
+                      "core",
+                      "vcodec0_core";
+
+        resets = <&gcc GCC_VIDEO_AXI0_CLK_ARES>;
+        reset-names = "core";
+
+        power-domains = <&videocc MVS0C_GDSC>,
+                        <&videocc MVS0_GDSC>,
+                        <&rpmhpd SM8350_MX>;
+        power-domain-names = "venus",
+                             "vcodec0",
+                             "mx";
+
+        interconnects = <&gem_noc MASTER_APPSS_PROC 0 &config_noc SLAVE_VENUS_CFG 0>,
+                        <&mmss_noc MASTER_VIDEO_P0 0 &mc_virt SLAVE_EBI1 0>,
+                        <&mmss_noc MASTER_VIDEO_P0 0 &gem_noc SLAVE_LLCC 0>;
+        interconnect-names = "cpu-cfg",
+                             "video-mem",
+                             "video-llcc";
+
+        operating-points-v2 = <&venus_opp_table>;
+        iommus = <&apps_smmu 0x2100 0x400>;
+        memory-region = <&pil_video_mem>;
+
+        status = "disabled";
+
+        video-decoder {
+            compatible = "venus-decoder";
+        };
+
+        video-encoder {
+            compatible = "venus-encoder";
+        };
+    };
diff -Nrup linux-6.16.7/Documentation/devicetree/bindings/media/video-interface-devices.yaml linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/media/video-interface-devices.yaml
--- linux-6.16.7/Documentation/devicetree/bindings/media/video-interface-devices.yaml	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/media/video-interface-devices.yaml	2025-09-11 09:47:42.000000000 -0600
@@ -17,6 +17,14 @@ properties:
       An array of phandles, each referring to a flash LED, a sub-node of the LED
       driver device node.
 
+  leds:
+    minItems: 1
+    maxItems: 1
+
+  led-names:
+    enum:
+      - privacy
+
   lens-focus:
     $ref: /schemas/types.yaml#/definitions/phandle
     description:
diff -Nrup linux-6.16.7/Documentation/devicetree/bindings/phy/qcom,sc8280xp-qmp-usb43dp-phy.yaml linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/phy/qcom,sc8280xp-qmp-usb43dp-phy.yaml
--- linux-6.16.7/Documentation/devicetree/bindings/phy/qcom,sc8280xp-qmp-usb43dp-phy.yaml	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/phy/qcom,sc8280xp-qmp-usb43dp-phy.yaml	2025-09-11 09:47:42.000000000 -0600
@@ -72,10 +72,8 @@ properties:
     description:
       See include/dt-bindings/phy/phy-qcom-qmp.h
 
-  orientation-switch:
-    description:
-      Flag the PHY as possible handler of USB Type-C orientation switching
-    type: boolean
+  mode-switch: true
+  orientation-switch: true
 
   ports:
     $ref: /schemas/graph.yaml#/properties/ports
@@ -105,6 +103,7 @@ required:
   - "#phy-cells"
 
 allOf:
+  - $ref: /schemas/usb/usb-switch.yaml#
   - if:
       properties:
         compatible:
diff -Nrup linux-6.16.7/drivers/base/cpu.c linux-lenovo-x13s-linux-6.16.y/drivers/base/cpu.c
--- linux-6.16.7/drivers/base/cpu.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/base/cpu.c	2025-09-11 09:47:42.000000000 -0600
@@ -603,7 +603,6 @@ CPU_SHOW_VULN_FALLBACK(ghostwrite);
 CPU_SHOW_VULN_FALLBACK(old_microcode);
 CPU_SHOW_VULN_FALLBACK(indirect_target_selection);
 CPU_SHOW_VULN_FALLBACK(tsa);
-CPU_SHOW_VULN_FALLBACK(vmscape);
 
 static DEVICE_ATTR(meltdown, 0444, cpu_show_meltdown, NULL);
 static DEVICE_ATTR(spectre_v1, 0444, cpu_show_spectre_v1, NULL);
@@ -623,7 +622,6 @@ static DEVICE_ATTR(ghostwrite, 0444, cpu
 static DEVICE_ATTR(old_microcode, 0444, cpu_show_old_microcode, NULL);
 static DEVICE_ATTR(indirect_target_selection, 0444, cpu_show_indirect_target_selection, NULL);
 static DEVICE_ATTR(tsa, 0444, cpu_show_tsa, NULL);
-static DEVICE_ATTR(vmscape, 0444, cpu_show_vmscape, NULL);
 
 static struct attribute *cpu_root_vulnerabilities_attrs[] = {
 	&dev_attr_meltdown.attr,
@@ -644,7 +642,6 @@ static struct attribute *cpu_root_vulner
 	&dev_attr_old_microcode.attr,
 	&dev_attr_indirect_target_selection.attr,
 	&dev_attr_tsa.attr,
-	&dev_attr_vmscape.attr,
 	NULL
 };
 
diff -Nrup linux-6.16.7/drivers/base/firmware_loader/main.c linux-lenovo-x13s-linux-6.16.y/drivers/base/firmware_loader/main.c
--- linux-6.16.7/drivers/base/firmware_loader/main.c	2025-09-13 16:15:46.054046978 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/base/firmware_loader/main.c	2025-09-11 09:47:42.000000000 -0600
@@ -872,11 +872,6 @@ _request_firmware(const struct firmware
 
 	ret = _request_firmware_prepare(&fw, name, device, buf, size,
 					offset, opt_flags);
-
-#ifdef CONFIG_GENTOO_PRINT_FIRMWARE_INFO
-        printk(KERN_NOTICE "Loading firmware: %s\n", name);
-#endif
-
 	if (ret <= 0) /* error or already assigned */
 		goto out;
 
diff -Nrup linux-6.16.7/drivers/base/firmware_loader/main.c.orig linux-lenovo-x13s-linux-6.16.y/drivers/base/firmware_loader/main.c.orig
--- linux-6.16.7/drivers/base/firmware_loader/main.c.orig	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/base/firmware_loader/main.c.orig	1969-12-31 17:00:00.000000000 -0700
@@ -1,1698 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * main.c - Multi purpose firmware loading support
- *
- * Copyright (c) 2003 Manuel Estrada Sainz
- *
- * Please see Documentation/driver-api/firmware/ for more information.
- *
- */
-
-#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
-
-#include <linux/capability.h>
-#include <linux/device.h>
-#include <linux/kernel_read_file.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/initrd.h>
-#include <linux/timer.h>
-#include <linux/vmalloc.h>
-#include <linux/interrupt.h>
-#include <linux/bitops.h>
-#include <linux/mutex.h>
-#include <linux/workqueue.h>
-#include <linux/highmem.h>
-#include <linux/firmware.h>
-#include <linux/slab.h>
-#include <linux/sched.h>
-#include <linux/file.h>
-#include <linux/list.h>
-#include <linux/fs.h>
-#include <linux/async.h>
-#include <linux/pm.h>
-#include <linux/suspend.h>
-#include <linux/syscore_ops.h>
-#include <linux/reboot.h>
-#include <linux/security.h>
-#include <linux/zstd.h>
-#include <linux/xz.h>
-
-#include <generated/utsrelease.h>
-
-#include "../base.h"
-#include "firmware.h"
-#include "fallback.h"
-
-MODULE_AUTHOR("Manuel Estrada Sainz");
-MODULE_DESCRIPTION("Multi purpose firmware loading support");
-MODULE_LICENSE("GPL");
-
-struct firmware_cache {
-	/* firmware_buf instance will be added into the below list */
-	spinlock_t lock;
-	struct list_head head;
-	int state;
-
-#ifdef CONFIG_FW_CACHE
-	/*
-	 * Names of firmware images which have been cached successfully
-	 * will be added into the below list so that device uncache
-	 * helper can trace which firmware images have been cached
-	 * before.
-	 */
-	spinlock_t name_lock;
-	struct list_head fw_names;
-
-	struct delayed_work work;
-
-	struct notifier_block   pm_notify;
-#endif
-};
-
-struct fw_cache_entry {
-	struct list_head list;
-	const char *name;
-};
-
-struct fw_name_devm {
-	unsigned long magic;
-	const char *name;
-};
-
-static inline struct fw_priv *to_fw_priv(struct kref *ref)
-{
-	return container_of(ref, struct fw_priv, ref);
-}
-
-#define	FW_LOADER_NO_CACHE	0
-#define	FW_LOADER_START_CACHE	1
-
-/* fw_lock could be moved to 'struct fw_sysfs' but since it is just
- * guarding for corner cases a global lock should be OK */
-DEFINE_MUTEX(fw_lock);
-
-struct firmware_cache fw_cache;
-bool fw_load_abort_all;
-
-void fw_state_init(struct fw_priv *fw_priv)
-{
-	struct fw_state *fw_st = &fw_priv->fw_st;
-
-	init_completion(&fw_st->completion);
-	fw_st->status = FW_STATUS_UNKNOWN;
-}
-
-static inline int fw_state_wait(struct fw_priv *fw_priv)
-{
-	return __fw_state_wait_common(fw_priv, MAX_SCHEDULE_TIMEOUT);
-}
-
-static void fw_cache_piggyback_on_request(struct fw_priv *fw_priv);
-
-static struct fw_priv *__allocate_fw_priv(const char *fw_name,
-					  struct firmware_cache *fwc,
-					  void *dbuf,
-					  size_t size,
-					  size_t offset,
-					  u32 opt_flags)
-{
-	struct fw_priv *fw_priv;
-
-	/* For a partial read, the buffer must be preallocated. */
-	if ((opt_flags & FW_OPT_PARTIAL) && !dbuf)
-		return NULL;
-
-	/* Only partial reads are allowed to use an offset. */
-	if (offset != 0 && !(opt_flags & FW_OPT_PARTIAL))
-		return NULL;
-
-	fw_priv = kzalloc(sizeof(*fw_priv), GFP_ATOMIC);
-	if (!fw_priv)
-		return NULL;
-
-	fw_priv->fw_name = kstrdup_const(fw_name, GFP_ATOMIC);
-	if (!fw_priv->fw_name) {
-		kfree(fw_priv);
-		return NULL;
-	}
-
-	kref_init(&fw_priv->ref);
-	fw_priv->fwc = fwc;
-	fw_priv->data = dbuf;
-	fw_priv->allocated_size = size;
-	fw_priv->offset = offset;
-	fw_priv->opt_flags = opt_flags;
-	fw_state_init(fw_priv);
-#ifdef CONFIG_FW_LOADER_USER_HELPER
-	INIT_LIST_HEAD(&fw_priv->pending_list);
-#endif
-
-	pr_debug("%s: fw-%s fw_priv=%p\n", __func__, fw_name, fw_priv);
-
-	return fw_priv;
-}
-
-static struct fw_priv *__lookup_fw_priv(const char *fw_name)
-{
-	struct fw_priv *tmp;
-	struct firmware_cache *fwc = &fw_cache;
-
-	list_for_each_entry(tmp, &fwc->head, list)
-		if (!strcmp(tmp->fw_name, fw_name))
-			return tmp;
-	return NULL;
-}
-
-/* Returns 1 for batching firmware requests with the same name */
-int alloc_lookup_fw_priv(const char *fw_name, struct firmware_cache *fwc,
-			 struct fw_priv **fw_priv, void *dbuf, size_t size,
-			 size_t offset, u32 opt_flags)
-{
-	struct fw_priv *tmp;
-
-	spin_lock(&fwc->lock);
-	/*
-	 * Do not merge requests that are marked to be non-cached or
-	 * are performing partial reads.
-	 */
-	if (!(opt_flags & (FW_OPT_NOCACHE | FW_OPT_PARTIAL))) {
-		tmp = __lookup_fw_priv(fw_name);
-		if (tmp) {
-			kref_get(&tmp->ref);
-			spin_unlock(&fwc->lock);
-			*fw_priv = tmp;
-			pr_debug("batched request - sharing the same struct fw_priv and lookup for multiple requests\n");
-			return 1;
-		}
-	}
-
-	tmp = __allocate_fw_priv(fw_name, fwc, dbuf, size, offset, opt_flags);
-	if (tmp) {
-		INIT_LIST_HEAD(&tmp->list);
-		if (!(opt_flags & FW_OPT_NOCACHE))
-			list_add(&tmp->list, &fwc->head);
-	}
-	spin_unlock(&fwc->lock);
-
-	*fw_priv = tmp;
-
-	return tmp ? 0 : -ENOMEM;
-}
-
-static void __free_fw_priv(struct kref *ref)
-	__releases(&fwc->lock)
-{
-	struct fw_priv *fw_priv = to_fw_priv(ref);
-	struct firmware_cache *fwc = fw_priv->fwc;
-
-	pr_debug("%s: fw-%s fw_priv=%p data=%p size=%u\n",
-		 __func__, fw_priv->fw_name, fw_priv, fw_priv->data,
-		 (unsigned int)fw_priv->size);
-
-	list_del(&fw_priv->list);
-	spin_unlock(&fwc->lock);
-
-	if (fw_is_paged_buf(fw_priv))
-		fw_free_paged_buf(fw_priv);
-	else if (!fw_priv->allocated_size)
-		vfree(fw_priv->data);
-
-	kfree_const(fw_priv->fw_name);
-	kfree(fw_priv);
-}
-
-void free_fw_priv(struct fw_priv *fw_priv)
-{
-	struct firmware_cache *fwc = fw_priv->fwc;
-	spin_lock(&fwc->lock);
-	if (!kref_put(&fw_priv->ref, __free_fw_priv))
-		spin_unlock(&fwc->lock);
-}
-
-#ifdef CONFIG_FW_LOADER_PAGED_BUF
-bool fw_is_paged_buf(struct fw_priv *fw_priv)
-{
-	return fw_priv->is_paged_buf;
-}
-
-void fw_free_paged_buf(struct fw_priv *fw_priv)
-{
-	int i;
-
-	if (!fw_priv->pages)
-		return;
-
-	vunmap(fw_priv->data);
-
-	for (i = 0; i < fw_priv->nr_pages; i++)
-		__free_page(fw_priv->pages[i]);
-	kvfree(fw_priv->pages);
-	fw_priv->pages = NULL;
-	fw_priv->page_array_size = 0;
-	fw_priv->nr_pages = 0;
-	fw_priv->data = NULL;
-	fw_priv->size = 0;
-}
-
-int fw_grow_paged_buf(struct fw_priv *fw_priv, int pages_needed)
-{
-	/* If the array of pages is too small, grow it */
-	if (fw_priv->page_array_size < pages_needed) {
-		int new_array_size = max(pages_needed,
-					 fw_priv->page_array_size * 2);
-		struct page **new_pages;
-
-		new_pages = kvmalloc_array(new_array_size, sizeof(void *),
-					   GFP_KERNEL);
-		if (!new_pages)
-			return -ENOMEM;
-		memcpy(new_pages, fw_priv->pages,
-		       fw_priv->page_array_size * sizeof(void *));
-		memset(&new_pages[fw_priv->page_array_size], 0, sizeof(void *) *
-		       (new_array_size - fw_priv->page_array_size));
-		kvfree(fw_priv->pages);
-		fw_priv->pages = new_pages;
-		fw_priv->page_array_size = new_array_size;
-	}
-
-	while (fw_priv->nr_pages < pages_needed) {
-		fw_priv->pages[fw_priv->nr_pages] =
-			alloc_page(GFP_KERNEL | __GFP_HIGHMEM);
-
-		if (!fw_priv->pages[fw_priv->nr_pages])
-			return -ENOMEM;
-		fw_priv->nr_pages++;
-	}
-
-	return 0;
-}
-
-int fw_map_paged_buf(struct fw_priv *fw_priv)
-{
-	/* one pages buffer should be mapped/unmapped only once */
-	if (!fw_priv->pages)
-		return 0;
-
-	vunmap(fw_priv->data);
-	fw_priv->data = vmap(fw_priv->pages, fw_priv->nr_pages, 0,
-			     PAGE_KERNEL_RO);
-	if (!fw_priv->data)
-		return -ENOMEM;
-
-	return 0;
-}
-#endif
-
-/*
- * ZSTD-compressed firmware support
- */
-#ifdef CONFIG_FW_LOADER_COMPRESS_ZSTD
-static int fw_decompress_zstd(struct device *dev, struct fw_priv *fw_priv,
-			      size_t in_size, const void *in_buffer)
-{
-	size_t len, out_size, workspace_size;
-	void *workspace, *out_buf;
-	zstd_dctx *ctx;
-	int err;
-
-	if (fw_priv->allocated_size) {
-		out_size = fw_priv->allocated_size;
-		out_buf = fw_priv->data;
-	} else {
-		zstd_frame_header params;
-
-		if (zstd_get_frame_header(&params, in_buffer, in_size) ||
-		    params.frameContentSize == ZSTD_CONTENTSIZE_UNKNOWN) {
-			dev_dbg(dev, "%s: invalid zstd header\n", __func__);
-			return -EINVAL;
-		}
-		out_size = params.frameContentSize;
-		out_buf = vzalloc(out_size);
-		if (!out_buf)
-			return -ENOMEM;
-	}
-
-	workspace_size = zstd_dctx_workspace_bound();
-	workspace = kvzalloc(workspace_size, GFP_KERNEL);
-	if (!workspace) {
-		err = -ENOMEM;
-		goto error;
-	}
-
-	ctx = zstd_init_dctx(workspace, workspace_size);
-	if (!ctx) {
-		dev_dbg(dev, "%s: failed to initialize context\n", __func__);
-		err = -EINVAL;
-		goto error;
-	}
-
-	len = zstd_decompress_dctx(ctx, out_buf, out_size, in_buffer, in_size);
-	if (zstd_is_error(len)) {
-		dev_dbg(dev, "%s: failed to decompress: %d\n", __func__,
-			zstd_get_error_code(len));
-		err = -EINVAL;
-		goto error;
-	}
-
-	if (!fw_priv->allocated_size)
-		fw_priv->data = out_buf;
-	fw_priv->size = len;
-	err = 0;
-
- error:
-	kvfree(workspace);
-	if (err && !fw_priv->allocated_size)
-		vfree(out_buf);
-	return err;
-}
-#endif /* CONFIG_FW_LOADER_COMPRESS_ZSTD */
-
-/*
- * XZ-compressed firmware support
- */
-#ifdef CONFIG_FW_LOADER_COMPRESS_XZ
-/* show an error and return the standard error code */
-static int fw_decompress_xz_error(struct device *dev, enum xz_ret xz_ret)
-{
-	if (xz_ret != XZ_STREAM_END) {
-		dev_warn(dev, "xz decompression failed (xz_ret=%d)\n", xz_ret);
-		return xz_ret == XZ_MEM_ERROR ? -ENOMEM : -EINVAL;
-	}
-	return 0;
-}
-
-/* single-shot decompression onto the pre-allocated buffer */
-static int fw_decompress_xz_single(struct device *dev, struct fw_priv *fw_priv,
-				   size_t in_size, const void *in_buffer)
-{
-	struct xz_dec *xz_dec;
-	struct xz_buf xz_buf;
-	enum xz_ret xz_ret;
-
-	xz_dec = xz_dec_init(XZ_SINGLE, (u32)-1);
-	if (!xz_dec)
-		return -ENOMEM;
-
-	xz_buf.in_size = in_size;
-	xz_buf.in = in_buffer;
-	xz_buf.in_pos = 0;
-	xz_buf.out_size = fw_priv->allocated_size;
-	xz_buf.out = fw_priv->data;
-	xz_buf.out_pos = 0;
-
-	xz_ret = xz_dec_run(xz_dec, &xz_buf);
-	xz_dec_end(xz_dec);
-
-	fw_priv->size = xz_buf.out_pos;
-	return fw_decompress_xz_error(dev, xz_ret);
-}
-
-/* decompression on paged buffer and map it */
-static int fw_decompress_xz_pages(struct device *dev, struct fw_priv *fw_priv,
-				  size_t in_size, const void *in_buffer)
-{
-	struct xz_dec *xz_dec;
-	struct xz_buf xz_buf;
-	enum xz_ret xz_ret;
-	struct page *page;
-	int err = 0;
-
-	xz_dec = xz_dec_init(XZ_DYNALLOC, (u32)-1);
-	if (!xz_dec)
-		return -ENOMEM;
-
-	xz_buf.in_size = in_size;
-	xz_buf.in = in_buffer;
-	xz_buf.in_pos = 0;
-
-	fw_priv->is_paged_buf = true;
-	fw_priv->size = 0;
-	do {
-		if (fw_grow_paged_buf(fw_priv, fw_priv->nr_pages + 1)) {
-			err = -ENOMEM;
-			goto out;
-		}
-
-		/* decompress onto the new allocated page */
-		page = fw_priv->pages[fw_priv->nr_pages - 1];
-		xz_buf.out = kmap_local_page(page);
-		xz_buf.out_pos = 0;
-		xz_buf.out_size = PAGE_SIZE;
-		xz_ret = xz_dec_run(xz_dec, &xz_buf);
-		kunmap_local(xz_buf.out);
-		fw_priv->size += xz_buf.out_pos;
-		/* partial decompression means either end or error */
-		if (xz_buf.out_pos != PAGE_SIZE)
-			break;
-	} while (xz_ret == XZ_OK);
-
-	err = fw_decompress_xz_error(dev, xz_ret);
-	if (!err)
-		err = fw_map_paged_buf(fw_priv);
-
- out:
-	xz_dec_end(xz_dec);
-	return err;
-}
-
-static int fw_decompress_xz(struct device *dev, struct fw_priv *fw_priv,
-			    size_t in_size, const void *in_buffer)
-{
-	/* if the buffer is pre-allocated, we can perform in single-shot mode */
-	if (fw_priv->data)
-		return fw_decompress_xz_single(dev, fw_priv, in_size, in_buffer);
-	else
-		return fw_decompress_xz_pages(dev, fw_priv, in_size, in_buffer);
-}
-#endif /* CONFIG_FW_LOADER_COMPRESS_XZ */
-
-/* direct firmware loading support */
-static char fw_path_para[256];
-static const char * const fw_path[] = {
-	fw_path_para,
-	"/lib/firmware/updates/" UTS_RELEASE,
-	"/lib/firmware/updates",
-	"/lib/firmware/" UTS_RELEASE,
-	"/lib/firmware"
-};
-
-/*
- * Typical usage is that passing 'firmware_class.path=$CUSTOMIZED_PATH'
- * from kernel command line because firmware_class is generally built in
- * kernel instead of module.
- */
-module_param_string(path, fw_path_para, sizeof(fw_path_para), 0644);
-MODULE_PARM_DESC(path, "customized firmware image search path with a higher priority than default path");
-
-static int
-fw_get_filesystem_firmware(struct device *device, struct fw_priv *fw_priv,
-			   const char *suffix,
-			   int (*decompress)(struct device *dev,
-					     struct fw_priv *fw_priv,
-					     size_t in_size,
-					     const void *in_buffer))
-{
-	size_t size;
-	int i, len, maxlen = 0;
-	int rc = -ENOENT;
-	char *path, *nt = NULL;
-	size_t msize = INT_MAX;
-	void *buffer = NULL;
-
-	/* Already populated data member means we're loading into a buffer */
-	if (!decompress && fw_priv->data) {
-		buffer = fw_priv->data;
-		msize = fw_priv->allocated_size;
-	}
-
-	path = __getname();
-	if (!path)
-		return -ENOMEM;
-
-	wait_for_initramfs();
-	for (i = 0; i < ARRAY_SIZE(fw_path); i++) {
-		size_t file_size = 0;
-		size_t *file_size_ptr = NULL;
-
-		/* skip the unset customized path */
-		if (!fw_path[i][0])
-			continue;
-
-		/* strip off \n from customized path */
-		maxlen = strlen(fw_path[i]);
-		if (i == 0) {
-			nt = strchr(fw_path[i], '\n');
-			if (nt)
-				maxlen = nt - fw_path[i];
-		}
-
-		len = snprintf(path, PATH_MAX, "%.*s/%s%s",
-			       maxlen, fw_path[i],
-			       fw_priv->fw_name, suffix);
-		if (len >= PATH_MAX) {
-			rc = -ENAMETOOLONG;
-			break;
-		}
-
-		fw_priv->size = 0;
-
-		/*
-		 * The total file size is only examined when doing a partial
-		 * read; the "full read" case needs to fail if the whole
-		 * firmware was not completely loaded.
-		 */
-		if ((fw_priv->opt_flags & FW_OPT_PARTIAL) && buffer)
-			file_size_ptr = &file_size;
-
-		/* load firmware files from the mount namespace of init */
-		rc = kernel_read_file_from_path_initns(path, fw_priv->offset,
-						       &buffer, msize,
-						       file_size_ptr,
-						       READING_FIRMWARE);
-		if (rc < 0) {
-			if (!(fw_priv->opt_flags & FW_OPT_NO_WARN)) {
-				if (rc != -ENOENT)
-					dev_warn(device,
-						 "loading %s failed with error %d\n",
-						 path, rc);
-				else
-					dev_dbg(device,
-						"loading %s failed for no such file or directory.\n",
-						path);
-			}
-			continue;
-		}
-		size = rc;
-		rc = 0;
-
-		dev_dbg(device, "Loading firmware from %s\n", path);
-		if (decompress) {
-			dev_dbg(device, "f/w decompressing %s\n",
-				fw_priv->fw_name);
-			rc = decompress(device, fw_priv, size, buffer);
-			/* discard the superfluous original content */
-			vfree(buffer);
-			buffer = NULL;
-			if (rc) {
-				fw_free_paged_buf(fw_priv);
-				continue;
-			}
-		} else {
-			dev_dbg(device, "direct-loading %s\n",
-				fw_priv->fw_name);
-			if (!fw_priv->data)
-				fw_priv->data = buffer;
-			fw_priv->size = size;
-		}
-		fw_state_done(fw_priv);
-		break;
-	}
-	__putname(path);
-
-	return rc;
-}
-
-/* firmware holds the ownership of pages */
-static void firmware_free_data(const struct firmware *fw)
-{
-	/* Loaded directly? */
-	if (!fw->priv) {
-		vfree(fw->data);
-		return;
-	}
-	free_fw_priv(fw->priv);
-}
-
-/* store the pages buffer info firmware from buf */
-static void fw_set_page_data(struct fw_priv *fw_priv, struct firmware *fw)
-{
-	fw->priv = fw_priv;
-	fw->size = fw_priv->size;
-	fw->data = fw_priv->data;
-
-	pr_debug("%s: fw-%s fw_priv=%p data=%p size=%u\n",
-		 __func__, fw_priv->fw_name, fw_priv, fw_priv->data,
-		 (unsigned int)fw_priv->size);
-}
-
-#ifdef CONFIG_FW_CACHE
-static void fw_name_devm_release(struct device *dev, void *res)
-{
-	struct fw_name_devm *fwn = res;
-
-	if (fwn->magic == (unsigned long)&fw_cache)
-		pr_debug("%s: fw_name-%s devm-%p released\n",
-				__func__, fwn->name, res);
-	kfree_const(fwn->name);
-}
-
-static int fw_devm_match(struct device *dev, void *res,
-		void *match_data)
-{
-	struct fw_name_devm *fwn = res;
-
-	return (fwn->magic == (unsigned long)&fw_cache) &&
-		!strcmp(fwn->name, match_data);
-}
-
-static struct fw_name_devm *fw_find_devm_name(struct device *dev,
-		const char *name)
-{
-	struct fw_name_devm *fwn;
-
-	fwn = devres_find(dev, fw_name_devm_release,
-			  fw_devm_match, (void *)name);
-	return fwn;
-}
-
-static bool fw_cache_is_setup(struct device *dev, const char *name)
-{
-	struct fw_name_devm *fwn;
-
-	fwn = fw_find_devm_name(dev, name);
-	if (fwn)
-		return true;
-
-	return false;
-}
-
-/* add firmware name into devres list */
-static int fw_add_devm_name(struct device *dev, const char *name)
-{
-	struct fw_name_devm *fwn;
-
-	if (fw_cache_is_setup(dev, name))
-		return 0;
-
-	fwn = devres_alloc(fw_name_devm_release, sizeof(struct fw_name_devm),
-			   GFP_KERNEL);
-	if (!fwn)
-		return -ENOMEM;
-	fwn->name = kstrdup_const(name, GFP_KERNEL);
-	if (!fwn->name) {
-		devres_free(fwn);
-		return -ENOMEM;
-	}
-
-	fwn->magic = (unsigned long)&fw_cache;
-	devres_add(dev, fwn);
-
-	return 0;
-}
-#else
-static bool fw_cache_is_setup(struct device *dev, const char *name)
-{
-	return false;
-}
-
-static int fw_add_devm_name(struct device *dev, const char *name)
-{
-	return 0;
-}
-#endif
-
-int assign_fw(struct firmware *fw, struct device *device)
-{
-	struct fw_priv *fw_priv = fw->priv;
-	int ret;
-
-	mutex_lock(&fw_lock);
-	if (!fw_priv->size || fw_state_is_aborted(fw_priv)) {
-		mutex_unlock(&fw_lock);
-		return -ENOENT;
-	}
-
-	/*
-	 * add firmware name into devres list so that we can auto cache
-	 * and uncache firmware for device.
-	 *
-	 * device may has been deleted already, but the problem
-	 * should be fixed in devres or driver core.
-	 */
-	/* don't cache firmware handled without uevent */
-	if (device && (fw_priv->opt_flags & FW_OPT_UEVENT) &&
-	    !(fw_priv->opt_flags & FW_OPT_NOCACHE)) {
-		ret = fw_add_devm_name(device, fw_priv->fw_name);
-		if (ret) {
-			mutex_unlock(&fw_lock);
-			return ret;
-		}
-	}
-
-	/*
-	 * After caching firmware image is started, let it piggyback
-	 * on request firmware.
-	 */
-	if (!(fw_priv->opt_flags & FW_OPT_NOCACHE) &&
-	    fw_priv->fwc->state == FW_LOADER_START_CACHE)
-		fw_cache_piggyback_on_request(fw_priv);
-
-	/* pass the pages buffer to driver at the last minute */
-	fw_set_page_data(fw_priv, fw);
-	mutex_unlock(&fw_lock);
-	return 0;
-}
-
-/* prepare firmware and firmware_buf structs;
- * return 0 if a firmware is already assigned, 1 if need to load one,
- * or a negative error code
- */
-static int
-_request_firmware_prepare(struct firmware **firmware_p, const char *name,
-			  struct device *device, void *dbuf, size_t size,
-			  size_t offset, u32 opt_flags)
-{
-	struct firmware *firmware;
-	struct fw_priv *fw_priv;
-	int ret;
-
-	*firmware_p = firmware = kzalloc(sizeof(*firmware), GFP_KERNEL);
-	if (!firmware) {
-		dev_err(device, "%s: kmalloc(struct firmware) failed\n",
-			__func__);
-		return -ENOMEM;
-	}
-
-	if (firmware_request_builtin_buf(firmware, name, dbuf, size)) {
-		dev_dbg(device, "using built-in %s\n", name);
-		return 0; /* assigned */
-	}
-
-	ret = alloc_lookup_fw_priv(name, &fw_cache, &fw_priv, dbuf, size,
-				   offset, opt_flags);
-
-	/*
-	 * bind with 'priv' now to avoid warning in failure path
-	 * of requesting firmware.
-	 */
-	firmware->priv = fw_priv;
-
-	if (ret > 0) {
-		ret = fw_state_wait(fw_priv);
-		if (!ret) {
-			fw_set_page_data(fw_priv, firmware);
-			return 0; /* assigned */
-		}
-	}
-
-	if (ret < 0)
-		return ret;
-	return 1; /* need to load */
-}
-
-/*
- * Batched requests need only one wake, we need to do this step last due to the
- * fallback mechanism. The buf is protected with kref_get(), and it won't be
- * released until the last user calls release_firmware().
- *
- * Failed batched requests are possible as well, in such cases we just share
- * the struct fw_priv and won't release it until all requests are woken
- * and have gone through this same path.
- */
-static void fw_abort_batch_reqs(struct firmware *fw)
-{
-	struct fw_priv *fw_priv;
-
-	/* Loaded directly? */
-	if (!fw || !fw->priv)
-		return;
-
-	fw_priv = fw->priv;
-	mutex_lock(&fw_lock);
-	if (!fw_state_is_aborted(fw_priv))
-		fw_state_aborted(fw_priv);
-	mutex_unlock(&fw_lock);
-}
-
-#if defined(CONFIG_FW_LOADER_DEBUG)
-#include <crypto/sha2.h>
-
-static void fw_log_firmware_info(const struct firmware *fw, const char *name, struct device *device)
-{
-	u8 digest[SHA256_DIGEST_SIZE];
-
-	sha256(fw->data, fw->size, digest);
-	dev_dbg(device, "Loaded FW: %s, sha256: %*phN\n",
-		name, SHA256_DIGEST_SIZE, digest);
-}
-#else
-static void fw_log_firmware_info(const struct firmware *fw, const char *name,
-				 struct device *device)
-{}
-#endif
-
-/*
- * Reject firmware file names with ".." path components.
- * There are drivers that construct firmware file names from device-supplied
- * strings, and we don't want some device to be able to tell us "I would like to
- * be sent my firmware from ../../../etc/shadow, please".
- *
- * Search for ".." surrounded by either '/' or start/end of string.
- *
- * This intentionally only looks at the firmware name, not at the firmware base
- * directory or at symlink contents.
- */
-static bool name_contains_dotdot(const char *name)
-{
-	size_t name_len = strlen(name);
-
-	return strcmp(name, "..") == 0 || strncmp(name, "../", 3) == 0 ||
-	       strstr(name, "/../") != NULL ||
-	       (name_len >= 3 && strcmp(name+name_len-3, "/..") == 0);
-}
-
-/* called from request_firmware() and request_firmware_work_func() */
-static int
-_request_firmware(const struct firmware **firmware_p, const char *name,
-		  struct device *device, void *buf, size_t size,
-		  size_t offset, u32 opt_flags)
-{
-	struct firmware *fw = NULL;
-	struct cred *kern_cred = NULL;
-	const struct cred *old_cred;
-	bool nondirect = false;
-	int ret;
-
-	if (!firmware_p)
-		return -EINVAL;
-
-	if (!name || name[0] == '\0') {
-		ret = -EINVAL;
-		goto out;
-	}
-
-	if (name_contains_dotdot(name)) {
-		dev_warn(device,
-			 "Firmware load for '%s' refused, path contains '..' component\n",
-			 name);
-		ret = -EINVAL;
-		goto out;
-	}
-
-	ret = _request_firmware_prepare(&fw, name, device, buf, size,
-					offset, opt_flags);
-	if (ret <= 0) /* error or already assigned */
-		goto out;
-
-	/*
-	 * We are about to try to access the firmware file. Because we may have been
-	 * called by a driver when serving an unrelated request from userland, we use
-	 * the kernel credentials to read the file.
-	 */
-	kern_cred = prepare_kernel_cred(&init_task);
-	if (!kern_cred) {
-		ret = -ENOMEM;
-		goto out;
-	}
-	old_cred = override_creds(kern_cred);
-
-	ret = fw_get_filesystem_firmware(device, fw->priv, "", NULL);
-
-	/* Only full reads can support decompression, platform, and sysfs. */
-	if (!(opt_flags & FW_OPT_PARTIAL))
-		nondirect = true;
-
-#ifdef CONFIG_FW_LOADER_COMPRESS_ZSTD
-	if (ret == -ENOENT && nondirect)
-		ret = fw_get_filesystem_firmware(device, fw->priv, ".zst",
-						 fw_decompress_zstd);
-#endif
-#ifdef CONFIG_FW_LOADER_COMPRESS_XZ
-	if (ret == -ENOENT && nondirect)
-		ret = fw_get_filesystem_firmware(device, fw->priv, ".xz",
-						 fw_decompress_xz);
-#endif
-	if (ret == -ENOENT && nondirect)
-		ret = firmware_fallback_platform(fw->priv);
-
-	if (ret) {
-		if (!(opt_flags & FW_OPT_NO_WARN))
-			dev_warn(device,
-				 "Direct firmware load for %s failed with error %d\n",
-				 name, ret);
-		if (nondirect)
-			ret = firmware_fallback_sysfs(fw, name, device,
-						      opt_flags, ret);
-	} else
-		ret = assign_fw(fw, device);
-
-	revert_creds(old_cred);
-	put_cred(kern_cred);
-
-out:
-	if (ret < 0) {
-		fw_abort_batch_reqs(fw);
-		release_firmware(fw);
-		fw = NULL;
-	} else {
-		fw_log_firmware_info(fw, name, device);
-	}
-
-	*firmware_p = fw;
-	return ret;
-}
-
-/**
- * request_firmware() - send firmware request and wait for it
- * @firmware_p: pointer to firmware image
- * @name: name of firmware file
- * @device: device for which firmware is being loaded
- *
- *      @firmware_p will be used to return a firmware image by the name
- *      of @name for device @device.
- *
- *      Should be called from user context where sleeping is allowed.
- *
- *      @name will be used as $FIRMWARE in the uevent environment and
- *      should be distinctive enough not to be confused with any other
- *      firmware image for this or any other device.
- *	It must not contain any ".." path components - "foo/bar..bin" is
- *	allowed, but "foo/../bar.bin" is not.
- *
- *	Caller must hold the reference count of @device.
- *
- *	The function can be called safely inside device's suspend and
- *	resume callback.
- **/
-int
-request_firmware(const struct firmware **firmware_p, const char *name,
-		 struct device *device)
-{
-	int ret;
-
-	/* Need to pin this module until return */
-	__module_get(THIS_MODULE);
-	ret = _request_firmware(firmware_p, name, device, NULL, 0, 0,
-				FW_OPT_UEVENT);
-	module_put(THIS_MODULE);
-	return ret;
-}
-EXPORT_SYMBOL(request_firmware);
-
-/**
- * firmware_request_nowarn() - request for an optional fw module
- * @firmware: pointer to firmware image
- * @name: name of firmware file
- * @device: device for which firmware is being loaded
- *
- * This function is similar in behaviour to request_firmware(), except it
- * doesn't produce warning messages when the file is not found. The sysfs
- * fallback mechanism is enabled if direct filesystem lookup fails. However,
- * failures to find the firmware file with it are still suppressed. It is
- * therefore up to the driver to check for the return value of this call and to
- * decide when to inform the users of errors.
- **/
-int firmware_request_nowarn(const struct firmware **firmware, const char *name,
-			    struct device *device)
-{
-	int ret;
-
-	/* Need to pin this module until return */
-	__module_get(THIS_MODULE);
-	ret = _request_firmware(firmware, name, device, NULL, 0, 0,
-				FW_OPT_UEVENT | FW_OPT_NO_WARN);
-	module_put(THIS_MODULE);
-	return ret;
-}
-EXPORT_SYMBOL_GPL(firmware_request_nowarn);
-
-/**
- * request_firmware_direct() - load firmware directly without usermode helper
- * @firmware_p: pointer to firmware image
- * @name: name of firmware file
- * @device: device for which firmware is being loaded
- *
- * This function works pretty much like request_firmware(), but this doesn't
- * fall back to usermode helper even if the firmware couldn't be loaded
- * directly from fs.  Hence it's useful for loading optional firmwares, which
- * aren't always present, without extra long timeouts of udev.
- **/
-int request_firmware_direct(const struct firmware **firmware_p,
-			    const char *name, struct device *device)
-{
-	int ret;
-
-	__module_get(THIS_MODULE);
-	ret = _request_firmware(firmware_p, name, device, NULL, 0, 0,
-				FW_OPT_UEVENT | FW_OPT_NO_WARN |
-				FW_OPT_NOFALLBACK_SYSFS);
-	module_put(THIS_MODULE);
-	return ret;
-}
-EXPORT_SYMBOL_GPL(request_firmware_direct);
-
-/**
- * firmware_request_platform() - request firmware with platform-fw fallback
- * @firmware: pointer to firmware image
- * @name: name of firmware file
- * @device: device for which firmware is being loaded
- *
- * This function is similar in behaviour to request_firmware, except that if
- * direct filesystem lookup fails, it will fallback to looking for a copy of the
- * requested firmware embedded in the platform's main (e.g. UEFI) firmware.
- **/
-int firmware_request_platform(const struct firmware **firmware,
-			      const char *name, struct device *device)
-{
-	int ret;
-
-	/* Need to pin this module until return */
-	__module_get(THIS_MODULE);
-	ret = _request_firmware(firmware, name, device, NULL, 0, 0,
-				FW_OPT_UEVENT | FW_OPT_FALLBACK_PLATFORM);
-	module_put(THIS_MODULE);
-	return ret;
-}
-EXPORT_SYMBOL_GPL(firmware_request_platform);
-
-/**
- * firmware_request_cache() - cache firmware for suspend so resume can use it
- * @device: device for which firmware should be cached for
- * @name: name of firmware file
- *
- * There are some devices with an optimization that enables the device to not
- * require loading firmware on system reboot. This optimization may still
- * require the firmware present on resume from suspend. This routine can be
- * used to ensure the firmware is present on resume from suspend in these
- * situations. This helper is not compatible with drivers which use
- * request_firmware_into_buf() or request_firmware_nowait() with no uevent set.
- **/
-int firmware_request_cache(struct device *device, const char *name)
-{
-	int ret;
-
-	mutex_lock(&fw_lock);
-	ret = fw_add_devm_name(device, name);
-	mutex_unlock(&fw_lock);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(firmware_request_cache);
-
-/**
- * request_firmware_into_buf() - load firmware into a previously allocated buffer
- * @firmware_p: pointer to firmware image
- * @name: name of firmware file
- * @device: device for which firmware is being loaded and DMA region allocated
- * @buf: address of buffer to load firmware into
- * @size: size of buffer
- *
- * This function works pretty much like request_firmware(), but it doesn't
- * allocate a buffer to hold the firmware data. Instead, the firmware
- * is loaded directly into the buffer pointed to by @buf and the @firmware_p
- * data member is pointed at @buf.
- *
- * This function doesn't cache firmware either.
- */
-int
-request_firmware_into_buf(const struct firmware **firmware_p, const char *name,
-			  struct device *device, void *buf, size_t size)
-{
-	int ret;
-
-	if (fw_cache_is_setup(device, name))
-		return -EOPNOTSUPP;
-
-	__module_get(THIS_MODULE);
-	ret = _request_firmware(firmware_p, name, device, buf, size, 0,
-				FW_OPT_UEVENT | FW_OPT_NOCACHE);
-	module_put(THIS_MODULE);
-	return ret;
-}
-EXPORT_SYMBOL(request_firmware_into_buf);
-
-/**
- * request_partial_firmware_into_buf() - load partial firmware into a previously allocated buffer
- * @firmware_p: pointer to firmware image
- * @name: name of firmware file
- * @device: device for which firmware is being loaded and DMA region allocated
- * @buf: address of buffer to load firmware into
- * @size: size of buffer
- * @offset: offset into file to read
- *
- * This function works pretty much like request_firmware_into_buf except
- * it allows a partial read of the file.
- */
-int
-request_partial_firmware_into_buf(const struct firmware **firmware_p,
-				  const char *name, struct device *device,
-				  void *buf, size_t size, size_t offset)
-{
-	int ret;
-
-	if (fw_cache_is_setup(device, name))
-		return -EOPNOTSUPP;
-
-	__module_get(THIS_MODULE);
-	ret = _request_firmware(firmware_p, name, device, buf, size, offset,
-				FW_OPT_UEVENT | FW_OPT_NOCACHE |
-				FW_OPT_PARTIAL);
-	module_put(THIS_MODULE);
-	return ret;
-}
-EXPORT_SYMBOL(request_partial_firmware_into_buf);
-
-/**
- * release_firmware() - release the resource associated with a firmware image
- * @fw: firmware resource to release
- **/
-void release_firmware(const struct firmware *fw)
-{
-	if (fw) {
-		if (!firmware_is_builtin(fw))
-			firmware_free_data(fw);
-		kfree(fw);
-	}
-}
-EXPORT_SYMBOL(release_firmware);
-
-/* Async support */
-struct firmware_work {
-	struct work_struct work;
-	struct module *module;
-	const char *name;
-	struct device *device;
-	void *context;
-	void (*cont)(const struct firmware *fw, void *context);
-	u32 opt_flags;
-};
-
-static void request_firmware_work_func(struct work_struct *work)
-{
-	struct firmware_work *fw_work;
-	const struct firmware *fw;
-
-	fw_work = container_of(work, struct firmware_work, work);
-
-	_request_firmware(&fw, fw_work->name, fw_work->device, NULL, 0, 0,
-			  fw_work->opt_flags);
-	fw_work->cont(fw, fw_work->context);
-	put_device(fw_work->device); /* taken in request_firmware_nowait() */
-
-	module_put(fw_work->module);
-	kfree_const(fw_work->name);
-	kfree(fw_work);
-}
-
-
-static int _request_firmware_nowait(
-	struct module *module, bool uevent,
-	const char *name, struct device *device, gfp_t gfp, void *context,
-	void (*cont)(const struct firmware *fw, void *context), bool nowarn)
-{
-	struct firmware_work *fw_work;
-
-	fw_work = kzalloc(sizeof(struct firmware_work), gfp);
-	if (!fw_work)
-		return -ENOMEM;
-
-	fw_work->module = module;
-	fw_work->name = kstrdup_const(name, gfp);
-	if (!fw_work->name) {
-		kfree(fw_work);
-		return -ENOMEM;
-	}
-	fw_work->device = device;
-	fw_work->context = context;
-	fw_work->cont = cont;
-	fw_work->opt_flags = FW_OPT_NOWAIT |
-		(uevent ? FW_OPT_UEVENT : FW_OPT_USERHELPER) |
-		(nowarn ? FW_OPT_NO_WARN : 0);
-
-	if (!uevent && fw_cache_is_setup(device, name)) {
-		kfree_const(fw_work->name);
-		kfree(fw_work);
-		return -EOPNOTSUPP;
-	}
-
-	if (!try_module_get(module)) {
-		kfree_const(fw_work->name);
-		kfree(fw_work);
-		return -EFAULT;
-	}
-
-	get_device(fw_work->device);
-	INIT_WORK(&fw_work->work, request_firmware_work_func);
-	schedule_work(&fw_work->work);
-	return 0;
-}
-
-/**
- * request_firmware_nowait() - asynchronous version of request_firmware
- * @module: module requesting the firmware
- * @uevent: sends uevent to copy the firmware image if this flag
- *	is non-zero else the firmware copy must be done manually.
- * @name: name of firmware file
- * @device: device for which firmware is being loaded
- * @gfp: allocation flags
- * @context: will be passed over to @cont, and
- *	@fw may be %NULL if firmware request fails.
- * @cont: function will be called asynchronously when the firmware
- *	request is over.
- *
- *	Caller must hold the reference count of @device.
- *
- *	Asynchronous variant of request_firmware() for user contexts:
- *		- sleep for as small periods as possible since it may
- *		  increase kernel boot time of built-in device drivers
- *		  requesting firmware in their ->probe() methods, if
- *		  @gfp is GFP_KERNEL.
- *
- *		- can't sleep at all if @gfp is GFP_ATOMIC.
- **/
-int request_firmware_nowait(
-	struct module *module, bool uevent,
-	const char *name, struct device *device, gfp_t gfp, void *context,
-	void (*cont)(const struct firmware *fw, void *context))
-{
-	return _request_firmware_nowait(module, uevent, name, device, gfp,
-					context, cont, false);
-
-}
-EXPORT_SYMBOL(request_firmware_nowait);
-
-/**
- * firmware_request_nowait_nowarn() - async version of request_firmware_nowarn
- * @module: module requesting the firmware
- * @name: name of firmware file
- * @device: device for which firmware is being loaded
- * @gfp: allocation flags
- * @context: will be passed over to @cont, and
- *	@fw may be %NULL if firmware request fails.
- * @cont: function will be called asynchronously when the firmware
- *	request is over.
- *
- * Similar in function to request_firmware_nowait(), but doesn't print a warning
- * when the firmware file could not be found and always sends a uevent to copy
- * the firmware image.
- */
-int firmware_request_nowait_nowarn(
-	struct module *module, const char *name,
-	struct device *device, gfp_t gfp, void *context,
-	void (*cont)(const struct firmware *fw, void *context))
-{
-	return _request_firmware_nowait(module, FW_ACTION_UEVENT, name, device,
-					gfp, context, cont, true);
-}
-EXPORT_SYMBOL_GPL(firmware_request_nowait_nowarn);
-
-#ifdef CONFIG_FW_CACHE
-static ASYNC_DOMAIN_EXCLUSIVE(fw_cache_domain);
-
-/**
- * cache_firmware() - cache one firmware image in kernel memory space
- * @fw_name: the firmware image name
- *
- * Cache firmware in kernel memory so that drivers can use it when
- * system isn't ready for them to request firmware image from userspace.
- * Once it returns successfully, driver can use request_firmware or its
- * nowait version to get the cached firmware without any interacting
- * with userspace
- *
- * Return 0 if the firmware image has been cached successfully
- * Return !0 otherwise
- *
- */
-static int cache_firmware(const char *fw_name)
-{
-	int ret;
-	const struct firmware *fw;
-
-	pr_debug("%s: %s\n", __func__, fw_name);
-
-	ret = request_firmware(&fw, fw_name, NULL);
-	if (!ret)
-		kfree(fw);
-
-	pr_debug("%s: %s ret=%d\n", __func__, fw_name, ret);
-
-	return ret;
-}
-
-static struct fw_priv *lookup_fw_priv(const char *fw_name)
-{
-	struct fw_priv *tmp;
-	struct firmware_cache *fwc = &fw_cache;
-
-	spin_lock(&fwc->lock);
-	tmp = __lookup_fw_priv(fw_name);
-	spin_unlock(&fwc->lock);
-
-	return tmp;
-}
-
-/**
- * uncache_firmware() - remove one cached firmware image
- * @fw_name: the firmware image name
- *
- * Uncache one firmware image which has been cached successfully
- * before.
- *
- * Return 0 if the firmware cache has been removed successfully
- * Return !0 otherwise
- *
- */
-static int uncache_firmware(const char *fw_name)
-{
-	struct fw_priv *fw_priv;
-	struct firmware fw;
-
-	pr_debug("%s: %s\n", __func__, fw_name);
-
-	if (firmware_request_builtin(&fw, fw_name))
-		return 0;
-
-	fw_priv = lookup_fw_priv(fw_name);
-	if (fw_priv) {
-		free_fw_priv(fw_priv);
-		return 0;
-	}
-
-	return -EINVAL;
-}
-
-static struct fw_cache_entry *alloc_fw_cache_entry(const char *name)
-{
-	struct fw_cache_entry *fce;
-
-	fce = kzalloc(sizeof(*fce), GFP_ATOMIC);
-	if (!fce)
-		goto exit;
-
-	fce->name = kstrdup_const(name, GFP_ATOMIC);
-	if (!fce->name) {
-		kfree(fce);
-		fce = NULL;
-		goto exit;
-	}
-exit:
-	return fce;
-}
-
-static int __fw_entry_found(const char *name)
-{
-	struct firmware_cache *fwc = &fw_cache;
-	struct fw_cache_entry *fce;
-
-	list_for_each_entry(fce, &fwc->fw_names, list) {
-		if (!strcmp(fce->name, name))
-			return 1;
-	}
-	return 0;
-}
-
-static void fw_cache_piggyback_on_request(struct fw_priv *fw_priv)
-{
-	const char *name = fw_priv->fw_name;
-	struct firmware_cache *fwc = fw_priv->fwc;
-	struct fw_cache_entry *fce;
-
-	spin_lock(&fwc->name_lock);
-	if (__fw_entry_found(name))
-		goto found;
-
-	fce = alloc_fw_cache_entry(name);
-	if (fce) {
-		list_add(&fce->list, &fwc->fw_names);
-		kref_get(&fw_priv->ref);
-		pr_debug("%s: fw: %s\n", __func__, name);
-	}
-found:
-	spin_unlock(&fwc->name_lock);
-}
-
-static void free_fw_cache_entry(struct fw_cache_entry *fce)
-{
-	kfree_const(fce->name);
-	kfree(fce);
-}
-
-static void __async_dev_cache_fw_image(void *fw_entry,
-				       async_cookie_t cookie)
-{
-	struct fw_cache_entry *fce = fw_entry;
-	struct firmware_cache *fwc = &fw_cache;
-	int ret;
-
-	ret = cache_firmware(fce->name);
-	if (ret) {
-		spin_lock(&fwc->name_lock);
-		list_del(&fce->list);
-		spin_unlock(&fwc->name_lock);
-
-		free_fw_cache_entry(fce);
-	}
-}
-
-/* called with dev->devres_lock held */
-static void dev_create_fw_entry(struct device *dev, void *res,
-				void *data)
-{
-	struct fw_name_devm *fwn = res;
-	const char *fw_name = fwn->name;
-	struct list_head *head = data;
-	struct fw_cache_entry *fce;
-
-	fce = alloc_fw_cache_entry(fw_name);
-	if (fce)
-		list_add(&fce->list, head);
-}
-
-static int devm_name_match(struct device *dev, void *res,
-			   void *match_data)
-{
-	struct fw_name_devm *fwn = res;
-	return (fwn->magic == (unsigned long)match_data);
-}
-
-static void dev_cache_fw_image(struct device *dev, void *data)
-{
-	LIST_HEAD(todo);
-	struct fw_cache_entry *fce;
-	struct fw_cache_entry *fce_next;
-	struct firmware_cache *fwc = &fw_cache;
-
-	devres_for_each_res(dev, fw_name_devm_release,
-			    devm_name_match, &fw_cache,
-			    dev_create_fw_entry, &todo);
-
-	list_for_each_entry_safe(fce, fce_next, &todo, list) {
-		list_del(&fce->list);
-
-		spin_lock(&fwc->name_lock);
-		/* only one cache entry for one firmware */
-		if (!__fw_entry_found(fce->name)) {
-			list_add(&fce->list, &fwc->fw_names);
-		} else {
-			free_fw_cache_entry(fce);
-			fce = NULL;
-		}
-		spin_unlock(&fwc->name_lock);
-
-		if (fce)
-			async_schedule_domain(__async_dev_cache_fw_image,
-					      (void *)fce,
-					      &fw_cache_domain);
-	}
-}
-
-static void __device_uncache_fw_images(void)
-{
-	struct firmware_cache *fwc = &fw_cache;
-	struct fw_cache_entry *fce;
-
-	spin_lock(&fwc->name_lock);
-	while (!list_empty(&fwc->fw_names)) {
-		fce = list_entry(fwc->fw_names.next,
-				struct fw_cache_entry, list);
-		list_del(&fce->list);
-		spin_unlock(&fwc->name_lock);
-
-		uncache_firmware(fce->name);
-		free_fw_cache_entry(fce);
-
-		spin_lock(&fwc->name_lock);
-	}
-	spin_unlock(&fwc->name_lock);
-}
-
-/**
- * device_cache_fw_images() - cache devices' firmware
- *
- * If one device called request_firmware or its nowait version
- * successfully before, the firmware names are recored into the
- * device's devres link list, so device_cache_fw_images can call
- * cache_firmware() to cache these firmwares for the device,
- * then the device driver can load its firmwares easily at
- * time when system is not ready to complete loading firmware.
- */
-static void device_cache_fw_images(void)
-{
-	struct firmware_cache *fwc = &fw_cache;
-	DEFINE_WAIT(wait);
-
-	pr_debug("%s\n", __func__);
-
-	/* cancel uncache work */
-	cancel_delayed_work_sync(&fwc->work);
-
-	fw_fallback_set_cache_timeout();
-
-	mutex_lock(&fw_lock);
-	fwc->state = FW_LOADER_START_CACHE;
-	dpm_for_each_dev(NULL, dev_cache_fw_image);
-	mutex_unlock(&fw_lock);
-
-	/* wait for completion of caching firmware for all devices */
-	async_synchronize_full_domain(&fw_cache_domain);
-
-	fw_fallback_set_default_timeout();
-}
-
-/**
- * device_uncache_fw_images() - uncache devices' firmware
- *
- * uncache all firmwares which have been cached successfully
- * by device_uncache_fw_images earlier
- */
-static void device_uncache_fw_images(void)
-{
-	pr_debug("%s\n", __func__);
-	__device_uncache_fw_images();
-}
-
-static void device_uncache_fw_images_work(struct work_struct *work)
-{
-	device_uncache_fw_images();
-}
-
-/**
- * device_uncache_fw_images_delay() - uncache devices firmwares
- * @delay: number of milliseconds to delay uncache device firmwares
- *
- * uncache all devices's firmwares which has been cached successfully
- * by device_cache_fw_images after @delay milliseconds.
- */
-static void device_uncache_fw_images_delay(unsigned long delay)
-{
-	queue_delayed_work(system_power_efficient_wq, &fw_cache.work,
-			   msecs_to_jiffies(delay));
-}
-
-static int fw_pm_notify(struct notifier_block *notify_block,
-			unsigned long mode, void *unused)
-{
-	switch (mode) {
-	case PM_HIBERNATION_PREPARE:
-	case PM_SUSPEND_PREPARE:
-	case PM_RESTORE_PREPARE:
-		/*
-		 * Here, kill pending fallback requests will only kill
-		 * non-uevent firmware request to avoid stalling suspend.
-		 */
-		kill_pending_fw_fallback_reqs(false);
-		device_cache_fw_images();
-		break;
-
-	case PM_POST_SUSPEND:
-	case PM_POST_HIBERNATION:
-	case PM_POST_RESTORE:
-		/*
-		 * In case that system sleep failed and syscore_suspend is
-		 * not called.
-		 */
-		mutex_lock(&fw_lock);
-		fw_cache.state = FW_LOADER_NO_CACHE;
-		mutex_unlock(&fw_lock);
-
-		device_uncache_fw_images_delay(10 * MSEC_PER_SEC);
-		break;
-	}
-
-	return 0;
-}
-
-/* stop caching firmware once syscore_suspend is reached */
-static int fw_suspend(void)
-{
-	fw_cache.state = FW_LOADER_NO_CACHE;
-	return 0;
-}
-
-static struct syscore_ops fw_syscore_ops = {
-	.suspend = fw_suspend,
-};
-
-static int __init register_fw_pm_ops(void)
-{
-	int ret;
-
-	spin_lock_init(&fw_cache.name_lock);
-	INIT_LIST_HEAD(&fw_cache.fw_names);
-
-	INIT_DELAYED_WORK(&fw_cache.work,
-			  device_uncache_fw_images_work);
-
-	fw_cache.pm_notify.notifier_call = fw_pm_notify;
-	ret = register_pm_notifier(&fw_cache.pm_notify);
-	if (ret)
-		return ret;
-
-	register_syscore_ops(&fw_syscore_ops);
-
-	return ret;
-}
-
-static inline void unregister_fw_pm_ops(void)
-{
-	unregister_syscore_ops(&fw_syscore_ops);
-	unregister_pm_notifier(&fw_cache.pm_notify);
-}
-#else
-static void fw_cache_piggyback_on_request(struct fw_priv *fw_priv)
-{
-}
-static inline int register_fw_pm_ops(void)
-{
-	return 0;
-}
-static inline void unregister_fw_pm_ops(void)
-{
-}
-#endif
-
-static void __init fw_cache_init(void)
-{
-	spin_lock_init(&fw_cache.lock);
-	INIT_LIST_HEAD(&fw_cache.head);
-	fw_cache.state = FW_LOADER_NO_CACHE;
-}
-
-static int fw_shutdown_notify(struct notifier_block *unused1,
-			      unsigned long unused2, void *unused3)
-{
-	/*
-	 * Kill all pending fallback requests to avoid both stalling shutdown,
-	 * and avoid a deadlock with the usermode_lock.
-	 */
-	kill_pending_fw_fallback_reqs(true);
-
-	return NOTIFY_DONE;
-}
-
-static struct notifier_block fw_shutdown_nb = {
-	.notifier_call = fw_shutdown_notify,
-};
-
-static int __init firmware_class_init(void)
-{
-	int ret;
-
-	/* No need to unfold these on exit */
-	fw_cache_init();
-
-	ret = register_fw_pm_ops();
-	if (ret)
-		return ret;
-
-	ret = register_reboot_notifier(&fw_shutdown_nb);
-	if (ret)
-		goto out;
-
-	return register_sysfs_loader();
-
-out:
-	unregister_fw_pm_ops();
-	return ret;
-}
-
-static void __exit firmware_class_exit(void)
-{
-	unregister_fw_pm_ops();
-	unregister_reboot_notifier(&fw_shutdown_nb);
-	unregister_sysfs_loader();
-}
-
-fs_initcall(firmware_class_init);
-module_exit(firmware_class_exit);
diff -Nrup linux-6.16.7/drivers/bluetooth/hci_qca.c linux-lenovo-x13s-linux-6.16.y/drivers/bluetooth/hci_qca.c
--- linux-6.16.7/drivers/bluetooth/hci_qca.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/bluetooth/hci_qca.c	2025-09-11 09:47:42.000000000 -0600
@@ -1220,7 +1220,14 @@ static int qca_recv_event(struct hci_dev
 		 * vendor command).
 		 */
 
-		if (hdr->evt == HCI_EV_VENDOR)
+		/* For the WCN6750/WCN6855/WCN7850, like the WCN3990, the
+		 * vendor command for a baudrate change command isn't sent as
+		 * synchronous HCI command, the controller sends the corresponding
+		 * command complete event with the new baudrate. The event is
+		 * received and properly decoded after changing the baudrate of
+		 * the host port. It needs to be dropped.
+		 */
+		if (hdr->evt == HCI_EV_VENDOR || hdr->evt == HCI_EV_CMD_COMPLETE)
 			complete(&qca->drop_ev_comp);
 
 		kfree_skb(skb);
@@ -1514,6 +1521,9 @@ static int qca_set_speed(struct hci_uart
 
 		switch (soc_type) {
 		case QCA_WCN3990:
+		case QCA_WCN6750:
+		case QCA_WCN6855:
+		case QCA_WCN7850:
 			reinit_completion(&qca->drop_ev_comp);
 			set_bit(QCA_DROP_VENDOR_EVENT, &qca->flags);
 			break;
@@ -1549,6 +1559,9 @@ error:
 
 		switch (soc_type) {
 		case QCA_WCN3990:
+		case QCA_WCN6750:
+		case QCA_WCN6855:
+		case QCA_WCN7850:
 			/* Wait for the controller to send the vendor event
 			 * for the baudrate change command.
 			 */
diff -Nrup linux-6.16.7/drivers/cpuidle/cpuidle-qcom-spm.c linux-lenovo-x13s-linux-6.16.y/drivers/cpuidle/cpuidle-qcom-spm.c
--- linux-6.16.7/drivers/cpuidle/cpuidle-qcom-spm.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/cpuidle/cpuidle-qcom-spm.c	2025-09-11 09:47:42.000000000 -0600
@@ -86,9 +86,9 @@ static const struct of_device_id qcom_id
 
 static int spm_cpuidle_register(struct device *cpuidle_dev, int cpu)
 {
-	struct platform_device *pdev = NULL;
+	struct platform_device *pdev;
 	struct device_node *cpu_node, *saw_node;
-	struct cpuidle_qcom_spm_data *data = NULL;
+	struct cpuidle_qcom_spm_data *data;
 	int ret;
 
 	cpu_node = of_cpu_device_node_get(cpu);
@@ -96,20 +96,23 @@ static int spm_cpuidle_register(struct d
 		return -ENODEV;
 
 	saw_node = of_parse_phandle(cpu_node, "qcom,saw", 0);
+	of_node_put(cpu_node);
 	if (!saw_node)
 		return -ENODEV;
 
 	pdev = of_find_device_by_node(saw_node);
 	of_node_put(saw_node);
-	of_node_put(cpu_node);
 	if (!pdev)
 		return -ENODEV;
 
 	data = devm_kzalloc(cpuidle_dev, sizeof(*data), GFP_KERNEL);
-	if (!data)
+	if (!data) {
+		put_device(&pdev->dev);
 		return -ENOMEM;
+	}
 
 	data->spm = dev_get_drvdata(&pdev->dev);
+	put_device(&pdev->dev);
 	if (!data->spm)
 		return -EINVAL;
 
diff -Nrup linux-6.16.7/drivers/firmware/efi/libstub/efistub.h linux-lenovo-x13s-linux-6.16.y/drivers/firmware/efi/libstub/efistub.h
--- linux-6.16.7/drivers/firmware/efi/libstub/efistub.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/firmware/efi/libstub/efistub.h	2025-09-11 09:47:42.000000000 -0600
@@ -272,7 +272,7 @@ union efi_boot_services {
 		efi_status_t (__efiapi *wait_for_event)(unsigned long,
 							efi_event_t *,
 							unsigned long *);
-		void *signal_event;
+		efi_status_t (__efiapi *signal_event)(efi_event_t);
 		efi_status_t (__efiapi *close_event)(efi_event_t);
 		void *check_event;
 		void *install_protocol_interface;
@@ -324,7 +324,7 @@ union efi_boot_services {
 		void *calculate_crc32;
 		void (__efiapi *copy_mem)(void *, const void *, unsigned long);
 		void (__efiapi *set_mem)(void *, unsigned long, unsigned char);
-		void *create_event_ex;
+		efi_status_t (__efiapi *create_event_ex)(u32, int, void *, void *, void *, efi_event_t *);
 	};
 	struct {
 		efi_table_hdr_t hdr;
diff -Nrup linux-6.16.7/drivers/firmware/efi/libstub/efi-stub-helper.c linux-lenovo-x13s-linux-6.16.y/drivers/firmware/efi/libstub/efi-stub-helper.c
--- linux-6.16.7/drivers/firmware/efi/libstub/efi-stub-helper.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/firmware/efi/libstub/efi-stub-helper.c	2025-09-11 09:47:42.000000000 -0600
@@ -407,6 +407,13 @@ char *efi_convert_cmdline(efi_loaded_ima
 	return (char *)cmdline_addr;
 }
 
+#define EFI_EVENT_GROUP_BEFORE_EXIT_BOOT_SERVICES \
+	EFI_GUID(0x8be0e274, 0x3970, 0x4b44,  0x80, 0xc5, 0x1a, 0xb9, 0x50, 0x2f, 0x3b, 0xfc)
+
+static void efi_before_ebs_notify(efi_event_t event, void *context)
+{
+}
+
 /**
  * efi_exit_boot_services() - Exit boot services
  * @handle:	handle of the exiting image
@@ -427,10 +434,27 @@ efi_status_t efi_exit_boot_services(void
 {
 	struct efi_boot_memmap *map;
 	efi_status_t status;
+	efi_guid_t guid = EFI_EVENT_GROUP_BEFORE_EXIT_BOOT_SERVICES;
+	efi_event_t event;
 
 	if (efi_disable_pci_dma)
 		efi_pci_disable_bridge_busmaster();
 
+	status = efi_bs_call(create_event_ex, EFI_EVT_NOTIFY_SIGNAL,
+			     EFI_TPL_CALLBACK, efi_before_ebs_notify, NULL,
+			     &guid, &event);
+	if (status == EFI_SUCCESS) {
+		status = efi_bs_call(signal_event, event);
+		if (status != EFI_SUCCESS)
+			efi_err("%s - signal event failed: %02lx\n", __func__, status);
+
+		status = efi_bs_call(close_event, event);
+		if (status != EFI_SUCCESS)
+			efi_err("%s - close event failed: %02lx\n", __func__, status);
+	} else {
+		efi_err("%s - create event ex failed: %02lx\n", __func__, status);
+	}
+
 	status = efi_get_memory_map(&map, true);
 	if (status != EFI_SUCCESS)
 		return status;
diff -Nrup linux-6.16.7/drivers/firmware/psci/psci.c linux-lenovo-x13s-linux-6.16.y/drivers/firmware/psci/psci.c
--- linux-6.16.7/drivers/firmware/psci/psci.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/firmware/psci/psci.c	2025-09-11 09:47:42.000000000 -0600
@@ -79,6 +79,7 @@ struct psci_0_1_function_ids get_psci_0_
 static u32 psci_cpu_suspend_feature;
 static bool psci_system_reset2_supported;
 static bool psci_system_off2_hibernate_supported;
+static u32 psci_s2ram_suspend_param;
 
 static inline bool psci_has_ext_power_state(void)
 {
@@ -539,12 +540,22 @@ static int psci_system_suspend(unsigned
 
 static int psci_system_suspend_enter(suspend_state_t state)
 {
+	pm_set_resume_via_firmware();
+
 	return cpu_suspend(0, psci_system_suspend);
 }
 
-static const struct platform_suspend_ops psci_suspend_ops = {
-	.valid          = suspend_valid_only_mem,
-	.enter          = psci_system_suspend_enter,
+static int psci_system_suspend_begin(suspend_state_t state)
+{
+	pm_set_suspend_via_firmware();
+
+	return 0;
+}
+
+static const struct platform_suspend_ops psci_system_suspend_ops = {
+	.valid = suspend_valid_only_mem,
+	.enter = psci_system_suspend_enter,
+	.begin = psci_system_suspend_begin,
 };
 
 static void __init psci_init_system_reset2(void)
@@ -579,7 +590,7 @@ static void __init psci_init_system_susp
 	ret = psci_features(PSCI_FN_NATIVE(1_0, SYSTEM_SUSPEND));
 
 	if (ret != PSCI_RET_NOT_SUPPORTED)
-		suspend_set_ops(&psci_suspend_ops);
+		suspend_set_ops(&psci_system_suspend_ops);
 }
 
 static void __init psci_init_cpu_suspend(void)
@@ -708,6 +719,17 @@ static int __init psci_probe(void)
 
 typedef int (*psci_initcall_t)(const struct device_node *);
 
+static int psci_cpu_suspend_s2ram_enter(suspend_state_t state)
+{
+	return psci_cpu_suspend_enter(psci_s2ram_suspend_param);
+}
+
+static const struct platform_suspend_ops psci_cpu_suspend_s2ram_ops = {
+	.valid = suspend_valid_only_mem,
+	.enter = psci_cpu_suspend_s2ram_enter,
+	.begin = psci_system_suspend_begin,
+};
+
 /*
  * PSCI init function for PSCI versions >=0.2
  *
@@ -722,6 +744,20 @@ static int __init psci_0_2_init(const st
 		return err;
 
 	/*
+	 * Some firmwares expose S2RAM entry through a custom suspend param.
+	 *
+	 * If found, register a suspend handler instead of registering the
+	 * idle state with cpuidle.
+	 */
+	err = of_property_read_u32(np, "arm,psci-s2ram-param", &psci_s2ram_suspend_param);
+	if (!err) {
+		suspend_set_ops(&psci_cpu_suspend_s2ram_ops);
+	} else if (err != -EINVAL) {
+		pr_err("Couldn't read the S2RAM PSCI suspend param: %d\n",
+		       psci_s2ram_suspend_param);
+	}
+
+	/*
 	 * Starting with v0.2, the PSCI specification introduced a call
 	 * (PSCI_VERSION) that allows probing the firmware version, so
 	 * that PSCI function IDs and version specific initialization
diff -Nrup linux-6.16.7/drivers/gpu/drm/display/drm_dp_helper.c linux-lenovo-x13s-linux-6.16.y/drivers/gpu/drm/display/drm_dp_helper.c
--- linux-6.16.7/drivers/gpu/drm/display/drm_dp_helper.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/gpu/drm/display/drm_dp_helper.c	2025-09-11 09:47:42.000000000 -0600
@@ -28,6 +28,7 @@
 #include <linux/init.h>
 #include <linux/iopoll.h>
 #include <linux/kernel.h>
+#include <linux/minmax.h>
 #include <linux/module.h>
 #include <linux/sched.h>
 #include <linux/seq_file.h>
@@ -4111,6 +4112,32 @@ drm_edp_backlight_probe_max(struct drm_d
 	}
 
 	pn &= DP_EDP_PWMGEN_BIT_COUNT_MASK;
+
+	ret = drm_dp_dpcd_read_byte(aux, DP_EDP_PWMGEN_BIT_COUNT_CAP_MIN, &pn_min);
+	if (ret < 0) {
+		drm_dbg_kms(aux->drm_dev, "%s: Failed to read pwmgen bit count cap min: %d\n",
+			    aux->name, ret);
+		return -ENODEV;
+	}
+	pn_min &= DP_EDP_PWMGEN_BIT_COUNT_MASK;
+
+	ret = drm_dp_dpcd_read_byte(aux, DP_EDP_PWMGEN_BIT_COUNT_CAP_MAX, &pn_max);
+	if (ret < 0) {
+		drm_dbg_kms(aux->drm_dev, "%s: Failed to read pwmgen bit count cap max: %d\n",
+			    aux->name, ret);
+		return -ENODEV;
+	}
+	pn_max &= DP_EDP_PWMGEN_BIT_COUNT_MASK;
+
+	/*
+	 * Per VESA eDP Spec v1.4b, section 3.3.10.2:
+	 * If DP_EDP_PWMGEN_BIT_COUNT is less than DP_EDP_PWMGEN_BIT_COUNT_CAP_MIN,
+	 * the sink must use the MIN value as the effective PWM bit count.
+	 * Clamp the reported value to the [MIN, MAX] capability range to ensure
+	 * correct brightness scaling on compliant eDP panels.
+	 */
+	pn = clamp(pn, pn_min, pn_max);
+
 	bl->max = (1 << pn) - 1;
 	if (!driver_pwm_freq_hz)
 		return 0;
@@ -4137,20 +4164,6 @@ drm_edp_backlight_probe_max(struct drm_d
 	 * - FxP is within 25% of desired value.
 	 *   Note: 25% is arbitrary value and may need some tweak.
 	 */
-	ret = drm_dp_dpcd_read_byte(aux, DP_EDP_PWMGEN_BIT_COUNT_CAP_MIN, &pn_min);
-	if (ret < 0) {
-		drm_dbg_kms(aux->drm_dev, "%s: Failed to read pwmgen bit count cap min: %d\n",
-			    aux->name, ret);
-		return 0;
-	}
-	ret = drm_dp_dpcd_read_byte(aux, DP_EDP_PWMGEN_BIT_COUNT_CAP_MAX, &pn_max);
-	if (ret < 0) {
-		drm_dbg_kms(aux->drm_dev, "%s: Failed to read pwmgen bit count cap max: %d\n",
-			    aux->name, ret);
-		return 0;
-	}
-	pn_min &= DP_EDP_PWMGEN_BIT_COUNT_MASK;
-	pn_max &= DP_EDP_PWMGEN_BIT_COUNT_MASK;
 
 	/* Ensure frequency is within 25% of desired value */
 	fxp_min = DIV_ROUND_CLOSEST(fxp * 3, 4);
diff -Nrup linux-6.16.7/drivers/gpu/drm/panel/panel-edp.c linux-lenovo-x13s-linux-6.16.y/drivers/gpu/drm/panel/panel-edp.c
--- linux-6.16.7/drivers/gpu/drm/panel/panel-edp.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/gpu/drm/panel/panel-edp.c	2025-09-11 09:47:42.000000000 -0600
@@ -1923,6 +1923,7 @@ static const struct edp_panel_entry edp_
 	EDP_PANEL_ENTRY('B', 'O', 'E', 0x094b, &delay_200_500_e50, "NT116WHM-N21"),
 	EDP_PANEL_ENTRY('B', 'O', 'E', 0x0951, &delay_200_500_e80, "NV116WHM-N47"),
 	EDP_PANEL_ENTRY('B', 'O', 'E', 0x095f, &delay_200_500_e50, "NE135FBM-N41 v8.1"),
+	EDP_PANEL_ENTRY('B', 'O', 'E', 0x0964, &delay_200_500_e50, "NV116WUM-N61"),
 	EDP_PANEL_ENTRY('B', 'O', 'E', 0x096e, &delay_200_500_e50_po2e200, "NV116WHM-T07 V8.0"),
 	EDP_PANEL_ENTRY('B', 'O', 'E', 0x0979, &delay_200_500_e50, "NV116WHM-N49 V8.0"),
 	EDP_PANEL_ENTRY('B', 'O', 'E', 0x098d, &boe_nv110wtm_n61.delay, "NV110WTM-N61"),
@@ -1935,6 +1936,7 @@ static const struct edp_panel_entry edp_
 	EDP_PANEL_ENTRY('B', 'O', 'E', 0x0a3e, &delay_200_500_e80, "NV116WHM-N49"),
 	EDP_PANEL_ENTRY('B', 'O', 'E', 0x0a5d, &delay_200_500_e50, "NV116WHM-N45"),
 	EDP_PANEL_ENTRY('B', 'O', 'E', 0x0ac5, &delay_200_500_e50, "NV116WHM-N4C"),
+	EDP_PANEL_ENTRY('B', 'O', 'E', 0x0a84, &delay_200_500_e50, "NV133WUM-T01"),
 	EDP_PANEL_ENTRY('B', 'O', 'E', 0x0ae8, &delay_200_500_e50_p2e80, "NV140WUM-N41"),
 	EDP_PANEL_ENTRY('B', 'O', 'E', 0x0b09, &delay_200_500_e50_po2e200, "NV140FHM-NZ"),
 	EDP_PANEL_ENTRY('B', 'O', 'E', 0x0b34, &delay_200_500_e80, "NV122WUM-N41"),
diff -Nrup linux-6.16.7/drivers/i2c/busses/i2c-qcom-cci.c linux-lenovo-x13s-linux-6.16.y/drivers/i2c/busses/i2c-qcom-cci.c
--- linux-6.16.7/drivers/i2c/busses/i2c-qcom-cci.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/i2c/busses/i2c-qcom-cci.c	2025-09-11 09:47:42.000000000 -0600
@@ -10,6 +10,7 @@
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/platform_device.h>
+#include <linux/pm_opp.h>
 #include <linux/pm_runtime.h>
 
 #define CCI_HW_VERSION				0x0
@@ -121,6 +122,7 @@ struct cci_data {
 	struct i2c_adapter_quirks quirks;
 	u16 queue_size[NUM_QUEUES];
 	struct hw_params params[3];
+	bool fast_mode_plus_supported;
 };
 
 struct cci {
@@ -466,21 +468,25 @@ static const struct i2c_algorithm cci_al
 	.functionality = cci_func,
 };
 
-static int cci_enable_clocks(struct cci *cci)
+static unsigned long cci_desired_clk_rate(struct cci *cci)
 {
-	return clk_bulk_prepare_enable(cci->nclocks, cci->clocks);
-}
+	if (cci->data->fast_mode_plus_supported)
+		return 37500000ULL;
 
-static void cci_disable_clocks(struct cci *cci)
-{
-	clk_bulk_disable_unprepare(cci->nclocks, cci->clocks);
+	return 19200000ULL;
 }
 
 static int __maybe_unused cci_suspend_runtime(struct device *dev)
 {
 	struct cci *cci = dev_get_drvdata(dev);
+	int ret;
+
+	ret = dev_pm_opp_set_rate(dev, 0);
+	if (ret)
+		return ret;
+
+	clk_bulk_disable_unprepare(cci->nclocks, cci->clocks);
 
-	cci_disable_clocks(cci);
 	return 0;
 }
 
@@ -489,11 +495,16 @@ static int __maybe_unused cci_resume_run
 	struct cci *cci = dev_get_drvdata(dev);
 	int ret;
 
-	ret = cci_enable_clocks(cci);
+	ret = clk_bulk_prepare_enable(cci->nclocks, cci->clocks);
+	if (ret)
+		return ret;
+
+	ret = dev_pm_opp_set_rate(dev, cci_desired_clk_rate(cci));
 	if (ret)
 		return ret;
 
 	cci_init(cci);
+
 	return 0;
 }
 
@@ -592,10 +603,23 @@ static int cci_probe(struct platform_dev
 		return dev_err_probe(dev, -EINVAL, "not enough clocks in DT\n");
 	cci->nclocks = ret;
 
-	ret = cci_enable_clocks(cci);
+	ret = clk_bulk_prepare_enable(cci->nclocks, cci->clocks);
 	if (ret < 0)
 		return ret;
 
+	ret = devm_pm_opp_set_clkname(dev, "cci");
+	if (ret)
+		return ret;
+
+	/* OPP table is optional */
+	ret = devm_pm_opp_of_add_table(dev);
+	if (ret && ret != -ENODEV)
+		return dev_err_probe(dev, ret, "invalid OPP table in device tree\n");
+
+	ret = dev_pm_opp_set_rate(dev, cci_desired_clk_rate(cci));
+	if (ret)
+		return ret;
+
 	/* Interrupt */
 
 	ret = platform_get_irq(pdev, 0);
@@ -651,7 +675,7 @@ error_i2c:
 error:
 	disable_irq(cci->irq);
 disable_clocks:
-	cci_disable_clocks(cci);
+	clk_bulk_disable_unprepare(cci->nclocks, cci->clocks);
 
 	return ret;
 }
@@ -783,6 +807,7 @@ static const struct cci_data cci_v2_data
 		.trdhld = 3,
 		.tsp = 3
 	},
+	.fast_mode_plus_supported = true,
 };
 
 static const struct of_device_id cci_dt_match[] = {
diff -Nrup linux-6.16.7/drivers/leds/led-class.c linux-lenovo-x13s-linux-6.16.y/drivers/leds/led-class.c
--- linux-6.16.7/drivers/leds/led-class.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/leds/led-class.c	2025-09-11 09:47:42.000000000 -0600
@@ -252,15 +252,23 @@ static const struct class leds_class = {
  * of_led_get() - request a LED device via the LED framework
  * @np: device node to get the LED device from
  * @index: the index of the LED
+ * @name: the name of the LED used to map it to its function, if present
  *
  * Returns the LED device parsed from the phandle specified in the "leds"
  * property of a device tree node or a negative error-code on failure.
  */
-struct led_classdev *of_led_get(struct device_node *np, int index)
+static struct led_classdev *of_led_get(struct device_node *np, int index,
+				       const char *name)
 {
 	struct device *led_dev;
 	struct device_node *led_node;
 
+	/*
+	 * For named LEDs, first look up the name in the "led-names" property.
+	 * If it cannot be found, then of_parse_phandle() will propagate the error.
+	 */
+	if (name)
+		index = of_property_match_string(np, "led-names", name);
 	led_node = of_parse_phandle(np, "leds", index);
 	if (!led_node)
 		return ERR_PTR(-ENOENT);
@@ -270,7 +278,6 @@ struct led_classdev *of_led_get(struct d
 
 	return led_module_get(led_dev);
 }
-EXPORT_SYMBOL_GPL(of_led_get);
 
 /**
  * led_put() - release a LED device
@@ -325,7 +332,7 @@ struct led_classdev *__must_check devm_o
 	if (!dev)
 		return ERR_PTR(-EINVAL);
 
-	led = of_led_get(dev->of_node, index);
+	led = of_led_get(dev->of_node, index, NULL);
 	if (IS_ERR(led))
 		return led;
 
@@ -343,9 +350,14 @@ EXPORT_SYMBOL_GPL(devm_of_led_get);
 struct led_classdev *led_get(struct device *dev, char *con_id)
 {
 	struct led_lookup_data *lookup;
+	struct led_classdev *led_cdev;
 	const char *provider = NULL;
 	struct device *led_dev;
 
+	led_cdev = of_led_get(dev->of_node, -1, con_id);
+	if (!IS_ERR(led_cdev) || PTR_ERR(led_cdev) != -ENOENT)
+		return led_cdev;
+
 	mutex_lock(&leds_lookup_lock);
 	list_for_each_entry(lookup, &leds_lookup_list, list) {
 		if (!strcmp(lookup->dev_id, dev_name(dev)) &&
diff -Nrup linux-6.16.7/drivers/media/platform/qcom/camss/camss.c linux-lenovo-x13s-linux-6.16.y/drivers/media/platform/qcom/camss/camss.c
--- linux-6.16.7/drivers/media/platform/qcom/camss/camss.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/media/platform/qcom/camss/camss.c	2025-09-11 09:47:42.000000000 -0600
@@ -2845,6 +2845,14 @@ struct media_pad *camss_find_sensor_pad(
 
 	while (1) {
 		pad = &entity->pads[0];
+
+		/*
+		 * Work around unresolved bug in camss (or v4l2) which can
+		 * result in pad being NULL here.
+		 */
+		if (WARN_ON(!pad))
+			return NULL;
+
 		if (!(pad->flags & MEDIA_PAD_FL_SINK))
 			return NULL;
 
diff -Nrup linux-6.16.7/drivers/media/platform/qcom/camss/camss-vfe.c linux-lenovo-x13s-linux-6.16.y/drivers/media/platform/qcom/camss/camss-vfe.c
--- linux-6.16.7/drivers/media/platform/qcom/camss/camss-vfe.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/media/platform/qcom/camss/camss-vfe.c	2025-09-11 09:47:42.000000000 -0600
@@ -871,7 +871,7 @@ void vfe_isr_reset_ack(struct vfe_device
  */
 void vfe_pm_domain_off(struct vfe_device *vfe)
 {
-	if (!vfe->genpd)
+	if (!vfe->genpd_link)
 		return;
 
 	device_link_del(vfe->genpd_link);
diff -Nrup linux-6.16.7/drivers/media/platform/qcom/camss/camss-video.c linux-lenovo-x13s-linux-6.16.y/drivers/media/platform/qcom/camss/camss-video.c
--- linux-6.16.7/drivers/media/platform/qcom/camss/camss-video.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/media/platform/qcom/camss/camss-video.c	2025-09-11 09:47:42.000000000 -0600
@@ -225,6 +225,21 @@ static int video_check_format(struct cam
 	return 0;
 }
 
+static int video_prepare_streaming(struct vb2_queue *q)
+{
+	struct camss_video *video = vb2_get_drv_priv(q);
+	struct video_device *vdev = &video->vdev;
+	int ret;
+
+	ret = v4l2_pipeline_pm_get(&vdev->entity);
+	if (ret < 0) {
+		dev_err(video->camss->dev, "Failed to power up pipeline: %d\n",
+			ret);
+	}
+
+	return ret;
+}
+
 static int video_start_streaming(struct vb2_queue *q, unsigned int count)
 {
 	struct camss_video *video = vb2_get_drv_priv(q);
@@ -308,13 +323,23 @@ static void video_stop_streaming(struct
 	video->ops->flush_buffers(video, VB2_BUF_STATE_ERROR);
 }
 
+static void video_unprepare_streaming(struct vb2_queue *q)
+{
+	struct camss_video *video = vb2_get_drv_priv(q);
+	struct video_device *vdev = &video->vdev;
+
+	v4l2_pipeline_pm_put(&vdev->entity);
+}
+
 static const struct vb2_ops msm_video_vb2_q_ops = {
 	.queue_setup     = video_queue_setup,
 	.buf_init        = video_buf_init,
 	.buf_prepare     = video_buf_prepare,
 	.buf_queue       = video_buf_queue,
+	.prepare_streaming = video_prepare_streaming,
 	.start_streaming = video_start_streaming,
 	.stop_streaming  = video_stop_streaming,
+	.unprepare_streaming = video_unprepare_streaming,
 };
 
 /* -----------------------------------------------------------------------------
@@ -599,20 +624,10 @@ static int video_open(struct file *file)
 
 	file->private_data = vfh;
 
-	ret = v4l2_pipeline_pm_get(&vdev->entity);
-	if (ret < 0) {
-		dev_err(video->camss->dev, "Failed to power up pipeline: %d\n",
-			ret);
-		goto error_pm_use;
-	}
-
 	mutex_unlock(&video->lock);
 
 	return 0;
 
-error_pm_use:
-	v4l2_fh_release(file);
-
 error_alloc:
 	mutex_unlock(&video->lock);
 
@@ -621,12 +636,8 @@ error_alloc:
 
 static int video_release(struct file *file)
 {
-	struct video_device *vdev = video_devdata(file);
-
 	vb2_fop_release(file);
 
-	v4l2_pipeline_pm_put(&vdev->entity);
-
 	file->private_data = NULL;
 
 	return 0;
diff -Nrup linux-6.16.7/drivers/media/platform/qcom/venus/core.c linux-lenovo-x13s-linux-6.16.y/drivers/media/platform/qcom/venus/core.c
--- linux-6.16.7/drivers/media/platform/qcom/venus/core.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/media/platform/qcom/venus/core.c	2025-09-11 09:47:42.000000000 -0600
@@ -393,6 +393,15 @@ static int venus_probe(struct platform_d
 	if (IS_ERR(core->cpucfg_path))
 		return PTR_ERR(core->cpucfg_path);
 
+	core->llcc_path = devm_of_icc_get(dev, "video-llcc");
+	if (IS_ERR(core->llcc_path)) {
+		/* LLCC path is optional */
+		if (PTR_ERR(core->llcc_path) == -ENODATA)
+			core->llcc_path = NULL;
+		else
+			return PTR_ERR(core->llcc_path);
+	}
+
 	core->irq = platform_get_irq(pdev, 0);
 	if (core->irq < 0)
 		return core->irq;
@@ -581,12 +590,18 @@ static __maybe_unused int venus_runtime_
 	if (ret)
 		goto err_cpucfg_path;
 
+	ret = icc_set_bw(core->llcc_path, 0, 0);
+	if (ret)
+		goto err_llcc_path;
+
 	ret = icc_set_bw(core->video_path, 0, 0);
 	if (ret)
 		goto err_video_path;
 
 	return ret;
 
+err_llcc_path:
+	icc_set_bw(core->video_path, kbps_to_icc(20000), 0);
 err_video_path:
 	icc_set_bw(core->cpucfg_path, kbps_to_icc(1000), 0);
 err_cpucfg_path:
@@ -626,6 +641,10 @@ static __maybe_unused int venus_runtime_
 	if (ret)
 		return ret;
 
+	ret = icc_set_bw(core->llcc_path, kbps_to_icc(20000), 0);
+	if (ret)
+		return ret;
+
 	ret = icc_set_bw(core->cpucfg_path, kbps_to_icc(1000), 0);
 	if (ret)
 		return ret;
@@ -993,6 +1012,46 @@ static const struct venus_resources sm82
 	.enc_nodename = "video-encoder",
 };
 
+static const struct reg_val sm8350_reg_preset[] = {
+	{ 0xb0088, 0, 0x11 },
+};
+
+static const struct venus_resources sm8350_res = {
+	.freq_tbl = sm8250_freq_table,
+	.freq_tbl_size = ARRAY_SIZE(sm8250_freq_table),
+	.reg_tbl = sm8350_reg_preset,
+	.reg_tbl_size = ARRAY_SIZE(sm8350_reg_preset),
+	.bw_tbl_enc = sm8250_bw_table_enc,
+	.bw_tbl_enc_size = ARRAY_SIZE(sm8250_bw_table_enc),
+	.bw_tbl_dec = sm8250_bw_table_dec,
+	.bw_tbl_dec_size = ARRAY_SIZE(sm8250_bw_table_dec),
+	.clks = { "core", "iface" },
+	.clks_num = 2,
+	.resets = { "core" },
+	.resets_num = 1,
+	.vcodec0_clks = { "vcodec0_core" },
+	.vcodec_clks_num = 1,
+	.vcodec_pmdomains = (const char *[]) { "venus", "vcodec0" },
+	.vcodec_pmdomains_num = 2,
+	.opp_pmdomain = (const char *[]) { "mx", NULL },
+	.vcodec_num = 1,
+	.max_load = 7833600, /* 7680x4320@60fps */
+	.hfi_version = HFI_VERSION_6XX,
+	.vpu_version = VPU_VERSION_IRIS2,
+	.num_vpp_pipes = 4,
+	.vmem_id = VIDC_RESOURCE_NONE,
+	.vmem_size = 0,
+	.vmem_addr = 0,
+	.dma_mask = GENMASK(31, 29) - 1,
+	.cp_start = 0,
+	.cp_size = 0x25800000,
+	.cp_nonpixel_start = 0x1000000,
+	.cp_nonpixel_size = 0x24800000,
+	.fwname = "qcom/vpu-2.0/venus.mbn",
+	.dec_nodename = "video-decoder",
+	.enc_nodename = "video-encoder",
+};
+
 static const struct freq_tbl sc7280_freq_table[] = {
 	{ 0, 460000000 },
 	{ 0, 424000000 },
@@ -1057,16 +1116,62 @@ static const struct venus_resources sc72
 	.enc_nodename = "video-encoder",
 };
 
+static const struct freq_tbl sc8280xp_freq_table[] = {
+	{ 0, 239999999 },
+	{ 0, 338000000 },
+	{ 0, 366000000 },
+	{ 0, 444000000 },
+	{ 0, 533000000 },
+	{ 0, 560000000 },
+};
+
+static const struct venus_resources sc8280xp_res = {
+	.freq_tbl = sc8280xp_freq_table,
+	.freq_tbl_size = ARRAY_SIZE(sc8280xp_freq_table),
+	.reg_tbl = sm8350_reg_preset,
+	.reg_tbl_size = ARRAY_SIZE(sm8350_reg_preset),
+	.bw_tbl_enc = sm8250_bw_table_enc,
+	.bw_tbl_enc_size = ARRAY_SIZE(sm8250_bw_table_enc),
+	.bw_tbl_dec = sm8250_bw_table_dec,
+	.bw_tbl_dec_size = ARRAY_SIZE(sm8250_bw_table_dec),
+	.clks = { "core", "iface" },
+	.clks_num = 2,
+	.resets = { "core" },
+	.resets_num = 1,
+	.vcodec0_clks = { "vcodec0_core" },
+	.vcodec_clks_num = 1,
+	.vcodec_pmdomains = (const char *[]) { "venus", "vcodec0" },
+	.vcodec_pmdomains_num = 2,
+	.opp_pmdomain = (const char *[]) { "mx", NULL },
+	.vcodec_num = 1,
+	.max_load = 7833600, /* 7680x4320@60fps */
+	.hfi_version = HFI_VERSION_6XX,
+	.vpu_version = VPU_VERSION_IRIS2,
+	.num_vpp_pipes = 4,
+	.vmem_id = VIDC_RESOURCE_NONE,
+	.vmem_size = 0,
+	.vmem_addr = 0,
+	.dma_mask = GENMASK(31, 29) - 1,
+	.cp_start = 0,
+	.cp_size = 0x25800000,
+	.cp_nonpixel_start = 0x1000000,
+	.cp_nonpixel_size = 0x24800000,
+	.fwname = "qcom/vpu-2.0/venus.mbn",
+};
+
+
 static const struct of_device_id venus_dt_match[] = {
-	{ .compatible = "qcom,msm8916-venus", .data = &msm8916_res, },
-	{ .compatible = "qcom,msm8996-venus", .data = &msm8996_res, },
-	{ .compatible = "qcom,msm8998-venus", .data = &msm8998_res, },
-	{ .compatible = "qcom,sdm660-venus", .data = &sdm660_res, },
-	{ .compatible = "qcom,sdm845-venus", .data = &sdm845_res, },
-	{ .compatible = "qcom,sdm845-venus-v2", .data = &sdm845_res_v2, },
-	{ .compatible = "qcom,sc7180-venus", .data = &sc7180_res, },
-	{ .compatible = "qcom,sc7280-venus", .data = &sc7280_res, },
-	{ .compatible = "qcom,sm8250-venus", .data = &sm8250_res, },
+	{ .compatible = "qcom,msm8916-venus", .data = &msm8916_res },
+	{ .compatible = "qcom,msm8996-venus", .data = &msm8996_res },
+	{ .compatible = "qcom,msm8998-venus", .data = &msm8998_res },
+	{ .compatible = "qcom,sdm660-venus", .data = &sdm660_res },
+	{ .compatible = "qcom,sdm845-venus", .data = &sdm845_res },
+	{ .compatible = "qcom,sdm845-venus-v2", .data = &sdm845_res_v2 },
+	{ .compatible = "qcom,sc7180-venus", .data = &sc7180_res },
+	{ .compatible = "qcom,sc7280-venus", .data = &sc7280_res },
+	{ .compatible = "qcom,sc8280xp-venus", .data = &sc8280xp_res },
+	{ .compatible = "qcom,sm8250-venus", .data = &sm8250_res },
+	{ .compatible = "qcom,sm8350-venus", .data = &sm8350_res },
 	{ }
 };
 MODULE_DEVICE_TABLE(of, venus_dt_match);
diff -Nrup linux-6.16.7/drivers/media/platform/qcom/venus/core.h linux-lenovo-x13s-linux-6.16.y/drivers/media/platform/qcom/venus/core.h
--- linux-6.16.7/drivers/media/platform/qcom/venus/core.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/media/platform/qcom/venus/core.h	2025-09-11 09:47:42.000000000 -0600
@@ -40,6 +40,7 @@ struct freq_tbl {
 struct reg_val {
 	u32 reg;
 	u32 value;
+	u32 mask;
 };
 
 struct bw_tbl {
@@ -66,6 +67,7 @@ struct venus_resources {
 	unsigned int bw_tbl_enc_size;
 	const struct bw_tbl *bw_tbl_dec;
 	unsigned int bw_tbl_dec_size;
+	bool has_llcc_path;
 	const struct reg_val *reg_tbl;
 	unsigned int reg_tbl_size;
 	const struct hfi_ubwc_config *ubwc_conf;
@@ -137,6 +139,7 @@ struct venus_format {
  * @vcodec1_clks: an array of vcodec1 struct clk pointers
  * @video_path: an interconnect handle to video to/from memory path
  * @cpucfg_path: an interconnect handle to cpu configuration path
+ * @llcc_path: an interconnect handle to video to/from llcc path
  * @pmdomains:	a pointer to a list of pmdomains
  * @opp_pmdomain: an OPP power-domain
  * @resets: an array of reset signals
@@ -191,6 +194,7 @@ struct venus_core {
 	struct clk *vcodec1_clks[VIDC_VCODEC_CLKS_NUM_MAX];
 	struct icc_path *video_path;
 	struct icc_path *cpucfg_path;
+	struct icc_path *llcc_path;
 	struct dev_pm_domain_list *pmdomains;
 	struct dev_pm_domain_list *opp_pmdomain;
 	struct reset_control *resets[VIDC_RESETS_NUM_MAX];
diff -Nrup linux-6.16.7/drivers/media/platform/qcom/venus/hfi_venus.c linux-lenovo-x13s-linux-6.16.y/drivers/media/platform/qcom/venus/hfi_venus.c
--- linux-6.16.7/drivers/media/platform/qcom/venus/hfi_venus.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/media/platform/qcom/venus/hfi_venus.c	2025-09-11 09:47:42.000000000 -0600
@@ -369,10 +369,19 @@ static void venus_set_registers(struct v
 	const struct venus_resources *res = hdev->core->res;
 	const struct reg_val *tbl = res->reg_tbl;
 	unsigned int count = res->reg_tbl_size;
-	unsigned int i;
+	unsigned int i, val;
 
-	for (i = 0; i < count; i++)
-		writel(tbl[i].value, hdev->core->base + tbl[i].reg);
+	for (i = 0; i < count; i++) {
+		val = tbl[i].value;
+
+		/* In some cases, we only want to update certain bits */
+		if (tbl[i].mask) {
+			val = readl(hdev->core->base + tbl[i].reg);
+			val = (val & ~tbl[i].mask) | (tbl[i].value & tbl[i].mask);
+		}
+
+		writel(val, hdev->core->base + tbl[i].reg);
+	}
 }
 
 static void venus_soft_int(struct venus_hfi_device *hdev)
diff -Nrup linux-6.16.7/drivers/media/platform/qcom/venus/pm_helpers.c linux-lenovo-x13s-linux-6.16.y/drivers/media/platform/qcom/venus/pm_helpers.c
--- linux-6.16.7/drivers/media/platform/qcom/venus/pm_helpers.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/media/platform/qcom/venus/pm_helpers.c	2025-09-11 09:47:42.000000000 -0600
@@ -237,6 +237,9 @@ static int load_scale_bw(struct venus_co
 	dev_dbg(core->dev, VDBGL "total: avg_bw: %u, peak_bw: %u\n",
 		total_avg, total_peak);
 
+	if (core->res->has_llcc_path)
+		icc_set_bw(core->llcc_path, total_avg, total_peak);
+
 	return icc_set_bw(core->video_path, total_avg, total_peak);
 }
 
diff -Nrup linux-6.16.7/drivers/media/v4l2-core/v4l2-subdev.c linux-lenovo-x13s-linux-6.16.y/drivers/media/v4l2-core/v4l2-subdev.c
--- linux-6.16.7/drivers/media/v4l2-core/v4l2-subdev.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/media/v4l2-core/v4l2-subdev.c	2025-09-11 09:47:42.000000000 -0600
@@ -2563,7 +2563,7 @@ EXPORT_SYMBOL_GPL(v4l2_subdev_is_streami
 int v4l2_subdev_get_privacy_led(struct v4l2_subdev *sd)
 {
 #if IS_REACHABLE(CONFIG_LEDS_CLASS)
-	sd->privacy_led = led_get(sd->dev, "privacy-led");
+	sd->privacy_led = led_get(sd->dev, "privacy");
 	if (IS_ERR(sd->privacy_led) && PTR_ERR(sd->privacy_led) != -ENOENT)
 		return dev_err_probe(sd->dev, PTR_ERR(sd->privacy_led),
 				     "getting privacy LED\n");
diff -Nrup linux-6.16.7/drivers/net/wireless/ath/ath11k/core.c linux-lenovo-x13s-linux-6.16.y/drivers/net/wireless/ath/ath11k/core.c
--- linux-6.16.7/drivers/net/wireless/ath/ath11k/core.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/net/wireless/ath/ath11k/core.c	2025-09-11 09:47:42.000000000 -0600
@@ -2581,10 +2581,15 @@ int ath11k_core_init(struct ath11k_base
 	ret = ath11k_core_soc_create(ab);
 	if (ret) {
 		ath11k_err(ab, "failed to create soc core: %d\n", ret);
-		return ret;
+		goto err_unregister_pm_notifier;
 	}
 
 	return 0;
+
+err_unregister_pm_notifier:
+	ath11k_core_pm_notifier_unregister(ab);
+
+	return ret;
 }
 EXPORT_SYMBOL(ath11k_core_init);
 
diff -Nrup linux-6.16.7/drivers/net/wireless/ath/ath11k/dp_rx.c linux-lenovo-x13s-linux-6.16.y/drivers/net/wireless/ath/ath11k/dp_rx.c
--- linux-6.16.7/drivers/net/wireless/ath/ath11k/dp_rx.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/net/wireless/ath/ath11k/dp_rx.c	2025-09-11 09:47:42.000000000 -0600
@@ -2537,7 +2537,7 @@ static int ath11k_dp_rx_process_msdu(str
 	lrx_desc = (struct hal_rx_desc *)last_buf->data;
 	rx_attention = ath11k_dp_rx_get_attention(ab, lrx_desc);
 	if (!ath11k_dp_rx_h_attn_msdu_done(rx_attention)) {
-		ath11k_warn(ab, "msdu_done bit in attention is not set\n");
+		/* ath11k_warn(ab, "msdu_done bit in attention is not set\n"); */
 		ret = -EIO;
 		goto free_out;
 	}
@@ -2637,7 +2637,7 @@ int ath11k_dp_process_rx(struct ath11k_b
 	struct ath11k *ar;
 	struct hal_reo_dest_ring *desc;
 	enum hal_reo_dest_ring_push_reason push_reason;
-	u32 cookie, info0, rx_msdu_info0, rx_mpdu_info0;
+	u32 cookie;
 	int i;
 
 	for (i = 0; i < MAX_RADIOS; i++)
@@ -2654,7 +2654,7 @@ try_again:
 	      (struct hal_reo_dest_ring *)ath11k_hal_srng_dst_get_next_entry(ab,
 									     srng))) {
 		cookie = FIELD_GET(BUFFER_ADDR_INFO1_SW_COOKIE,
-				   READ_ONCE(desc->buf_addr_info.info1));
+				   desc->buf_addr_info.info1);
 		buf_id = FIELD_GET(DP_RXDMA_BUF_COOKIE_BUF_ID,
 				   cookie);
 		mac_id = FIELD_GET(DP_RXDMA_BUF_COOKIE_PDEV_ID, cookie);
@@ -2683,9 +2683,8 @@ try_again:
 
 		num_buffs_reaped[mac_id]++;
 
-		info0 = READ_ONCE(desc->info0);
 		push_reason = FIELD_GET(HAL_REO_DEST_RING_INFO0_PUSH_REASON,
-					info0);
+					desc->info0);
 		if (unlikely(push_reason !=
 			     HAL_REO_DEST_RING_PUSH_REASON_ROUTING_INSTRUCTION)) {
 			dev_kfree_skb_any(msdu);
@@ -2693,21 +2692,18 @@ try_again:
 			continue;
 		}
 
-		rx_msdu_info0 = READ_ONCE(desc->rx_msdu_info.info0);
-		rx_mpdu_info0 = READ_ONCE(desc->rx_mpdu_info.info0);
-
-		rxcb->is_first_msdu = !!(rx_msdu_info0 &
+		rxcb->is_first_msdu = !!(desc->rx_msdu_info.info0 &
 					 RX_MSDU_DESC_INFO0_FIRST_MSDU_IN_MPDU);
-		rxcb->is_last_msdu = !!(rx_msdu_info0 &
+		rxcb->is_last_msdu = !!(desc->rx_msdu_info.info0 &
 					RX_MSDU_DESC_INFO0_LAST_MSDU_IN_MPDU);
-		rxcb->is_continuation = !!(rx_msdu_info0 &
+		rxcb->is_continuation = !!(desc->rx_msdu_info.info0 &
 					   RX_MSDU_DESC_INFO0_MSDU_CONTINUATION);
 		rxcb->peer_id = FIELD_GET(RX_MPDU_DESC_META_DATA_PEER_ID,
-					  READ_ONCE(desc->rx_mpdu_info.meta_data));
+					  desc->rx_mpdu_info.meta_data);
 		rxcb->seq_no = FIELD_GET(RX_MPDU_DESC_INFO0_SEQ_NUM,
-					 rx_mpdu_info0);
+					 desc->rx_mpdu_info.info0);
 		rxcb->tid = FIELD_GET(HAL_REO_DEST_RING_INFO0_RX_QUEUE_NUM,
-				      info0);
+				      desc->info0);
 
 		rxcb->mac_id = mac_id;
 		__skb_queue_tail(&msdu_list[mac_id], msdu);
diff -Nrup linux-6.16.7/drivers/net/wireless/ath/ath11k/hal.c linux-lenovo-x13s-linux-6.16.y/drivers/net/wireless/ath/ath11k/hal.c
--- linux-6.16.7/drivers/net/wireless/ath/ath11k/hal.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/net/wireless/ath/ath11k/hal.c	2025-09-11 09:47:42.000000000 -0600
@@ -599,7 +599,7 @@ u32 ath11k_hal_ce_dst_status_get_length(
 	struct hal_ce_srng_dst_status_desc *desc = buf;
 	u32 len;
 
-	len = FIELD_GET(HAL_CE_DST_STATUS_DESC_FLAGS_LEN, READ_ONCE(desc->flags));
+	len = FIELD_GET(HAL_CE_DST_STATUS_DESC_FLAGS_LEN, desc->flags);
 	desc->flags &= ~HAL_CE_DST_STATUS_DESC_FLAGS_LEN;
 
 	return len;
diff -Nrup linux-6.16.7/drivers/net/wireless/ath/ath12k/hal.c linux-lenovo-x13s-linux-6.16.y/drivers/net/wireless/ath/ath12k/hal.c
--- linux-6.16.7/drivers/net/wireless/ath/ath12k/hal.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/net/wireless/ath/ath12k/hal.c	2025-09-11 09:47:42.000000000 -0600
@@ -1950,7 +1950,7 @@ u32 ath12k_hal_ce_dst_status_get_length(
 {
 	u32 len;
 
-	len = le32_get_bits(READ_ONCE(desc->flags), HAL_CE_DST_STATUS_DESC_FLAGS_LEN);
+	len = le32_get_bits(desc->flags, HAL_CE_DST_STATUS_DESC_FLAGS_LEN);
 	desc->flags &= ~cpu_to_le32(HAL_CE_DST_STATUS_DESC_FLAGS_LEN);
 
 	return len;
diff -Nrup linux-6.16.7/drivers/net/wireless/ath/ath12k/mac.c linux-lenovo-x13s-linux-6.16.y/drivers/net/wireless/ath/ath12k/mac.c
--- linux-6.16.7/drivers/net/wireless/ath/ath12k/mac.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/net/wireless/ath/ath12k/mac.c	2025-09-11 09:47:42.000000000 -0600
@@ -4955,9 +4955,9 @@ static int ath12k_mac_set_key(struct ath
 	}
 
 	if (key->flags & IEEE80211_KEY_FLAG_PAIRWISE)
-		flags |= WMI_KEY_PAIRWISE;
+		flags = WMI_KEY_PAIRWISE;
 	else
-		flags |= WMI_KEY_GROUP;
+		flags = WMI_KEY_GROUP;
 
 	ret = ath12k_install_key(arvif, key, cmd, peer_addr, flags);
 	if (ret) {
diff -Nrup linux-6.16.7/drivers/pci/controller/dwc/Kconfig linux-lenovo-x13s-linux-6.16.y/drivers/pci/controller/dwc/Kconfig
--- linux-6.16.7/drivers/pci/controller/dwc/Kconfig	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/pci/controller/dwc/Kconfig	2025-09-11 09:47:42.000000000 -0600
@@ -290,7 +290,7 @@ config PCIE_QCOM_COMMON
 	bool
 
 config PCIE_QCOM
-	bool "Qualcomm PCIe controller (host mode)"
+	tristate "Qualcomm PCIe controller (host mode)"
 	depends on OF && (ARCH_QCOM || COMPILE_TEST)
 	depends on PCI_MSI
 	select PCIE_DW_HOST
diff -Nrup linux-6.16.7/drivers/pci/controller/dwc/pcie-qcom.c linux-lenovo-x13s-linux-6.16.y/drivers/pci/controller/dwc/pcie-qcom.c
--- linux-6.16.7/drivers/pci/controller/dwc/pcie-qcom.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/pci/controller/dwc/pcie-qcom.c	2025-09-11 09:47:42.000000000 -0600
@@ -20,6 +20,8 @@
 #include <linux/kernel.h>
 #include <linux/limits.h>
 #include <linux/init.h>
+#include <linux/module.h>
+#include <linux/notifier.h>
 #include <linux/of.h>
 #include <linux/pci.h>
 #include <linux/pm_opp.h>
@@ -244,7 +246,6 @@ struct qcom_pcie_ops {
 	int (*get_resources)(struct qcom_pcie *pcie);
 	int (*init)(struct qcom_pcie *pcie);
 	int (*post_init)(struct qcom_pcie *pcie);
-	void (*host_post_init)(struct qcom_pcie *pcie);
 	void (*deinit)(struct qcom_pcie *pcie);
 	void (*ltssm_enable)(struct qcom_pcie *pcie);
 	int (*config_sid)(struct qcom_pcie *pcie);
@@ -274,6 +275,7 @@ struct qcom_pcie {
 	struct icc_path *icc_cpu;
 	const struct qcom_pcie_cfg *cfg;
 	struct dentry *debugfs;
+	struct notifier_block nb;
 	bool suspended;
 	bool use_pm_opp;
 };
@@ -1016,25 +1018,6 @@ static int qcom_pcie_post_init_2_7_0(str
 	return 0;
 }
 
-static int qcom_pcie_enable_aspm(struct pci_dev *pdev, void *userdata)
-{
-	/*
-	 * Downstream devices need to be in D0 state before enabling PCI PM
-	 * substates.
-	 */
-	pci_set_power_state_locked(pdev, PCI_D0);
-	pci_enable_link_state_locked(pdev, PCIE_LINK_STATE_ALL);
-
-	return 0;
-}
-
-static void qcom_pcie_host_post_init_2_7_0(struct qcom_pcie *pcie)
-{
-	struct dw_pcie_rp *pp = &pcie->pci->pp;
-
-	pci_walk_bus(pp->bridge->bus, qcom_pcie_enable_aspm, NULL);
-}
-
 static void qcom_pcie_deinit_2_7_0(struct qcom_pcie *pcie)
 {
 	struct qcom_pcie_resources_2_7_0 *res = &pcie->res.v2_7_0;
@@ -1285,19 +1268,9 @@ static void qcom_pcie_host_deinit(struct
 	pcie->cfg->ops->deinit(pcie);
 }
 
-static void qcom_pcie_host_post_init(struct dw_pcie_rp *pp)
-{
-	struct dw_pcie *pci = to_dw_pcie_from_pp(pp);
-	struct qcom_pcie *pcie = to_qcom_pcie(pci);
-
-	if (pcie->cfg->ops->host_post_init)
-		pcie->cfg->ops->host_post_init(pcie);
-}
-
 static const struct dw_pcie_host_ops qcom_pcie_dw_ops = {
 	.init		= qcom_pcie_host_init,
 	.deinit		= qcom_pcie_host_deinit,
-	.post_init	= qcom_pcie_host_post_init,
 };
 
 /* Qcom IP rev.: 2.1.0	Synopsys IP rev.: 4.01a */
@@ -1359,7 +1332,6 @@ static const struct qcom_pcie_ops ops_1_
 	.get_resources = qcom_pcie_get_resources_2_7_0,
 	.init = qcom_pcie_init_2_7_0,
 	.post_init = qcom_pcie_post_init_2_7_0,
-	.host_post_init = qcom_pcie_host_post_init_2_7_0,
 	.deinit = qcom_pcie_deinit_2_7_0,
 	.ltssm_enable = qcom_pcie_2_3_2_ltssm_enable,
 	.config_sid = qcom_pcie_config_sid_1_9_0,
@@ -1370,7 +1342,6 @@ static const struct qcom_pcie_ops ops_1_
 	.get_resources = qcom_pcie_get_resources_2_7_0,
 	.init = qcom_pcie_init_2_7_0,
 	.post_init = qcom_pcie_post_init_2_7_0,
-	.host_post_init = qcom_pcie_host_post_init_2_7_0,
 	.deinit = qcom_pcie_deinit_2_7_0,
 	.ltssm_enable = qcom_pcie_2_3_2_ltssm_enable,
 };
@@ -1580,6 +1551,38 @@ static irqreturn_t qcom_pcie_global_irq_
 	return IRQ_HANDLED;
 }
 
+static int qcom_pcie_enable_aspm(struct pci_dev *pdev)
+{
+	/*
+	 * Downstream devices need to be in D0 state before enabling PCI PM
+	 * substates.
+	 */
+	pci_set_power_state(pdev, PCI_D0);
+	pci_enable_link_state(pdev, PCIE_LINK_STATE_ALL);
+
+	return 0;
+}
+
+static int pcie_qcom_notify(struct notifier_block *nb, unsigned long action,
+		void *data)
+{
+	struct device *dev = data;
+	struct pci_dev *pdev = to_pci_dev(dev);
+
+	switch (action) {
+	case BUS_NOTIFY_BIND_DRIVER:
+		qcom_pcie_enable_aspm(pdev);
+		break;
+	}
+
+	return NOTIFY_DONE;
+}
+
+static void qcom_pcie_deinit_debugfs(struct qcom_pcie *pcie)
+{
+	debugfs_remove(pcie->debugfs);
+}
+
 static int qcom_pcie_probe(struct platform_device *pdev)
 {
 	const struct qcom_pcie_cfg *pcie_cfg;
@@ -1710,10 +1713,15 @@ static int qcom_pcie_probe(struct platfo
 	if (irq > 0)
 		pp->use_linkup_irq = true;
 
+	pcie->nb.notifier_call = pcie_qcom_notify;
+	ret = bus_register_notifier(&pci_bus_type, &pcie->nb);
+	if (ret)
+		goto err_phy_exit;
+
 	ret = dw_pcie_host_init(pp);
 	if (ret) {
 		dev_err(dev, "cannot initialize host\n");
-		goto err_phy_exit;
+		goto err_unregister_notifier;
 	}
 
 	name = devm_kasprintf(dev, GFP_KERNEL, "qcom_pcie_global_irq%d",
@@ -1746,6 +1754,8 @@ static int qcom_pcie_probe(struct platfo
 
 err_host_deinit:
 	dw_pcie_host_deinit(pp);
+err_unregister_notifier:
+	bus_unregister_notifier(&pci_bus_type, &pcie->nb);
 err_phy_exit:
 	phy_exit(pcie->phy);
 err_pm_runtime_put:
@@ -1755,6 +1765,23 @@ err_pm_runtime_put:
 	return ret;
 }
 
+static void qcom_pcie_remove(struct platform_device *pdev)
+{
+	struct qcom_pcie *pcie = platform_get_drvdata(pdev);
+	struct device *dev = &pdev->dev;
+
+	qcom_pcie_deinit_debugfs(pcie);
+
+	dw_pcie_host_deinit(&pcie->pci->pp);
+
+	bus_unregister_notifier(&pci_bus_type, &pcie->nb);
+
+	phy_exit(pcie->phy);
+
+	pm_runtime_put_sync(dev);
+	pm_runtime_disable(dev);
+}
+
 static int qcom_pcie_suspend_noirq(struct device *dev)
 {
 	struct qcom_pcie *pcie = dev_get_drvdata(dev);
@@ -1866,6 +1893,7 @@ static const struct of_device_id qcom_pc
 	{ .compatible = "qcom,pcie-x1e80100", .data = &cfg_sc8280xp },
 	{ }
 };
+MODULE_DEVICE_TABLE(of, qcom_pcie_match);
 
 static void qcom_fixup_class(struct pci_dev *dev)
 {
@@ -1885,12 +1913,16 @@ static const struct dev_pm_ops qcom_pcie
 
 static struct platform_driver qcom_pcie_driver = {
 	.probe = qcom_pcie_probe,
+	.remove = qcom_pcie_remove,
 	.driver = {
 		.name = "qcom-pcie",
-		.suppress_bind_attrs = true,
 		.of_match_table = qcom_pcie_match,
 		.pm = &qcom_pcie_pm_ops,
 		.probe_type = PROBE_PREFER_ASYNCHRONOUS,
 	},
 };
-builtin_platform_driver(qcom_pcie_driver);
+module_platform_driver(qcom_pcie_driver);
+
+MODULE_AUTHOR("Stanimir Varbanov <svarbanov@mm-sol.com>");
+MODULE_DESCRIPTION("Qualcomm PCIe root complex driver");
+MODULE_LICENSE("GPL");
diff -Nrup linux-6.16.7/drivers/phy/broadcom/phy-bcm-ns2-pcie.c linux-lenovo-x13s-linux-6.16.y/drivers/phy/broadcom/phy-bcm-ns2-pcie.c
--- linux-6.16.7/drivers/phy/broadcom/phy-bcm-ns2-pcie.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/phy/broadcom/phy-bcm-ns2-pcie.c	2025-09-11 09:47:42.000000000 -0600
@@ -61,8 +61,6 @@ static int ns2_pci_phy_probe(struct mdio
 		return PTR_ERR(provider);
 	}
 
-	dev_info(dev, "%s PHY registered\n", dev_name(dev));
-
 	return 0;
 }
 
diff -Nrup linux-6.16.7/drivers/phy/broadcom/phy-bcm-ns2-usbdrd.c linux-lenovo-x13s-linux-6.16.y/drivers/phy/broadcom/phy-bcm-ns2-usbdrd.c
--- linux-6.16.7/drivers/phy/broadcom/phy-bcm-ns2-usbdrd.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/phy/broadcom/phy-bcm-ns2-usbdrd.c	2025-09-11 09:47:42.000000000 -0600
@@ -395,7 +395,6 @@ static int ns2_drd_phy_probe(struct plat
 
 	platform_set_drvdata(pdev, driver);
 
-	dev_info(dev, "Registered NS2 DRD Phy device\n");
 	queue_delayed_work(system_power_efficient_wq, &driver->wq_extcon,
 			   driver->debounce_jiffies);
 
diff -Nrup linux-6.16.7/drivers/phy/broadcom/phy-bcm-sr-pcie.c linux-lenovo-x13s-linux-6.16.y/drivers/phy/broadcom/phy-bcm-sr-pcie.c
--- linux-6.16.7/drivers/phy/broadcom/phy-bcm-sr-pcie.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/phy/broadcom/phy-bcm-sr-pcie.c	2025-09-11 09:47:42.000000000 -0600
@@ -277,8 +277,6 @@ static int sr_pcie_phy_probe(struct plat
 		return PTR_ERR(provider);
 	}
 
-	dev_info(dev, "Stingray PCIe PHY driver initialized\n");
-
 	return 0;
 }
 
diff -Nrup linux-6.16.7/drivers/phy/broadcom/phy-brcm-sata.c linux-lenovo-x13s-linux-6.16.y/drivers/phy/broadcom/phy-brcm-sata.c
--- linux-6.16.7/drivers/phy/broadcom/phy-brcm-sata.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/phy/broadcom/phy-brcm-sata.c	2025-09-11 09:47:42.000000000 -0600
@@ -832,7 +832,7 @@ static int brcm_sata_phy_probe(struct pl
 		return PTR_ERR(provider);
 	}
 
-	dev_info(dev, "registered %d port(s)\n", count);
+	dev_dbg(dev, "registered %d port(s)\n", count);
 
 	return 0;
 }
diff -Nrup linux-6.16.7/drivers/phy/marvell/phy-pxa-usb.c linux-lenovo-x13s-linux-6.16.y/drivers/phy/marvell/phy-pxa-usb.c
--- linux-6.16.7/drivers/phy/marvell/phy-pxa-usb.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/phy/marvell/phy-pxa-usb.c	2025-09-11 09:47:42.000000000 -0600
@@ -325,7 +325,6 @@ static int pxa_usb_phy_probe(struct plat
 		phy_create_lookup(pxa_usb_phy->phy, "usb", "mv-otg");
 	}
 
-	dev_info(dev, "Marvell PXA USB PHY");
 	return 0;
 }
 
diff -Nrup linux-6.16.7/drivers/phy/phy-snps-eusb2.c linux-lenovo-x13s-linux-6.16.y/drivers/phy/phy-snps-eusb2.c
--- linux-6.16.7/drivers/phy/phy-snps-eusb2.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/phy/phy-snps-eusb2.c	2025-09-11 09:47:42.000000000 -0600
@@ -256,7 +256,7 @@ static int exynos_eusb2_ref_clk_init(str
 	}
 
 	if (!config) {
-		dev_err(&phy->phy->dev, "unsupported ref_clk_freq:%lu\n", ref_clk_freq);
+		dev_err(&phy->phy->dev, "unsupported ref_clk_freq: %lu\n", ref_clk_freq);
 		return -EINVAL;
 	}
 
@@ -293,7 +293,7 @@ static int qcom_eusb2_ref_clk_init(struc
 	}
 
 	if (!config) {
-		dev_err(&phy->phy->dev, "unsupported ref_clk_freq:%lu\n", ref_clk_freq);
+		dev_err(&phy->phy->dev, "unsupported ref_clk_freq: %lu\n", ref_clk_freq);
 		return -EINVAL;
 	}
 
@@ -464,39 +464,40 @@ static int snps_eusb2_hsphy_init(struct
 
 	ret = phy_init(phy->repeater);
 	if (ret) {
-		dev_err(&p->dev, "repeater init failed. %d\n", ret);
+		dev_err(&p->dev, "repeater init failed: %d\n", ret);
 		goto disable_vreg;
 	}
 
 	ret = clk_bulk_prepare_enable(phy->data->num_clks, phy->clks);
 	if (ret) {
-		dev_err(&p->dev, "failed to enable ref clock, %d\n", ret);
-		goto disable_vreg;
+		dev_err(&p->dev, "failed to enable ref clock: %d\n", ret);
+		goto exit_repeater;
 	}
 
 	ret = reset_control_assert(phy->phy_reset);
 	if (ret) {
-		dev_err(&p->dev, "failed to assert phy_reset, %d\n", ret);
-		goto disable_ref_clk;
+		dev_err(&p->dev, "failed to assert phy_reset: %d\n", ret);
+		goto disable_clks;
 	}
 
 	usleep_range(100, 150);
 
 	ret = reset_control_deassert(phy->phy_reset);
 	if (ret) {
-		dev_err(&p->dev, "failed to de-assert phy_reset, %d\n", ret);
-		goto disable_ref_clk;
+		dev_err(&p->dev, "failed to de-assert phy_reset: %d\n", ret);
+		goto disable_clks;
 	}
 
 	ret = phy->data->phy_init(p);
 	if (ret)
-		goto disable_ref_clk;
+		goto disable_clks;
 
 	return 0;
 
-disable_ref_clk:
+disable_clks:
 	clk_bulk_disable_unprepare(phy->data->num_clks, phy->clks);
-
+exit_repeater:
+	phy_exit(phy->repeater);
 disable_vreg:
 	regulator_bulk_disable(ARRAY_SIZE(phy->vregs), phy->vregs);
 
@@ -507,7 +508,7 @@ static int snps_eusb2_hsphy_exit(struct
 {
 	struct snps_eusb2_hsphy *phy = phy_get_drvdata(p);
 
-	clk_disable_unprepare(phy->ref_clk);
+	clk_bulk_disable_unprepare(phy->data->num_clks, phy->clks);
 
 	regulator_bulk_disable(ARRAY_SIZE(phy->vregs), phy->vregs);
 
@@ -554,7 +555,7 @@ static int snps_eusb2_hsphy_probe(struct
 	if (!phy->clks)
 		return -ENOMEM;
 
-	for (int i = 0; i < phy->data->num_clks; ++i)
+	for (i = 0; i < phy->data->num_clks; ++i)
 		phy->clks[i].id = phy->data->clk_names[i];
 
 	ret = devm_clk_bulk_get(dev, phy->data->num_clks, phy->clks);
@@ -563,7 +564,7 @@ static int snps_eusb2_hsphy_probe(struct
 				     "failed to get phy clock(s)\n");
 
 	phy->ref_clk = NULL;
-	for (int i = 0; i < phy->data->num_clks; ++i) {
+	for (i = 0; i < phy->data->num_clks; ++i) {
 		if (!strcmp(phy->clks[i].id, "ref")) {
 			phy->ref_clk = phy->clks[i].clk;
 			break;
@@ -585,14 +586,14 @@ static int snps_eusb2_hsphy_probe(struct
 		return dev_err_probe(dev, ret,
 				     "failed to get regulator supplies\n");
 
-	phy->repeater = devm_of_phy_optional_get(dev, np, 0);
+	phy->repeater = devm_of_phy_optional_get(dev, np, NULL);
 	if (IS_ERR(phy->repeater))
 		return dev_err_probe(dev, PTR_ERR(phy->repeater),
 				     "failed to get repeater\n");
 
 	generic_phy = devm_phy_create(dev, NULL, &snps_eusb2_hsphy_ops);
 	if (IS_ERR(generic_phy)) {
-		dev_err(dev, "failed to create phy %d\n", ret);
+		dev_err(dev, "failed to create phy: %d\n", ret);
 		return PTR_ERR(generic_phy);
 	}
 
@@ -603,8 +604,6 @@ static int snps_eusb2_hsphy_probe(struct
 	if (IS_ERR(phy_provider))
 		return PTR_ERR(phy_provider);
 
-	dev_info(dev, "Registered Snps-eUSB2 phy\n");
-
 	return 0;
 }
 
@@ -615,7 +614,9 @@ static const struct of_device_id snps_eu
 	}, {
 		.compatible = "samsung,exynos2200-eusb2-phy",
 		.data = &exynos2200_snps_eusb2_phy,
-	}, { },
+	}, {
+		/* sentinel */
+	}
 };
 MODULE_DEVICE_TABLE(of, snps_eusb2_hsphy_of_match_table);
 
diff -Nrup linux-6.16.7/drivers/phy/qualcomm/phy-qcom-eusb2-repeater.c linux-lenovo-x13s-linux-6.16.y/drivers/phy/qualcomm/phy-qcom-eusb2-repeater.c
--- linux-6.16.7/drivers/phy/qualcomm/phy-qcom-eusb2-repeater.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/phy/qualcomm/phy-qcom-eusb2-repeater.c	2025-09-11 09:47:42.000000000 -0600
@@ -241,8 +241,6 @@ static int eusb2_repeater_probe(struct p
 	if (IS_ERR(phy_provider))
 		return PTR_ERR(phy_provider);
 
-	dev_info(dev, "Registered Qcom-eUSB2 repeater\n");
-
 	return 0;
 }
 
diff -Nrup linux-6.16.7/drivers/phy/qualcomm/phy-qcom-m31.c linux-lenovo-x13s-linux-6.16.y/drivers/phy/qualcomm/phy-qcom-m31.c
--- linux-6.16.7/drivers/phy/qualcomm/phy-qcom-m31.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/phy/qualcomm/phy-qcom-m31.c	2025-09-11 09:47:42.000000000 -0600
@@ -311,8 +311,6 @@ static int m31usb_phy_probe(struct platf
 	phy_set_drvdata(qphy->phy, qphy);
 
 	phy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);
-	if (!IS_ERR(phy_provider))
-		dev_info(dev, "Registered M31 USB phy\n");
 
 	return PTR_ERR_OR_ZERO(phy_provider);
 }
diff -Nrup linux-6.16.7/drivers/phy/qualcomm/phy-qcom-qmp-combo.c linux-lenovo-x13s-linux-6.16.y/drivers/phy/qualcomm/phy-qcom-qmp-combo.c
--- linux-6.16.7/drivers/phy/qualcomm/phy-qcom-qmp-combo.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/phy/qualcomm/phy-qcom-qmp-combo.c	2025-09-11 09:47:42.000000000 -0600
@@ -19,6 +19,7 @@
 #include <linux/reset.h>
 #include <linux/slab.h>
 #include <linux/usb/typec.h>
+#include <linux/usb/typec_dp.h>
 #include <linux/usb/typec_mux.h>
 
 #include <drm/bridge/aux-bridge.h>
@@ -61,6 +62,12 @@
 
 #define PHY_INIT_COMPLETE_TIMEOUT		10000
 
+enum qmpphy_mode {
+	QMPPHY_MODE_USB3DP = 0,
+	QMPPHY_MODE_DP_ONLY,
+	QMPPHY_MODE_USB3_ONLY,
+};
+
 /* set of registers with offsets different per-PHY */
 enum qphy_reg_layout {
 	/* PCS registers */
@@ -1685,15 +1692,17 @@ struct qmp_combo {
 
 	struct mutex phy_mutex;
 	int init_count;
+	enum qmpphy_mode qmpphy_mode;
 
 	struct phy *usb_phy;
-	enum phy_mode mode;
+	enum phy_mode phy_mode;
 	unsigned int usb_init_count;
 
 	struct phy *dp_phy;
 	unsigned int dp_aux_cfg;
 	struct phy_configure_opts_dp dp_opts;
 	unsigned int dp_init_count;
+	bool dp_powered_on;
 
 	struct clk_fixed_rate pipe_clk_fixed;
 	struct clk_hw dp_link_hw;
@@ -1701,6 +1710,8 @@ struct qmp_combo {
 
 	struct typec_switch_dev *sw;
 	enum typec_orientation orientation;
+
+	struct typec_mux_dev *mux;
 };
 
 static void qmp_v3_dp_aux_init(struct qmp_combo *qmp);
@@ -2816,12 +2827,33 @@ static int qmp_combo_com_init(struct qmp
 	if (qmp->orientation == TYPEC_ORIENTATION_REVERSE)
 		val |= SW_PORTSELECT_VAL;
 	writel(val, com + QPHY_V3_DP_COM_TYPEC_CTRL);
-	writel(USB3_MODE | DP_MODE, com + QPHY_V3_DP_COM_PHY_MODE_CTRL);
 
-	/* bring both QMP USB and QMP DP PHYs PCS block out of reset */
-	qphy_clrbits(com, QPHY_V3_DP_COM_RESET_OVRD_CTRL,
-			SW_DPPHY_RESET_MUX | SW_DPPHY_RESET |
-			SW_USB3PHY_RESET_MUX | SW_USB3PHY_RESET);
+	switch (qmp->qmpphy_mode) {
+	case QMPPHY_MODE_USB3DP:
+		writel(USB3_MODE | DP_MODE, com + QPHY_V3_DP_COM_PHY_MODE_CTRL);
+
+		/* bring both QMP USB and QMP DP PHYs PCS block out of reset */
+		qphy_clrbits(com, QPHY_V3_DP_COM_RESET_OVRD_CTRL,
+				SW_DPPHY_RESET_MUX | SW_DPPHY_RESET |
+				SW_USB3PHY_RESET_MUX | SW_USB3PHY_RESET);
+		break;
+
+	case QMPPHY_MODE_DP_ONLY:
+		writel(DP_MODE, com + QPHY_V3_DP_COM_PHY_MODE_CTRL);
+
+		/* bring QMP DP PHY PCS block out of reset */
+		qphy_clrbits(com, QPHY_V3_DP_COM_RESET_OVRD_CTRL,
+				SW_DPPHY_RESET_MUX | SW_DPPHY_RESET);
+		break;
+
+	case QMPPHY_MODE_USB3_ONLY:
+		writel(USB3_MODE, com + QPHY_V3_DP_COM_PHY_MODE_CTRL);
+
+		/* bring QMP USB PHY PCS block out of reset */
+		qphy_clrbits(com, QPHY_V3_DP_COM_RESET_OVRD_CTRL,
+				SW_USB3PHY_RESET_MUX | SW_USB3PHY_RESET);
+		break;
+	}
 
 	qphy_clrbits(com, QPHY_V3_DP_COM_SWI_CTRL, 0x03);
 	qphy_clrbits(com, QPHY_V3_DP_COM_SW_RESET, SW_RESET);
@@ -2913,6 +2945,8 @@ static int qmp_combo_dp_power_on(struct
 	/* Configure link rate, swing, etc. */
 	cfg->configure_dp_phy(qmp);
 
+	qmp->dp_powered_on = true;
+
 	mutex_unlock(&qmp->phy_mutex);
 
 	return 0;
@@ -2927,6 +2961,8 @@ static int qmp_combo_dp_power_off(struct
 	/* Assert DP PHY power down */
 	writel(DP_PHY_PD_CTL_PSR_PWRDN, qmp->dp_dp_phy + QSERDES_DP_PHY_PD_CTL);
 
+	qmp->dp_powered_on = false;
+
 	mutex_unlock(&qmp->phy_mutex);
 
 	return 0;
@@ -3062,7 +3098,7 @@ static int qmp_combo_usb_set_mode(struct
 {
 	struct qmp_combo *qmp = phy_get_drvdata(phy);
 
-	qmp->mode = mode;
+	qmp->phy_mode = mode;
 
 	return 0;
 }
@@ -3091,8 +3127,8 @@ static void qmp_combo_enable_autonomous_
 	void __iomem *pcs_misc = qmp->pcs_misc;
 	u32 intr_mask;
 
-	if (qmp->mode == PHY_MODE_USB_HOST_SS ||
-	    qmp->mode == PHY_MODE_USB_DEVICE_SS)
+	if (qmp->phy_mode == PHY_MODE_USB_HOST_SS ||
+	    qmp->phy_mode == PHY_MODE_USB_DEVICE_SS)
 		intr_mask = ARCVR_DTCT_EN | ALFPS_DTCT_EN;
 	else
 		intr_mask = ARCVR_DTCT_EN | ARCVR_DTCT_EVENT_SEL;
@@ -3135,7 +3171,7 @@ static int __maybe_unused qmp_combo_runt
 {
 	struct qmp_combo *qmp = dev_get_drvdata(dev);
 
-	dev_vdbg(dev, "Suspending QMP phy, mode:%d\n", qmp->mode);
+	dev_vdbg(dev, "Suspending QMP phy, mode:%d\n", qmp->phy_mode);
 
 	if (!qmp->init_count) {
 		dev_vdbg(dev, "PHY not initialized, bailing out\n");
@@ -3155,7 +3191,7 @@ static int __maybe_unused qmp_combo_runt
 	struct qmp_combo *qmp = dev_get_drvdata(dev);
 	int ret = 0;
 
-	dev_vdbg(dev, "Resuming QMP phy, mode:%d\n", qmp->mode);
+	dev_vdbg(dev, "Resuming QMP phy, mode:%d\n", qmp->phy_mode);
 
 	if (!qmp->init_count) {
 		dev_vdbg(dev, "PHY not initialized, bailing out\n");
@@ -3549,17 +3585,109 @@ static int qmp_combo_typec_switch_set(st
 	return 0;
 }
 
-static void qmp_combo_typec_unregister(void *data)
+static int qmp_combo_typec_mux_set(struct typec_mux_dev *mux, struct typec_mux_state *state)
+{
+	struct qmp_combo *qmp = typec_mux_get_drvdata(mux);
+	const struct qmp_phy_cfg *cfg = qmp->cfg;
+	enum qmpphy_mode new_mode;
+	unsigned int svid;
+
+	guard(mutex)(&qmp->phy_mutex);
+
+	if (state->alt)
+		svid = state->alt->svid;
+	else
+		svid = 0;
+
+	if (svid == USB_TYPEC_DP_SID) {
+		switch (state->mode) {
+		/* DP Only */
+		case TYPEC_DP_STATE_C:
+		case TYPEC_DP_STATE_E:
+			new_mode = QMPPHY_MODE_DP_ONLY;
+			break;
+
+		/* DP + USB */
+		case TYPEC_DP_STATE_D:
+		case TYPEC_DP_STATE_F:
+
+		/* Safe fallback...*/
+		default:
+			new_mode = QMPPHY_MODE_USB3DP;
+			break;
+		}
+	} else {
+		/* No DP SVID => don't care, assume it's just USB3 */
+		new_mode = QMPPHY_MODE_USB3_ONLY;
+	}
+
+	if (new_mode == qmp->qmpphy_mode) {
+		dev_dbg(qmp->dev, "typec_mux_set: same qmpphy mode, bail out\n");
+		return 0;
+	}
+
+	if (qmp->qmpphy_mode != QMPPHY_MODE_USB3_ONLY && qmp->dp_powered_on) {
+		dev_dbg(qmp->dev, "typec_mux_set: DP PHY is still in use, delaying switch\n");
+		return 0;
+	}
+
+	dev_dbg(qmp->dev, "typec_mux_set: switching from qmpphy mode %d to %d\n",
+		qmp->qmpphy_mode, new_mode);
+
+	qmp->qmpphy_mode = new_mode;
+
+	if (qmp->init_count) {
+		if (qmp->usb_init_count)
+			qmp_combo_usb_power_off(qmp->usb_phy);
+
+		if (qmp->dp_init_count)
+			writel(DP_PHY_PD_CTL_PSR_PWRDN, qmp->dp_dp_phy + QSERDES_DP_PHY_PD_CTL);
+
+		qmp_combo_com_exit(qmp, true);
+
+		/* Now everything's powered down, power up the right PHYs */
+		qmp_combo_com_init(qmp, true);
+
+		if (new_mode == QMPPHY_MODE_DP_ONLY) {
+			if (qmp->usb_init_count)
+				qmp->usb_init_count--;
+		}
+
+		if (new_mode == QMPPHY_MODE_USB3DP || new_mode == QMPPHY_MODE_USB3_ONLY) {
+			qmp_combo_usb_power_on(qmp->usb_phy);
+			if (!qmp->usb_init_count)
+				qmp->usb_init_count++;
+		}
+
+		if (new_mode == QMPPHY_MODE_DP_ONLY || new_mode == QMPPHY_MODE_USB3DP) {
+			if (qmp->dp_init_count)
+				cfg->dp_aux_init(qmp);
+		}
+	}
+
+	return 0;
+}
+
+static void qmp_combo_typec_switch_unregister(void *data)
 {
 	struct qmp_combo *qmp = data;
 
 	typec_switch_unregister(qmp->sw);
 }
 
-static int qmp_combo_typec_switch_register(struct qmp_combo *qmp)
+static void qmp_combo_typec_mux_unregister(void *data)
+{
+	struct qmp_combo *qmp = data;
+
+	typec_mux_unregister(qmp->mux);
+}
+
+static int qmp_combo_typec_register(struct qmp_combo *qmp)
 {
 	struct typec_switch_desc sw_desc = {};
+	struct typec_mux_desc mux_desc = { };
 	struct device *dev = qmp->dev;
+	int ret;
 
 	sw_desc.drvdata = qmp;
 	sw_desc.fwnode = dev->fwnode;
@@ -3570,10 +3698,23 @@ static int qmp_combo_typec_switch_regist
 		return PTR_ERR(qmp->sw);
 	}
 
-	return devm_add_action_or_reset(dev, qmp_combo_typec_unregister, qmp);
+	ret = devm_add_action_or_reset(dev, qmp_combo_typec_switch_unregister, qmp);
+	if (ret)
+		return ret;
+
+	mux_desc.drvdata = qmp;
+	mux_desc.fwnode = dev->fwnode;
+	mux_desc.set = qmp_combo_typec_mux_set;
+	qmp->mux = typec_mux_register(dev, &mux_desc);
+	if (IS_ERR(qmp->mux)) {
+		dev_err(dev, "Unable to register typec mux: %pe\n", qmp->mux);
+		return PTR_ERR(qmp->mux);
+	}
+
+	return devm_add_action_or_reset(dev, qmp_combo_typec_mux_unregister, qmp);
 }
 #else
-static int qmp_combo_typec_switch_register(struct qmp_combo *qmp)
+static int qmp_combo_typec_register(struct qmp_combo *qmp)
 {
 	return 0;
 }
@@ -3806,7 +3947,7 @@ static int qmp_combo_probe(struct platfo
 	if (ret)
 		goto err_node_put;
 
-	ret = qmp_combo_typec_switch_register(qmp);
+	ret = qmp_combo_typec_register(qmp);
 	if (ret)
 		goto err_node_put;
 
@@ -3828,6 +3969,12 @@ static int qmp_combo_probe(struct platfo
 	if (ret)
 		goto err_node_put;
 
+	/*
+	 * The hw default is USB3_ONLY, but USB3+DP mode lets us more easily
+	 * check both sub-blocks' init tables for blunders at probe time.
+	 */
+	qmp->qmpphy_mode = QMPPHY_MODE_USB3DP;
+
 	qmp->usb_phy = devm_phy_create(dev, usb_np, &qmp_combo_usb_phy_ops);
 	if (IS_ERR(qmp->usb_phy)) {
 		ret = PTR_ERR(qmp->usb_phy);
diff -Nrup linux-6.16.7/drivers/phy/qualcomm/phy-qcom-qusb2.c linux-lenovo-x13s-linux-6.16.y/drivers/phy/qualcomm/phy-qcom-qusb2.c
--- linux-6.16.7/drivers/phy/qualcomm/phy-qcom-qusb2.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/phy/qualcomm/phy-qcom-qusb2.c	2025-09-11 09:47:42.000000000 -0600
@@ -1114,9 +1114,7 @@ static int qusb2_phy_probe(struct platfo
 	phy_set_drvdata(generic_phy, qphy);
 
 	phy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);
-	if (!IS_ERR(phy_provider))
-		dev_info(dev, "Registered Qcom-QUSB2 phy\n");
-	else
+	if (IS_ERR(phy_provider))
 		pm_runtime_disable(dev);
 
 	return PTR_ERR_OR_ZERO(phy_provider);
diff -Nrup linux-6.16.7/drivers/phy/st/phy-stih407-usb.c linux-lenovo-x13s-linux-6.16.y/drivers/phy/st/phy-stih407-usb.c
--- linux-6.16.7/drivers/phy/st/phy-stih407-usb.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/phy/st/phy-stih407-usb.c	2025-09-11 09:47:42.000000000 -0600
@@ -139,8 +139,6 @@ static int stih407_usb2_picophy_probe(st
 	if (IS_ERR(phy_provider))
 		return PTR_ERR(phy_provider);
 
-	dev_info(dev, "STiH407 USB Generic picoPHY driver probed!");
-
 	return 0;
 }
 
diff -Nrup linux-6.16.7/drivers/phy/st/phy-stm32-usbphyc.c linux-lenovo-x13s-linux-6.16.y/drivers/phy/st/phy-stm32-usbphyc.c
--- linux-6.16.7/drivers/phy/st/phy-stm32-usbphyc.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/phy/st/phy-stm32-usbphyc.c	2025-09-11 09:47:42.000000000 -0600
@@ -757,8 +757,8 @@ static int stm32_usbphyc_probe(struct pl
 	}
 
 	version = readl_relaxed(usbphyc->base + STM32_USBPHYC_VERSION);
-	dev_info(dev, "registered rev:%lu.%lu\n",
-		 FIELD_GET(MAJREV, version), FIELD_GET(MINREV, version));
+	dev_dbg(dev, "registered rev: %lu.%lu\n",
+		FIELD_GET(MAJREV, version), FIELD_GET(MINREV, version));
 
 	return 0;
 
diff -Nrup linux-6.16.7/drivers/phy/ti/phy-twl4030-usb.c linux-lenovo-x13s-linux-6.16.y/drivers/phy/ti/phy-twl4030-usb.c
--- linux-6.16.7/drivers/phy/ti/phy-twl4030-usb.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/phy/ti/phy-twl4030-usb.c	2025-09-11 09:47:42.000000000 -0600
@@ -784,7 +784,6 @@ static int twl4030_usb_probe(struct plat
 	pm_runtime_mark_last_busy(&pdev->dev);
 	pm_runtime_put_autosuspend(twl->dev);
 
-	dev_info(&pdev->dev, "Initialized TWL4030 USB module\n");
 	return 0;
 }
 
diff -Nrup linux-6.16.7/drivers/platform/x86/asus-wmi.c.rej linux-lenovo-x13s-linux-6.16.y/drivers/platform/x86/asus-wmi.c.rej
--- linux-6.16.7/drivers/platform/x86/asus-wmi.c.rej	2025-09-13 16:15:46.038293399 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/platform/x86/asus-wmi.c.rej	1969-12-31 17:00:00.000000000 -0700
@@ -1,34 +0,0 @@
---- drivers/platform/x86/asus-wmi.c
-+++ drivers/platform/x86/asus-wmi.c
-@@ -5088,16 +5088,22 @@ static int asus_wmi_probe(struct platform_device *pdev)
- 
- 	asus_s2idle_check_register();
- 
--	return asus_wmi_add(pdev);
-+	ret = asus_wmi_add(pdev);
-+	if (ret)
-+		asus_s2idle_check_unregister();
-+
-+	return ret;
- }
- 
- static bool used;
-+static DEFINE_MUTEX(register_mutex);
- 
- int __init_or_module asus_wmi_register_driver(struct asus_wmi_driver *driver)
- {
- 	struct platform_driver *platform_driver;
- 	struct platform_device *platform_device;
- 
-+	guard(mutex)(&register_mutex);
- 	if (used)
- 		return -EBUSY;
- 
-@@ -5120,6 +5126,7 @@ EXPORT_SYMBOL_GPL(asus_wmi_register_driver);
- 
- void asus_wmi_unregister_driver(struct asus_wmi_driver *driver)
- {
-+	guard(mutex)(&register_mutex);
- 	asus_s2idle_check_unregister();
- 
- 	platform_device_unregister(driver->platform_device);
diff -Nrup linux-6.16.7/drivers/platform/x86/intel/int3472/led.c linux-lenovo-x13s-linux-6.16.y/drivers/platform/x86/intel/int3472/led.c
--- linux-6.16.7/drivers/platform/x86/intel/int3472/led.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/platform/x86/intel/int3472/led.c	2025-09-11 09:47:42.000000000 -0600
@@ -43,7 +43,7 @@ int skl_int3472_register_pled(struct int
 
 	int3472->pled.lookup.provider = int3472->pled.name;
 	int3472->pled.lookup.dev_id = int3472->sensor_name;
-	int3472->pled.lookup.con_id = "privacy-led";
+	int3472->pled.lookup.con_id = "privacy";
 	led_add_lookup(&int3472->pled.lookup);
 
 	return 0;
diff -Nrup linux-6.16.7/drivers/power/supply/qcom_battmgr.c linux-lenovo-x13s-linux-6.16.y/drivers/power/supply/qcom_battmgr.c
--- linux-6.16.7/drivers/power/supply/qcom_battmgr.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/power/supply/qcom_battmgr.c	2025-09-11 09:47:42.000000000 -0600
@@ -577,6 +577,8 @@ static int qcom_battmgr_bat_get_property
 		val->intval = battmgr->status.capacity;
 		break;
 	case POWER_SUPPLY_PROP_CAPACITY:
+		if (battmgr->status.percent == (unsigned int)-1)
+			return -ENODATA;
 		val->intval = battmgr->status.percent;
 		break;
 	case POWER_SUPPLY_PROP_TEMP:
@@ -617,6 +619,7 @@ static const enum power_supply_property
 	POWER_SUPPLY_PROP_STATUS,
 	POWER_SUPPLY_PROP_PRESENT,
 	POWER_SUPPLY_PROP_TECHNOLOGY,
+	POWER_SUPPLY_PROP_CAPACITY,
 	POWER_SUPPLY_PROP_CYCLE_COUNT,
 	POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN,
 	POWER_SUPPLY_PROP_VOLTAGE_NOW,
@@ -1065,6 +1068,21 @@ static void qcom_battmgr_sc8280xp_callba
 		battmgr->ac.online = source == BATTMGR_CHARGING_SOURCE_AC;
 		battmgr->usb.online = source == BATTMGR_CHARGING_SOURCE_USB;
 		battmgr->wireless.online = source == BATTMGR_CHARGING_SOURCE_WIRELESS;
+		if (battmgr->info.last_full_capacity != 0) {
+			/*
+			 * 100 * battmgr->status.capacity can overflow a 32bit
+			 * unsigned integer. Do a temporary cast to avoid that.
+			 */
+			battmgr->status.percent =
+				(uint64_t)100 * battmgr->status.capacity /
+				battmgr->info.last_full_capacity;
+		} else {
+			/*
+			 * Let the sysfs handler know no data is available at
+			 * this time.
+			 */
+			battmgr->status.percent = (unsigned int)-1;
+		}
 		break;
 	case BATTMGR_BAT_DISCHARGE_TIME:
 		battmgr->status.discharge_time = le32_to_cpu(resp->time);
diff -Nrup linux-6.16.7/drivers/soc/qcom/icc-bwmon.c linux-lenovo-x13s-linux-6.16.y/drivers/soc/qcom/icc-bwmon.c
--- linux-6.16.7/drivers/soc/qcom/icc-bwmon.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/soc/qcom/icc-bwmon.c	2025-09-11 09:47:42.000000000 -0600
@@ -827,7 +827,7 @@ static const struct icc_bwmon_data msm89
 static const struct icc_bwmon_data sdm845_cpu_bwmon_data = {
 	.sample_ms = 4,
 	.count_unit_kb = 64,
-	.zone1_thres_count = 16,
+	.zone1_thres_count = 3,
 	.zone3_thres_count = 1,
 	.quirks = BWMON_HAS_GLOBAL_IRQ,
 	.regmap_fields = sdm845_cpu_bwmon_reg_fields,
@@ -846,7 +846,7 @@ static const struct icc_bwmon_data sdm84
 static const struct icc_bwmon_data sc7280_llcc_bwmon_data = {
 	.sample_ms = 4,
 	.count_unit_kb = 64,
-	.zone1_thres_count = 16,
+	.zone1_thres_count = 3,
 	.zone3_thres_count = 1,
 	.quirks = BWMON_NEEDS_FORCE_CLEAR,
 	.regmap_fields = sdm845_llcc_bwmon_reg_fields,
diff -Nrup linux-6.16.7/drivers/soundwire/bus.c linux-lenovo-x13s-linux-6.16.y/drivers/soundwire/bus.c
--- linux-6.16.7/drivers/soundwire/bus.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/soundwire/bus.c	2025-09-11 09:47:42.000000000 -0600
@@ -1360,6 +1360,18 @@ int sdw_slave_get_scale_index(struct sdw
 }
 EXPORT_SYMBOL(sdw_slave_get_scale_index);
 
+int sdw_slave_get_current_bank(struct sdw_slave *slave)
+{
+	int tmp;
+
+	tmp = sdw_read(slave, SDW_SCP_CTRL);
+	if (tmp < 0)
+		return tmp;
+
+	return FIELD_GET(SDW_SCP_STAT_CURR_BANK, tmp);
+}
+EXPORT_SYMBOL_GPL(sdw_slave_get_current_bank);
+
 static int sdw_slave_set_frequency(struct sdw_slave *slave)
 {
 	int scale_index;
diff -Nrup linux-6.16.7/drivers/soundwire/qcom.c linux-lenovo-x13s-linux-6.16.y/drivers/soundwire/qcom.c
--- linux-6.16.7/drivers/soundwire/qcom.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/soundwire/qcom.c	2025-09-11 09:47:42.000000000 -0600
@@ -1622,9 +1622,9 @@ static int qcom_swrm_probe(struct platfo
 	if (ret)
 		goto err_master_add;
 
-	dev_info(dev, "Qualcomm Soundwire controller v%x.%x.%x Registered\n",
-		 (ctrl->version >> 24) & 0xff, (ctrl->version >> 16) & 0xff,
-		 ctrl->version & 0xffff);
+	dev_dbg(dev, "Qualcomm Soundwire controller v%x.%x.%x registered\n",
+		(ctrl->version >> 24) & 0xff, (ctrl->version >> 16) & 0xff,
+		ctrl->version & 0xffff);
 
 	pm_runtime_set_autosuspend_delay(dev, 3000);
 	pm_runtime_use_autosuspend(dev);
diff -Nrup linux-6.16.7/drivers/soundwire/slave.c linux-lenovo-x13s-linux-6.16.y/drivers/soundwire/slave.c
--- linux-6.16.7/drivers/soundwire/slave.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/soundwire/slave.c	2025-09-11 09:47:42.000000000 -0600
@@ -273,4 +273,10 @@ int sdw_of_find_slaves(struct sdw_bus *b
 	return 0;
 }
 
+struct device *of_sdw_find_device_by_node(struct device_node *np)
+{
+	return bus_find_device_by_of_node(&sdw_bus_type, np);
+}
+EXPORT_SYMBOL_GPL(of_sdw_find_device_by_node);
+
 MODULE_IMPORT_NS("SND_SOC_SDCA");
diff -Nrup linux-6.16.7/fs/namei.c linux-lenovo-x13s-linux-6.16.y/fs/namei.c
--- linux-6.16.7/fs/namei.c	2025-09-13 16:15:37.954860024 -0600
+++ linux-lenovo-x13s-linux-6.16.y/fs/namei.c	2025-09-11 09:47:42.000000000 -0600
@@ -1095,10 +1095,10 @@ static inline void put_link(struct namei
 		path_put(&last->link);
 }
 
-static int sysctl_protected_symlinks __read_mostly = 1;
-static int sysctl_protected_hardlinks __read_mostly = 1;
-int sysctl_protected_fifos __read_mostly = 1;
-int sysctl_protected_regular __read_mostly = 1;
+static int sysctl_protected_symlinks __read_mostly;
+static int sysctl_protected_hardlinks __read_mostly;
+static int sysctl_protected_fifos __read_mostly;
+static int sysctl_protected_regular __read_mostly;
 
 #ifdef CONFIG_SYSCTL
 static const struct ctl_table namei_sysctls[] = {
diff -Nrup linux-6.16.7/fs/namei.c.orig linux-lenovo-x13s-linux-6.16.y/fs/namei.c.orig
--- linux-6.16.7/fs/namei.c.orig	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/fs/namei.c.orig	1969-12-31 17:00:00.000000000 -0700
@@ -1,5545 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- *  linux/fs/namei.c
- *
- *  Copyright (C) 1991, 1992  Linus Torvalds
- */
-
-/*
- * Some corrections by tytso.
- */
-
-/* [Feb 1997 T. Schoebel-Theuer] Complete rewrite of the pathname
- * lookup logic.
- */
-/* [Feb-Apr 2000, AV] Rewrite to the new namespace architecture.
- */
-
-#include <linux/init.h>
-#include <linux/export.h>
-#include <linux/slab.h>
-#include <linux/wordpart.h>
-#include <linux/fs.h>
-#include <linux/filelock.h>
-#include <linux/namei.h>
-#include <linux/pagemap.h>
-#include <linux/sched/mm.h>
-#include <linux/fsnotify.h>
-#include <linux/personality.h>
-#include <linux/security.h>
-#include <linux/syscalls.h>
-#include <linux/mount.h>
-#include <linux/audit.h>
-#include <linux/capability.h>
-#include <linux/file.h>
-#include <linux/fcntl.h>
-#include <linux/device_cgroup.h>
-#include <linux/fs_struct.h>
-#include <linux/posix_acl.h>
-#include <linux/hash.h>
-#include <linux/bitops.h>
-#include <linux/init_task.h>
-#include <linux/uaccess.h>
-
-#include "internal.h"
-#include "mount.h"
-
-/* [Feb-1997 T. Schoebel-Theuer]
- * Fundamental changes in the pathname lookup mechanisms (namei)
- * were necessary because of omirr.  The reason is that omirr needs
- * to know the _real_ pathname, not the user-supplied one, in case
- * of symlinks (and also when transname replacements occur).
- *
- * The new code replaces the old recursive symlink resolution with
- * an iterative one (in case of non-nested symlink chains).  It does
- * this with calls to <fs>_follow_link().
- * As a side effect, dir_namei(), _namei() and follow_link() are now 
- * replaced with a single function lookup_dentry() that can handle all 
- * the special cases of the former code.
- *
- * With the new dcache, the pathname is stored at each inode, at least as
- * long as the refcount of the inode is positive.  As a side effect, the
- * size of the dcache depends on the inode cache and thus is dynamic.
- *
- * [29-Apr-1998 C. Scott Ananian] Updated above description of symlink
- * resolution to correspond with current state of the code.
- *
- * Note that the symlink resolution is not *completely* iterative.
- * There is still a significant amount of tail- and mid- recursion in
- * the algorithm.  Also, note that <fs>_readlink() is not used in
- * lookup_dentry(): lookup_dentry() on the result of <fs>_readlink()
- * may return different results than <fs>_follow_link().  Many virtual
- * filesystems (including /proc) exhibit this behavior.
- */
-
-/* [24-Feb-97 T. Schoebel-Theuer] Side effects caused by new implementation:
- * New symlink semantics: when open() is called with flags O_CREAT | O_EXCL
- * and the name already exists in form of a symlink, try to create the new
- * name indicated by the symlink. The old code always complained that the
- * name already exists, due to not following the symlink even if its target
- * is nonexistent.  The new semantics affects also mknod() and link() when
- * the name is a symlink pointing to a non-existent name.
- *
- * I don't know which semantics is the right one, since I have no access
- * to standards. But I found by trial that HP-UX 9.0 has the full "new"
- * semantics implemented, while SunOS 4.1.1 and Solaris (SunOS 5.4) have the
- * "old" one. Personally, I think the new semantics is much more logical.
- * Note that "ln old new" where "new" is a symlink pointing to a non-existing
- * file does succeed in both HP-UX and SunOs, but not in Solaris
- * and in the old Linux semantics.
- */
-
-/* [16-Dec-97 Kevin Buhr] For security reasons, we change some symlink
- * semantics.  See the comments in "open_namei" and "do_link" below.
- *
- * [10-Sep-98 Alan Modra] Another symlink change.
- */
-
-/* [Feb-Apr 2000 AV] Complete rewrite. Rules for symlinks:
- *	inside the path - always follow.
- *	in the last component in creation/removal/renaming - never follow.
- *	if LOOKUP_FOLLOW passed - follow.
- *	if the pathname has trailing slashes - follow.
- *	otherwise - don't follow.
- * (applied in that order).
- *
- * [Jun 2000 AV] Inconsistent behaviour of open() in case if flags==O_CREAT
- * restored for 2.4. This is the last surviving part of old 4.2BSD bug.
- * During the 2.4 we need to fix the userland stuff depending on it -
- * hopefully we will be able to get rid of that wart in 2.5. So far only
- * XEmacs seems to be relying on it...
- */
-/*
- * [Sep 2001 AV] Single-semaphore locking scheme (kudos to David Holland)
- * implemented.  Let's see if raised priority of ->s_vfs_rename_mutex gives
- * any extra contention...
- */
-
-/* In order to reduce some races, while at the same time doing additional
- * checking and hopefully speeding things up, we copy filenames to the
- * kernel data space before using them..
- *
- * POSIX.1 2.4: an empty pathname is invalid (ENOENT).
- * PATH_MAX includes the nul terminator --RR.
- */
-
-#define EMBEDDED_NAME_MAX	(PATH_MAX - offsetof(struct filename, iname))
-
-static inline void initname(struct filename *name, const char __user *uptr)
-{
-	name->uptr = uptr;
-	name->aname = NULL;
-	atomic_set(&name->refcnt, 1);
-}
-
-struct filename *
-getname_flags(const char __user *filename, int flags)
-{
-	struct filename *result;
-	char *kname;
-	int len;
-
-	result = audit_reusename(filename);
-	if (result)
-		return result;
-
-	result = __getname();
-	if (unlikely(!result))
-		return ERR_PTR(-ENOMEM);
-
-	/*
-	 * First, try to embed the struct filename inside the names_cache
-	 * allocation
-	 */
-	kname = (char *)result->iname;
-	result->name = kname;
-
-	len = strncpy_from_user(kname, filename, EMBEDDED_NAME_MAX);
-	/*
-	 * Handle both empty path and copy failure in one go.
-	 */
-	if (unlikely(len <= 0)) {
-		if (unlikely(len < 0)) {
-			__putname(result);
-			return ERR_PTR(len);
-		}
-
-		/* The empty path is special. */
-		if (!(flags & LOOKUP_EMPTY)) {
-			__putname(result);
-			return ERR_PTR(-ENOENT);
-		}
-	}
-
-	/*
-	 * Uh-oh. We have a name that's approaching PATH_MAX. Allocate a
-	 * separate struct filename so we can dedicate the entire
-	 * names_cache allocation for the pathname, and re-do the copy from
-	 * userland.
-	 */
-	if (unlikely(len == EMBEDDED_NAME_MAX)) {
-		const size_t size = offsetof(struct filename, iname[1]);
-		kname = (char *)result;
-
-		/*
-		 * size is chosen that way we to guarantee that
-		 * result->iname[0] is within the same object and that
-		 * kname can't be equal to result->iname, no matter what.
-		 */
-		result = kzalloc(size, GFP_KERNEL);
-		if (unlikely(!result)) {
-			__putname(kname);
-			return ERR_PTR(-ENOMEM);
-		}
-		result->name = kname;
-		len = strncpy_from_user(kname, filename, PATH_MAX);
-		if (unlikely(len < 0)) {
-			__putname(kname);
-			kfree(result);
-			return ERR_PTR(len);
-		}
-		/* The empty path is special. */
-		if (unlikely(!len) && !(flags & LOOKUP_EMPTY)) {
-			__putname(kname);
-			kfree(result);
-			return ERR_PTR(-ENOENT);
-		}
-		if (unlikely(len == PATH_MAX)) {
-			__putname(kname);
-			kfree(result);
-			return ERR_PTR(-ENAMETOOLONG);
-		}
-	}
-	initname(result, filename);
-	audit_getname(result);
-	return result;
-}
-
-struct filename *getname_uflags(const char __user *filename, int uflags)
-{
-	int flags = (uflags & AT_EMPTY_PATH) ? LOOKUP_EMPTY : 0;
-
-	return getname_flags(filename, flags);
-}
-
-struct filename *__getname_maybe_null(const char __user *pathname)
-{
-	struct filename *name;
-	char c;
-
-	/* try to save on allocations; loss on um, though */
-	if (get_user(c, pathname))
-		return ERR_PTR(-EFAULT);
-	if (!c)
-		return NULL;
-
-	name = getname_flags(pathname, LOOKUP_EMPTY);
-	if (!IS_ERR(name) && !(name->name[0])) {
-		putname(name);
-		name = NULL;
-	}
-	return name;
-}
-
-struct filename *getname_kernel(const char * filename)
-{
-	struct filename *result;
-	int len = strlen(filename) + 1;
-
-	result = __getname();
-	if (unlikely(!result))
-		return ERR_PTR(-ENOMEM);
-
-	if (len <= EMBEDDED_NAME_MAX) {
-		result->name = (char *)result->iname;
-	} else if (len <= PATH_MAX) {
-		const size_t size = offsetof(struct filename, iname[1]);
-		struct filename *tmp;
-
-		tmp = kmalloc(size, GFP_KERNEL);
-		if (unlikely(!tmp)) {
-			__putname(result);
-			return ERR_PTR(-ENOMEM);
-		}
-		tmp->name = (char *)result;
-		result = tmp;
-	} else {
-		__putname(result);
-		return ERR_PTR(-ENAMETOOLONG);
-	}
-	memcpy((char *)result->name, filename, len);
-	initname(result, NULL);
-	audit_getname(result);
-	return result;
-}
-EXPORT_SYMBOL(getname_kernel);
-
-void putname(struct filename *name)
-{
-	int refcnt;
-
-	if (IS_ERR_OR_NULL(name))
-		return;
-
-	refcnt = atomic_read(&name->refcnt);
-	if (refcnt != 1) {
-		if (WARN_ON_ONCE(!refcnt))
-			return;
-
-		if (!atomic_dec_and_test(&name->refcnt))
-			return;
-	}
-
-	if (name->name != name->iname) {
-		__putname(name->name);
-		kfree(name);
-	} else
-		__putname(name);
-}
-EXPORT_SYMBOL(putname);
-
-/**
- * check_acl - perform ACL permission checking
- * @idmap:	idmap of the mount the inode was found from
- * @inode:	inode to check permissions on
- * @mask:	right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC ...)
- *
- * This function performs the ACL permission checking. Since this function
- * retrieve POSIX acls it needs to know whether it is called from a blocking or
- * non-blocking context and thus cares about the MAY_NOT_BLOCK bit.
- *
- * If the inode has been found through an idmapped mount the idmap of
- * the vfsmount must be passed through @idmap. This function will then take
- * care to map the inode according to @idmap before checking permissions.
- * On non-idmapped mounts or if permission checking is to be performed on the
- * raw inode simply pass @nop_mnt_idmap.
- */
-static int check_acl(struct mnt_idmap *idmap,
-		     struct inode *inode, int mask)
-{
-#ifdef CONFIG_FS_POSIX_ACL
-	struct posix_acl *acl;
-
-	if (mask & MAY_NOT_BLOCK) {
-		acl = get_cached_acl_rcu(inode, ACL_TYPE_ACCESS);
-	        if (!acl)
-	                return -EAGAIN;
-		/* no ->get_inode_acl() calls in RCU mode... */
-		if (is_uncached_acl(acl))
-			return -ECHILD;
-	        return posix_acl_permission(idmap, inode, acl, mask);
-	}
-
-	acl = get_inode_acl(inode, ACL_TYPE_ACCESS);
-	if (IS_ERR(acl))
-		return PTR_ERR(acl);
-	if (acl) {
-	        int error = posix_acl_permission(idmap, inode, acl, mask);
-	        posix_acl_release(acl);
-	        return error;
-	}
-#endif
-
-	return -EAGAIN;
-}
-
-/*
- * Very quick optimistic "we know we have no ACL's" check.
- *
- * Note that this is purely for ACL_TYPE_ACCESS, and purely
- * for the "we have cached that there are no ACLs" case.
- *
- * If this returns true, we know there are no ACLs. But if
- * it returns false, we might still not have ACLs (it could
- * be the is_uncached_acl() case).
- */
-static inline bool no_acl_inode(struct inode *inode)
-{
-#ifdef CONFIG_FS_POSIX_ACL
-	return likely(!READ_ONCE(inode->i_acl));
-#else
-	return true;
-#endif
-}
-
-/**
- * acl_permission_check - perform basic UNIX permission checking
- * @idmap:	idmap of the mount the inode was found from
- * @inode:	inode to check permissions on
- * @mask:	right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC ...)
- *
- * This function performs the basic UNIX permission checking. Since this
- * function may retrieve POSIX acls it needs to know whether it is called from a
- * blocking or non-blocking context and thus cares about the MAY_NOT_BLOCK bit.
- *
- * If the inode has been found through an idmapped mount the idmap of
- * the vfsmount must be passed through @idmap. This function will then take
- * care to map the inode according to @idmap before checking permissions.
- * On non-idmapped mounts or if permission checking is to be performed on the
- * raw inode simply pass @nop_mnt_idmap.
- */
-static int acl_permission_check(struct mnt_idmap *idmap,
-				struct inode *inode, int mask)
-{
-	unsigned int mode = inode->i_mode;
-	vfsuid_t vfsuid;
-
-	/*
-	 * Common cheap case: everybody has the requested
-	 * rights, and there are no ACLs to check. No need
-	 * to do any owner/group checks in that case.
-	 *
-	 *  - 'mask&7' is the requested permission bit set
-	 *  - multiplying by 0111 spreads them out to all of ugo
-	 *  - '& ~mode' looks for missing inode permission bits
-	 *  - the '!' is for "no missing permissions"
-	 *
-	 * After that, we just need to check that there are no
-	 * ACL's on the inode - do the 'IS_POSIXACL()' check last
-	 * because it will dereference the ->i_sb pointer and we
-	 * want to avoid that if at all possible.
-	 */
-	if (!((mask & 7) * 0111 & ~mode)) {
-		if (no_acl_inode(inode))
-			return 0;
-		if (!IS_POSIXACL(inode))
-			return 0;
-	}
-
-	/* Are we the owner? If so, ACL's don't matter */
-	vfsuid = i_uid_into_vfsuid(idmap, inode);
-	if (likely(vfsuid_eq_kuid(vfsuid, current_fsuid()))) {
-		mask &= 7;
-		mode >>= 6;
-		return (mask & ~mode) ? -EACCES : 0;
-	}
-
-	/* Do we have ACL's? */
-	if (IS_POSIXACL(inode) && (mode & S_IRWXG)) {
-		int error = check_acl(idmap, inode, mask);
-		if (error != -EAGAIN)
-			return error;
-	}
-
-	/* Only RWX matters for group/other mode bits */
-	mask &= 7;
-
-	/*
-	 * Are the group permissions different from
-	 * the other permissions in the bits we care
-	 * about? Need to check group ownership if so.
-	 */
-	if (mask & (mode ^ (mode >> 3))) {
-		vfsgid_t vfsgid = i_gid_into_vfsgid(idmap, inode);
-		if (vfsgid_in_group_p(vfsgid))
-			mode >>= 3;
-	}
-
-	/* Bits in 'mode' clear that we require? */
-	return (mask & ~mode) ? -EACCES : 0;
-}
-
-/**
- * generic_permission -  check for access rights on a Posix-like filesystem
- * @idmap:	idmap of the mount the inode was found from
- * @inode:	inode to check access rights for
- * @mask:	right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC,
- *		%MAY_NOT_BLOCK ...)
- *
- * Used to check for read/write/execute permissions on a file.
- * We use "fsuid" for this, letting us set arbitrary permissions
- * for filesystem access without changing the "normal" uids which
- * are used for other things.
- *
- * generic_permission is rcu-walk aware. It returns -ECHILD in case an rcu-walk
- * request cannot be satisfied (eg. requires blocking or too much complexity).
- * It would then be called again in ref-walk mode.
- *
- * If the inode has been found through an idmapped mount the idmap of
- * the vfsmount must be passed through @idmap. This function will then take
- * care to map the inode according to @idmap before checking permissions.
- * On non-idmapped mounts or if permission checking is to be performed on the
- * raw inode simply pass @nop_mnt_idmap.
- */
-int generic_permission(struct mnt_idmap *idmap, struct inode *inode,
-		       int mask)
-{
-	int ret;
-
-	/*
-	 * Do the basic permission checks.
-	 */
-	ret = acl_permission_check(idmap, inode, mask);
-	if (ret != -EACCES)
-		return ret;
-
-	if (S_ISDIR(inode->i_mode)) {
-		/* DACs are overridable for directories */
-		if (!(mask & MAY_WRITE))
-			if (capable_wrt_inode_uidgid(idmap, inode,
-						     CAP_DAC_READ_SEARCH))
-				return 0;
-		if (capable_wrt_inode_uidgid(idmap, inode,
-					     CAP_DAC_OVERRIDE))
-			return 0;
-		return -EACCES;
-	}
-
-	/*
-	 * Searching includes executable on directories, else just read.
-	 */
-	mask &= MAY_READ | MAY_WRITE | MAY_EXEC;
-	if (mask == MAY_READ)
-		if (capable_wrt_inode_uidgid(idmap, inode,
-					     CAP_DAC_READ_SEARCH))
-			return 0;
-	/*
-	 * Read/write DACs are always overridable.
-	 * Executable DACs are overridable when there is
-	 * at least one exec bit set.
-	 */
-	if (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))
-		if (capable_wrt_inode_uidgid(idmap, inode,
-					     CAP_DAC_OVERRIDE))
-			return 0;
-
-	return -EACCES;
-}
-EXPORT_SYMBOL(generic_permission);
-
-/**
- * do_inode_permission - UNIX permission checking
- * @idmap:	idmap of the mount the inode was found from
- * @inode:	inode to check permissions on
- * @mask:	right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC ...)
- *
- * We _really_ want to just do "generic_permission()" without
- * even looking at the inode->i_op values. So we keep a cache
- * flag in inode->i_opflags, that says "this has not special
- * permission function, use the fast case".
- */
-static inline int do_inode_permission(struct mnt_idmap *idmap,
-				      struct inode *inode, int mask)
-{
-	if (unlikely(!(inode->i_opflags & IOP_FASTPERM))) {
-		if (likely(inode->i_op->permission))
-			return inode->i_op->permission(idmap, inode, mask);
-
-		/* This gets set once for the inode lifetime */
-		spin_lock(&inode->i_lock);
-		inode->i_opflags |= IOP_FASTPERM;
-		spin_unlock(&inode->i_lock);
-	}
-	return generic_permission(idmap, inode, mask);
-}
-
-/**
- * sb_permission - Check superblock-level permissions
- * @sb: Superblock of inode to check permission on
- * @inode: Inode to check permission on
- * @mask: Right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC)
- *
- * Separate out file-system wide checks from inode-specific permission checks.
- */
-static int sb_permission(struct super_block *sb, struct inode *inode, int mask)
-{
-	if (unlikely(mask & MAY_WRITE)) {
-		umode_t mode = inode->i_mode;
-
-		/* Nobody gets write access to a read-only fs. */
-		if (sb_rdonly(sb) && (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)))
-			return -EROFS;
-	}
-	return 0;
-}
-
-/**
- * inode_permission - Check for access rights to a given inode
- * @idmap:	idmap of the mount the inode was found from
- * @inode:	Inode to check permission on
- * @mask:	Right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC)
- *
- * Check for read/write/execute permissions on an inode.  We use fs[ug]id for
- * this, letting us set arbitrary permissions for filesystem access without
- * changing the "normal" UIDs which are used for other things.
- *
- * When checking for MAY_APPEND, MAY_WRITE must also be set in @mask.
- */
-int inode_permission(struct mnt_idmap *idmap,
-		     struct inode *inode, int mask)
-{
-	int retval;
-
-	retval = sb_permission(inode->i_sb, inode, mask);
-	if (unlikely(retval))
-		return retval;
-
-	if (unlikely(mask & MAY_WRITE)) {
-		/*
-		 * Nobody gets write access to an immutable file.
-		 */
-		if (unlikely(IS_IMMUTABLE(inode)))
-			return -EPERM;
-
-		/*
-		 * Updating mtime will likely cause i_uid and i_gid to be
-		 * written back improperly if their true value is unknown
-		 * to the vfs.
-		 */
-		if (unlikely(HAS_UNMAPPED_ID(idmap, inode)))
-			return -EACCES;
-	}
-
-	retval = do_inode_permission(idmap, inode, mask);
-	if (unlikely(retval))
-		return retval;
-
-	retval = devcgroup_inode_permission(inode, mask);
-	if (unlikely(retval))
-		return retval;
-
-	return security_inode_permission(inode, mask);
-}
-EXPORT_SYMBOL(inode_permission);
-
-/**
- * path_get - get a reference to a path
- * @path: path to get the reference to
- *
- * Given a path increment the reference count to the dentry and the vfsmount.
- */
-void path_get(const struct path *path)
-{
-	mntget(path->mnt);
-	dget(path->dentry);
-}
-EXPORT_SYMBOL(path_get);
-
-/**
- * path_put - put a reference to a path
- * @path: path to put the reference to
- *
- * Given a path decrement the reference count to the dentry and the vfsmount.
- */
-void path_put(const struct path *path)
-{
-	dput(path->dentry);
-	mntput(path->mnt);
-}
-EXPORT_SYMBOL(path_put);
-
-#define EMBEDDED_LEVELS 2
-struct nameidata {
-	struct path	path;
-	struct qstr	last;
-	struct path	root;
-	struct inode	*inode; /* path.dentry.d_inode */
-	unsigned int	flags, state;
-	unsigned	seq, next_seq, m_seq, r_seq;
-	int		last_type;
-	unsigned	depth;
-	int		total_link_count;
-	struct saved {
-		struct path link;
-		struct delayed_call done;
-		const char *name;
-		unsigned seq;
-	} *stack, internal[EMBEDDED_LEVELS];
-	struct filename	*name;
-	const char *pathname;
-	struct nameidata *saved;
-	unsigned	root_seq;
-	int		dfd;
-	vfsuid_t	dir_vfsuid;
-	umode_t		dir_mode;
-} __randomize_layout;
-
-#define ND_ROOT_PRESET 1
-#define ND_ROOT_GRABBED 2
-#define ND_JUMPED 4
-
-static void __set_nameidata(struct nameidata *p, int dfd, struct filename *name)
-{
-	struct nameidata *old = current->nameidata;
-	p->stack = p->internal;
-	p->depth = 0;
-	p->dfd = dfd;
-	p->name = name;
-	p->pathname = likely(name) ? name->name : "";
-	p->path.mnt = NULL;
-	p->path.dentry = NULL;
-	p->total_link_count = old ? old->total_link_count : 0;
-	p->saved = old;
-	current->nameidata = p;
-}
-
-static inline void set_nameidata(struct nameidata *p, int dfd, struct filename *name,
-			  const struct path *root)
-{
-	__set_nameidata(p, dfd, name);
-	p->state = 0;
-	if (unlikely(root)) {
-		p->state = ND_ROOT_PRESET;
-		p->root = *root;
-	}
-}
-
-static void restore_nameidata(void)
-{
-	struct nameidata *now = current->nameidata, *old = now->saved;
-
-	current->nameidata = old;
-	if (old)
-		old->total_link_count = now->total_link_count;
-	if (now->stack != now->internal)
-		kfree(now->stack);
-}
-
-static bool nd_alloc_stack(struct nameidata *nd)
-{
-	struct saved *p;
-
-	p= kmalloc_array(MAXSYMLINKS, sizeof(struct saved),
-			 nd->flags & LOOKUP_RCU ? GFP_ATOMIC : GFP_KERNEL);
-	if (unlikely(!p))
-		return false;
-	memcpy(p, nd->internal, sizeof(nd->internal));
-	nd->stack = p;
-	return true;
-}
-
-/**
- * path_connected - Verify that a dentry is below mnt.mnt_root
- * @mnt: The mountpoint to check.
- * @dentry: The dentry to check.
- *
- * Rename can sometimes move a file or directory outside of a bind
- * mount, path_connected allows those cases to be detected.
- */
-static bool path_connected(struct vfsmount *mnt, struct dentry *dentry)
-{
-	struct super_block *sb = mnt->mnt_sb;
-
-	/* Bind mounts can have disconnected paths */
-	if (mnt->mnt_root == sb->s_root)
-		return true;
-
-	return is_subdir(dentry, mnt->mnt_root);
-}
-
-static void drop_links(struct nameidata *nd)
-{
-	int i = nd->depth;
-	while (i--) {
-		struct saved *last = nd->stack + i;
-		do_delayed_call(&last->done);
-		clear_delayed_call(&last->done);
-	}
-}
-
-static void leave_rcu(struct nameidata *nd)
-{
-	nd->flags &= ~LOOKUP_RCU;
-	nd->seq = nd->next_seq = 0;
-	rcu_read_unlock();
-}
-
-static void terminate_walk(struct nameidata *nd)
-{
-	drop_links(nd);
-	if (!(nd->flags & LOOKUP_RCU)) {
-		int i;
-		path_put(&nd->path);
-		for (i = 0; i < nd->depth; i++)
-			path_put(&nd->stack[i].link);
-		if (nd->state & ND_ROOT_GRABBED) {
-			path_put(&nd->root);
-			nd->state &= ~ND_ROOT_GRABBED;
-		}
-	} else {
-		leave_rcu(nd);
-	}
-	nd->depth = 0;
-	nd->path.mnt = NULL;
-	nd->path.dentry = NULL;
-}
-
-/* path_put is needed afterwards regardless of success or failure */
-static bool __legitimize_path(struct path *path, unsigned seq, unsigned mseq)
-{
-	int res = __legitimize_mnt(path->mnt, mseq);
-	if (unlikely(res)) {
-		if (res > 0)
-			path->mnt = NULL;
-		path->dentry = NULL;
-		return false;
-	}
-	if (unlikely(!lockref_get_not_dead(&path->dentry->d_lockref))) {
-		path->dentry = NULL;
-		return false;
-	}
-	return !read_seqcount_retry(&path->dentry->d_seq, seq);
-}
-
-static inline bool legitimize_path(struct nameidata *nd,
-			    struct path *path, unsigned seq)
-{
-	return __legitimize_path(path, seq, nd->m_seq);
-}
-
-static bool legitimize_links(struct nameidata *nd)
-{
-	int i;
-	if (unlikely(nd->flags & LOOKUP_CACHED)) {
-		drop_links(nd);
-		nd->depth = 0;
-		return false;
-	}
-	for (i = 0; i < nd->depth; i++) {
-		struct saved *last = nd->stack + i;
-		if (unlikely(!legitimize_path(nd, &last->link, last->seq))) {
-			drop_links(nd);
-			nd->depth = i + 1;
-			return false;
-		}
-	}
-	return true;
-}
-
-static bool legitimize_root(struct nameidata *nd)
-{
-	/* Nothing to do if nd->root is zero or is managed by the VFS user. */
-	if (!nd->root.mnt || (nd->state & ND_ROOT_PRESET))
-		return true;
-	nd->state |= ND_ROOT_GRABBED;
-	return legitimize_path(nd, &nd->root, nd->root_seq);
-}
-
-/*
- * Path walking has 2 modes, rcu-walk and ref-walk (see
- * Documentation/filesystems/path-lookup.txt).  In situations when we can't
- * continue in RCU mode, we attempt to drop out of rcu-walk mode and grab
- * normal reference counts on dentries and vfsmounts to transition to ref-walk
- * mode.  Refcounts are grabbed at the last known good point before rcu-walk
- * got stuck, so ref-walk may continue from there. If this is not successful
- * (eg. a seqcount has changed), then failure is returned and it's up to caller
- * to restart the path walk from the beginning in ref-walk mode.
- */
-
-/**
- * try_to_unlazy - try to switch to ref-walk mode.
- * @nd: nameidata pathwalk data
- * Returns: true on success, false on failure
- *
- * try_to_unlazy attempts to legitimize the current nd->path and nd->root
- * for ref-walk mode.
- * Must be called from rcu-walk context.
- * Nothing should touch nameidata between try_to_unlazy() failure and
- * terminate_walk().
- */
-static bool try_to_unlazy(struct nameidata *nd)
-{
-	struct dentry *parent = nd->path.dentry;
-
-	BUG_ON(!(nd->flags & LOOKUP_RCU));
-
-	if (unlikely(!legitimize_links(nd)))
-		goto out1;
-	if (unlikely(!legitimize_path(nd, &nd->path, nd->seq)))
-		goto out;
-	if (unlikely(!legitimize_root(nd)))
-		goto out;
-	leave_rcu(nd);
-	BUG_ON(nd->inode != parent->d_inode);
-	return true;
-
-out1:
-	nd->path.mnt = NULL;
-	nd->path.dentry = NULL;
-out:
-	leave_rcu(nd);
-	return false;
-}
-
-/**
- * try_to_unlazy_next - try to switch to ref-walk mode.
- * @nd: nameidata pathwalk data
- * @dentry: next dentry to step into
- * Returns: true on success, false on failure
- *
- * Similar to try_to_unlazy(), but here we have the next dentry already
- * picked by rcu-walk and want to legitimize that in addition to the current
- * nd->path and nd->root for ref-walk mode.  Must be called from rcu-walk context.
- * Nothing should touch nameidata between try_to_unlazy_next() failure and
- * terminate_walk().
- */
-static bool try_to_unlazy_next(struct nameidata *nd, struct dentry *dentry)
-{
-	int res;
-	BUG_ON(!(nd->flags & LOOKUP_RCU));
-
-	if (unlikely(!legitimize_links(nd)))
-		goto out2;
-	res = __legitimize_mnt(nd->path.mnt, nd->m_seq);
-	if (unlikely(res)) {
-		if (res > 0)
-			goto out2;
-		goto out1;
-	}
-	if (unlikely(!lockref_get_not_dead(&nd->path.dentry->d_lockref)))
-		goto out1;
-
-	/*
-	 * We need to move both the parent and the dentry from the RCU domain
-	 * to be properly refcounted. And the sequence number in the dentry
-	 * validates *both* dentry counters, since we checked the sequence
-	 * number of the parent after we got the child sequence number. So we
-	 * know the parent must still be valid if the child sequence number is
-	 */
-	if (unlikely(!lockref_get_not_dead(&dentry->d_lockref)))
-		goto out;
-	if (read_seqcount_retry(&dentry->d_seq, nd->next_seq))
-		goto out_dput;
-	/*
-	 * Sequence counts matched. Now make sure that the root is
-	 * still valid and get it if required.
-	 */
-	if (unlikely(!legitimize_root(nd)))
-		goto out_dput;
-	leave_rcu(nd);
-	return true;
-
-out2:
-	nd->path.mnt = NULL;
-out1:
-	nd->path.dentry = NULL;
-out:
-	leave_rcu(nd);
-	return false;
-out_dput:
-	leave_rcu(nd);
-	dput(dentry);
-	return false;
-}
-
-static inline int d_revalidate(struct inode *dir, const struct qstr *name,
-			       struct dentry *dentry, unsigned int flags)
-{
-	if (unlikely(dentry->d_flags & DCACHE_OP_REVALIDATE))
-		return dentry->d_op->d_revalidate(dir, name, dentry, flags);
-	else
-		return 1;
-}
-
-/**
- * complete_walk - successful completion of path walk
- * @nd:  pointer nameidata
- *
- * If we had been in RCU mode, drop out of it and legitimize nd->path.
- * Revalidate the final result, unless we'd already done that during
- * the path walk or the filesystem doesn't ask for it.  Return 0 on
- * success, -error on failure.  In case of failure caller does not
- * need to drop nd->path.
- */
-static int complete_walk(struct nameidata *nd)
-{
-	struct dentry *dentry = nd->path.dentry;
-	int status;
-
-	if (nd->flags & LOOKUP_RCU) {
-		/*
-		 * We don't want to zero nd->root for scoped-lookups or
-		 * externally-managed nd->root.
-		 */
-		if (!(nd->state & ND_ROOT_PRESET))
-			if (!(nd->flags & LOOKUP_IS_SCOPED))
-				nd->root.mnt = NULL;
-		nd->flags &= ~LOOKUP_CACHED;
-		if (!try_to_unlazy(nd))
-			return -ECHILD;
-	}
-
-	if (unlikely(nd->flags & LOOKUP_IS_SCOPED)) {
-		/*
-		 * While the guarantee of LOOKUP_IS_SCOPED is (roughly) "don't
-		 * ever step outside the root during lookup" and should already
-		 * be guaranteed by the rest of namei, we want to avoid a namei
-		 * BUG resulting in userspace being given a path that was not
-		 * scoped within the root at some point during the lookup.
-		 *
-		 * So, do a final sanity-check to make sure that in the
-		 * worst-case scenario (a complete bypass of LOOKUP_IS_SCOPED)
-		 * we won't silently return an fd completely outside of the
-		 * requested root to userspace.
-		 *
-		 * Userspace could move the path outside the root after this
-		 * check, but as discussed elsewhere this is not a concern (the
-		 * resolved file was inside the root at some point).
-		 */
-		if (!path_is_under(&nd->path, &nd->root))
-			return -EXDEV;
-	}
-
-	if (likely(!(nd->state & ND_JUMPED)))
-		return 0;
-
-	if (likely(!(dentry->d_flags & DCACHE_OP_WEAK_REVALIDATE)))
-		return 0;
-
-	status = dentry->d_op->d_weak_revalidate(dentry, nd->flags);
-	if (status > 0)
-		return 0;
-
-	if (!status)
-		status = -ESTALE;
-
-	return status;
-}
-
-static int set_root(struct nameidata *nd)
-{
-	struct fs_struct *fs = current->fs;
-
-	/*
-	 * Jumping to the real root in a scoped-lookup is a BUG in namei, but we
-	 * still have to ensure it doesn't happen because it will cause a breakout
-	 * from the dirfd.
-	 */
-	if (WARN_ON(nd->flags & LOOKUP_IS_SCOPED))
-		return -ENOTRECOVERABLE;
-
-	if (nd->flags & LOOKUP_RCU) {
-		unsigned seq;
-
-		do {
-			seq = read_seqcount_begin(&fs->seq);
-			nd->root = fs->root;
-			nd->root_seq = __read_seqcount_begin(&nd->root.dentry->d_seq);
-		} while (read_seqcount_retry(&fs->seq, seq));
-	} else {
-		get_fs_root(fs, &nd->root);
-		nd->state |= ND_ROOT_GRABBED;
-	}
-	return 0;
-}
-
-static int nd_jump_root(struct nameidata *nd)
-{
-	if (unlikely(nd->flags & LOOKUP_BENEATH))
-		return -EXDEV;
-	if (unlikely(nd->flags & LOOKUP_NO_XDEV)) {
-		/* Absolute path arguments to path_init() are allowed. */
-		if (nd->path.mnt != NULL && nd->path.mnt != nd->root.mnt)
-			return -EXDEV;
-	}
-	if (!nd->root.mnt) {
-		int error = set_root(nd);
-		if (error)
-			return error;
-	}
-	if (nd->flags & LOOKUP_RCU) {
-		struct dentry *d;
-		nd->path = nd->root;
-		d = nd->path.dentry;
-		nd->inode = d->d_inode;
-		nd->seq = nd->root_seq;
-		if (read_seqcount_retry(&d->d_seq, nd->seq))
-			return -ECHILD;
-	} else {
-		path_put(&nd->path);
-		nd->path = nd->root;
-		path_get(&nd->path);
-		nd->inode = nd->path.dentry->d_inode;
-	}
-	nd->state |= ND_JUMPED;
-	return 0;
-}
-
-/*
- * Helper to directly jump to a known parsed path from ->get_link,
- * caller must have taken a reference to path beforehand.
- */
-int nd_jump_link(const struct path *path)
-{
-	int error = -ELOOP;
-	struct nameidata *nd = current->nameidata;
-
-	if (unlikely(nd->flags & LOOKUP_NO_MAGICLINKS))
-		goto err;
-
-	error = -EXDEV;
-	if (unlikely(nd->flags & LOOKUP_NO_XDEV)) {
-		if (nd->path.mnt != path->mnt)
-			goto err;
-	}
-	/* Not currently safe for scoped-lookups. */
-	if (unlikely(nd->flags & LOOKUP_IS_SCOPED))
-		goto err;
-
-	path_put(&nd->path);
-	nd->path = *path;
-	nd->inode = nd->path.dentry->d_inode;
-	nd->state |= ND_JUMPED;
-	return 0;
-
-err:
-	path_put(path);
-	return error;
-}
-
-static inline void put_link(struct nameidata *nd)
-{
-	struct saved *last = nd->stack + --nd->depth;
-	do_delayed_call(&last->done);
-	if (!(nd->flags & LOOKUP_RCU))
-		path_put(&last->link);
-}
-
-static int sysctl_protected_symlinks __read_mostly;
-static int sysctl_protected_hardlinks __read_mostly;
-static int sysctl_protected_fifos __read_mostly;
-static int sysctl_protected_regular __read_mostly;
-
-#ifdef CONFIG_SYSCTL
-static const struct ctl_table namei_sysctls[] = {
-	{
-		.procname	= "protected_symlinks",
-		.data		= &sysctl_protected_symlinks,
-		.maxlen		= sizeof(int),
-		.mode		= 0644,
-		.proc_handler	= proc_dointvec_minmax,
-		.extra1		= SYSCTL_ZERO,
-		.extra2		= SYSCTL_ONE,
-	},
-	{
-		.procname	= "protected_hardlinks",
-		.data		= &sysctl_protected_hardlinks,
-		.maxlen		= sizeof(int),
-		.mode		= 0644,
-		.proc_handler	= proc_dointvec_minmax,
-		.extra1		= SYSCTL_ZERO,
-		.extra2		= SYSCTL_ONE,
-	},
-	{
-		.procname	= "protected_fifos",
-		.data		= &sysctl_protected_fifos,
-		.maxlen		= sizeof(int),
-		.mode		= 0644,
-		.proc_handler	= proc_dointvec_minmax,
-		.extra1		= SYSCTL_ZERO,
-		.extra2		= SYSCTL_TWO,
-	},
-	{
-		.procname	= "protected_regular",
-		.data		= &sysctl_protected_regular,
-		.maxlen		= sizeof(int),
-		.mode		= 0644,
-		.proc_handler	= proc_dointvec_minmax,
-		.extra1		= SYSCTL_ZERO,
-		.extra2		= SYSCTL_TWO,
-	},
-};
-
-static int __init init_fs_namei_sysctls(void)
-{
-	register_sysctl_init("fs", namei_sysctls);
-	return 0;
-}
-fs_initcall(init_fs_namei_sysctls);
-
-#endif /* CONFIG_SYSCTL */
-
-/**
- * may_follow_link - Check symlink following for unsafe situations
- * @nd: nameidata pathwalk data
- * @inode: Used for idmapping.
- *
- * In the case of the sysctl_protected_symlinks sysctl being enabled,
- * CAP_DAC_OVERRIDE needs to be specifically ignored if the symlink is
- * in a sticky world-writable directory. This is to protect privileged
- * processes from failing races against path names that may change out
- * from under them by way of other users creating malicious symlinks.
- * It will permit symlinks to be followed only when outside a sticky
- * world-writable directory, or when the uid of the symlink and follower
- * match, or when the directory owner matches the symlink's owner.
- *
- * Returns 0 if following the symlink is allowed, -ve on error.
- */
-static inline int may_follow_link(struct nameidata *nd, const struct inode *inode)
-{
-	struct mnt_idmap *idmap;
-	vfsuid_t vfsuid;
-
-	if (!sysctl_protected_symlinks)
-		return 0;
-
-	idmap = mnt_idmap(nd->path.mnt);
-	vfsuid = i_uid_into_vfsuid(idmap, inode);
-	/* Allowed if owner and follower match. */
-	if (vfsuid_eq_kuid(vfsuid, current_fsuid()))
-		return 0;
-
-	/* Allowed if parent directory not sticky and world-writable. */
-	if ((nd->dir_mode & (S_ISVTX|S_IWOTH)) != (S_ISVTX|S_IWOTH))
-		return 0;
-
-	/* Allowed if parent directory and link owner match. */
-	if (vfsuid_valid(nd->dir_vfsuid) && vfsuid_eq(nd->dir_vfsuid, vfsuid))
-		return 0;
-
-	if (nd->flags & LOOKUP_RCU)
-		return -ECHILD;
-
-	audit_inode(nd->name, nd->stack[0].link.dentry, 0);
-	audit_log_path_denied(AUDIT_ANOM_LINK, "follow_link");
-	return -EACCES;
-}
-
-/**
- * safe_hardlink_source - Check for safe hardlink conditions
- * @idmap: idmap of the mount the inode was found from
- * @inode: the source inode to hardlink from
- *
- * Return false if at least one of the following conditions:
- *    - inode is not a regular file
- *    - inode is setuid
- *    - inode is setgid and group-exec
- *    - access failure for read and write
- *
- * Otherwise returns true.
- */
-static bool safe_hardlink_source(struct mnt_idmap *idmap,
-				 struct inode *inode)
-{
-	umode_t mode = inode->i_mode;
-
-	/* Special files should not get pinned to the filesystem. */
-	if (!S_ISREG(mode))
-		return false;
-
-	/* Setuid files should not get pinned to the filesystem. */
-	if (mode & S_ISUID)
-		return false;
-
-	/* Executable setgid files should not get pinned to the filesystem. */
-	if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP))
-		return false;
-
-	/* Hardlinking to unreadable or unwritable sources is dangerous. */
-	if (inode_permission(idmap, inode, MAY_READ | MAY_WRITE))
-		return false;
-
-	return true;
-}
-
-/**
- * may_linkat - Check permissions for creating a hardlink
- * @idmap: idmap of the mount the inode was found from
- * @link:  the source to hardlink from
- *
- * Block hardlink when all of:
- *  - sysctl_protected_hardlinks enabled
- *  - fsuid does not match inode
- *  - hardlink source is unsafe (see safe_hardlink_source() above)
- *  - not CAP_FOWNER in a namespace with the inode owner uid mapped
- *
- * If the inode has been found through an idmapped mount the idmap of
- * the vfsmount must be passed through @idmap. This function will then take
- * care to map the inode according to @idmap before checking permissions.
- * On non-idmapped mounts or if permission checking is to be performed on the
- * raw inode simply pass @nop_mnt_idmap.
- *
- * Returns 0 if successful, -ve on error.
- */
-int may_linkat(struct mnt_idmap *idmap, const struct path *link)
-{
-	struct inode *inode = link->dentry->d_inode;
-
-	/* Inode writeback is not safe when the uid or gid are invalid. */
-	if (!vfsuid_valid(i_uid_into_vfsuid(idmap, inode)) ||
-	    !vfsgid_valid(i_gid_into_vfsgid(idmap, inode)))
-		return -EOVERFLOW;
-
-	if (!sysctl_protected_hardlinks)
-		return 0;
-
-	/* Source inode owner (or CAP_FOWNER) can hardlink all they like,
-	 * otherwise, it must be a safe source.
-	 */
-	if (safe_hardlink_source(idmap, inode) ||
-	    inode_owner_or_capable(idmap, inode))
-		return 0;
-
-	audit_log_path_denied(AUDIT_ANOM_LINK, "linkat");
-	return -EPERM;
-}
-
-/**
- * may_create_in_sticky - Check whether an O_CREAT open in a sticky directory
- *			  should be allowed, or not, on files that already
- *			  exist.
- * @idmap: idmap of the mount the inode was found from
- * @nd: nameidata pathwalk data
- * @inode: the inode of the file to open
- *
- * Block an O_CREAT open of a FIFO (or a regular file) when:
- *   - sysctl_protected_fifos (or sysctl_protected_regular) is enabled
- *   - the file already exists
- *   - we are in a sticky directory
- *   - we don't own the file
- *   - the owner of the directory doesn't own the file
- *   - the directory is world writable
- * If the sysctl_protected_fifos (or sysctl_protected_regular) is set to 2
- * the directory doesn't have to be world writable: being group writable will
- * be enough.
- *
- * If the inode has been found through an idmapped mount the idmap of
- * the vfsmount must be passed through @idmap. This function will then take
- * care to map the inode according to @idmap before checking permissions.
- * On non-idmapped mounts or if permission checking is to be performed on the
- * raw inode simply pass @nop_mnt_idmap.
- *
- * Returns 0 if the open is allowed, -ve on error.
- */
-static int may_create_in_sticky(struct mnt_idmap *idmap, struct nameidata *nd,
-				struct inode *const inode)
-{
-	umode_t dir_mode = nd->dir_mode;
-	vfsuid_t dir_vfsuid = nd->dir_vfsuid, i_vfsuid;
-
-	if (likely(!(dir_mode & S_ISVTX)))
-		return 0;
-
-	if (S_ISREG(inode->i_mode) && !sysctl_protected_regular)
-		return 0;
-
-	if (S_ISFIFO(inode->i_mode) && !sysctl_protected_fifos)
-		return 0;
-
-	i_vfsuid = i_uid_into_vfsuid(idmap, inode);
-
-	if (vfsuid_eq(i_vfsuid, dir_vfsuid))
-		return 0;
-
-	if (vfsuid_eq_kuid(i_vfsuid, current_fsuid()))
-		return 0;
-
-	if (likely(dir_mode & 0002)) {
-		audit_log_path_denied(AUDIT_ANOM_CREAT, "sticky_create");
-		return -EACCES;
-	}
-
-	if (dir_mode & 0020) {
-		if (sysctl_protected_fifos >= 2 && S_ISFIFO(inode->i_mode)) {
-			audit_log_path_denied(AUDIT_ANOM_CREAT,
-					      "sticky_create_fifo");
-			return -EACCES;
-		}
-
-		if (sysctl_protected_regular >= 2 && S_ISREG(inode->i_mode)) {
-			audit_log_path_denied(AUDIT_ANOM_CREAT,
-					      "sticky_create_regular");
-			return -EACCES;
-		}
-	}
-
-	return 0;
-}
-
-/*
- * follow_up - Find the mountpoint of path's vfsmount
- *
- * Given a path, find the mountpoint of its source file system.
- * Replace @path with the path of the mountpoint in the parent mount.
- * Up is towards /.
- *
- * Return 1 if we went up a level and 0 if we were already at the
- * root.
- */
-int follow_up(struct path *path)
-{
-	struct mount *mnt = real_mount(path->mnt);
-	struct mount *parent;
-	struct dentry *mountpoint;
-
-	read_seqlock_excl(&mount_lock);
-	parent = mnt->mnt_parent;
-	if (parent == mnt) {
-		read_sequnlock_excl(&mount_lock);
-		return 0;
-	}
-	mntget(&parent->mnt);
-	mountpoint = dget(mnt->mnt_mountpoint);
-	read_sequnlock_excl(&mount_lock);
-	dput(path->dentry);
-	path->dentry = mountpoint;
-	mntput(path->mnt);
-	path->mnt = &parent->mnt;
-	return 1;
-}
-EXPORT_SYMBOL(follow_up);
-
-static bool choose_mountpoint_rcu(struct mount *m, const struct path *root,
-				  struct path *path, unsigned *seqp)
-{
-	while (mnt_has_parent(m)) {
-		struct dentry *mountpoint = m->mnt_mountpoint;
-
-		m = m->mnt_parent;
-		if (unlikely(root->dentry == mountpoint &&
-			     root->mnt == &m->mnt))
-			break;
-		if (mountpoint != m->mnt.mnt_root) {
-			path->mnt = &m->mnt;
-			path->dentry = mountpoint;
-			*seqp = read_seqcount_begin(&mountpoint->d_seq);
-			return true;
-		}
-	}
-	return false;
-}
-
-static bool choose_mountpoint(struct mount *m, const struct path *root,
-			      struct path *path)
-{
-	bool found;
-
-	rcu_read_lock();
-	while (1) {
-		unsigned seq, mseq = read_seqbegin(&mount_lock);
-
-		found = choose_mountpoint_rcu(m, root, path, &seq);
-		if (unlikely(!found)) {
-			if (!read_seqretry(&mount_lock, mseq))
-				break;
-		} else {
-			if (likely(__legitimize_path(path, seq, mseq)))
-				break;
-			rcu_read_unlock();
-			path_put(path);
-			rcu_read_lock();
-		}
-	}
-	rcu_read_unlock();
-	return found;
-}
-
-/*
- * Perform an automount
- * - return -EISDIR to tell follow_managed() to stop and return the path we
- *   were called with.
- */
-static int follow_automount(struct path *path, int *count, unsigned lookup_flags)
-{
-	struct dentry *dentry = path->dentry;
-
-	/* We don't want to mount if someone's just doing a stat -
-	 * unless they're stat'ing a directory and appended a '/' to
-	 * the name.
-	 *
-	 * We do, however, want to mount if someone wants to open or
-	 * create a file of any type under the mountpoint, wants to
-	 * traverse through the mountpoint or wants to open the
-	 * mounted directory.  Also, autofs may mark negative dentries
-	 * as being automount points.  These will need the attentions
-	 * of the daemon to instantiate them before they can be used.
-	 */
-	if (!(lookup_flags & (LOOKUP_PARENT | LOOKUP_DIRECTORY |
-			   LOOKUP_OPEN | LOOKUP_CREATE | LOOKUP_AUTOMOUNT)) &&
-	    dentry->d_inode)
-		return -EISDIR;
-
-	if (count && (*count)++ >= MAXSYMLINKS)
-		return -ELOOP;
-
-	return finish_automount(dentry->d_op->d_automount(path), path);
-}
-
-/*
- * mount traversal - out-of-line part.  One note on ->d_flags accesses -
- * dentries are pinned but not locked here, so negative dentry can go
- * positive right under us.  Use of smp_load_acquire() provides a barrier
- * sufficient for ->d_inode and ->d_flags consistency.
- */
-static int __traverse_mounts(struct path *path, unsigned flags, bool *jumped,
-			     int *count, unsigned lookup_flags)
-{
-	struct vfsmount *mnt = path->mnt;
-	bool need_mntput = false;
-	int ret = 0;
-
-	while (flags & DCACHE_MANAGED_DENTRY) {
-		/* Allow the filesystem to manage the transit without i_mutex
-		 * being held. */
-		if (flags & DCACHE_MANAGE_TRANSIT) {
-			ret = path->dentry->d_op->d_manage(path, false);
-			flags = smp_load_acquire(&path->dentry->d_flags);
-			if (ret < 0)
-				break;
-		}
-
-		if (flags & DCACHE_MOUNTED) {	// something's mounted on it..
-			struct vfsmount *mounted = lookup_mnt(path);
-			if (mounted) {		// ... in our namespace
-				dput(path->dentry);
-				if (need_mntput)
-					mntput(path->mnt);
-				path->mnt = mounted;
-				path->dentry = dget(mounted->mnt_root);
-				// here we know it's positive
-				flags = path->dentry->d_flags;
-				need_mntput = true;
-				continue;
-			}
-		}
-
-		if (!(flags & DCACHE_NEED_AUTOMOUNT))
-			break;
-
-		// uncovered automount point
-		ret = follow_automount(path, count, lookup_flags);
-		flags = smp_load_acquire(&path->dentry->d_flags);
-		if (ret < 0)
-			break;
-	}
-
-	if (ret == -EISDIR)
-		ret = 0;
-	// possible if you race with several mount --move
-	if (need_mntput && path->mnt == mnt)
-		mntput(path->mnt);
-	if (!ret && unlikely(d_flags_negative(flags)))
-		ret = -ENOENT;
-	*jumped = need_mntput;
-	return ret;
-}
-
-static inline int traverse_mounts(struct path *path, bool *jumped,
-				  int *count, unsigned lookup_flags)
-{
-	unsigned flags = smp_load_acquire(&path->dentry->d_flags);
-
-	/* fastpath */
-	if (likely(!(flags & DCACHE_MANAGED_DENTRY))) {
-		*jumped = false;
-		if (unlikely(d_flags_negative(flags)))
-			return -ENOENT;
-		return 0;
-	}
-	return __traverse_mounts(path, flags, jumped, count, lookup_flags);
-}
-
-int follow_down_one(struct path *path)
-{
-	struct vfsmount *mounted;
-
-	mounted = lookup_mnt(path);
-	if (mounted) {
-		dput(path->dentry);
-		mntput(path->mnt);
-		path->mnt = mounted;
-		path->dentry = dget(mounted->mnt_root);
-		return 1;
-	}
-	return 0;
-}
-EXPORT_SYMBOL(follow_down_one);
-
-/*
- * Follow down to the covering mount currently visible to userspace.  At each
- * point, the filesystem owning that dentry may be queried as to whether the
- * caller is permitted to proceed or not.
- */
-int follow_down(struct path *path, unsigned int flags)
-{
-	struct vfsmount *mnt = path->mnt;
-	bool jumped;
-	int ret = traverse_mounts(path, &jumped, NULL, flags);
-
-	if (path->mnt != mnt)
-		mntput(mnt);
-	return ret;
-}
-EXPORT_SYMBOL(follow_down);
-
-/*
- * Try to skip to top of mountpoint pile in rcuwalk mode.  Fail if
- * we meet a managed dentry that would need blocking.
- */
-static bool __follow_mount_rcu(struct nameidata *nd, struct path *path)
-{
-	struct dentry *dentry = path->dentry;
-	unsigned int flags = dentry->d_flags;
-
-	if (likely(!(flags & DCACHE_MANAGED_DENTRY)))
-		return true;
-
-	if (unlikely(nd->flags & LOOKUP_NO_XDEV))
-		return false;
-
-	for (;;) {
-		/*
-		 * Don't forget we might have a non-mountpoint managed dentry
-		 * that wants to block transit.
-		 */
-		if (unlikely(flags & DCACHE_MANAGE_TRANSIT)) {
-			int res = dentry->d_op->d_manage(path, true);
-			if (res)
-				return res == -EISDIR;
-			flags = dentry->d_flags;
-		}
-
-		if (flags & DCACHE_MOUNTED) {
-			struct mount *mounted = __lookup_mnt(path->mnt, dentry);
-			if (mounted) {
-				path->mnt = &mounted->mnt;
-				dentry = path->dentry = mounted->mnt.mnt_root;
-				nd->state |= ND_JUMPED;
-				nd->next_seq = read_seqcount_begin(&dentry->d_seq);
-				flags = dentry->d_flags;
-				// makes sure that non-RCU pathwalk could reach
-				// this state.
-				if (read_seqretry(&mount_lock, nd->m_seq))
-					return false;
-				continue;
-			}
-			if (read_seqretry(&mount_lock, nd->m_seq))
-				return false;
-		}
-		return !(flags & DCACHE_NEED_AUTOMOUNT);
-	}
-}
-
-static inline int handle_mounts(struct nameidata *nd, struct dentry *dentry,
-			  struct path *path)
-{
-	bool jumped;
-	int ret;
-
-	path->mnt = nd->path.mnt;
-	path->dentry = dentry;
-	if (nd->flags & LOOKUP_RCU) {
-		unsigned int seq = nd->next_seq;
-		if (likely(__follow_mount_rcu(nd, path)))
-			return 0;
-		// *path and nd->next_seq might've been clobbered
-		path->mnt = nd->path.mnt;
-		path->dentry = dentry;
-		nd->next_seq = seq;
-		if (!try_to_unlazy_next(nd, dentry))
-			return -ECHILD;
-	}
-	ret = traverse_mounts(path, &jumped, &nd->total_link_count, nd->flags);
-	if (jumped) {
-		if (unlikely(nd->flags & LOOKUP_NO_XDEV))
-			ret = -EXDEV;
-		else
-			nd->state |= ND_JUMPED;
-	}
-	if (unlikely(ret)) {
-		dput(path->dentry);
-		if (path->mnt != nd->path.mnt)
-			mntput(path->mnt);
-	}
-	return ret;
-}
-
-/*
- * This looks up the name in dcache and possibly revalidates the found dentry.
- * NULL is returned if the dentry does not exist in the cache.
- */
-static struct dentry *lookup_dcache(const struct qstr *name,
-				    struct dentry *dir,
-				    unsigned int flags)
-{
-	struct dentry *dentry = d_lookup(dir, name);
-	if (dentry) {
-		int error = d_revalidate(dir->d_inode, name, dentry, flags);
-		if (unlikely(error <= 0)) {
-			if (!error)
-				d_invalidate(dentry);
-			dput(dentry);
-			return ERR_PTR(error);
-		}
-	}
-	return dentry;
-}
-
-static struct dentry *lookup_one_qstr_excl_raw(const struct qstr *name,
-					       struct dentry *base,
-					       unsigned int flags)
-{
-	struct dentry *dentry;
-	struct dentry *old;
-	struct inode *dir;
-
-	dentry = lookup_dcache(name, base, flags);
-	if (dentry)
-		return dentry;
-
-	/* Don't create child dentry for a dead directory. */
-	dir = base->d_inode;
-	if (unlikely(IS_DEADDIR(dir)))
-		return ERR_PTR(-ENOENT);
-
-	dentry = d_alloc(base, name);
-	if (unlikely(!dentry))
-		return ERR_PTR(-ENOMEM);
-
-	old = dir->i_op->lookup(dir, dentry, flags);
-	if (unlikely(old)) {
-		dput(dentry);
-		dentry = old;
-	}
-	return dentry;
-}
-
-/*
- * Parent directory has inode locked exclusive.  This is one
- * and only case when ->lookup() gets called on non in-lookup
- * dentries - as the matter of fact, this only gets called
- * when directory is guaranteed to have no in-lookup children
- * at all.
- * Will return -ENOENT if name isn't found and LOOKUP_CREATE wasn't passed.
- * Will return -EEXIST if name is found and LOOKUP_EXCL was passed.
- */
-struct dentry *lookup_one_qstr_excl(const struct qstr *name,
-				    struct dentry *base, unsigned int flags)
-{
-	struct dentry *dentry;
-
-	dentry = lookup_one_qstr_excl_raw(name, base, flags);
-	if (IS_ERR(dentry))
-		return dentry;
-	if (d_is_negative(dentry) && !(flags & LOOKUP_CREATE)) {
-		dput(dentry);
-		return ERR_PTR(-ENOENT);
-	}
-	if (d_is_positive(dentry) && (flags & LOOKUP_EXCL)) {
-		dput(dentry);
-		return ERR_PTR(-EEXIST);
-	}
-	return dentry;
-}
-EXPORT_SYMBOL(lookup_one_qstr_excl);
-
-/**
- * lookup_fast - do fast lockless (but racy) lookup of a dentry
- * @nd: current nameidata
- *
- * Do a fast, but racy lookup in the dcache for the given dentry, and
- * revalidate it. Returns a valid dentry pointer or NULL if one wasn't
- * found. On error, an ERR_PTR will be returned.
- *
- * If this function returns a valid dentry and the walk is no longer
- * lazy, the dentry will carry a reference that must later be put. If
- * RCU mode is still in force, then this is not the case and the dentry
- * must be legitimized before use. If this returns NULL, then the walk
- * will no longer be in RCU mode.
- */
-static struct dentry *lookup_fast(struct nameidata *nd)
-{
-	struct dentry *dentry, *parent = nd->path.dentry;
-	int status = 1;
-
-	/*
-	 * Rename seqlock is not required here because in the off chance
-	 * of a false negative due to a concurrent rename, the caller is
-	 * going to fall back to non-racy lookup.
-	 */
-	if (nd->flags & LOOKUP_RCU) {
-		dentry = __d_lookup_rcu(parent, &nd->last, &nd->next_seq);
-		if (unlikely(!dentry)) {
-			if (!try_to_unlazy(nd))
-				return ERR_PTR(-ECHILD);
-			return NULL;
-		}
-
-		/*
-		 * This sequence count validates that the parent had no
-		 * changes while we did the lookup of the dentry above.
-		 */
-		if (read_seqcount_retry(&parent->d_seq, nd->seq))
-			return ERR_PTR(-ECHILD);
-
-		status = d_revalidate(nd->inode, &nd->last, dentry, nd->flags);
-		if (likely(status > 0))
-			return dentry;
-		if (!try_to_unlazy_next(nd, dentry))
-			return ERR_PTR(-ECHILD);
-		if (status == -ECHILD)
-			/* we'd been told to redo it in non-rcu mode */
-			status = d_revalidate(nd->inode, &nd->last,
-					      dentry, nd->flags);
-	} else {
-		dentry = __d_lookup(parent, &nd->last);
-		if (unlikely(!dentry))
-			return NULL;
-		status = d_revalidate(nd->inode, &nd->last, dentry, nd->flags);
-	}
-	if (unlikely(status <= 0)) {
-		if (!status)
-			d_invalidate(dentry);
-		dput(dentry);
-		return ERR_PTR(status);
-	}
-	return dentry;
-}
-
-/* Fast lookup failed, do it the slow way */
-static struct dentry *__lookup_slow(const struct qstr *name,
-				    struct dentry *dir,
-				    unsigned int flags)
-{
-	struct dentry *dentry, *old;
-	struct inode *inode = dir->d_inode;
-	DECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq);
-
-	/* Don't go there if it's already dead */
-	if (unlikely(IS_DEADDIR(inode)))
-		return ERR_PTR(-ENOENT);
-again:
-	dentry = d_alloc_parallel(dir, name, &wq);
-	if (IS_ERR(dentry))
-		return dentry;
-	if (unlikely(!d_in_lookup(dentry))) {
-		int error = d_revalidate(inode, name, dentry, flags);
-		if (unlikely(error <= 0)) {
-			if (!error) {
-				d_invalidate(dentry);
-				dput(dentry);
-				goto again;
-			}
-			dput(dentry);
-			dentry = ERR_PTR(error);
-		}
-	} else {
-		old = inode->i_op->lookup(inode, dentry, flags);
-		d_lookup_done(dentry);
-		if (unlikely(old)) {
-			dput(dentry);
-			dentry = old;
-		}
-	}
-	return dentry;
-}
-
-static struct dentry *lookup_slow(const struct qstr *name,
-				  struct dentry *dir,
-				  unsigned int flags)
-{
-	struct inode *inode = dir->d_inode;
-	struct dentry *res;
-	inode_lock_shared(inode);
-	res = __lookup_slow(name, dir, flags);
-	inode_unlock_shared(inode);
-	return res;
-}
-
-static inline int may_lookup(struct mnt_idmap *idmap,
-			     struct nameidata *restrict nd)
-{
-	int err, mask;
-
-	mask = nd->flags & LOOKUP_RCU ? MAY_NOT_BLOCK : 0;
-	err = inode_permission(idmap, nd->inode, mask | MAY_EXEC);
-	if (likely(!err))
-		return 0;
-
-	// If we failed, and we weren't in LOOKUP_RCU, it's final
-	if (!(nd->flags & LOOKUP_RCU))
-		return err;
-
-	// Drop out of RCU mode to make sure it wasn't transient
-	if (!try_to_unlazy(nd))
-		return -ECHILD;	// redo it all non-lazy
-
-	if (err != -ECHILD)	// hard error
-		return err;
-
-	return inode_permission(idmap, nd->inode, MAY_EXEC);
-}
-
-static int reserve_stack(struct nameidata *nd, struct path *link)
-{
-	if (unlikely(nd->total_link_count++ >= MAXSYMLINKS))
-		return -ELOOP;
-
-	if (likely(nd->depth != EMBEDDED_LEVELS))
-		return 0;
-	if (likely(nd->stack != nd->internal))
-		return 0;
-	if (likely(nd_alloc_stack(nd)))
-		return 0;
-
-	if (nd->flags & LOOKUP_RCU) {
-		// we need to grab link before we do unlazy.  And we can't skip
-		// unlazy even if we fail to grab the link - cleanup needs it
-		bool grabbed_link = legitimize_path(nd, link, nd->next_seq);
-
-		if (!try_to_unlazy(nd) || !grabbed_link)
-			return -ECHILD;
-
-		if (nd_alloc_stack(nd))
-			return 0;
-	}
-	return -ENOMEM;
-}
-
-enum {WALK_TRAILING = 1, WALK_MORE = 2, WALK_NOFOLLOW = 4};
-
-static const char *pick_link(struct nameidata *nd, struct path *link,
-		     struct inode *inode, int flags)
-{
-	struct saved *last;
-	const char *res;
-	int error = reserve_stack(nd, link);
-
-	if (unlikely(error)) {
-		if (!(nd->flags & LOOKUP_RCU))
-			path_put(link);
-		return ERR_PTR(error);
-	}
-	last = nd->stack + nd->depth++;
-	last->link = *link;
-	clear_delayed_call(&last->done);
-	last->seq = nd->next_seq;
-
-	if (flags & WALK_TRAILING) {
-		error = may_follow_link(nd, inode);
-		if (unlikely(error))
-			return ERR_PTR(error);
-	}
-
-	if (unlikely(nd->flags & LOOKUP_NO_SYMLINKS) ||
-			unlikely(link->mnt->mnt_flags & MNT_NOSYMFOLLOW))
-		return ERR_PTR(-ELOOP);
-
-	if (unlikely(atime_needs_update(&last->link, inode))) {
-		if (nd->flags & LOOKUP_RCU) {
-			if (!try_to_unlazy(nd))
-				return ERR_PTR(-ECHILD);
-		}
-		touch_atime(&last->link);
-		cond_resched();
-	}
-
-	error = security_inode_follow_link(link->dentry, inode,
-					   nd->flags & LOOKUP_RCU);
-	if (unlikely(error))
-		return ERR_PTR(error);
-
-	res = READ_ONCE(inode->i_link);
-	if (!res) {
-		const char * (*get)(struct dentry *, struct inode *,
-				struct delayed_call *);
-		get = inode->i_op->get_link;
-		if (nd->flags & LOOKUP_RCU) {
-			res = get(NULL, inode, &last->done);
-			if (res == ERR_PTR(-ECHILD) && try_to_unlazy(nd))
-				res = get(link->dentry, inode, &last->done);
-		} else {
-			res = get(link->dentry, inode, &last->done);
-		}
-		if (!res)
-			goto all_done;
-		if (IS_ERR(res))
-			return res;
-	}
-	if (*res == '/') {
-		error = nd_jump_root(nd);
-		if (unlikely(error))
-			return ERR_PTR(error);
-		while (unlikely(*++res == '/'))
-			;
-	}
-	if (*res)
-		return res;
-all_done: // pure jump
-	put_link(nd);
-	return NULL;
-}
-
-/*
- * Do we need to follow links? We _really_ want to be able
- * to do this check without having to look at inode->i_op,
- * so we keep a cache of "no, this doesn't need follow_link"
- * for the common case.
- *
- * NOTE: dentry must be what nd->next_seq had been sampled from.
- */
-static const char *step_into(struct nameidata *nd, int flags,
-		     struct dentry *dentry)
-{
-	struct path path;
-	struct inode *inode;
-	int err = handle_mounts(nd, dentry, &path);
-
-	if (err < 0)
-		return ERR_PTR(err);
-	inode = path.dentry->d_inode;
-	if (likely(!d_is_symlink(path.dentry)) ||
-	   ((flags & WALK_TRAILING) && !(nd->flags & LOOKUP_FOLLOW)) ||
-	   (flags & WALK_NOFOLLOW)) {
-		/* not a symlink or should not follow */
-		if (nd->flags & LOOKUP_RCU) {
-			if (read_seqcount_retry(&path.dentry->d_seq, nd->next_seq))
-				return ERR_PTR(-ECHILD);
-			if (unlikely(!inode))
-				return ERR_PTR(-ENOENT);
-		} else {
-			dput(nd->path.dentry);
-			if (nd->path.mnt != path.mnt)
-				mntput(nd->path.mnt);
-		}
-		nd->path = path;
-		nd->inode = inode;
-		nd->seq = nd->next_seq;
-		return NULL;
-	}
-	if (nd->flags & LOOKUP_RCU) {
-		/* make sure that d_is_symlink above matches inode */
-		if (read_seqcount_retry(&path.dentry->d_seq, nd->next_seq))
-			return ERR_PTR(-ECHILD);
-	} else {
-		if (path.mnt == nd->path.mnt)
-			mntget(path.mnt);
-	}
-	return pick_link(nd, &path, inode, flags);
-}
-
-static struct dentry *follow_dotdot_rcu(struct nameidata *nd)
-{
-	struct dentry *parent, *old;
-
-	if (path_equal(&nd->path, &nd->root))
-		goto in_root;
-	if (unlikely(nd->path.dentry == nd->path.mnt->mnt_root)) {
-		struct path path;
-		unsigned seq;
-		if (!choose_mountpoint_rcu(real_mount(nd->path.mnt),
-					   &nd->root, &path, &seq))
-			goto in_root;
-		if (unlikely(nd->flags & LOOKUP_NO_XDEV))
-			return ERR_PTR(-ECHILD);
-		nd->path = path;
-		nd->inode = path.dentry->d_inode;
-		nd->seq = seq;
-		// makes sure that non-RCU pathwalk could reach this state
-		if (read_seqretry(&mount_lock, nd->m_seq))
-			return ERR_PTR(-ECHILD);
-		/* we know that mountpoint was pinned */
-	}
-	old = nd->path.dentry;
-	parent = old->d_parent;
-	nd->next_seq = read_seqcount_begin(&parent->d_seq);
-	// makes sure that non-RCU pathwalk could reach this state
-	if (read_seqcount_retry(&old->d_seq, nd->seq))
-		return ERR_PTR(-ECHILD);
-	if (unlikely(!path_connected(nd->path.mnt, parent)))
-		return ERR_PTR(-ECHILD);
-	return parent;
-in_root:
-	if (read_seqretry(&mount_lock, nd->m_seq))
-		return ERR_PTR(-ECHILD);
-	if (unlikely(nd->flags & LOOKUP_BENEATH))
-		return ERR_PTR(-ECHILD);
-	nd->next_seq = nd->seq;
-	return nd->path.dentry;
-}
-
-static struct dentry *follow_dotdot(struct nameidata *nd)
-{
-	struct dentry *parent;
-
-	if (path_equal(&nd->path, &nd->root))
-		goto in_root;
-	if (unlikely(nd->path.dentry == nd->path.mnt->mnt_root)) {
-		struct path path;
-
-		if (!choose_mountpoint(real_mount(nd->path.mnt),
-				       &nd->root, &path))
-			goto in_root;
-		path_put(&nd->path);
-		nd->path = path;
-		nd->inode = path.dentry->d_inode;
-		if (unlikely(nd->flags & LOOKUP_NO_XDEV))
-			return ERR_PTR(-EXDEV);
-	}
-	/* rare case of legitimate dget_parent()... */
-	parent = dget_parent(nd->path.dentry);
-	if (unlikely(!path_connected(nd->path.mnt, parent))) {
-		dput(parent);
-		return ERR_PTR(-ENOENT);
-	}
-	return parent;
-
-in_root:
-	if (unlikely(nd->flags & LOOKUP_BENEATH))
-		return ERR_PTR(-EXDEV);
-	return dget(nd->path.dentry);
-}
-
-static const char *handle_dots(struct nameidata *nd, int type)
-{
-	if (type == LAST_DOTDOT) {
-		const char *error = NULL;
-		struct dentry *parent;
-
-		if (!nd->root.mnt) {
-			error = ERR_PTR(set_root(nd));
-			if (error)
-				return error;
-		}
-		if (nd->flags & LOOKUP_RCU)
-			parent = follow_dotdot_rcu(nd);
-		else
-			parent = follow_dotdot(nd);
-		if (IS_ERR(parent))
-			return ERR_CAST(parent);
-		error = step_into(nd, WALK_NOFOLLOW, parent);
-		if (unlikely(error))
-			return error;
-
-		if (unlikely(nd->flags & LOOKUP_IS_SCOPED)) {
-			/*
-			 * If there was a racing rename or mount along our
-			 * path, then we can't be sure that ".." hasn't jumped
-			 * above nd->root (and so userspace should retry or use
-			 * some fallback).
-			 */
-			smp_rmb();
-			if (__read_seqcount_retry(&mount_lock.seqcount, nd->m_seq))
-				return ERR_PTR(-EAGAIN);
-			if (__read_seqcount_retry(&rename_lock.seqcount, nd->r_seq))
-				return ERR_PTR(-EAGAIN);
-		}
-	}
-	return NULL;
-}
-
-static const char *walk_component(struct nameidata *nd, int flags)
-{
-	struct dentry *dentry;
-	/*
-	 * "." and ".." are special - ".." especially so because it has
-	 * to be able to know about the current root directory and
-	 * parent relationships.
-	 */
-	if (unlikely(nd->last_type != LAST_NORM)) {
-		if (!(flags & WALK_MORE) && nd->depth)
-			put_link(nd);
-		return handle_dots(nd, nd->last_type);
-	}
-	dentry = lookup_fast(nd);
-	if (IS_ERR(dentry))
-		return ERR_CAST(dentry);
-	if (unlikely(!dentry)) {
-		dentry = lookup_slow(&nd->last, nd->path.dentry, nd->flags);
-		if (IS_ERR(dentry))
-			return ERR_CAST(dentry);
-	}
-	if (!(flags & WALK_MORE) && nd->depth)
-		put_link(nd);
-	return step_into(nd, flags, dentry);
-}
-
-/*
- * We can do the critical dentry name comparison and hashing
- * operations one word at a time, but we are limited to:
- *
- * - Architectures with fast unaligned word accesses. We could
- *   do a "get_unaligned()" if this helps and is sufficiently
- *   fast.
- *
- * - non-CONFIG_DEBUG_PAGEALLOC configurations (so that we
- *   do not trap on the (extremely unlikely) case of a page
- *   crossing operation.
- *
- * - Furthermore, we need an efficient 64-bit compile for the
- *   64-bit case in order to generate the "number of bytes in
- *   the final mask". Again, that could be replaced with a
- *   efficient population count instruction or similar.
- */
-#ifdef CONFIG_DCACHE_WORD_ACCESS
-
-#include <asm/word-at-a-time.h>
-
-#ifdef HASH_MIX
-
-/* Architecture provides HASH_MIX and fold_hash() in <asm/hash.h> */
-
-#elif defined(CONFIG_64BIT)
-/*
- * Register pressure in the mixing function is an issue, particularly
- * on 32-bit x86, but almost any function requires one state value and
- * one temporary.  Instead, use a function designed for two state values
- * and no temporaries.
- *
- * This function cannot create a collision in only two iterations, so
- * we have two iterations to achieve avalanche.  In those two iterations,
- * we have six layers of mixing, which is enough to spread one bit's
- * influence out to 2^6 = 64 state bits.
- *
- * Rotate constants are scored by considering either 64 one-bit input
- * deltas or 64*63/2 = 2016 two-bit input deltas, and finding the
- * probability of that delta causing a change to each of the 128 output
- * bits, using a sample of random initial states.
- *
- * The Shannon entropy of the computed probabilities is then summed
- * to produce a score.  Ideally, any input change has a 50% chance of
- * toggling any given output bit.
- *
- * Mixing scores (in bits) for (12,45):
- * Input delta: 1-bit      2-bit
- * 1 round:     713.3    42542.6
- * 2 rounds:   2753.7   140389.8
- * 3 rounds:   5954.1   233458.2
- * 4 rounds:   7862.6   256672.2
- * Perfect:    8192     258048
- *            (64*128) (64*63/2 * 128)
- */
-#define HASH_MIX(x, y, a)	\
-	(	x ^= (a),	\
-	y ^= x,	x = rol64(x,12),\
-	x += y,	y = rol64(y,45),\
-	y *= 9			)
-
-/*
- * Fold two longs into one 32-bit hash value.  This must be fast, but
- * latency isn't quite as critical, as there is a fair bit of additional
- * work done before the hash value is used.
- */
-static inline unsigned int fold_hash(unsigned long x, unsigned long y)
-{
-	y ^= x * GOLDEN_RATIO_64;
-	y *= GOLDEN_RATIO_64;
-	return y >> 32;
-}
-
-#else	/* 32-bit case */
-
-/*
- * Mixing scores (in bits) for (7,20):
- * Input delta: 1-bit      2-bit
- * 1 round:     330.3     9201.6
- * 2 rounds:   1246.4    25475.4
- * 3 rounds:   1907.1    31295.1
- * 4 rounds:   2042.3    31718.6
- * Perfect:    2048      31744
- *            (32*64)   (32*31/2 * 64)
- */
-#define HASH_MIX(x, y, a)	\
-	(	x ^= (a),	\
-	y ^= x,	x = rol32(x, 7),\
-	x += y,	y = rol32(y,20),\
-	y *= 9			)
-
-static inline unsigned int fold_hash(unsigned long x, unsigned long y)
-{
-	/* Use arch-optimized multiply if one exists */
-	return __hash_32(y ^ __hash_32(x));
-}
-
-#endif
-
-/*
- * Return the hash of a string of known length.  This is carfully
- * designed to match hash_name(), which is the more critical function.
- * In particular, we must end by hashing a final word containing 0..7
- * payload bytes, to match the way that hash_name() iterates until it
- * finds the delimiter after the name.
- */
-unsigned int full_name_hash(const void *salt, const char *name, unsigned int len)
-{
-	unsigned long a, x = 0, y = (unsigned long)salt;
-
-	for (;;) {
-		if (!len)
-			goto done;
-		a = load_unaligned_zeropad(name);
-		if (len < sizeof(unsigned long))
-			break;
-		HASH_MIX(x, y, a);
-		name += sizeof(unsigned long);
-		len -= sizeof(unsigned long);
-	}
-	x ^= a & bytemask_from_count(len);
-done:
-	return fold_hash(x, y);
-}
-EXPORT_SYMBOL(full_name_hash);
-
-/* Return the "hash_len" (hash and length) of a null-terminated string */
-u64 hashlen_string(const void *salt, const char *name)
-{
-	unsigned long a = 0, x = 0, y = (unsigned long)salt;
-	unsigned long adata, mask, len;
-	const struct word_at_a_time constants = WORD_AT_A_TIME_CONSTANTS;
-
-	len = 0;
-	goto inside;
-
-	do {
-		HASH_MIX(x, y, a);
-		len += sizeof(unsigned long);
-inside:
-		a = load_unaligned_zeropad(name+len);
-	} while (!has_zero(a, &adata, &constants));
-
-	adata = prep_zero_mask(a, adata, &constants);
-	mask = create_zero_mask(adata);
-	x ^= a & zero_bytemask(mask);
-
-	return hashlen_create(fold_hash(x, y), len + find_zero(mask));
-}
-EXPORT_SYMBOL(hashlen_string);
-
-/*
- * Calculate the length and hash of the path component, and
- * return the length as the result.
- */
-static inline const char *hash_name(struct nameidata *nd,
-				    const char *name,
-				    unsigned long *lastword)
-{
-	unsigned long a, b, x, y = (unsigned long)nd->path.dentry;
-	unsigned long adata, bdata, mask, len;
-	const struct word_at_a_time constants = WORD_AT_A_TIME_CONSTANTS;
-
-	/*
-	 * The first iteration is special, because it can result in
-	 * '.' and '..' and has no mixing other than the final fold.
-	 */
-	a = load_unaligned_zeropad(name);
-	b = a ^ REPEAT_BYTE('/');
-	if (has_zero(a, &adata, &constants) | has_zero(b, &bdata, &constants)) {
-		adata = prep_zero_mask(a, adata, &constants);
-		bdata = prep_zero_mask(b, bdata, &constants);
-		mask = create_zero_mask(adata | bdata);
-		a &= zero_bytemask(mask);
-		*lastword = a;
-		len = find_zero(mask);
-		nd->last.hash = fold_hash(a, y);
-		nd->last.len = len;
-		return name + len;
-	}
-
-	len = 0;
-	x = 0;
-	do {
-		HASH_MIX(x, y, a);
-		len += sizeof(unsigned long);
-		a = load_unaligned_zeropad(name+len);
-		b = a ^ REPEAT_BYTE('/');
-	} while (!(has_zero(a, &adata, &constants) | has_zero(b, &bdata, &constants)));
-
-	adata = prep_zero_mask(a, adata, &constants);
-	bdata = prep_zero_mask(b, bdata, &constants);
-	mask = create_zero_mask(adata | bdata);
-	a &= zero_bytemask(mask);
-	x ^= a;
-	len += find_zero(mask);
-	*lastword = 0;		// Multi-word components cannot be DOT or DOTDOT
-
-	nd->last.hash = fold_hash(x, y);
-	nd->last.len = len;
-	return name + len;
-}
-
-/*
- * Note that the 'last' word is always zero-masked, but
- * was loaded as a possibly big-endian word.
- */
-#ifdef __BIG_ENDIAN
-  #define LAST_WORD_IS_DOT	(0x2eul << (BITS_PER_LONG-8))
-  #define LAST_WORD_IS_DOTDOT	(0x2e2eul << (BITS_PER_LONG-16))
-#endif
-
-#else	/* !CONFIG_DCACHE_WORD_ACCESS: Slow, byte-at-a-time version */
-
-/* Return the hash of a string of known length */
-unsigned int full_name_hash(const void *salt, const char *name, unsigned int len)
-{
-	unsigned long hash = init_name_hash(salt);
-	while (len--)
-		hash = partial_name_hash((unsigned char)*name++, hash);
-	return end_name_hash(hash);
-}
-EXPORT_SYMBOL(full_name_hash);
-
-/* Return the "hash_len" (hash and length) of a null-terminated string */
-u64 hashlen_string(const void *salt, const char *name)
-{
-	unsigned long hash = init_name_hash(salt);
-	unsigned long len = 0, c;
-
-	c = (unsigned char)*name;
-	while (c) {
-		len++;
-		hash = partial_name_hash(c, hash);
-		c = (unsigned char)name[len];
-	}
-	return hashlen_create(end_name_hash(hash), len);
-}
-EXPORT_SYMBOL(hashlen_string);
-
-/*
- * We know there's a real path component here of at least
- * one character.
- */
-static inline const char *hash_name(struct nameidata *nd, const char *name, unsigned long *lastword)
-{
-	unsigned long hash = init_name_hash(nd->path.dentry);
-	unsigned long len = 0, c, last = 0;
-
-	c = (unsigned char)*name;
-	do {
-		last = (last << 8) + c;
-		len++;
-		hash = partial_name_hash(c, hash);
-		c = (unsigned char)name[len];
-	} while (c && c != '/');
-
-	// This is reliable for DOT or DOTDOT, since the component
-	// cannot contain NUL characters - top bits being zero means
-	// we cannot have had any other pathnames.
-	*lastword = last;
-	nd->last.hash = end_name_hash(hash);
-	nd->last.len = len;
-	return name + len;
-}
-
-#endif
-
-#ifndef LAST_WORD_IS_DOT
-  #define LAST_WORD_IS_DOT	0x2e
-  #define LAST_WORD_IS_DOTDOT	0x2e2e
-#endif
-
-/*
- * Name resolution.
- * This is the basic name resolution function, turning a pathname into
- * the final dentry. We expect 'base' to be positive and a directory.
- *
- * Returns 0 and nd will have valid dentry and mnt on success.
- * Returns error and drops reference to input namei data on failure.
- */
-static int link_path_walk(const char *name, struct nameidata *nd)
-{
-	int depth = 0; // depth <= nd->depth
-	int err;
-
-	nd->last_type = LAST_ROOT;
-	nd->flags |= LOOKUP_PARENT;
-	if (IS_ERR(name))
-		return PTR_ERR(name);
-	if (*name == '/') {
-		do {
-			name++;
-		} while (unlikely(*name == '/'));
-	}
-	if (unlikely(!*name)) {
-		nd->dir_mode = 0; // short-circuit the 'hardening' idiocy
-		return 0;
-	}
-
-	/* At this point we know we have a real path component. */
-	for(;;) {
-		struct mnt_idmap *idmap;
-		const char *link;
-		unsigned long lastword;
-
-		idmap = mnt_idmap(nd->path.mnt);
-		err = may_lookup(idmap, nd);
-		if (unlikely(err))
-			return err;
-
-		nd->last.name = name;
-		name = hash_name(nd, name, &lastword);
-
-		switch(lastword) {
-		case LAST_WORD_IS_DOTDOT:
-			nd->last_type = LAST_DOTDOT;
-			nd->state |= ND_JUMPED;
-			break;
-
-		case LAST_WORD_IS_DOT:
-			nd->last_type = LAST_DOT;
-			break;
-
-		default:
-			nd->last_type = LAST_NORM;
-			nd->state &= ~ND_JUMPED;
-
-			struct dentry *parent = nd->path.dentry;
-			if (unlikely(parent->d_flags & DCACHE_OP_HASH)) {
-				err = parent->d_op->d_hash(parent, &nd->last);
-				if (err < 0)
-					return err;
-			}
-		}
-
-		if (!*name)
-			goto OK;
-		/*
-		 * If it wasn't NUL, we know it was '/'. Skip that
-		 * slash, and continue until no more slashes.
-		 */
-		do {
-			name++;
-		} while (unlikely(*name == '/'));
-		if (unlikely(!*name)) {
-OK:
-			/* pathname or trailing symlink, done */
-			if (!depth) {
-				nd->dir_vfsuid = i_uid_into_vfsuid(idmap, nd->inode);
-				nd->dir_mode = nd->inode->i_mode;
-				nd->flags &= ~LOOKUP_PARENT;
-				return 0;
-			}
-			/* last component of nested symlink */
-			name = nd->stack[--depth].name;
-			link = walk_component(nd, 0);
-		} else {
-			/* not the last component */
-			link = walk_component(nd, WALK_MORE);
-		}
-		if (unlikely(link)) {
-			if (IS_ERR(link))
-				return PTR_ERR(link);
-			/* a symlink to follow */
-			nd->stack[depth++].name = name;
-			name = link;
-			continue;
-		}
-		if (unlikely(!d_can_lookup(nd->path.dentry))) {
-			if (nd->flags & LOOKUP_RCU) {
-				if (!try_to_unlazy(nd))
-					return -ECHILD;
-			}
-			return -ENOTDIR;
-		}
-	}
-}
-
-/* must be paired with terminate_walk() */
-static const char *path_init(struct nameidata *nd, unsigned flags)
-{
-	int error;
-	const char *s = nd->pathname;
-
-	/* LOOKUP_CACHED requires RCU, ask caller to retry */
-	if ((flags & (LOOKUP_RCU | LOOKUP_CACHED)) == LOOKUP_CACHED)
-		return ERR_PTR(-EAGAIN);
-
-	if (!*s)
-		flags &= ~LOOKUP_RCU;
-	if (flags & LOOKUP_RCU)
-		rcu_read_lock();
-	else
-		nd->seq = nd->next_seq = 0;
-
-	nd->flags = flags;
-	nd->state |= ND_JUMPED;
-
-	nd->m_seq = __read_seqcount_begin(&mount_lock.seqcount);
-	nd->r_seq = __read_seqcount_begin(&rename_lock.seqcount);
-	smp_rmb();
-
-	if (nd->state & ND_ROOT_PRESET) {
-		struct dentry *root = nd->root.dentry;
-		struct inode *inode = root->d_inode;
-		if (*s && unlikely(!d_can_lookup(root)))
-			return ERR_PTR(-ENOTDIR);
-		nd->path = nd->root;
-		nd->inode = inode;
-		if (flags & LOOKUP_RCU) {
-			nd->seq = read_seqcount_begin(&nd->path.dentry->d_seq);
-			nd->root_seq = nd->seq;
-		} else {
-			path_get(&nd->path);
-		}
-		return s;
-	}
-
-	nd->root.mnt = NULL;
-
-	/* Absolute pathname -- fetch the root (LOOKUP_IN_ROOT uses nd->dfd). */
-	if (*s == '/' && !(flags & LOOKUP_IN_ROOT)) {
-		error = nd_jump_root(nd);
-		if (unlikely(error))
-			return ERR_PTR(error);
-		return s;
-	}
-
-	/* Relative pathname -- get the starting-point it is relative to. */
-	if (nd->dfd == AT_FDCWD) {
-		if (flags & LOOKUP_RCU) {
-			struct fs_struct *fs = current->fs;
-			unsigned seq;
-
-			do {
-				seq = read_seqcount_begin(&fs->seq);
-				nd->path = fs->pwd;
-				nd->inode = nd->path.dentry->d_inode;
-				nd->seq = __read_seqcount_begin(&nd->path.dentry->d_seq);
-			} while (read_seqcount_retry(&fs->seq, seq));
-		} else {
-			get_fs_pwd(current->fs, &nd->path);
-			nd->inode = nd->path.dentry->d_inode;
-		}
-	} else {
-		/* Caller must check execute permissions on the starting path component */
-		CLASS(fd_raw, f)(nd->dfd);
-		struct dentry *dentry;
-
-		if (fd_empty(f))
-			return ERR_PTR(-EBADF);
-
-		if (flags & LOOKUP_LINKAT_EMPTY) {
-			if (fd_file(f)->f_cred != current_cred() &&
-			    !ns_capable(fd_file(f)->f_cred->user_ns, CAP_DAC_READ_SEARCH))
-				return ERR_PTR(-ENOENT);
-		}
-
-		dentry = fd_file(f)->f_path.dentry;
-
-		if (*s && unlikely(!d_can_lookup(dentry)))
-			return ERR_PTR(-ENOTDIR);
-
-		nd->path = fd_file(f)->f_path;
-		if (flags & LOOKUP_RCU) {
-			nd->inode = nd->path.dentry->d_inode;
-			nd->seq = read_seqcount_begin(&nd->path.dentry->d_seq);
-		} else {
-			path_get(&nd->path);
-			nd->inode = nd->path.dentry->d_inode;
-		}
-	}
-
-	/* For scoped-lookups we need to set the root to the dirfd as well. */
-	if (flags & LOOKUP_IS_SCOPED) {
-		nd->root = nd->path;
-		if (flags & LOOKUP_RCU) {
-			nd->root_seq = nd->seq;
-		} else {
-			path_get(&nd->root);
-			nd->state |= ND_ROOT_GRABBED;
-		}
-	}
-	return s;
-}
-
-static inline const char *lookup_last(struct nameidata *nd)
-{
-	if (nd->last_type == LAST_NORM && nd->last.name[nd->last.len])
-		nd->flags |= LOOKUP_FOLLOW | LOOKUP_DIRECTORY;
-
-	return walk_component(nd, WALK_TRAILING);
-}
-
-static int handle_lookup_down(struct nameidata *nd)
-{
-	if (!(nd->flags & LOOKUP_RCU))
-		dget(nd->path.dentry);
-	nd->next_seq = nd->seq;
-	return PTR_ERR(step_into(nd, WALK_NOFOLLOW, nd->path.dentry));
-}
-
-/* Returns 0 and nd will be valid on success; Returns error, otherwise. */
-static int path_lookupat(struct nameidata *nd, unsigned flags, struct path *path)
-{
-	const char *s = path_init(nd, flags);
-	int err;
-
-	if (unlikely(flags & LOOKUP_DOWN) && !IS_ERR(s)) {
-		err = handle_lookup_down(nd);
-		if (unlikely(err < 0))
-			s = ERR_PTR(err);
-	}
-
-	while (!(err = link_path_walk(s, nd)) &&
-	       (s = lookup_last(nd)) != NULL)
-		;
-	if (!err && unlikely(nd->flags & LOOKUP_MOUNTPOINT)) {
-		err = handle_lookup_down(nd);
-		nd->state &= ~ND_JUMPED; // no d_weak_revalidate(), please...
-	}
-	if (!err)
-		err = complete_walk(nd);
-
-	if (!err && nd->flags & LOOKUP_DIRECTORY)
-		if (!d_can_lookup(nd->path.dentry))
-			err = -ENOTDIR;
-	if (!err) {
-		*path = nd->path;
-		nd->path.mnt = NULL;
-		nd->path.dentry = NULL;
-	}
-	terminate_walk(nd);
-	return err;
-}
-
-int filename_lookup(int dfd, struct filename *name, unsigned flags,
-		    struct path *path, struct path *root)
-{
-	int retval;
-	struct nameidata nd;
-	if (IS_ERR(name))
-		return PTR_ERR(name);
-	set_nameidata(&nd, dfd, name, root);
-	retval = path_lookupat(&nd, flags | LOOKUP_RCU, path);
-	if (unlikely(retval == -ECHILD))
-		retval = path_lookupat(&nd, flags, path);
-	if (unlikely(retval == -ESTALE))
-		retval = path_lookupat(&nd, flags | LOOKUP_REVAL, path);
-
-	if (likely(!retval))
-		audit_inode(name, path->dentry,
-			    flags & LOOKUP_MOUNTPOINT ? AUDIT_INODE_NOEVAL : 0);
-	restore_nameidata();
-	return retval;
-}
-
-/* Returns 0 and nd will be valid on success; Returns error, otherwise. */
-static int path_parentat(struct nameidata *nd, unsigned flags,
-				struct path *parent)
-{
-	const char *s = path_init(nd, flags);
-	int err = link_path_walk(s, nd);
-	if (!err)
-		err = complete_walk(nd);
-	if (!err) {
-		*parent = nd->path;
-		nd->path.mnt = NULL;
-		nd->path.dentry = NULL;
-	}
-	terminate_walk(nd);
-	return err;
-}
-
-/* Note: this does not consume "name" */
-static int __filename_parentat(int dfd, struct filename *name,
-			       unsigned int flags, struct path *parent,
-			       struct qstr *last, int *type,
-			       const struct path *root)
-{
-	int retval;
-	struct nameidata nd;
-
-	if (IS_ERR(name))
-		return PTR_ERR(name);
-	set_nameidata(&nd, dfd, name, root);
-	retval = path_parentat(&nd, flags | LOOKUP_RCU, parent);
-	if (unlikely(retval == -ECHILD))
-		retval = path_parentat(&nd, flags, parent);
-	if (unlikely(retval == -ESTALE))
-		retval = path_parentat(&nd, flags | LOOKUP_REVAL, parent);
-	if (likely(!retval)) {
-		*last = nd.last;
-		*type = nd.last_type;
-		audit_inode(name, parent->dentry, AUDIT_INODE_PARENT);
-	}
-	restore_nameidata();
-	return retval;
-}
-
-static int filename_parentat(int dfd, struct filename *name,
-			     unsigned int flags, struct path *parent,
-			     struct qstr *last, int *type)
-{
-	return __filename_parentat(dfd, name, flags, parent, last, type, NULL);
-}
-
-/* does lookup, returns the object with parent locked */
-static struct dentry *__kern_path_locked(int dfd, struct filename *name, struct path *path)
-{
-	struct path parent_path __free(path_put) = {};
-	struct dentry *d;
-	struct qstr last;
-	int type, error;
-
-	error = filename_parentat(dfd, name, 0, &parent_path, &last, &type);
-	if (error)
-		return ERR_PTR(error);
-	if (unlikely(type != LAST_NORM))
-		return ERR_PTR(-EINVAL);
-	inode_lock_nested(parent_path.dentry->d_inode, I_MUTEX_PARENT);
-	d = lookup_one_qstr_excl(&last, parent_path.dentry, 0);
-	if (IS_ERR(d)) {
-		inode_unlock(parent_path.dentry->d_inode);
-		return d;
-	}
-	path->dentry = no_free_ptr(parent_path.dentry);
-	path->mnt = no_free_ptr(parent_path.mnt);
-	return d;
-}
-
-struct dentry *kern_path_locked_negative(const char *name, struct path *path)
-{
-	struct path parent_path __free(path_put) = {};
-	struct filename *filename __free(putname) = getname_kernel(name);
-	struct dentry *d;
-	struct qstr last;
-	int type, error;
-
-	error = filename_parentat(AT_FDCWD, filename, 0, &parent_path, &last, &type);
-	if (error)
-		return ERR_PTR(error);
-	if (unlikely(type != LAST_NORM))
-		return ERR_PTR(-EINVAL);
-	inode_lock_nested(parent_path.dentry->d_inode, I_MUTEX_PARENT);
-	d = lookup_one_qstr_excl_raw(&last, parent_path.dentry, 0);
-	if (IS_ERR(d)) {
-		inode_unlock(parent_path.dentry->d_inode);
-		return d;
-	}
-	path->dentry = no_free_ptr(parent_path.dentry);
-	path->mnt = no_free_ptr(parent_path.mnt);
-	return d;
-}
-
-struct dentry *kern_path_locked(const char *name, struct path *path)
-{
-	struct filename *filename = getname_kernel(name);
-	struct dentry *res = __kern_path_locked(AT_FDCWD, filename, path);
-
-	putname(filename);
-	return res;
-}
-
-struct dentry *user_path_locked_at(int dfd, const char __user *name, struct path *path)
-{
-	struct filename *filename = getname(name);
-	struct dentry *res = __kern_path_locked(dfd, filename, path);
-
-	putname(filename);
-	return res;
-}
-EXPORT_SYMBOL(user_path_locked_at);
-
-int kern_path(const char *name, unsigned int flags, struct path *path)
-{
-	struct filename *filename = getname_kernel(name);
-	int ret = filename_lookup(AT_FDCWD, filename, flags, path, NULL);
-
-	putname(filename);
-	return ret;
-
-}
-EXPORT_SYMBOL(kern_path);
-
-/**
- * vfs_path_parent_lookup - lookup a parent path relative to a dentry-vfsmount pair
- * @filename: filename structure
- * @flags: lookup flags
- * @parent: pointer to struct path to fill
- * @last: last component
- * @type: type of the last component
- * @root: pointer to struct path of the base directory
- */
-int vfs_path_parent_lookup(struct filename *filename, unsigned int flags,
-			   struct path *parent, struct qstr *last, int *type,
-			   const struct path *root)
-{
-	return  __filename_parentat(AT_FDCWD, filename, flags, parent, last,
-				    type, root);
-}
-EXPORT_SYMBOL(vfs_path_parent_lookup);
-
-/**
- * vfs_path_lookup - lookup a file path relative to a dentry-vfsmount pair
- * @dentry:  pointer to dentry of the base directory
- * @mnt: pointer to vfs mount of the base directory
- * @name: pointer to file name
- * @flags: lookup flags
- * @path: pointer to struct path to fill
- */
-int vfs_path_lookup(struct dentry *dentry, struct vfsmount *mnt,
-		    const char *name, unsigned int flags,
-		    struct path *path)
-{
-	struct filename *filename;
-	struct path root = {.mnt = mnt, .dentry = dentry};
-	int ret;
-
-	filename = getname_kernel(name);
-	/* the first argument of filename_lookup() is ignored with root */
-	ret = filename_lookup(AT_FDCWD, filename, flags, path, &root);
-	putname(filename);
-	return ret;
-}
-EXPORT_SYMBOL(vfs_path_lookup);
-
-static int lookup_noperm_common(struct qstr *qname, struct dentry *base)
-{
-	const char *name = qname->name;
-	u32 len = qname->len;
-
-	qname->hash = full_name_hash(base, name, len);
-	if (!len)
-		return -EACCES;
-
-	if (is_dot_dotdot(name, len))
-		return -EACCES;
-
-	while (len--) {
-		unsigned int c = *(const unsigned char *)name++;
-		if (c == '/' || c == '\0')
-			return -EACCES;
-	}
-	/*
-	 * See if the low-level filesystem might want
-	 * to use its own hash..
-	 */
-	if (base->d_flags & DCACHE_OP_HASH) {
-		int err = base->d_op->d_hash(base, qname);
-		if (err < 0)
-			return err;
-	}
-	return 0;
-}
-
-static int lookup_one_common(struct mnt_idmap *idmap,
-			     struct qstr *qname, struct dentry *base)
-{
-	int err;
-	err = lookup_noperm_common(qname, base);
-	if (err < 0)
-		return err;
-	return inode_permission(idmap, base->d_inode, MAY_EXEC);
-}
-
-/**
- * try_lookup_noperm - filesystem helper to lookup single pathname component
- * @name:	qstr storing pathname component to lookup
- * @base:	base directory to lookup from
- *
- * Look up a dentry by name in the dcache, returning NULL if it does not
- * currently exist.  The function does not try to create a dentry and if one
- * is found it doesn't try to revalidate it.
- *
- * Note that this routine is purely a helper for filesystem usage and should
- * not be called by generic code.  It does no permission checking.
- *
- * No locks need be held - only a counted reference to @base is needed.
- *
- */
-struct dentry *try_lookup_noperm(struct qstr *name, struct dentry *base)
-{
-	int err;
-
-	err = lookup_noperm_common(name, base);
-	if (err)
-		return ERR_PTR(err);
-
-	return d_lookup(base, name);
-}
-EXPORT_SYMBOL(try_lookup_noperm);
-
-/**
- * lookup_noperm - filesystem helper to lookup single pathname component
- * @name:	qstr storing pathname component to lookup
- * @base:	base directory to lookup from
- *
- * Note that this routine is purely a helper for filesystem usage and should
- * not be called by generic code.  It does no permission checking.
- *
- * The caller must hold base->i_mutex.
- */
-struct dentry *lookup_noperm(struct qstr *name, struct dentry *base)
-{
-	struct dentry *dentry;
-	int err;
-
-	WARN_ON_ONCE(!inode_is_locked(base->d_inode));
-
-	err = lookup_noperm_common(name, base);
-	if (err)
-		return ERR_PTR(err);
-
-	dentry = lookup_dcache(name, base, 0);
-	return dentry ? dentry : __lookup_slow(name, base, 0);
-}
-EXPORT_SYMBOL(lookup_noperm);
-
-/**
- * lookup_one - lookup single pathname component
- * @idmap:	idmap of the mount the lookup is performed from
- * @name:	qstr holding pathname component to lookup
- * @base:	base directory to lookup from
- *
- * This can be used for in-kernel filesystem clients such as file servers.
- *
- * The caller must hold base->i_mutex.
- */
-struct dentry *lookup_one(struct mnt_idmap *idmap, struct qstr *name,
-			  struct dentry *base)
-{
-	struct dentry *dentry;
-	int err;
-
-	WARN_ON_ONCE(!inode_is_locked(base->d_inode));
-
-	err = lookup_one_common(idmap, name, base);
-	if (err)
-		return ERR_PTR(err);
-
-	dentry = lookup_dcache(name, base, 0);
-	return dentry ? dentry : __lookup_slow(name, base, 0);
-}
-EXPORT_SYMBOL(lookup_one);
-
-/**
- * lookup_one_unlocked - lookup single pathname component
- * @idmap:	idmap of the mount the lookup is performed from
- * @name:	qstr olding pathname component to lookup
- * @base:	base directory to lookup from
- *
- * This can be used for in-kernel filesystem clients such as file servers.
- *
- * Unlike lookup_one, it should be called without the parent
- * i_rwsem held, and will take the i_rwsem itself if necessary.
- */
-struct dentry *lookup_one_unlocked(struct mnt_idmap *idmap, struct qstr *name,
-				   struct dentry *base)
-{
-	int err;
-	struct dentry *ret;
-
-	err = lookup_one_common(idmap, name, base);
-	if (err)
-		return ERR_PTR(err);
-
-	ret = lookup_dcache(name, base, 0);
-	if (!ret)
-		ret = lookup_slow(name, base, 0);
-	return ret;
-}
-EXPORT_SYMBOL(lookup_one_unlocked);
-
-/**
- * lookup_one_positive_unlocked - lookup single pathname component
- * @idmap:	idmap of the mount the lookup is performed from
- * @name:	qstr holding pathname component to lookup
- * @base:	base directory to lookup from
- *
- * This helper will yield ERR_PTR(-ENOENT) on negatives. The helper returns
- * known positive or ERR_PTR(). This is what most of the users want.
- *
- * Note that pinned negative with unlocked parent _can_ become positive at any
- * time, so callers of lookup_one_unlocked() need to be very careful; pinned
- * positives have >d_inode stable, so this one avoids such problems.
- *
- * This can be used for in-kernel filesystem clients such as file servers.
- *
- * The helper should be called without i_rwsem held.
- */
-struct dentry *lookup_one_positive_unlocked(struct mnt_idmap *idmap,
-					    struct qstr *name,
-					    struct dentry *base)
-{
-	struct dentry *ret = lookup_one_unlocked(idmap, name, base);
-
-	if (!IS_ERR(ret) && d_flags_negative(smp_load_acquire(&ret->d_flags))) {
-		dput(ret);
-		ret = ERR_PTR(-ENOENT);
-	}
-	return ret;
-}
-EXPORT_SYMBOL(lookup_one_positive_unlocked);
-
-/**
- * lookup_noperm_unlocked - filesystem helper to lookup single pathname component
- * @name:	pathname component to lookup
- * @base:	base directory to lookup from
- *
- * Note that this routine is purely a helper for filesystem usage and should
- * not be called by generic code. It does no permission checking.
- *
- * Unlike lookup_noperm(), it should be called without the parent
- * i_rwsem held, and will take the i_rwsem itself if necessary.
- *
- * Unlike try_lookup_noperm() it *does* revalidate the dentry if it already
- * existed.
- */
-struct dentry *lookup_noperm_unlocked(struct qstr *name, struct dentry *base)
-{
-	struct dentry *ret;
-	int err;
-
-	err = lookup_noperm_common(name, base);
-	if (err)
-		return ERR_PTR(err);
-
-	ret = lookup_dcache(name, base, 0);
-	if (!ret)
-		ret = lookup_slow(name, base, 0);
-	return ret;
-}
-EXPORT_SYMBOL(lookup_noperm_unlocked);
-
-/*
- * Like lookup_noperm_unlocked(), except that it yields ERR_PTR(-ENOENT)
- * on negatives.  Returns known positive or ERR_PTR(); that's what
- * most of the users want.  Note that pinned negative with unlocked parent
- * _can_ become positive at any time, so callers of lookup_noperm_unlocked()
- * need to be very careful; pinned positives have ->d_inode stable, so
- * this one avoids such problems.
- */
-struct dentry *lookup_noperm_positive_unlocked(struct qstr *name,
-					       struct dentry *base)
-{
-	struct dentry *ret;
-
-	ret = lookup_noperm_unlocked(name, base);
-	if (!IS_ERR(ret) && d_flags_negative(smp_load_acquire(&ret->d_flags))) {
-		dput(ret);
-		ret = ERR_PTR(-ENOENT);
-	}
-	return ret;
-}
-EXPORT_SYMBOL(lookup_noperm_positive_unlocked);
-
-#ifdef CONFIG_UNIX98_PTYS
-int path_pts(struct path *path)
-{
-	/* Find something mounted on "pts" in the same directory as
-	 * the input path.
-	 */
-	struct dentry *parent = dget_parent(path->dentry);
-	struct dentry *child;
-	struct qstr this = QSTR_INIT("pts", 3);
-
-	if (unlikely(!path_connected(path->mnt, parent))) {
-		dput(parent);
-		return -ENOENT;
-	}
-	dput(path->dentry);
-	path->dentry = parent;
-	child = d_hash_and_lookup(parent, &this);
-	if (IS_ERR_OR_NULL(child))
-		return -ENOENT;
-
-	path->dentry = child;
-	dput(parent);
-	follow_down(path, 0);
-	return 0;
-}
-#endif
-
-int user_path_at(int dfd, const char __user *name, unsigned flags,
-		 struct path *path)
-{
-	struct filename *filename = getname_flags(name, flags);
-	int ret = filename_lookup(dfd, filename, flags, path, NULL);
-
-	putname(filename);
-	return ret;
-}
-EXPORT_SYMBOL(user_path_at);
-
-int __check_sticky(struct mnt_idmap *idmap, struct inode *dir,
-		   struct inode *inode)
-{
-	kuid_t fsuid = current_fsuid();
-
-	if (vfsuid_eq_kuid(i_uid_into_vfsuid(idmap, inode), fsuid))
-		return 0;
-	if (vfsuid_eq_kuid(i_uid_into_vfsuid(idmap, dir), fsuid))
-		return 0;
-	return !capable_wrt_inode_uidgid(idmap, inode, CAP_FOWNER);
-}
-EXPORT_SYMBOL(__check_sticky);
-
-/*
- *	Check whether we can remove a link victim from directory dir, check
- *  whether the type of victim is right.
- *  1. We can't do it if dir is read-only (done in permission())
- *  2. We should have write and exec permissions on dir
- *  3. We can't remove anything from append-only dir
- *  4. We can't do anything with immutable dir (done in permission())
- *  5. If the sticky bit on dir is set we should either
- *	a. be owner of dir, or
- *	b. be owner of victim, or
- *	c. have CAP_FOWNER capability
- *  6. If the victim is append-only or immutable we can't do antyhing with
- *     links pointing to it.
- *  7. If the victim has an unknown uid or gid we can't change the inode.
- *  8. If we were asked to remove a directory and victim isn't one - ENOTDIR.
- *  9. If we were asked to remove a non-directory and victim isn't one - EISDIR.
- * 10. We can't remove a root or mountpoint.
- * 11. We don't allow removal of NFS sillyrenamed files; it's handled by
- *     nfs_async_unlink().
- */
-static int may_delete(struct mnt_idmap *idmap, struct inode *dir,
-		      struct dentry *victim, bool isdir)
-{
-	struct inode *inode = d_backing_inode(victim);
-	int error;
-
-	if (d_is_negative(victim))
-		return -ENOENT;
-	BUG_ON(!inode);
-
-	BUG_ON(victim->d_parent->d_inode != dir);
-
-	/* Inode writeback is not safe when the uid or gid are invalid. */
-	if (!vfsuid_valid(i_uid_into_vfsuid(idmap, inode)) ||
-	    !vfsgid_valid(i_gid_into_vfsgid(idmap, inode)))
-		return -EOVERFLOW;
-
-	audit_inode_child(dir, victim, AUDIT_TYPE_CHILD_DELETE);
-
-	error = inode_permission(idmap, dir, MAY_WRITE | MAY_EXEC);
-	if (error)
-		return error;
-	if (IS_APPEND(dir))
-		return -EPERM;
-
-	if (check_sticky(idmap, dir, inode) || IS_APPEND(inode) ||
-	    IS_IMMUTABLE(inode) || IS_SWAPFILE(inode) ||
-	    HAS_UNMAPPED_ID(idmap, inode))
-		return -EPERM;
-	if (isdir) {
-		if (!d_is_dir(victim))
-			return -ENOTDIR;
-		if (IS_ROOT(victim))
-			return -EBUSY;
-	} else if (d_is_dir(victim))
-		return -EISDIR;
-	if (IS_DEADDIR(dir))
-		return -ENOENT;
-	if (victim->d_flags & DCACHE_NFSFS_RENAMED)
-		return -EBUSY;
-	return 0;
-}
-
-/*	Check whether we can create an object with dentry child in directory
- *  dir.
- *  1. We can't do it if child already exists (open has special treatment for
- *     this case, but since we are inlined it's OK)
- *  2. We can't do it if dir is read-only (done in permission())
- *  3. We can't do it if the fs can't represent the fsuid or fsgid.
- *  4. We should have write and exec permissions on dir
- *  5. We can't do it if dir is immutable (done in permission())
- */
-static inline int may_create(struct mnt_idmap *idmap,
-			     struct inode *dir, struct dentry *child)
-{
-	audit_inode_child(dir, child, AUDIT_TYPE_CHILD_CREATE);
-	if (child->d_inode)
-		return -EEXIST;
-	if (IS_DEADDIR(dir))
-		return -ENOENT;
-	if (!fsuidgid_has_mapping(dir->i_sb, idmap))
-		return -EOVERFLOW;
-
-	return inode_permission(idmap, dir, MAY_WRITE | MAY_EXEC);
-}
-
-// p1 != p2, both are on the same filesystem, ->s_vfs_rename_mutex is held
-static struct dentry *lock_two_directories(struct dentry *p1, struct dentry *p2)
-{
-	struct dentry *p = p1, *q = p2, *r;
-
-	while ((r = p->d_parent) != p2 && r != p)
-		p = r;
-	if (r == p2) {
-		// p is a child of p2 and an ancestor of p1 or p1 itself
-		inode_lock_nested(p2->d_inode, I_MUTEX_PARENT);
-		inode_lock_nested(p1->d_inode, I_MUTEX_PARENT2);
-		return p;
-	}
-	// p is the root of connected component that contains p1
-	// p2 does not occur on the path from p to p1
-	while ((r = q->d_parent) != p1 && r != p && r != q)
-		q = r;
-	if (r == p1) {
-		// q is a child of p1 and an ancestor of p2 or p2 itself
-		inode_lock_nested(p1->d_inode, I_MUTEX_PARENT);
-		inode_lock_nested(p2->d_inode, I_MUTEX_PARENT2);
-		return q;
-	} else if (likely(r == p)) {
-		// both p2 and p1 are descendents of p
-		inode_lock_nested(p1->d_inode, I_MUTEX_PARENT);
-		inode_lock_nested(p2->d_inode, I_MUTEX_PARENT2);
-		return NULL;
-	} else { // no common ancestor at the time we'd been called
-		mutex_unlock(&p1->d_sb->s_vfs_rename_mutex);
-		return ERR_PTR(-EXDEV);
-	}
-}
-
-/*
- * p1 and p2 should be directories on the same fs.
- */
-struct dentry *lock_rename(struct dentry *p1, struct dentry *p2)
-{
-	if (p1 == p2) {
-		inode_lock_nested(p1->d_inode, I_MUTEX_PARENT);
-		return NULL;
-	}
-
-	mutex_lock(&p1->d_sb->s_vfs_rename_mutex);
-	return lock_two_directories(p1, p2);
-}
-EXPORT_SYMBOL(lock_rename);
-
-/*
- * c1 and p2 should be on the same fs.
- */
-struct dentry *lock_rename_child(struct dentry *c1, struct dentry *p2)
-{
-	if (READ_ONCE(c1->d_parent) == p2) {
-		/*
-		 * hopefully won't need to touch ->s_vfs_rename_mutex at all.
-		 */
-		inode_lock_nested(p2->d_inode, I_MUTEX_PARENT);
-		/*
-		 * now that p2 is locked, nobody can move in or out of it,
-		 * so the test below is safe.
-		 */
-		if (likely(c1->d_parent == p2))
-			return NULL;
-
-		/*
-		 * c1 got moved out of p2 while we'd been taking locks;
-		 * unlock and fall back to slow case.
-		 */
-		inode_unlock(p2->d_inode);
-	}
-
-	mutex_lock(&c1->d_sb->s_vfs_rename_mutex);
-	/*
-	 * nobody can move out of any directories on this fs.
-	 */
-	if (likely(c1->d_parent != p2))
-		return lock_two_directories(c1->d_parent, p2);
-
-	/*
-	 * c1 got moved into p2 while we were taking locks;
-	 * we need p2 locked and ->s_vfs_rename_mutex unlocked,
-	 * for consistency with lock_rename().
-	 */
-	inode_lock_nested(p2->d_inode, I_MUTEX_PARENT);
-	mutex_unlock(&c1->d_sb->s_vfs_rename_mutex);
-	return NULL;
-}
-EXPORT_SYMBOL(lock_rename_child);
-
-void unlock_rename(struct dentry *p1, struct dentry *p2)
-{
-	inode_unlock(p1->d_inode);
-	if (p1 != p2) {
-		inode_unlock(p2->d_inode);
-		mutex_unlock(&p1->d_sb->s_vfs_rename_mutex);
-	}
-}
-EXPORT_SYMBOL(unlock_rename);
-
-/**
- * vfs_prepare_mode - prepare the mode to be used for a new inode
- * @idmap:	idmap of the mount the inode was found from
- * @dir:	parent directory of the new inode
- * @mode:	mode of the new inode
- * @mask_perms:	allowed permission by the vfs
- * @type:	type of file to be created
- *
- * This helper consolidates and enforces vfs restrictions on the @mode of a new
- * object to be created.
- *
- * Umask stripping depends on whether the filesystem supports POSIX ACLs (see
- * the kernel documentation for mode_strip_umask()). Moving umask stripping
- * after setgid stripping allows the same ordering for both non-POSIX ACL and
- * POSIX ACL supporting filesystems.
- *
- * Note that it's currently valid for @type to be 0 if a directory is created.
- * Filesystems raise that flag individually and we need to check whether each
- * filesystem can deal with receiving S_IFDIR from the vfs before we enforce a
- * non-zero type.
- *
- * Returns: mode to be passed to the filesystem
- */
-static inline umode_t vfs_prepare_mode(struct mnt_idmap *idmap,
-				       const struct inode *dir, umode_t mode,
-				       umode_t mask_perms, umode_t type)
-{
-	mode = mode_strip_sgid(idmap, dir, mode);
-	mode = mode_strip_umask(dir, mode);
-
-	/*
-	 * Apply the vfs mandated allowed permission mask and set the type of
-	 * file to be created before we call into the filesystem.
-	 */
-	mode &= (mask_perms & ~S_IFMT);
-	mode |= (type & S_IFMT);
-
-	return mode;
-}
-
-/**
- * vfs_create - create new file
- * @idmap:	idmap of the mount the inode was found from
- * @dir:	inode of the parent directory
- * @dentry:	dentry of the child file
- * @mode:	mode of the child file
- * @want_excl:	whether the file must not yet exist
- *
- * Create a new file.
- *
- * If the inode has been found through an idmapped mount the idmap of
- * the vfsmount must be passed through @idmap. This function will then take
- * care to map the inode according to @idmap before checking permissions.
- * On non-idmapped mounts or if permission checking is to be performed on the
- * raw inode simply pass @nop_mnt_idmap.
- */
-int vfs_create(struct mnt_idmap *idmap, struct inode *dir,
-	       struct dentry *dentry, umode_t mode, bool want_excl)
-{
-	int error;
-
-	error = may_create(idmap, dir, dentry);
-	if (error)
-		return error;
-
-	if (!dir->i_op->create)
-		return -EACCES;	/* shouldn't it be ENOSYS? */
-
-	mode = vfs_prepare_mode(idmap, dir, mode, S_IALLUGO, S_IFREG);
-	error = security_inode_create(dir, dentry, mode);
-	if (error)
-		return error;
-	error = dir->i_op->create(idmap, dir, dentry, mode, want_excl);
-	if (!error)
-		fsnotify_create(dir, dentry);
-	return error;
-}
-EXPORT_SYMBOL(vfs_create);
-
-int vfs_mkobj(struct dentry *dentry, umode_t mode,
-		int (*f)(struct dentry *, umode_t, void *),
-		void *arg)
-{
-	struct inode *dir = dentry->d_parent->d_inode;
-	int error = may_create(&nop_mnt_idmap, dir, dentry);
-	if (error)
-		return error;
-
-	mode &= S_IALLUGO;
-	mode |= S_IFREG;
-	error = security_inode_create(dir, dentry, mode);
-	if (error)
-		return error;
-	error = f(dentry, mode, arg);
-	if (!error)
-		fsnotify_create(dir, dentry);
-	return error;
-}
-EXPORT_SYMBOL(vfs_mkobj);
-
-bool may_open_dev(const struct path *path)
-{
-	return !(path->mnt->mnt_flags & MNT_NODEV) &&
-		!(path->mnt->mnt_sb->s_iflags & SB_I_NODEV);
-}
-
-static int may_open(struct mnt_idmap *idmap, const struct path *path,
-		    int acc_mode, int flag)
-{
-	struct dentry *dentry = path->dentry;
-	struct inode *inode = dentry->d_inode;
-	int error;
-
-	if (!inode)
-		return -ENOENT;
-
-	switch (inode->i_mode & S_IFMT) {
-	case S_IFLNK:
-		return -ELOOP;
-	case S_IFDIR:
-		if (acc_mode & MAY_WRITE)
-			return -EISDIR;
-		if (acc_mode & MAY_EXEC)
-			return -EACCES;
-		break;
-	case S_IFBLK:
-	case S_IFCHR:
-		if (!may_open_dev(path))
-			return -EACCES;
-		fallthrough;
-	case S_IFIFO:
-	case S_IFSOCK:
-		if (acc_mode & MAY_EXEC)
-			return -EACCES;
-		flag &= ~O_TRUNC;
-		break;
-	case S_IFREG:
-		if ((acc_mode & MAY_EXEC) && path_noexec(path))
-			return -EACCES;
-		break;
-	default:
-		VFS_BUG_ON_INODE(!IS_ANON_FILE(inode), inode);
-	}
-
-	error = inode_permission(idmap, inode, MAY_OPEN | acc_mode);
-	if (error)
-		return error;
-
-	/*
-	 * An append-only file must be opened in append mode for writing.
-	 */
-	if (IS_APPEND(inode)) {
-		if  ((flag & O_ACCMODE) != O_RDONLY && !(flag & O_APPEND))
-			return -EPERM;
-		if (flag & O_TRUNC)
-			return -EPERM;
-	}
-
-	/* O_NOATIME can only be set by the owner or superuser */
-	if (flag & O_NOATIME && !inode_owner_or_capable(idmap, inode))
-		return -EPERM;
-
-	return 0;
-}
-
-static int handle_truncate(struct mnt_idmap *idmap, struct file *filp)
-{
-	const struct path *path = &filp->f_path;
-	struct inode *inode = path->dentry->d_inode;
-	int error = get_write_access(inode);
-	if (error)
-		return error;
-
-	error = security_file_truncate(filp);
-	if (!error) {
-		error = do_truncate(idmap, path->dentry, 0,
-				    ATTR_MTIME|ATTR_CTIME|ATTR_OPEN,
-				    filp);
-	}
-	put_write_access(inode);
-	return error;
-}
-
-static inline int open_to_namei_flags(int flag)
-{
-	if ((flag & O_ACCMODE) == 3)
-		flag--;
-	return flag;
-}
-
-static int may_o_create(struct mnt_idmap *idmap,
-			const struct path *dir, struct dentry *dentry,
-			umode_t mode)
-{
-	int error = security_path_mknod(dir, dentry, mode, 0);
-	if (error)
-		return error;
-
-	if (!fsuidgid_has_mapping(dir->dentry->d_sb, idmap))
-		return -EOVERFLOW;
-
-	error = inode_permission(idmap, dir->dentry->d_inode,
-				 MAY_WRITE | MAY_EXEC);
-	if (error)
-		return error;
-
-	return security_inode_create(dir->dentry->d_inode, dentry, mode);
-}
-
-/*
- * Attempt to atomically look up, create and open a file from a negative
- * dentry.
- *
- * Returns 0 if successful.  The file will have been created and attached to
- * @file by the filesystem calling finish_open().
- *
- * If the file was looked up only or didn't need creating, FMODE_OPENED won't
- * be set.  The caller will need to perform the open themselves.  @path will
- * have been updated to point to the new dentry.  This may be negative.
- *
- * Returns an error code otherwise.
- */
-static struct dentry *atomic_open(struct nameidata *nd, struct dentry *dentry,
-				  struct file *file,
-				  int open_flag, umode_t mode)
-{
-	struct dentry *const DENTRY_NOT_SET = (void *) -1UL;
-	struct inode *dir =  nd->path.dentry->d_inode;
-	int error;
-
-	if (nd->flags & LOOKUP_DIRECTORY)
-		open_flag |= O_DIRECTORY;
-
-	file->f_path.dentry = DENTRY_NOT_SET;
-	file->f_path.mnt = nd->path.mnt;
-	error = dir->i_op->atomic_open(dir, dentry, file,
-				       open_to_namei_flags(open_flag), mode);
-	d_lookup_done(dentry);
-	if (!error) {
-		if (file->f_mode & FMODE_OPENED) {
-			if (unlikely(dentry != file->f_path.dentry)) {
-				dput(dentry);
-				dentry = dget(file->f_path.dentry);
-			}
-		} else if (WARN_ON(file->f_path.dentry == DENTRY_NOT_SET)) {
-			error = -EIO;
-		} else {
-			if (file->f_path.dentry) {
-				dput(dentry);
-				dentry = file->f_path.dentry;
-			}
-			if (unlikely(d_is_negative(dentry)))
-				error = -ENOENT;
-		}
-	}
-	if (error) {
-		dput(dentry);
-		dentry = ERR_PTR(error);
-	}
-	return dentry;
-}
-
-/*
- * Look up and maybe create and open the last component.
- *
- * Must be called with parent locked (exclusive in O_CREAT case).
- *
- * Returns 0 on success, that is, if
- *  the file was successfully atomically created (if necessary) and opened, or
- *  the file was not completely opened at this time, though lookups and
- *  creations were performed.
- * These case are distinguished by presence of FMODE_OPENED on file->f_mode.
- * In the latter case dentry returned in @path might be negative if O_CREAT
- * hadn't been specified.
- *
- * An error code is returned on failure.
- */
-static struct dentry *lookup_open(struct nameidata *nd, struct file *file,
-				  const struct open_flags *op,
-				  bool got_write)
-{
-	struct mnt_idmap *idmap;
-	struct dentry *dir = nd->path.dentry;
-	struct inode *dir_inode = dir->d_inode;
-	int open_flag = op->open_flag;
-	struct dentry *dentry;
-	int error, create_error = 0;
-	umode_t mode = op->mode;
-	DECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq);
-
-	if (unlikely(IS_DEADDIR(dir_inode)))
-		return ERR_PTR(-ENOENT);
-
-	file->f_mode &= ~FMODE_CREATED;
-	dentry = d_lookup(dir, &nd->last);
-	for (;;) {
-		if (!dentry) {
-			dentry = d_alloc_parallel(dir, &nd->last, &wq);
-			if (IS_ERR(dentry))
-				return dentry;
-		}
-		if (d_in_lookup(dentry))
-			break;
-
-		error = d_revalidate(dir_inode, &nd->last, dentry, nd->flags);
-		if (likely(error > 0))
-			break;
-		if (error)
-			goto out_dput;
-		d_invalidate(dentry);
-		dput(dentry);
-		dentry = NULL;
-	}
-	if (dentry->d_inode) {
-		/* Cached positive dentry: will open in f_op->open */
-		return dentry;
-	}
-
-	if (open_flag & O_CREAT)
-		audit_inode(nd->name, dir, AUDIT_INODE_PARENT);
-
-	/*
-	 * Checking write permission is tricky, bacuse we don't know if we are
-	 * going to actually need it: O_CREAT opens should work as long as the
-	 * file exists.  But checking existence breaks atomicity.  The trick is
-	 * to check access and if not granted clear O_CREAT from the flags.
-	 *
-	 * Another problem is returing the "right" error value (e.g. for an
-	 * O_EXCL open we want to return EEXIST not EROFS).
-	 */
-	if (unlikely(!got_write))
-		open_flag &= ~O_TRUNC;
-	idmap = mnt_idmap(nd->path.mnt);
-	if (open_flag & O_CREAT) {
-		if (open_flag & O_EXCL)
-			open_flag &= ~O_TRUNC;
-		mode = vfs_prepare_mode(idmap, dir->d_inode, mode, mode, mode);
-		if (likely(got_write))
-			create_error = may_o_create(idmap, &nd->path,
-						    dentry, mode);
-		else
-			create_error = -EROFS;
-	}
-	if (create_error)
-		open_flag &= ~O_CREAT;
-	if (dir_inode->i_op->atomic_open) {
-		dentry = atomic_open(nd, dentry, file, open_flag, mode);
-		if (unlikely(create_error) && dentry == ERR_PTR(-ENOENT))
-			dentry = ERR_PTR(create_error);
-		return dentry;
-	}
-
-	if (d_in_lookup(dentry)) {
-		struct dentry *res = dir_inode->i_op->lookup(dir_inode, dentry,
-							     nd->flags);
-		d_lookup_done(dentry);
-		if (unlikely(res)) {
-			if (IS_ERR(res)) {
-				error = PTR_ERR(res);
-				goto out_dput;
-			}
-			dput(dentry);
-			dentry = res;
-		}
-	}
-
-	/* Negative dentry, just create the file */
-	if (!dentry->d_inode && (open_flag & O_CREAT)) {
-		file->f_mode |= FMODE_CREATED;
-		audit_inode_child(dir_inode, dentry, AUDIT_TYPE_CHILD_CREATE);
-		if (!dir_inode->i_op->create) {
-			error = -EACCES;
-			goto out_dput;
-		}
-
-		error = dir_inode->i_op->create(idmap, dir_inode, dentry,
-						mode, open_flag & O_EXCL);
-		if (error)
-			goto out_dput;
-	}
-	if (unlikely(create_error) && !dentry->d_inode) {
-		error = create_error;
-		goto out_dput;
-	}
-	return dentry;
-
-out_dput:
-	dput(dentry);
-	return ERR_PTR(error);
-}
-
-static inline bool trailing_slashes(struct nameidata *nd)
-{
-	return (bool)nd->last.name[nd->last.len];
-}
-
-static struct dentry *lookup_fast_for_open(struct nameidata *nd, int open_flag)
-{
-	struct dentry *dentry;
-
-	if (open_flag & O_CREAT) {
-		if (trailing_slashes(nd))
-			return ERR_PTR(-EISDIR);
-
-		/* Don't bother on an O_EXCL create */
-		if (open_flag & O_EXCL)
-			return NULL;
-	}
-
-	if (trailing_slashes(nd))
-		nd->flags |= LOOKUP_FOLLOW | LOOKUP_DIRECTORY;
-
-	dentry = lookup_fast(nd);
-	if (IS_ERR_OR_NULL(dentry))
-		return dentry;
-
-	if (open_flag & O_CREAT) {
-		/* Discard negative dentries. Need inode_lock to do the create */
-		if (!dentry->d_inode) {
-			if (!(nd->flags & LOOKUP_RCU))
-				dput(dentry);
-			dentry = NULL;
-		}
-	}
-	return dentry;
-}
-
-static const char *open_last_lookups(struct nameidata *nd,
-		   struct file *file, const struct open_flags *op)
-{
-	struct dentry *dir = nd->path.dentry;
-	int open_flag = op->open_flag;
-	bool got_write = false;
-	struct dentry *dentry;
-	const char *res;
-
-	nd->flags |= op->intent;
-
-	if (nd->last_type != LAST_NORM) {
-		if (nd->depth)
-			put_link(nd);
-		return handle_dots(nd, nd->last_type);
-	}
-
-	/* We _can_ be in RCU mode here */
-	dentry = lookup_fast_for_open(nd, open_flag);
-	if (IS_ERR(dentry))
-		return ERR_CAST(dentry);
-
-	if (likely(dentry))
-		goto finish_lookup;
-
-	if (!(open_flag & O_CREAT)) {
-		if (WARN_ON_ONCE(nd->flags & LOOKUP_RCU))
-			return ERR_PTR(-ECHILD);
-	} else {
-		if (nd->flags & LOOKUP_RCU) {
-			if (!try_to_unlazy(nd))
-				return ERR_PTR(-ECHILD);
-		}
-	}
-
-	if (open_flag & (O_CREAT | O_TRUNC | O_WRONLY | O_RDWR)) {
-		got_write = !mnt_want_write(nd->path.mnt);
-		/*
-		 * do _not_ fail yet - we might not need that or fail with
-		 * a different error; let lookup_open() decide; we'll be
-		 * dropping this one anyway.
-		 */
-	}
-	if (open_flag & O_CREAT)
-		inode_lock(dir->d_inode);
-	else
-		inode_lock_shared(dir->d_inode);
-	dentry = lookup_open(nd, file, op, got_write);
-	if (!IS_ERR(dentry)) {
-		if (file->f_mode & FMODE_CREATED)
-			fsnotify_create(dir->d_inode, dentry);
-		if (file->f_mode & FMODE_OPENED)
-			fsnotify_open(file);
-	}
-	if (open_flag & O_CREAT)
-		inode_unlock(dir->d_inode);
-	else
-		inode_unlock_shared(dir->d_inode);
-
-	if (got_write)
-		mnt_drop_write(nd->path.mnt);
-
-	if (IS_ERR(dentry))
-		return ERR_CAST(dentry);
-
-	if (file->f_mode & (FMODE_OPENED | FMODE_CREATED)) {
-		dput(nd->path.dentry);
-		nd->path.dentry = dentry;
-		return NULL;
-	}
-
-finish_lookup:
-	if (nd->depth)
-		put_link(nd);
-	res = step_into(nd, WALK_TRAILING, dentry);
-	if (unlikely(res))
-		nd->flags &= ~(LOOKUP_OPEN|LOOKUP_CREATE|LOOKUP_EXCL);
-	return res;
-}
-
-/*
- * Handle the last step of open()
- */
-static int do_open(struct nameidata *nd,
-		   struct file *file, const struct open_flags *op)
-{
-	struct mnt_idmap *idmap;
-	int open_flag = op->open_flag;
-	bool do_truncate;
-	int acc_mode;
-	int error;
-
-	if (!(file->f_mode & (FMODE_OPENED | FMODE_CREATED))) {
-		error = complete_walk(nd);
-		if (error)
-			return error;
-	}
-	if (!(file->f_mode & FMODE_CREATED))
-		audit_inode(nd->name, nd->path.dentry, 0);
-	idmap = mnt_idmap(nd->path.mnt);
-	if (open_flag & O_CREAT) {
-		if ((open_flag & O_EXCL) && !(file->f_mode & FMODE_CREATED))
-			return -EEXIST;
-		if (d_is_dir(nd->path.dentry))
-			return -EISDIR;
-		error = may_create_in_sticky(idmap, nd,
-					     d_backing_inode(nd->path.dentry));
-		if (unlikely(error))
-			return error;
-	}
-	if ((nd->flags & LOOKUP_DIRECTORY) && !d_can_lookup(nd->path.dentry))
-		return -ENOTDIR;
-
-	do_truncate = false;
-	acc_mode = op->acc_mode;
-	if (file->f_mode & FMODE_CREATED) {
-		/* Don't check for write permission, don't truncate */
-		open_flag &= ~O_TRUNC;
-		acc_mode = 0;
-	} else if (d_is_reg(nd->path.dentry) && open_flag & O_TRUNC) {
-		error = mnt_want_write(nd->path.mnt);
-		if (error)
-			return error;
-		do_truncate = true;
-	}
-	error = may_open(idmap, &nd->path, acc_mode, open_flag);
-	if (!error && !(file->f_mode & FMODE_OPENED))
-		error = vfs_open(&nd->path, file);
-	if (!error)
-		error = security_file_post_open(file, op->acc_mode);
-	if (!error && do_truncate)
-		error = handle_truncate(idmap, file);
-	if (unlikely(error > 0)) {
-		WARN_ON(1);
-		error = -EINVAL;
-	}
-	if (do_truncate)
-		mnt_drop_write(nd->path.mnt);
-	return error;
-}
-
-/**
- * vfs_tmpfile - create tmpfile
- * @idmap:	idmap of the mount the inode was found from
- * @parentpath:	pointer to the path of the base directory
- * @file:	file descriptor of the new tmpfile
- * @mode:	mode of the new tmpfile
- *
- * Create a temporary file.
- *
- * If the inode has been found through an idmapped mount the idmap of
- * the vfsmount must be passed through @idmap. This function will then take
- * care to map the inode according to @idmap before checking permissions.
- * On non-idmapped mounts or if permission checking is to be performed on the
- * raw inode simply pass @nop_mnt_idmap.
- */
-int vfs_tmpfile(struct mnt_idmap *idmap,
-		const struct path *parentpath,
-		struct file *file, umode_t mode)
-{
-	struct dentry *child;
-	struct inode *dir = d_inode(parentpath->dentry);
-	struct inode *inode;
-	int error;
-	int open_flag = file->f_flags;
-
-	/* we want directory to be writable */
-	error = inode_permission(idmap, dir, MAY_WRITE | MAY_EXEC);
-	if (error)
-		return error;
-	if (!dir->i_op->tmpfile)
-		return -EOPNOTSUPP;
-	child = d_alloc(parentpath->dentry, &slash_name);
-	if (unlikely(!child))
-		return -ENOMEM;
-	file->f_path.mnt = parentpath->mnt;
-	file->f_path.dentry = child;
-	mode = vfs_prepare_mode(idmap, dir, mode, mode, mode);
-	error = dir->i_op->tmpfile(idmap, dir, file, mode);
-	dput(child);
-	if (file->f_mode & FMODE_OPENED)
-		fsnotify_open(file);
-	if (error)
-		return error;
-	/* Don't check for other permissions, the inode was just created */
-	error = may_open(idmap, &file->f_path, 0, file->f_flags);
-	if (error)
-		return error;
-	inode = file_inode(file);
-	if (!(open_flag & O_EXCL)) {
-		spin_lock(&inode->i_lock);
-		inode->i_state |= I_LINKABLE;
-		spin_unlock(&inode->i_lock);
-	}
-	security_inode_post_create_tmpfile(idmap, inode);
-	return 0;
-}
-
-/**
- * kernel_tmpfile_open - open a tmpfile for kernel internal use
- * @idmap:	idmap of the mount the inode was found from
- * @parentpath:	path of the base directory
- * @mode:	mode of the new tmpfile
- * @open_flag:	flags
- * @cred:	credentials for open
- *
- * Create and open a temporary file.  The file is not accounted in nr_files,
- * hence this is only for kernel internal use, and must not be installed into
- * file tables or such.
- */
-struct file *kernel_tmpfile_open(struct mnt_idmap *idmap,
-				 const struct path *parentpath,
-				 umode_t mode, int open_flag,
-				 const struct cred *cred)
-{
-	struct file *file;
-	int error;
-
-	file = alloc_empty_file_noaccount(open_flag, cred);
-	if (IS_ERR(file))
-		return file;
-
-	error = vfs_tmpfile(idmap, parentpath, file, mode);
-	if (error) {
-		fput(file);
-		file = ERR_PTR(error);
-	}
-	return file;
-}
-EXPORT_SYMBOL(kernel_tmpfile_open);
-
-static int do_tmpfile(struct nameidata *nd, unsigned flags,
-		const struct open_flags *op,
-		struct file *file)
-{
-	struct path path;
-	int error = path_lookupat(nd, flags | LOOKUP_DIRECTORY, &path);
-
-	if (unlikely(error))
-		return error;
-	error = mnt_want_write(path.mnt);
-	if (unlikely(error))
-		goto out;
-	error = vfs_tmpfile(mnt_idmap(path.mnt), &path, file, op->mode);
-	if (error)
-		goto out2;
-	audit_inode(nd->name, file->f_path.dentry, 0);
-out2:
-	mnt_drop_write(path.mnt);
-out:
-	path_put(&path);
-	return error;
-}
-
-static int do_o_path(struct nameidata *nd, unsigned flags, struct file *file)
-{
-	struct path path;
-	int error = path_lookupat(nd, flags, &path);
-	if (!error) {
-		audit_inode(nd->name, path.dentry, 0);
-		error = vfs_open(&path, file);
-		path_put(&path);
-	}
-	return error;
-}
-
-static struct file *path_openat(struct nameidata *nd,
-			const struct open_flags *op, unsigned flags)
-{
-	struct file *file;
-	int error;
-
-	file = alloc_empty_file(op->open_flag, current_cred());
-	if (IS_ERR(file))
-		return file;
-
-	if (unlikely(file->f_flags & __O_TMPFILE)) {
-		error = do_tmpfile(nd, flags, op, file);
-	} else if (unlikely(file->f_flags & O_PATH)) {
-		error = do_o_path(nd, flags, file);
-	} else {
-		const char *s = path_init(nd, flags);
-		while (!(error = link_path_walk(s, nd)) &&
-		       (s = open_last_lookups(nd, file, op)) != NULL)
-			;
-		if (!error)
-			error = do_open(nd, file, op);
-		terminate_walk(nd);
-	}
-	if (likely(!error)) {
-		if (likely(file->f_mode & FMODE_OPENED))
-			return file;
-		WARN_ON(1);
-		error = -EINVAL;
-	}
-	fput_close(file);
-	if (error == -EOPENSTALE) {
-		if (flags & LOOKUP_RCU)
-			error = -ECHILD;
-		else
-			error = -ESTALE;
-	}
-	return ERR_PTR(error);
-}
-
-struct file *do_filp_open(int dfd, struct filename *pathname,
-		const struct open_flags *op)
-{
-	struct nameidata nd;
-	int flags = op->lookup_flags;
-	struct file *filp;
-
-	set_nameidata(&nd, dfd, pathname, NULL);
-	filp = path_openat(&nd, op, flags | LOOKUP_RCU);
-	if (unlikely(filp == ERR_PTR(-ECHILD)))
-		filp = path_openat(&nd, op, flags);
-	if (unlikely(filp == ERR_PTR(-ESTALE)))
-		filp = path_openat(&nd, op, flags | LOOKUP_REVAL);
-	restore_nameidata();
-	return filp;
-}
-
-struct file *do_file_open_root(const struct path *root,
-		const char *name, const struct open_flags *op)
-{
-	struct nameidata nd;
-	struct file *file;
-	struct filename *filename;
-	int flags = op->lookup_flags;
-
-	if (d_is_symlink(root->dentry) && op->intent & LOOKUP_OPEN)
-		return ERR_PTR(-ELOOP);
-
-	filename = getname_kernel(name);
-	if (IS_ERR(filename))
-		return ERR_CAST(filename);
-
-	set_nameidata(&nd, -1, filename, root);
-	file = path_openat(&nd, op, flags | LOOKUP_RCU);
-	if (unlikely(file == ERR_PTR(-ECHILD)))
-		file = path_openat(&nd, op, flags);
-	if (unlikely(file == ERR_PTR(-ESTALE)))
-		file = path_openat(&nd, op, flags | LOOKUP_REVAL);
-	restore_nameidata();
-	putname(filename);
-	return file;
-}
-
-static struct dentry *filename_create(int dfd, struct filename *name,
-				      struct path *path, unsigned int lookup_flags)
-{
-	struct dentry *dentry = ERR_PTR(-EEXIST);
-	struct qstr last;
-	bool want_dir = lookup_flags & LOOKUP_DIRECTORY;
-	unsigned int reval_flag = lookup_flags & LOOKUP_REVAL;
-	unsigned int create_flags = LOOKUP_CREATE | LOOKUP_EXCL;
-	int type;
-	int err2;
-	int error;
-
-	error = filename_parentat(dfd, name, reval_flag, path, &last, &type);
-	if (error)
-		return ERR_PTR(error);
-
-	/*
-	 * Yucky last component or no last component at all?
-	 * (foo/., foo/.., /////)
-	 */
-	if (unlikely(type != LAST_NORM))
-		goto out;
-
-	/* don't fail immediately if it's r/o, at least try to report other errors */
-	err2 = mnt_want_write(path->mnt);
-	/*
-	 * Do the final lookup.  Suppress 'create' if there is a trailing
-	 * '/', and a directory wasn't requested.
-	 */
-	if (last.name[last.len] && !want_dir)
-		create_flags &= ~LOOKUP_CREATE;
-	inode_lock_nested(path->dentry->d_inode, I_MUTEX_PARENT);
-	dentry = lookup_one_qstr_excl(&last, path->dentry,
-				      reval_flag | create_flags);
-	if (IS_ERR(dentry))
-		goto unlock;
-
-	if (unlikely(err2)) {
-		error = err2;
-		goto fail;
-	}
-	return dentry;
-fail:
-	dput(dentry);
-	dentry = ERR_PTR(error);
-unlock:
-	inode_unlock(path->dentry->d_inode);
-	if (!err2)
-		mnt_drop_write(path->mnt);
-out:
-	path_put(path);
-	return dentry;
-}
-
-struct dentry *kern_path_create(int dfd, const char *pathname,
-				struct path *path, unsigned int lookup_flags)
-{
-	struct filename *filename = getname_kernel(pathname);
-	struct dentry *res = filename_create(dfd, filename, path, lookup_flags);
-
-	putname(filename);
-	return res;
-}
-EXPORT_SYMBOL(kern_path_create);
-
-void done_path_create(struct path *path, struct dentry *dentry)
-{
-	if (!IS_ERR(dentry))
-		dput(dentry);
-	inode_unlock(path->dentry->d_inode);
-	mnt_drop_write(path->mnt);
-	path_put(path);
-}
-EXPORT_SYMBOL(done_path_create);
-
-inline struct dentry *user_path_create(int dfd, const char __user *pathname,
-				struct path *path, unsigned int lookup_flags)
-{
-	struct filename *filename = getname(pathname);
-	struct dentry *res = filename_create(dfd, filename, path, lookup_flags);
-
-	putname(filename);
-	return res;
-}
-EXPORT_SYMBOL(user_path_create);
-
-/**
- * vfs_mknod - create device node or file
- * @idmap:	idmap of the mount the inode was found from
- * @dir:	inode of the parent directory
- * @dentry:	dentry of the child device node
- * @mode:	mode of the child device node
- * @dev:	device number of device to create
- *
- * Create a device node or file.
- *
- * If the inode has been found through an idmapped mount the idmap of
- * the vfsmount must be passed through @idmap. This function will then take
- * care to map the inode according to @idmap before checking permissions.
- * On non-idmapped mounts or if permission checking is to be performed on the
- * raw inode simply pass @nop_mnt_idmap.
- */
-int vfs_mknod(struct mnt_idmap *idmap, struct inode *dir,
-	      struct dentry *dentry, umode_t mode, dev_t dev)
-{
-	bool is_whiteout = S_ISCHR(mode) && dev == WHITEOUT_DEV;
-	int error = may_create(idmap, dir, dentry);
-
-	if (error)
-		return error;
-
-	if ((S_ISCHR(mode) || S_ISBLK(mode)) && !is_whiteout &&
-	    !capable(CAP_MKNOD))
-		return -EPERM;
-
-	if (!dir->i_op->mknod)
-		return -EPERM;
-
-	mode = vfs_prepare_mode(idmap, dir, mode, mode, mode);
-	error = devcgroup_inode_mknod(mode, dev);
-	if (error)
-		return error;
-
-	error = security_inode_mknod(dir, dentry, mode, dev);
-	if (error)
-		return error;
-
-	error = dir->i_op->mknod(idmap, dir, dentry, mode, dev);
-	if (!error)
-		fsnotify_create(dir, dentry);
-	return error;
-}
-EXPORT_SYMBOL(vfs_mknod);
-
-static int may_mknod(umode_t mode)
-{
-	switch (mode & S_IFMT) {
-	case S_IFREG:
-	case S_IFCHR:
-	case S_IFBLK:
-	case S_IFIFO:
-	case S_IFSOCK:
-	case 0: /* zero mode translates to S_IFREG */
-		return 0;
-	case S_IFDIR:
-		return -EPERM;
-	default:
-		return -EINVAL;
-	}
-}
-
-static int do_mknodat(int dfd, struct filename *name, umode_t mode,
-		unsigned int dev)
-{
-	struct mnt_idmap *idmap;
-	struct dentry *dentry;
-	struct path path;
-	int error;
-	unsigned int lookup_flags = 0;
-
-	error = may_mknod(mode);
-	if (error)
-		goto out1;
-retry:
-	dentry = filename_create(dfd, name, &path, lookup_flags);
-	error = PTR_ERR(dentry);
-	if (IS_ERR(dentry))
-		goto out1;
-
-	error = security_path_mknod(&path, dentry,
-			mode_strip_umask(path.dentry->d_inode, mode), dev);
-	if (error)
-		goto out2;
-
-	idmap = mnt_idmap(path.mnt);
-	switch (mode & S_IFMT) {
-		case 0: case S_IFREG:
-			error = vfs_create(idmap, path.dentry->d_inode,
-					   dentry, mode, true);
-			if (!error)
-				security_path_post_mknod(idmap, dentry);
-			break;
-		case S_IFCHR: case S_IFBLK:
-			error = vfs_mknod(idmap, path.dentry->d_inode,
-					  dentry, mode, new_decode_dev(dev));
-			break;
-		case S_IFIFO: case S_IFSOCK:
-			error = vfs_mknod(idmap, path.dentry->d_inode,
-					  dentry, mode, 0);
-			break;
-	}
-out2:
-	done_path_create(&path, dentry);
-	if (retry_estale(error, lookup_flags)) {
-		lookup_flags |= LOOKUP_REVAL;
-		goto retry;
-	}
-out1:
-	putname(name);
-	return error;
-}
-
-SYSCALL_DEFINE4(mknodat, int, dfd, const char __user *, filename, umode_t, mode,
-		unsigned int, dev)
-{
-	return do_mknodat(dfd, getname(filename), mode, dev);
-}
-
-SYSCALL_DEFINE3(mknod, const char __user *, filename, umode_t, mode, unsigned, dev)
-{
-	return do_mknodat(AT_FDCWD, getname(filename), mode, dev);
-}
-
-/**
- * vfs_mkdir - create directory returning correct dentry if possible
- * @idmap:	idmap of the mount the inode was found from
- * @dir:	inode of the parent directory
- * @dentry:	dentry of the child directory
- * @mode:	mode of the child directory
- *
- * Create a directory.
- *
- * If the inode has been found through an idmapped mount the idmap of
- * the vfsmount must be passed through @idmap. This function will then take
- * care to map the inode according to @idmap before checking permissions.
- * On non-idmapped mounts or if permission checking is to be performed on the
- * raw inode simply pass @nop_mnt_idmap.
- *
- * In the event that the filesystem does not use the *@dentry but leaves it
- * negative or unhashes it and possibly splices a different one returning it,
- * the original dentry is dput() and the alternate is returned.
- *
- * In case of an error the dentry is dput() and an ERR_PTR() is returned.
- */
-struct dentry *vfs_mkdir(struct mnt_idmap *idmap, struct inode *dir,
-			 struct dentry *dentry, umode_t mode)
-{
-	int error;
-	unsigned max_links = dir->i_sb->s_max_links;
-	struct dentry *de;
-
-	error = may_create(idmap, dir, dentry);
-	if (error)
-		goto err;
-
-	error = -EPERM;
-	if (!dir->i_op->mkdir)
-		goto err;
-
-	mode = vfs_prepare_mode(idmap, dir, mode, S_IRWXUGO | S_ISVTX, 0);
-	error = security_inode_mkdir(dir, dentry, mode);
-	if (error)
-		goto err;
-
-	error = -EMLINK;
-	if (max_links && dir->i_nlink >= max_links)
-		goto err;
-
-	de = dir->i_op->mkdir(idmap, dir, dentry, mode);
-	error = PTR_ERR(de);
-	if (IS_ERR(de))
-		goto err;
-	if (de) {
-		dput(dentry);
-		dentry = de;
-	}
-	fsnotify_mkdir(dir, dentry);
-	return dentry;
-
-err:
-	dput(dentry);
-	return ERR_PTR(error);
-}
-EXPORT_SYMBOL(vfs_mkdir);
-
-int do_mkdirat(int dfd, struct filename *name, umode_t mode)
-{
-	struct dentry *dentry;
-	struct path path;
-	int error;
-	unsigned int lookup_flags = LOOKUP_DIRECTORY;
-
-retry:
-	dentry = filename_create(dfd, name, &path, lookup_flags);
-	error = PTR_ERR(dentry);
-	if (IS_ERR(dentry))
-		goto out_putname;
-
-	error = security_path_mkdir(&path, dentry,
-			mode_strip_umask(path.dentry->d_inode, mode));
-	if (!error) {
-		dentry = vfs_mkdir(mnt_idmap(path.mnt), path.dentry->d_inode,
-				  dentry, mode);
-		if (IS_ERR(dentry))
-			error = PTR_ERR(dentry);
-	}
-	done_path_create(&path, dentry);
-	if (retry_estale(error, lookup_flags)) {
-		lookup_flags |= LOOKUP_REVAL;
-		goto retry;
-	}
-out_putname:
-	putname(name);
-	return error;
-}
-
-SYSCALL_DEFINE3(mkdirat, int, dfd, const char __user *, pathname, umode_t, mode)
-{
-	return do_mkdirat(dfd, getname(pathname), mode);
-}
-
-SYSCALL_DEFINE2(mkdir, const char __user *, pathname, umode_t, mode)
-{
-	return do_mkdirat(AT_FDCWD, getname(pathname), mode);
-}
-
-/**
- * vfs_rmdir - remove directory
- * @idmap:	idmap of the mount the inode was found from
- * @dir:	inode of the parent directory
- * @dentry:	dentry of the child directory
- *
- * Remove a directory.
- *
- * If the inode has been found through an idmapped mount the idmap of
- * the vfsmount must be passed through @idmap. This function will then take
- * care to map the inode according to @idmap before checking permissions.
- * On non-idmapped mounts or if permission checking is to be performed on the
- * raw inode simply pass @nop_mnt_idmap.
- */
-int vfs_rmdir(struct mnt_idmap *idmap, struct inode *dir,
-		     struct dentry *dentry)
-{
-	int error = may_delete(idmap, dir, dentry, 1);
-
-	if (error)
-		return error;
-
-	if (!dir->i_op->rmdir)
-		return -EPERM;
-
-	dget(dentry);
-	inode_lock(dentry->d_inode);
-
-	error = -EBUSY;
-	if (is_local_mountpoint(dentry) ||
-	    (dentry->d_inode->i_flags & S_KERNEL_FILE))
-		goto out;
-
-	error = security_inode_rmdir(dir, dentry);
-	if (error)
-		goto out;
-
-	error = dir->i_op->rmdir(dir, dentry);
-	if (error)
-		goto out;
-
-	shrink_dcache_parent(dentry);
-	dentry->d_inode->i_flags |= S_DEAD;
-	dont_mount(dentry);
-	detach_mounts(dentry);
-
-out:
-	inode_unlock(dentry->d_inode);
-	dput(dentry);
-	if (!error)
-		d_delete_notify(dir, dentry);
-	return error;
-}
-EXPORT_SYMBOL(vfs_rmdir);
-
-int do_rmdir(int dfd, struct filename *name)
-{
-	int error;
-	struct dentry *dentry;
-	struct path path;
-	struct qstr last;
-	int type;
-	unsigned int lookup_flags = 0;
-retry:
-	error = filename_parentat(dfd, name, lookup_flags, &path, &last, &type);
-	if (error)
-		goto exit1;
-
-	switch (type) {
-	case LAST_DOTDOT:
-		error = -ENOTEMPTY;
-		goto exit2;
-	case LAST_DOT:
-		error = -EINVAL;
-		goto exit2;
-	case LAST_ROOT:
-		error = -EBUSY;
-		goto exit2;
-	}
-
-	error = mnt_want_write(path.mnt);
-	if (error)
-		goto exit2;
-
-	inode_lock_nested(path.dentry->d_inode, I_MUTEX_PARENT);
-	dentry = lookup_one_qstr_excl(&last, path.dentry, lookup_flags);
-	error = PTR_ERR(dentry);
-	if (IS_ERR(dentry))
-		goto exit3;
-	error = security_path_rmdir(&path, dentry);
-	if (error)
-		goto exit4;
-	error = vfs_rmdir(mnt_idmap(path.mnt), path.dentry->d_inode, dentry);
-exit4:
-	dput(dentry);
-exit3:
-	inode_unlock(path.dentry->d_inode);
-	mnt_drop_write(path.mnt);
-exit2:
-	path_put(&path);
-	if (retry_estale(error, lookup_flags)) {
-		lookup_flags |= LOOKUP_REVAL;
-		goto retry;
-	}
-exit1:
-	putname(name);
-	return error;
-}
-
-SYSCALL_DEFINE1(rmdir, const char __user *, pathname)
-{
-	return do_rmdir(AT_FDCWD, getname(pathname));
-}
-
-/**
- * vfs_unlink - unlink a filesystem object
- * @idmap:	idmap of the mount the inode was found from
- * @dir:	parent directory
- * @dentry:	victim
- * @delegated_inode: returns victim inode, if the inode is delegated.
- *
- * The caller must hold dir->i_mutex.
- *
- * If vfs_unlink discovers a delegation, it will return -EWOULDBLOCK and
- * return a reference to the inode in delegated_inode.  The caller
- * should then break the delegation on that inode and retry.  Because
- * breaking a delegation may take a long time, the caller should drop
- * dir->i_mutex before doing so.
- *
- * Alternatively, a caller may pass NULL for delegated_inode.  This may
- * be appropriate for callers that expect the underlying filesystem not
- * to be NFS exported.
- *
- * If the inode has been found through an idmapped mount the idmap of
- * the vfsmount must be passed through @idmap. This function will then take
- * care to map the inode according to @idmap before checking permissions.
- * On non-idmapped mounts or if permission checking is to be performed on the
- * raw inode simply pass @nop_mnt_idmap.
- */
-int vfs_unlink(struct mnt_idmap *idmap, struct inode *dir,
-	       struct dentry *dentry, struct inode **delegated_inode)
-{
-	struct inode *target = dentry->d_inode;
-	int error = may_delete(idmap, dir, dentry, 0);
-
-	if (error)
-		return error;
-
-	if (!dir->i_op->unlink)
-		return -EPERM;
-
-	inode_lock(target);
-	if (IS_SWAPFILE(target))
-		error = -EPERM;
-	else if (is_local_mountpoint(dentry))
-		error = -EBUSY;
-	else {
-		error = security_inode_unlink(dir, dentry);
-		if (!error) {
-			error = try_break_deleg(target, delegated_inode);
-			if (error)
-				goto out;
-			error = dir->i_op->unlink(dir, dentry);
-			if (!error) {
-				dont_mount(dentry);
-				detach_mounts(dentry);
-			}
-		}
-	}
-out:
-	inode_unlock(target);
-
-	/* We don't d_delete() NFS sillyrenamed files--they still exist. */
-	if (!error && dentry->d_flags & DCACHE_NFSFS_RENAMED) {
-		fsnotify_unlink(dir, dentry);
-	} else if (!error) {
-		fsnotify_link_count(target);
-		d_delete_notify(dir, dentry);
-	}
-
-	return error;
-}
-EXPORT_SYMBOL(vfs_unlink);
-
-/*
- * Make sure that the actual truncation of the file will occur outside its
- * directory's i_mutex.  Truncate can take a long time if there is a lot of
- * writeout happening, and we don't want to prevent access to the directory
- * while waiting on the I/O.
- */
-int do_unlinkat(int dfd, struct filename *name)
-{
-	int error;
-	struct dentry *dentry;
-	struct path path;
-	struct qstr last;
-	int type;
-	struct inode *inode = NULL;
-	struct inode *delegated_inode = NULL;
-	unsigned int lookup_flags = 0;
-retry:
-	error = filename_parentat(dfd, name, lookup_flags, &path, &last, &type);
-	if (error)
-		goto exit1;
-
-	error = -EISDIR;
-	if (type != LAST_NORM)
-		goto exit2;
-
-	error = mnt_want_write(path.mnt);
-	if (error)
-		goto exit2;
-retry_deleg:
-	inode_lock_nested(path.dentry->d_inode, I_MUTEX_PARENT);
-	dentry = lookup_one_qstr_excl(&last, path.dentry, lookup_flags);
-	error = PTR_ERR(dentry);
-	if (!IS_ERR(dentry)) {
-
-		/* Why not before? Because we want correct error value */
-		if (last.name[last.len])
-			goto slashes;
-		inode = dentry->d_inode;
-		ihold(inode);
-		error = security_path_unlink(&path, dentry);
-		if (error)
-			goto exit3;
-		error = vfs_unlink(mnt_idmap(path.mnt), path.dentry->d_inode,
-				   dentry, &delegated_inode);
-exit3:
-		dput(dentry);
-	}
-	inode_unlock(path.dentry->d_inode);
-	if (inode)
-		iput(inode);	/* truncate the inode here */
-	inode = NULL;
-	if (delegated_inode) {
-		error = break_deleg_wait(&delegated_inode);
-		if (!error)
-			goto retry_deleg;
-	}
-	mnt_drop_write(path.mnt);
-exit2:
-	path_put(&path);
-	if (retry_estale(error, lookup_flags)) {
-		lookup_flags |= LOOKUP_REVAL;
-		inode = NULL;
-		goto retry;
-	}
-exit1:
-	putname(name);
-	return error;
-
-slashes:
-	if (d_is_dir(dentry))
-		error = -EISDIR;
-	else
-		error = -ENOTDIR;
-	goto exit3;
-}
-
-SYSCALL_DEFINE3(unlinkat, int, dfd, const char __user *, pathname, int, flag)
-{
-	if ((flag & ~AT_REMOVEDIR) != 0)
-		return -EINVAL;
-
-	if (flag & AT_REMOVEDIR)
-		return do_rmdir(dfd, getname(pathname));
-	return do_unlinkat(dfd, getname(pathname));
-}
-
-SYSCALL_DEFINE1(unlink, const char __user *, pathname)
-{
-	return do_unlinkat(AT_FDCWD, getname(pathname));
-}
-
-/**
- * vfs_symlink - create symlink
- * @idmap:	idmap of the mount the inode was found from
- * @dir:	inode of the parent directory
- * @dentry:	dentry of the child symlink file
- * @oldname:	name of the file to link to
- *
- * Create a symlink.
- *
- * If the inode has been found through an idmapped mount the idmap of
- * the vfsmount must be passed through @idmap. This function will then take
- * care to map the inode according to @idmap before checking permissions.
- * On non-idmapped mounts or if permission checking is to be performed on the
- * raw inode simply pass @nop_mnt_idmap.
- */
-int vfs_symlink(struct mnt_idmap *idmap, struct inode *dir,
-		struct dentry *dentry, const char *oldname)
-{
-	int error;
-
-	error = may_create(idmap, dir, dentry);
-	if (error)
-		return error;
-
-	if (!dir->i_op->symlink)
-		return -EPERM;
-
-	error = security_inode_symlink(dir, dentry, oldname);
-	if (error)
-		return error;
-
-	error = dir->i_op->symlink(idmap, dir, dentry, oldname);
-	if (!error)
-		fsnotify_create(dir, dentry);
-	return error;
-}
-EXPORT_SYMBOL(vfs_symlink);
-
-int do_symlinkat(struct filename *from, int newdfd, struct filename *to)
-{
-	int error;
-	struct dentry *dentry;
-	struct path path;
-	unsigned int lookup_flags = 0;
-
-	if (IS_ERR(from)) {
-		error = PTR_ERR(from);
-		goto out_putnames;
-	}
-retry:
-	dentry = filename_create(newdfd, to, &path, lookup_flags);
-	error = PTR_ERR(dentry);
-	if (IS_ERR(dentry))
-		goto out_putnames;
-
-	error = security_path_symlink(&path, dentry, from->name);
-	if (!error)
-		error = vfs_symlink(mnt_idmap(path.mnt), path.dentry->d_inode,
-				    dentry, from->name);
-	done_path_create(&path, dentry);
-	if (retry_estale(error, lookup_flags)) {
-		lookup_flags |= LOOKUP_REVAL;
-		goto retry;
-	}
-out_putnames:
-	putname(to);
-	putname(from);
-	return error;
-}
-
-SYSCALL_DEFINE3(symlinkat, const char __user *, oldname,
-		int, newdfd, const char __user *, newname)
-{
-	return do_symlinkat(getname(oldname), newdfd, getname(newname));
-}
-
-SYSCALL_DEFINE2(symlink, const char __user *, oldname, const char __user *, newname)
-{
-	return do_symlinkat(getname(oldname), AT_FDCWD, getname(newname));
-}
-
-/**
- * vfs_link - create a new link
- * @old_dentry:	object to be linked
- * @idmap:	idmap of the mount
- * @dir:	new parent
- * @new_dentry:	where to create the new link
- * @delegated_inode: returns inode needing a delegation break
- *
- * The caller must hold dir->i_mutex
- *
- * If vfs_link discovers a delegation on the to-be-linked file in need
- * of breaking, it will return -EWOULDBLOCK and return a reference to the
- * inode in delegated_inode.  The caller should then break the delegation
- * and retry.  Because breaking a delegation may take a long time, the
- * caller should drop the i_mutex before doing so.
- *
- * Alternatively, a caller may pass NULL for delegated_inode.  This may
- * be appropriate for callers that expect the underlying filesystem not
- * to be NFS exported.
- *
- * If the inode has been found through an idmapped mount the idmap of
- * the vfsmount must be passed through @idmap. This function will then take
- * care to map the inode according to @idmap before checking permissions.
- * On non-idmapped mounts or if permission checking is to be performed on the
- * raw inode simply pass @nop_mnt_idmap.
- */
-int vfs_link(struct dentry *old_dentry, struct mnt_idmap *idmap,
-	     struct inode *dir, struct dentry *new_dentry,
-	     struct inode **delegated_inode)
-{
-	struct inode *inode = old_dentry->d_inode;
-	unsigned max_links = dir->i_sb->s_max_links;
-	int error;
-
-	if (!inode)
-		return -ENOENT;
-
-	error = may_create(idmap, dir, new_dentry);
-	if (error)
-		return error;
-
-	if (dir->i_sb != inode->i_sb)
-		return -EXDEV;
-
-	/*
-	 * A link to an append-only or immutable file cannot be created.
-	 */
-	if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
-		return -EPERM;
-	/*
-	 * Updating the link count will likely cause i_uid and i_gid to
-	 * be writen back improperly if their true value is unknown to
-	 * the vfs.
-	 */
-	if (HAS_UNMAPPED_ID(idmap, inode))
-		return -EPERM;
-	if (!dir->i_op->link)
-		return -EPERM;
-	if (S_ISDIR(inode->i_mode))
-		return -EPERM;
-
-	error = security_inode_link(old_dentry, dir, new_dentry);
-	if (error)
-		return error;
-
-	inode_lock(inode);
-	/* Make sure we don't allow creating hardlink to an unlinked file */
-	if (inode->i_nlink == 0 && !(inode->i_state & I_LINKABLE))
-		error =  -ENOENT;
-	else if (max_links && inode->i_nlink >= max_links)
-		error = -EMLINK;
-	else {
-		error = try_break_deleg(inode, delegated_inode);
-		if (!error)
-			error = dir->i_op->link(old_dentry, dir, new_dentry);
-	}
-
-	if (!error && (inode->i_state & I_LINKABLE)) {
-		spin_lock(&inode->i_lock);
-		inode->i_state &= ~I_LINKABLE;
-		spin_unlock(&inode->i_lock);
-	}
-	inode_unlock(inode);
-	if (!error)
-		fsnotify_link(dir, inode, new_dentry);
-	return error;
-}
-EXPORT_SYMBOL(vfs_link);
-
-/*
- * Hardlinks are often used in delicate situations.  We avoid
- * security-related surprises by not following symlinks on the
- * newname.  --KAB
- *
- * We don't follow them on the oldname either to be compatible
- * with linux 2.0, and to avoid hard-linking to directories
- * and other special files.  --ADM
- */
-int do_linkat(int olddfd, struct filename *old, int newdfd,
-	      struct filename *new, int flags)
-{
-	struct mnt_idmap *idmap;
-	struct dentry *new_dentry;
-	struct path old_path, new_path;
-	struct inode *delegated_inode = NULL;
-	int how = 0;
-	int error;
-
-	if ((flags & ~(AT_SYMLINK_FOLLOW | AT_EMPTY_PATH)) != 0) {
-		error = -EINVAL;
-		goto out_putnames;
-	}
-	/*
-	 * To use null names we require CAP_DAC_READ_SEARCH or
-	 * that the open-time creds of the dfd matches current.
-	 * This ensures that not everyone will be able to create
-	 * a hardlink using the passed file descriptor.
-	 */
-	if (flags & AT_EMPTY_PATH)
-		how |= LOOKUP_LINKAT_EMPTY;
-
-	if (flags & AT_SYMLINK_FOLLOW)
-		how |= LOOKUP_FOLLOW;
-retry:
-	error = filename_lookup(olddfd, old, how, &old_path, NULL);
-	if (error)
-		goto out_putnames;
-
-	new_dentry = filename_create(newdfd, new, &new_path,
-					(how & LOOKUP_REVAL));
-	error = PTR_ERR(new_dentry);
-	if (IS_ERR(new_dentry))
-		goto out_putpath;
-
-	error = -EXDEV;
-	if (old_path.mnt != new_path.mnt)
-		goto out_dput;
-	idmap = mnt_idmap(new_path.mnt);
-	error = may_linkat(idmap, &old_path);
-	if (unlikely(error))
-		goto out_dput;
-	error = security_path_link(old_path.dentry, &new_path, new_dentry);
-	if (error)
-		goto out_dput;
-	error = vfs_link(old_path.dentry, idmap, new_path.dentry->d_inode,
-			 new_dentry, &delegated_inode);
-out_dput:
-	done_path_create(&new_path, new_dentry);
-	if (delegated_inode) {
-		error = break_deleg_wait(&delegated_inode);
-		if (!error) {
-			path_put(&old_path);
-			goto retry;
-		}
-	}
-	if (retry_estale(error, how)) {
-		path_put(&old_path);
-		how |= LOOKUP_REVAL;
-		goto retry;
-	}
-out_putpath:
-	path_put(&old_path);
-out_putnames:
-	putname(old);
-	putname(new);
-
-	return error;
-}
-
-SYSCALL_DEFINE5(linkat, int, olddfd, const char __user *, oldname,
-		int, newdfd, const char __user *, newname, int, flags)
-{
-	return do_linkat(olddfd, getname_uflags(oldname, flags),
-		newdfd, getname(newname), flags);
-}
-
-SYSCALL_DEFINE2(link, const char __user *, oldname, const char __user *, newname)
-{
-	return do_linkat(AT_FDCWD, getname(oldname), AT_FDCWD, getname(newname), 0);
-}
-
-/**
- * vfs_rename - rename a filesystem object
- * @rd:		pointer to &struct renamedata info
- *
- * The caller must hold multiple mutexes--see lock_rename()).
- *
- * If vfs_rename discovers a delegation in need of breaking at either
- * the source or destination, it will return -EWOULDBLOCK and return a
- * reference to the inode in delegated_inode.  The caller should then
- * break the delegation and retry.  Because breaking a delegation may
- * take a long time, the caller should drop all locks before doing
- * so.
- *
- * Alternatively, a caller may pass NULL for delegated_inode.  This may
- * be appropriate for callers that expect the underlying filesystem not
- * to be NFS exported.
- *
- * The worst of all namespace operations - renaming directory. "Perverted"
- * doesn't even start to describe it. Somebody in UCB had a heck of a trip...
- * Problems:
- *
- *	a) we can get into loop creation.
- *	b) race potential - two innocent renames can create a loop together.
- *	   That's where 4.4BSD screws up. Current fix: serialization on
- *	   sb->s_vfs_rename_mutex. We might be more accurate, but that's another
- *	   story.
- *	c) we may have to lock up to _four_ objects - parents and victim (if it exists),
- *	   and source (if it's a non-directory or a subdirectory that moves to
- *	   different parent).
- *	   And that - after we got ->i_mutex on parents (until then we don't know
- *	   whether the target exists).  Solution: try to be smart with locking
- *	   order for inodes.  We rely on the fact that tree topology may change
- *	   only under ->s_vfs_rename_mutex _and_ that parent of the object we
- *	   move will be locked.  Thus we can rank directories by the tree
- *	   (ancestors first) and rank all non-directories after them.
- *	   That works since everybody except rename does "lock parent, lookup,
- *	   lock child" and rename is under ->s_vfs_rename_mutex.
- *	   HOWEVER, it relies on the assumption that any object with ->lookup()
- *	   has no more than 1 dentry.  If "hybrid" objects will ever appear,
- *	   we'd better make sure that there's no link(2) for them.
- *	d) conversion from fhandle to dentry may come in the wrong moment - when
- *	   we are removing the target. Solution: we will have to grab ->i_mutex
- *	   in the fhandle_to_dentry code. [FIXME - current nfsfh.c relies on
- *	   ->i_mutex on parents, which works but leads to some truly excessive
- *	   locking].
- */
-int vfs_rename(struct renamedata *rd)
-{
-	int error;
-	struct inode *old_dir = rd->old_dir, *new_dir = rd->new_dir;
-	struct dentry *old_dentry = rd->old_dentry;
-	struct dentry *new_dentry = rd->new_dentry;
-	struct inode **delegated_inode = rd->delegated_inode;
-	unsigned int flags = rd->flags;
-	bool is_dir = d_is_dir(old_dentry);
-	struct inode *source = old_dentry->d_inode;
-	struct inode *target = new_dentry->d_inode;
-	bool new_is_dir = false;
-	unsigned max_links = new_dir->i_sb->s_max_links;
-	struct name_snapshot old_name;
-	bool lock_old_subdir, lock_new_subdir;
-
-	if (source == target)
-		return 0;
-
-	error = may_delete(rd->old_mnt_idmap, old_dir, old_dentry, is_dir);
-	if (error)
-		return error;
-
-	if (!target) {
-		error = may_create(rd->new_mnt_idmap, new_dir, new_dentry);
-	} else {
-		new_is_dir = d_is_dir(new_dentry);
-
-		if (!(flags & RENAME_EXCHANGE))
-			error = may_delete(rd->new_mnt_idmap, new_dir,
-					   new_dentry, is_dir);
-		else
-			error = may_delete(rd->new_mnt_idmap, new_dir,
-					   new_dentry, new_is_dir);
-	}
-	if (error)
-		return error;
-
-	if (!old_dir->i_op->rename)
-		return -EPERM;
-
-	/*
-	 * If we are going to change the parent - check write permissions,
-	 * we'll need to flip '..'.
-	 */
-	if (new_dir != old_dir) {
-		if (is_dir) {
-			error = inode_permission(rd->old_mnt_idmap, source,
-						 MAY_WRITE);
-			if (error)
-				return error;
-		}
-		if ((flags & RENAME_EXCHANGE) && new_is_dir) {
-			error = inode_permission(rd->new_mnt_idmap, target,
-						 MAY_WRITE);
-			if (error)
-				return error;
-		}
-	}
-
-	error = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry,
-				      flags);
-	if (error)
-		return error;
-
-	take_dentry_name_snapshot(&old_name, old_dentry);
-	dget(new_dentry);
-	/*
-	 * Lock children.
-	 * The source subdirectory needs to be locked on cross-directory
-	 * rename or cross-directory exchange since its parent changes.
-	 * The target subdirectory needs to be locked on cross-directory
-	 * exchange due to parent change and on any rename due to becoming
-	 * a victim.
-	 * Non-directories need locking in all cases (for NFS reasons);
-	 * they get locked after any subdirectories (in inode address order).
-	 *
-	 * NOTE: WE ONLY LOCK UNRELATED DIRECTORIES IN CROSS-DIRECTORY CASE.
-	 * NEVER, EVER DO THAT WITHOUT ->s_vfs_rename_mutex.
-	 */
-	lock_old_subdir = new_dir != old_dir;
-	lock_new_subdir = new_dir != old_dir || !(flags & RENAME_EXCHANGE);
-	if (is_dir) {
-		if (lock_old_subdir)
-			inode_lock_nested(source, I_MUTEX_CHILD);
-		if (target && (!new_is_dir || lock_new_subdir))
-			inode_lock(target);
-	} else if (new_is_dir) {
-		if (lock_new_subdir)
-			inode_lock_nested(target, I_MUTEX_CHILD);
-		inode_lock(source);
-	} else {
-		lock_two_nondirectories(source, target);
-	}
-
-	error = -EPERM;
-	if (IS_SWAPFILE(source) || (target && IS_SWAPFILE(target)))
-		goto out;
-
-	error = -EBUSY;
-	if (is_local_mountpoint(old_dentry) || is_local_mountpoint(new_dentry))
-		goto out;
-
-	if (max_links && new_dir != old_dir) {
-		error = -EMLINK;
-		if (is_dir && !new_is_dir && new_dir->i_nlink >= max_links)
-			goto out;
-		if ((flags & RENAME_EXCHANGE) && !is_dir && new_is_dir &&
-		    old_dir->i_nlink >= max_links)
-			goto out;
-	}
-	if (!is_dir) {
-		error = try_break_deleg(source, delegated_inode);
-		if (error)
-			goto out;
-	}
-	if (target && !new_is_dir) {
-		error = try_break_deleg(target, delegated_inode);
-		if (error)
-			goto out;
-	}
-	error = old_dir->i_op->rename(rd->new_mnt_idmap, old_dir, old_dentry,
-				      new_dir, new_dentry, flags);
-	if (error)
-		goto out;
-
-	if (!(flags & RENAME_EXCHANGE) && target) {
-		if (is_dir) {
-			shrink_dcache_parent(new_dentry);
-			target->i_flags |= S_DEAD;
-		}
-		dont_mount(new_dentry);
-		detach_mounts(new_dentry);
-	}
-	if (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE)) {
-		if (!(flags & RENAME_EXCHANGE))
-			d_move(old_dentry, new_dentry);
-		else
-			d_exchange(old_dentry, new_dentry);
-	}
-out:
-	if (!is_dir || lock_old_subdir)
-		inode_unlock(source);
-	if (target && (!new_is_dir || lock_new_subdir))
-		inode_unlock(target);
-	dput(new_dentry);
-	if (!error) {
-		fsnotify_move(old_dir, new_dir, &old_name.name, is_dir,
-			      !(flags & RENAME_EXCHANGE) ? target : NULL, old_dentry);
-		if (flags & RENAME_EXCHANGE) {
-			fsnotify_move(new_dir, old_dir, &old_dentry->d_name,
-				      new_is_dir, NULL, new_dentry);
-		}
-	}
-	release_dentry_name_snapshot(&old_name);
-
-	return error;
-}
-EXPORT_SYMBOL(vfs_rename);
-
-int do_renameat2(int olddfd, struct filename *from, int newdfd,
-		 struct filename *to, unsigned int flags)
-{
-	struct renamedata rd;
-	struct dentry *old_dentry, *new_dentry;
-	struct dentry *trap;
-	struct path old_path, new_path;
-	struct qstr old_last, new_last;
-	int old_type, new_type;
-	struct inode *delegated_inode = NULL;
-	unsigned int lookup_flags = 0, target_flags =
-		LOOKUP_RENAME_TARGET | LOOKUP_CREATE;
-	bool should_retry = false;
-	int error = -EINVAL;
-
-	if (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE | RENAME_WHITEOUT))
-		goto put_names;
-
-	if ((flags & (RENAME_NOREPLACE | RENAME_WHITEOUT)) &&
-	    (flags & RENAME_EXCHANGE))
-		goto put_names;
-
-	if (flags & RENAME_EXCHANGE)
-		target_flags = 0;
-	if (flags & RENAME_NOREPLACE)
-		target_flags |= LOOKUP_EXCL;
-
-retry:
-	error = filename_parentat(olddfd, from, lookup_flags, &old_path,
-				  &old_last, &old_type);
-	if (error)
-		goto put_names;
-
-	error = filename_parentat(newdfd, to, lookup_flags, &new_path, &new_last,
-				  &new_type);
-	if (error)
-		goto exit1;
-
-	error = -EXDEV;
-	if (old_path.mnt != new_path.mnt)
-		goto exit2;
-
-	error = -EBUSY;
-	if (old_type != LAST_NORM)
-		goto exit2;
-
-	if (flags & RENAME_NOREPLACE)
-		error = -EEXIST;
-	if (new_type != LAST_NORM)
-		goto exit2;
-
-	error = mnt_want_write(old_path.mnt);
-	if (error)
-		goto exit2;
-
-retry_deleg:
-	trap = lock_rename(new_path.dentry, old_path.dentry);
-	if (IS_ERR(trap)) {
-		error = PTR_ERR(trap);
-		goto exit_lock_rename;
-	}
-
-	old_dentry = lookup_one_qstr_excl(&old_last, old_path.dentry,
-					  lookup_flags);
-	error = PTR_ERR(old_dentry);
-	if (IS_ERR(old_dentry))
-		goto exit3;
-	new_dentry = lookup_one_qstr_excl(&new_last, new_path.dentry,
-					  lookup_flags | target_flags);
-	error = PTR_ERR(new_dentry);
-	if (IS_ERR(new_dentry))
-		goto exit4;
-	if (flags & RENAME_EXCHANGE) {
-		if (!d_is_dir(new_dentry)) {
-			error = -ENOTDIR;
-			if (new_last.name[new_last.len])
-				goto exit5;
-		}
-	}
-	/* unless the source is a directory trailing slashes give -ENOTDIR */
-	if (!d_is_dir(old_dentry)) {
-		error = -ENOTDIR;
-		if (old_last.name[old_last.len])
-			goto exit5;
-		if (!(flags & RENAME_EXCHANGE) && new_last.name[new_last.len])
-			goto exit5;
-	}
-	/* source should not be ancestor of target */
-	error = -EINVAL;
-	if (old_dentry == trap)
-		goto exit5;
-	/* target should not be an ancestor of source */
-	if (!(flags & RENAME_EXCHANGE))
-		error = -ENOTEMPTY;
-	if (new_dentry == trap)
-		goto exit5;
-
-	error = security_path_rename(&old_path, old_dentry,
-				     &new_path, new_dentry, flags);
-	if (error)
-		goto exit5;
-
-	rd.old_dir	   = old_path.dentry->d_inode;
-	rd.old_dentry	   = old_dentry;
-	rd.old_mnt_idmap   = mnt_idmap(old_path.mnt);
-	rd.new_dir	   = new_path.dentry->d_inode;
-	rd.new_dentry	   = new_dentry;
-	rd.new_mnt_idmap   = mnt_idmap(new_path.mnt);
-	rd.delegated_inode = &delegated_inode;
-	rd.flags	   = flags;
-	error = vfs_rename(&rd);
-exit5:
-	dput(new_dentry);
-exit4:
-	dput(old_dentry);
-exit3:
-	unlock_rename(new_path.dentry, old_path.dentry);
-exit_lock_rename:
-	if (delegated_inode) {
-		error = break_deleg_wait(&delegated_inode);
-		if (!error)
-			goto retry_deleg;
-	}
-	mnt_drop_write(old_path.mnt);
-exit2:
-	if (retry_estale(error, lookup_flags))
-		should_retry = true;
-	path_put(&new_path);
-exit1:
-	path_put(&old_path);
-	if (should_retry) {
-		should_retry = false;
-		lookup_flags |= LOOKUP_REVAL;
-		goto retry;
-	}
-put_names:
-	putname(from);
-	putname(to);
-	return error;
-}
-
-SYSCALL_DEFINE5(renameat2, int, olddfd, const char __user *, oldname,
-		int, newdfd, const char __user *, newname, unsigned int, flags)
-{
-	return do_renameat2(olddfd, getname(oldname), newdfd, getname(newname),
-				flags);
-}
-
-SYSCALL_DEFINE4(renameat, int, olddfd, const char __user *, oldname,
-		int, newdfd, const char __user *, newname)
-{
-	return do_renameat2(olddfd, getname(oldname), newdfd, getname(newname),
-				0);
-}
-
-SYSCALL_DEFINE2(rename, const char __user *, oldname, const char __user *, newname)
-{
-	return do_renameat2(AT_FDCWD, getname(oldname), AT_FDCWD,
-				getname(newname), 0);
-}
-
-int readlink_copy(char __user *buffer, int buflen, const char *link, int linklen)
-{
-	int copylen;
-
-	copylen = linklen;
-	if (unlikely(copylen > (unsigned) buflen))
-		copylen = buflen;
-	if (copy_to_user(buffer, link, copylen))
-		copylen = -EFAULT;
-	return copylen;
-}
-
-/**
- * vfs_readlink - copy symlink body into userspace buffer
- * @dentry: dentry on which to get symbolic link
- * @buffer: user memory pointer
- * @buflen: size of buffer
- *
- * Does not touch atime.  That's up to the caller if necessary
- *
- * Does not call security hook.
- */
-int vfs_readlink(struct dentry *dentry, char __user *buffer, int buflen)
-{
-	struct inode *inode = d_inode(dentry);
-	DEFINE_DELAYED_CALL(done);
-	const char *link;
-	int res;
-
-	if (inode->i_opflags & IOP_CACHED_LINK)
-		return readlink_copy(buffer, buflen, inode->i_link, inode->i_linklen);
-
-	if (unlikely(!(inode->i_opflags & IOP_DEFAULT_READLINK))) {
-		if (unlikely(inode->i_op->readlink))
-			return inode->i_op->readlink(dentry, buffer, buflen);
-
-		if (!d_is_symlink(dentry))
-			return -EINVAL;
-
-		spin_lock(&inode->i_lock);
-		inode->i_opflags |= IOP_DEFAULT_READLINK;
-		spin_unlock(&inode->i_lock);
-	}
-
-	link = READ_ONCE(inode->i_link);
-	if (!link) {
-		link = inode->i_op->get_link(dentry, inode, &done);
-		if (IS_ERR(link))
-			return PTR_ERR(link);
-	}
-	res = readlink_copy(buffer, buflen, link, strlen(link));
-	do_delayed_call(&done);
-	return res;
-}
-EXPORT_SYMBOL(vfs_readlink);
-
-/**
- * vfs_get_link - get symlink body
- * @dentry: dentry on which to get symbolic link
- * @done: caller needs to free returned data with this
- *
- * Calls security hook and i_op->get_link() on the supplied inode.
- *
- * It does not touch atime.  That's up to the caller if necessary.
- *
- * Does not work on "special" symlinks like /proc/$$/fd/N
- */
-const char *vfs_get_link(struct dentry *dentry, struct delayed_call *done)
-{
-	const char *res = ERR_PTR(-EINVAL);
-	struct inode *inode = d_inode(dentry);
-
-	if (d_is_symlink(dentry)) {
-		res = ERR_PTR(security_inode_readlink(dentry));
-		if (!res)
-			res = inode->i_op->get_link(dentry, inode, done);
-	}
-	return res;
-}
-EXPORT_SYMBOL(vfs_get_link);
-
-/* get the link contents into pagecache */
-static char *__page_get_link(struct dentry *dentry, struct inode *inode,
-			     struct delayed_call *callback)
-{
-	struct folio *folio;
-	struct address_space *mapping = inode->i_mapping;
-
-	if (!dentry) {
-		folio = filemap_get_folio(mapping, 0);
-		if (IS_ERR(folio))
-			return ERR_PTR(-ECHILD);
-		if (!folio_test_uptodate(folio)) {
-			folio_put(folio);
-			return ERR_PTR(-ECHILD);
-		}
-	} else {
-		folio = read_mapping_folio(mapping, 0, NULL);
-		if (IS_ERR(folio))
-			return ERR_CAST(folio);
-	}
-	set_delayed_call(callback, page_put_link, folio);
-	BUG_ON(mapping_gfp_mask(mapping) & __GFP_HIGHMEM);
-	return folio_address(folio);
-}
-
-const char *page_get_link_raw(struct dentry *dentry, struct inode *inode,
-			      struct delayed_call *callback)
-{
-	return __page_get_link(dentry, inode, callback);
-}
-EXPORT_SYMBOL_GPL(page_get_link_raw);
-
-/**
- * page_get_link() - An implementation of the get_link inode_operation.
- * @dentry: The directory entry which is the symlink.
- * @inode: The inode for the symlink.
- * @callback: Used to drop the reference to the symlink.
- *
- * Filesystems which store their symlinks in the page cache should use
- * this to implement the get_link() member of their inode_operations.
- *
- * Return: A pointer to the NUL-terminated symlink.
- */
-const char *page_get_link(struct dentry *dentry, struct inode *inode,
-					struct delayed_call *callback)
-{
-	char *kaddr = __page_get_link(dentry, inode, callback);
-
-	if (!IS_ERR(kaddr))
-		nd_terminate_link(kaddr, inode->i_size, PAGE_SIZE - 1);
-	return kaddr;
-}
-EXPORT_SYMBOL(page_get_link);
-
-/**
- * page_put_link() - Drop the reference to the symlink.
- * @arg: The folio which contains the symlink.
- *
- * This is used internally by page_get_link().  It is exported for use
- * by filesystems which need to implement a variant of page_get_link()
- * themselves.  Despite the apparent symmetry, filesystems which use
- * page_get_link() do not need to call page_put_link().
- *
- * The argument, while it has a void pointer type, must be a pointer to
- * the folio which was retrieved from the page cache.  The delayed_call
- * infrastructure is used to drop the reference count once the caller
- * is done with the symlink.
- */
-void page_put_link(void *arg)
-{
-	folio_put(arg);
-}
-EXPORT_SYMBOL(page_put_link);
-
-int page_readlink(struct dentry *dentry, char __user *buffer, int buflen)
-{
-	const char *link;
-	int res;
-
-	DEFINE_DELAYED_CALL(done);
-	link = page_get_link(dentry, d_inode(dentry), &done);
-	res = PTR_ERR(link);
-	if (!IS_ERR(link))
-		res = readlink_copy(buffer, buflen, link, strlen(link));
-	do_delayed_call(&done);
-	return res;
-}
-EXPORT_SYMBOL(page_readlink);
-
-int page_symlink(struct inode *inode, const char *symname, int len)
-{
-	struct address_space *mapping = inode->i_mapping;
-	const struct address_space_operations *aops = mapping->a_ops;
-	bool nofs = !mapping_gfp_constraint(mapping, __GFP_FS);
-	struct folio *folio;
-	void *fsdata = NULL;
-	int err;
-	unsigned int flags;
-
-retry:
-	if (nofs)
-		flags = memalloc_nofs_save();
-	err = aops->write_begin(NULL, mapping, 0, len-1, &folio, &fsdata);
-	if (nofs)
-		memalloc_nofs_restore(flags);
-	if (err)
-		goto fail;
-
-	memcpy(folio_address(folio), symname, len - 1);
-
-	err = aops->write_end(NULL, mapping, 0, len - 1, len - 1,
-						folio, fsdata);
-	if (err < 0)
-		goto fail;
-	if (err < len-1)
-		goto retry;
-
-	mark_inode_dirty(inode);
-	return 0;
-fail:
-	return err;
-}
-EXPORT_SYMBOL(page_symlink);
-
-const struct inode_operations page_symlink_inode_operations = {
-	.get_link	= page_get_link,
-};
-EXPORT_SYMBOL(page_symlink_inode_operations);
diff -Nrup linux-6.16.7/fs/proc/generic.c linux-lenovo-x13s-linux-6.16.y/fs/proc/generic.c
--- linux-6.16.7/fs/proc/generic.c	2025-09-13 16:15:43.482296968 -0600
+++ linux-lenovo-x13s-linux-6.16.y/fs/proc/generic.c	2025-09-11 09:47:42.000000000 -0600
@@ -390,8 +390,7 @@ struct proc_dir_entry *proc_register(str
 	if (proc_alloc_inum(&dp->low_ino))
 		goto out_free_entry;
 
-	if (!S_ISDIR(dp->mode))
-		pde_set_flags(dp);
+	pde_set_flags(dp);
 
 	write_lock(&proc_subdir_lock);
 	dp->parent = dir;
diff -Nrup linux-6.16.7/fs/proc/generic.c.orig linux-lenovo-x13s-linux-6.16.y/fs/proc/generic.c.orig
--- linux-6.16.7/fs/proc/generic.c.orig	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/fs/proc/generic.c.orig	1969-12-31 17:00:00.000000000 -0700
@@ -1,834 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * proc/fs/generic.c --- generic routines for the proc-fs
- *
- * This file contains generic proc-fs routines for handling
- * directories and files.
- * 
- * Copyright (C) 1991, 1992 Linus Torvalds.
- * Copyright (C) 1997 Theodore Ts'o
- */
-
-#include <linux/cache.h>
-#include <linux/errno.h>
-#include <linux/time.h>
-#include <linux/proc_fs.h>
-#include <linux/stat.h>
-#include <linux/mm.h>
-#include <linux/module.h>
-#include <linux/namei.h>
-#include <linux/slab.h>
-#include <linux/printk.h>
-#include <linux/mount.h>
-#include <linux/init.h>
-#include <linux/idr.h>
-#include <linux/bitops.h>
-#include <linux/spinlock.h>
-#include <linux/completion.h>
-#include <linux/uaccess.h>
-#include <linux/seq_file.h>
-
-#include "internal.h"
-
-static DEFINE_RWLOCK(proc_subdir_lock);
-
-struct kmem_cache *proc_dir_entry_cache __ro_after_init;
-
-void pde_free(struct proc_dir_entry *pde)
-{
-	if (S_ISLNK(pde->mode))
-		kfree(pde->data);
-	if (pde->name != pde->inline_name)
-		kfree(pde->name);
-	kmem_cache_free(proc_dir_entry_cache, pde);
-}
-
-static int proc_match(const char *name, struct proc_dir_entry *de, unsigned int len)
-{
-	if (len < de->namelen)
-		return -1;
-	if (len > de->namelen)
-		return 1;
-
-	return memcmp(name, de->name, len);
-}
-
-static struct proc_dir_entry *pde_subdir_first(struct proc_dir_entry *dir)
-{
-	return rb_entry_safe(rb_first(&dir->subdir), struct proc_dir_entry,
-			     subdir_node);
-}
-
-static struct proc_dir_entry *pde_subdir_next(struct proc_dir_entry *dir)
-{
-	return rb_entry_safe(rb_next(&dir->subdir_node), struct proc_dir_entry,
-			     subdir_node);
-}
-
-static struct proc_dir_entry *pde_subdir_find(struct proc_dir_entry *dir,
-					      const char *name,
-					      unsigned int len)
-{
-	struct rb_node *node = dir->subdir.rb_node;
-
-	while (node) {
-		struct proc_dir_entry *de = rb_entry(node,
-						     struct proc_dir_entry,
-						     subdir_node);
-		int result = proc_match(name, de, len);
-
-		if (result < 0)
-			node = node->rb_left;
-		else if (result > 0)
-			node = node->rb_right;
-		else
-			return de;
-	}
-	return NULL;
-}
-
-static bool pde_subdir_insert(struct proc_dir_entry *dir,
-			      struct proc_dir_entry *de)
-{
-	struct rb_root *root = &dir->subdir;
-	struct rb_node **new = &root->rb_node, *parent = NULL;
-
-	/* Figure out where to put new node */
-	while (*new) {
-		struct proc_dir_entry *this = rb_entry(*new,
-						       struct proc_dir_entry,
-						       subdir_node);
-		int result = proc_match(de->name, this, de->namelen);
-
-		parent = *new;
-		if (result < 0)
-			new = &(*new)->rb_left;
-		else if (result > 0)
-			new = &(*new)->rb_right;
-		else
-			return false;
-	}
-
-	/* Add new node and rebalance tree. */
-	rb_link_node(&de->subdir_node, parent, new);
-	rb_insert_color(&de->subdir_node, root);
-	return true;
-}
-
-static int proc_notify_change(struct mnt_idmap *idmap,
-			      struct dentry *dentry, struct iattr *iattr)
-{
-	struct inode *inode = d_inode(dentry);
-	struct proc_dir_entry *de = PDE(inode);
-	int error;
-
-	error = setattr_prepare(&nop_mnt_idmap, dentry, iattr);
-	if (error)
-		return error;
-
-	setattr_copy(&nop_mnt_idmap, inode, iattr);
-
-	proc_set_user(de, inode->i_uid, inode->i_gid);
-	de->mode = inode->i_mode;
-	return 0;
-}
-
-static int proc_getattr(struct mnt_idmap *idmap,
-			const struct path *path, struct kstat *stat,
-			u32 request_mask, unsigned int query_flags)
-{
-	struct inode *inode = d_inode(path->dentry);
-	struct proc_dir_entry *de = PDE(inode);
-	if (de) {
-		nlink_t nlink = READ_ONCE(de->nlink);
-		if (nlink > 0) {
-			set_nlink(inode, nlink);
-		}
-	}
-
-	generic_fillattr(&nop_mnt_idmap, request_mask, inode, stat);
-	return 0;
-}
-
-static const struct inode_operations proc_file_inode_operations = {
-	.setattr	= proc_notify_change,
-};
-
-/*
- * This function parses a name such as "tty/driver/serial", and
- * returns the struct proc_dir_entry for "/proc/tty/driver", and
- * returns "serial" in residual.
- */
-static int __xlate_proc_name(const char *name, struct proc_dir_entry **ret,
-			     const char **residual)
-{
-	const char     		*cp = name, *next;
-	struct proc_dir_entry	*de;
-
-	de = *ret ?: &proc_root;
-	while ((next = strchr(cp, '/')) != NULL) {
-		de = pde_subdir_find(de, cp, next - cp);
-		if (!de) {
-			WARN(1, "name '%s'\n", name);
-			return -ENOENT;
-		}
-		cp = next + 1;
-	}
-	*residual = cp;
-	*ret = de;
-	return 0;
-}
-
-static int xlate_proc_name(const char *name, struct proc_dir_entry **ret,
-			   const char **residual)
-{
-	int rv;
-
-	read_lock(&proc_subdir_lock);
-	rv = __xlate_proc_name(name, ret, residual);
-	read_unlock(&proc_subdir_lock);
-	return rv;
-}
-
-static DEFINE_IDA(proc_inum_ida);
-
-#define PROC_DYNAMIC_FIRST 0xF0000000U
-
-/*
- * Return an inode number between PROC_DYNAMIC_FIRST and
- * 0xffffffff, or zero on failure.
- */
-int proc_alloc_inum(unsigned int *inum)
-{
-	int i;
-
-	i = ida_alloc_max(&proc_inum_ida, UINT_MAX - PROC_DYNAMIC_FIRST,
-			  GFP_KERNEL);
-	if (i < 0)
-		return i;
-
-	*inum = PROC_DYNAMIC_FIRST + (unsigned int)i;
-	return 0;
-}
-
-void proc_free_inum(unsigned int inum)
-{
-	ida_free(&proc_inum_ida, inum - PROC_DYNAMIC_FIRST);
-}
-
-static int proc_misc_d_revalidate(struct inode *dir, const struct qstr *name,
-				  struct dentry *dentry, unsigned int flags)
-{
-	if (flags & LOOKUP_RCU)
-		return -ECHILD;
-
-	if (atomic_read(&PDE(d_inode(dentry))->in_use) < 0)
-		return 0; /* revalidate */
-	return 1;
-}
-
-static int proc_misc_d_delete(const struct dentry *dentry)
-{
-	return atomic_read(&PDE(d_inode(dentry))->in_use) < 0;
-}
-
-static const struct dentry_operations proc_misc_dentry_ops = {
-	.d_revalidate	= proc_misc_d_revalidate,
-	.d_delete	= proc_misc_d_delete,
-};
-
-/*
- * Don't create negative dentries here, return -ENOENT by hand
- * instead.
- */
-struct dentry *proc_lookup_de(struct inode *dir, struct dentry *dentry,
-			      struct proc_dir_entry *de)
-{
-	struct inode *inode;
-
-	read_lock(&proc_subdir_lock);
-	de = pde_subdir_find(de, dentry->d_name.name, dentry->d_name.len);
-	if (de) {
-		pde_get(de);
-		read_unlock(&proc_subdir_lock);
-		inode = proc_get_inode(dir->i_sb, de);
-		if (!inode)
-			return ERR_PTR(-ENOMEM);
-		d_set_d_op(dentry, de->proc_dops);
-		return d_splice_alias(inode, dentry);
-	}
-	read_unlock(&proc_subdir_lock);
-	return ERR_PTR(-ENOENT);
-}
-
-struct dentry *proc_lookup(struct inode *dir, struct dentry *dentry,
-		unsigned int flags)
-{
-	struct proc_fs_info *fs_info = proc_sb_info(dir->i_sb);
-
-	if (fs_info->pidonly == PROC_PIDONLY_ON)
-		return ERR_PTR(-ENOENT);
-
-	return proc_lookup_de(dir, dentry, PDE(dir));
-}
-
-/*
- * This returns non-zero if at EOF, so that the /proc
- * root directory can use this and check if it should
- * continue with the <pid> entries..
- *
- * Note that the VFS-layer doesn't care about the return
- * value of the readdir() call, as long as it's non-negative
- * for success..
- */
-int proc_readdir_de(struct file *file, struct dir_context *ctx,
-		    struct proc_dir_entry *de)
-{
-	int i;
-
-	if (!dir_emit_dots(file, ctx))
-		return 0;
-
-	i = ctx->pos - 2;
-	read_lock(&proc_subdir_lock);
-	de = pde_subdir_first(de);
-	for (;;) {
-		if (!de) {
-			read_unlock(&proc_subdir_lock);
-			return 0;
-		}
-		if (!i)
-			break;
-		de = pde_subdir_next(de);
-		i--;
-	}
-
-	do {
-		struct proc_dir_entry *next;
-		pde_get(de);
-		read_unlock(&proc_subdir_lock);
-		if (!dir_emit(ctx, de->name, de->namelen,
-			    de->low_ino, de->mode >> 12)) {
-			pde_put(de);
-			return 0;
-		}
-		ctx->pos++;
-		read_lock(&proc_subdir_lock);
-		next = pde_subdir_next(de);
-		pde_put(de);
-		de = next;
-	} while (de);
-	read_unlock(&proc_subdir_lock);
-	return 1;
-}
-
-int proc_readdir(struct file *file, struct dir_context *ctx)
-{
-	struct inode *inode = file_inode(file);
-	struct proc_fs_info *fs_info = proc_sb_info(inode->i_sb);
-
-	if (fs_info->pidonly == PROC_PIDONLY_ON)
-		return 1;
-
-	return proc_readdir_de(file, ctx, PDE(inode));
-}
-
-/*
- * These are the generic /proc directory operations. They
- * use the in-memory "struct proc_dir_entry" tree to parse
- * the /proc directory.
- */
-static const struct file_operations proc_dir_operations = {
-	.llseek			= generic_file_llseek,
-	.read			= generic_read_dir,
-	.iterate_shared		= proc_readdir,
-};
-
-static int proc_net_d_revalidate(struct inode *dir, const struct qstr *name,
-				 struct dentry *dentry, unsigned int flags)
-{
-	return 0;
-}
-
-const struct dentry_operations proc_net_dentry_ops = {
-	.d_revalidate	= proc_net_d_revalidate,
-	.d_delete	= always_delete_dentry,
-};
-
-/*
- * proc directories can do almost nothing..
- */
-static const struct inode_operations proc_dir_inode_operations = {
-	.lookup		= proc_lookup,
-	.getattr	= proc_getattr,
-	.setattr	= proc_notify_change,
-};
-
-static void pde_set_flags(struct proc_dir_entry *pde)
-{
-	const struct proc_ops *proc_ops = pde->proc_ops;
-
-	if (!proc_ops)
-		return;
-
-	if (proc_ops->proc_flags & PROC_ENTRY_PERMANENT)
-		pde->flags |= PROC_ENTRY_PERMANENT;
-	if (proc_ops->proc_read_iter)
-		pde->flags |= PROC_ENTRY_proc_read_iter;
-#ifdef CONFIG_COMPAT
-	if (proc_ops->proc_compat_ioctl)
-		pde->flags |= PROC_ENTRY_proc_compat_ioctl;
-#endif
-	if (proc_ops->proc_lseek)
-		pde->flags |= PROC_ENTRY_proc_lseek;
-}
-
-/* returns the registered entry, or frees dp and returns NULL on failure */
-struct proc_dir_entry *proc_register(struct proc_dir_entry *dir,
-		struct proc_dir_entry *dp)
-{
-	if (proc_alloc_inum(&dp->low_ino))
-		goto out_free_entry;
-
-	pde_set_flags(dp);
-
-	write_lock(&proc_subdir_lock);
-	dp->parent = dir;
-	if (pde_subdir_insert(dir, dp) == false) {
-		WARN(1, "proc_dir_entry '%s/%s' already registered\n",
-		     dir->name, dp->name);
-		write_unlock(&proc_subdir_lock);
-		goto out_free_inum;
-	}
-	dir->nlink++;
-	write_unlock(&proc_subdir_lock);
-
-	return dp;
-out_free_inum:
-	proc_free_inum(dp->low_ino);
-out_free_entry:
-	pde_free(dp);
-	return NULL;
-}
-
-static struct proc_dir_entry *__proc_create(struct proc_dir_entry **parent,
-					  const char *name,
-					  umode_t mode,
-					  nlink_t nlink)
-{
-	struct proc_dir_entry *ent = NULL;
-	const char *fn;
-	struct qstr qstr;
-
-	if (xlate_proc_name(name, parent, &fn) != 0)
-		goto out;
-	qstr.name = fn;
-	qstr.len = strlen(fn);
-	if (qstr.len == 0 || qstr.len >= 256) {
-		WARN(1, "name len %u\n", qstr.len);
-		return NULL;
-	}
-	if (qstr.len == 1 && fn[0] == '.') {
-		WARN(1, "name '.'\n");
-		return NULL;
-	}
-	if (qstr.len == 2 && fn[0] == '.' && fn[1] == '.') {
-		WARN(1, "name '..'\n");
-		return NULL;
-	}
-	if (*parent == &proc_root && name_to_int(&qstr) != ~0U) {
-		WARN(1, "create '/proc/%s' by hand\n", qstr.name);
-		return NULL;
-	}
-	if (is_empty_pde(*parent)) {
-		WARN(1, "attempt to add to permanently empty directory");
-		return NULL;
-	}
-
-	ent = kmem_cache_zalloc(proc_dir_entry_cache, GFP_KERNEL);
-	if (!ent)
-		goto out;
-
-	if (qstr.len + 1 <= SIZEOF_PDE_INLINE_NAME) {
-		ent->name = ent->inline_name;
-	} else {
-		ent->name = kmalloc(qstr.len + 1, GFP_KERNEL);
-		if (!ent->name) {
-			pde_free(ent);
-			return NULL;
-		}
-	}
-
-	memcpy(ent->name, fn, qstr.len + 1);
-	ent->namelen = qstr.len;
-	ent->mode = mode;
-	ent->nlink = nlink;
-	ent->subdir = RB_ROOT;
-	refcount_set(&ent->refcnt, 1);
-	spin_lock_init(&ent->pde_unload_lock);
-	INIT_LIST_HEAD(&ent->pde_openers);
-	proc_set_user(ent, (*parent)->uid, (*parent)->gid);
-
-	ent->proc_dops = &proc_misc_dentry_ops;
-	/* Revalidate everything under /proc/${pid}/net */
-	if ((*parent)->proc_dops == &proc_net_dentry_ops)
-		pde_force_lookup(ent);
-
-out:
-	return ent;
-}
-
-struct proc_dir_entry *proc_symlink(const char *name,
-		struct proc_dir_entry *parent, const char *dest)
-{
-	struct proc_dir_entry *ent;
-
-	ent = __proc_create(&parent, name,
-			  (S_IFLNK | S_IRUGO | S_IWUGO | S_IXUGO),1);
-
-	if (ent) {
-		ent->size = strlen(dest);
-		ent->data = kmemdup(dest, ent->size + 1, GFP_KERNEL);
-		if (ent->data) {
-			ent->proc_iops = &proc_link_inode_operations;
-			ent = proc_register(parent, ent);
-		} else {
-			pde_free(ent);
-			ent = NULL;
-		}
-	}
-	return ent;
-}
-EXPORT_SYMBOL(proc_symlink);
-
-struct proc_dir_entry *_proc_mkdir(const char *name, umode_t mode,
-		struct proc_dir_entry *parent, void *data, bool force_lookup)
-{
-	struct proc_dir_entry *ent;
-
-	if (mode == 0)
-		mode = S_IRUGO | S_IXUGO;
-
-	ent = __proc_create(&parent, name, S_IFDIR | mode, 2);
-	if (ent) {
-		ent->data = data;
-		ent->proc_dir_ops = &proc_dir_operations;
-		ent->proc_iops = &proc_dir_inode_operations;
-		if (force_lookup) {
-			pde_force_lookup(ent);
-		}
-		ent = proc_register(parent, ent);
-	}
-	return ent;
-}
-EXPORT_SYMBOL_GPL(_proc_mkdir);
-
-struct proc_dir_entry *proc_mkdir_data(const char *name, umode_t mode,
-		struct proc_dir_entry *parent, void *data)
-{
-	return _proc_mkdir(name, mode, parent, data, false);
-}
-EXPORT_SYMBOL_GPL(proc_mkdir_data);
-
-struct proc_dir_entry *proc_mkdir_mode(const char *name, umode_t mode,
-				       struct proc_dir_entry *parent)
-{
-	return proc_mkdir_data(name, mode, parent, NULL);
-}
-EXPORT_SYMBOL(proc_mkdir_mode);
-
-struct proc_dir_entry *proc_mkdir(const char *name,
-		struct proc_dir_entry *parent)
-{
-	return proc_mkdir_data(name, 0, parent, NULL);
-}
-EXPORT_SYMBOL(proc_mkdir);
-
-struct proc_dir_entry *proc_create_mount_point(const char *name)
-{
-	umode_t mode = S_IFDIR | S_IRUGO | S_IXUGO;
-	struct proc_dir_entry *ent, *parent = NULL;
-
-	ent = __proc_create(&parent, name, mode, 2);
-	if (ent) {
-		ent->data = NULL;
-		ent->proc_dir_ops = NULL;
-		ent->proc_iops = NULL;
-		ent = proc_register(parent, ent);
-	}
-	return ent;
-}
-EXPORT_SYMBOL(proc_create_mount_point);
-
-struct proc_dir_entry *proc_create_reg(const char *name, umode_t mode,
-		struct proc_dir_entry **parent, void *data)
-{
-	struct proc_dir_entry *p;
-
-	if ((mode & S_IFMT) == 0)
-		mode |= S_IFREG;
-	if ((mode & S_IALLUGO) == 0)
-		mode |= S_IRUGO;
-	if (WARN_ON_ONCE(!S_ISREG(mode)))
-		return NULL;
-
-	p = __proc_create(parent, name, mode, 1);
-	if (p) {
-		p->proc_iops = &proc_file_inode_operations;
-		p->data = data;
-	}
-	return p;
-}
-
-struct proc_dir_entry *proc_create_data(const char *name, umode_t mode,
-		struct proc_dir_entry *parent,
-		const struct proc_ops *proc_ops, void *data)
-{
-	struct proc_dir_entry *p;
-
-	p = proc_create_reg(name, mode, &parent, data);
-	if (!p)
-		return NULL;
-	p->proc_ops = proc_ops;
-	return proc_register(parent, p);
-}
-EXPORT_SYMBOL(proc_create_data);
- 
-struct proc_dir_entry *proc_create(const char *name, umode_t mode,
-				   struct proc_dir_entry *parent,
-				   const struct proc_ops *proc_ops)
-{
-	return proc_create_data(name, mode, parent, proc_ops, NULL);
-}
-EXPORT_SYMBOL(proc_create);
-
-static int proc_seq_open(struct inode *inode, struct file *file)
-{
-	struct proc_dir_entry *de = PDE(inode);
-
-	if (de->state_size)
-		return seq_open_private(file, de->seq_ops, de->state_size);
-	return seq_open(file, de->seq_ops);
-}
-
-static int proc_seq_release(struct inode *inode, struct file *file)
-{
-	struct proc_dir_entry *de = PDE(inode);
-
-	if (de->state_size)
-		return seq_release_private(inode, file);
-	return seq_release(inode, file);
-}
-
-static const struct proc_ops proc_seq_ops = {
-	/* not permanent -- can call into arbitrary seq_operations */
-	.proc_open	= proc_seq_open,
-	.proc_read_iter	= seq_read_iter,
-	.proc_lseek	= seq_lseek,
-	.proc_release	= proc_seq_release,
-};
-
-struct proc_dir_entry *proc_create_seq_private(const char *name, umode_t mode,
-		struct proc_dir_entry *parent, const struct seq_operations *ops,
-		unsigned int state_size, void *data)
-{
-	struct proc_dir_entry *p;
-
-	p = proc_create_reg(name, mode, &parent, data);
-	if (!p)
-		return NULL;
-	p->proc_ops = &proc_seq_ops;
-	p->seq_ops = ops;
-	p->state_size = state_size;
-	return proc_register(parent, p);
-}
-EXPORT_SYMBOL(proc_create_seq_private);
-
-static int proc_single_open(struct inode *inode, struct file *file)
-{
-	struct proc_dir_entry *de = PDE(inode);
-
-	return single_open(file, de->single_show, de->data);
-}
-
-static const struct proc_ops proc_single_ops = {
-	/* not permanent -- can call into arbitrary ->single_show */
-	.proc_open	= proc_single_open,
-	.proc_read_iter = seq_read_iter,
-	.proc_lseek	= seq_lseek,
-	.proc_release	= single_release,
-};
-
-struct proc_dir_entry *proc_create_single_data(const char *name, umode_t mode,
-		struct proc_dir_entry *parent,
-		int (*show)(struct seq_file *, void *), void *data)
-{
-	struct proc_dir_entry *p;
-
-	p = proc_create_reg(name, mode, &parent, data);
-	if (!p)
-		return NULL;
-	p->proc_ops = &proc_single_ops;
-	p->single_show = show;
-	return proc_register(parent, p);
-}
-EXPORT_SYMBOL(proc_create_single_data);
-
-void proc_set_size(struct proc_dir_entry *de, loff_t size)
-{
-	de->size = size;
-}
-EXPORT_SYMBOL(proc_set_size);
-
-void proc_set_user(struct proc_dir_entry *de, kuid_t uid, kgid_t gid)
-{
-	de->uid = uid;
-	de->gid = gid;
-}
-EXPORT_SYMBOL(proc_set_user);
-
-void pde_put(struct proc_dir_entry *pde)
-{
-	if (refcount_dec_and_test(&pde->refcnt)) {
-		proc_free_inum(pde->low_ino);
-		pde_free(pde);
-	}
-}
-
-/*
- * Remove a /proc entry and free it if it's not currently in use.
- */
-void remove_proc_entry(const char *name, struct proc_dir_entry *parent)
-{
-	struct proc_dir_entry *de = NULL;
-	const char *fn = name;
-	unsigned int len;
-
-	write_lock(&proc_subdir_lock);
-	if (__xlate_proc_name(name, &parent, &fn) != 0) {
-		write_unlock(&proc_subdir_lock);
-		return;
-	}
-	len = strlen(fn);
-
-	de = pde_subdir_find(parent, fn, len);
-	if (de) {
-		if (unlikely(pde_is_permanent(de))) {
-			WARN(1, "removing permanent /proc entry '%s'", de->name);
-			de = NULL;
-		} else {
-			rb_erase(&de->subdir_node, &parent->subdir);
-			if (S_ISDIR(de->mode))
-				parent->nlink--;
-		}
-	}
-	write_unlock(&proc_subdir_lock);
-	if (!de) {
-		WARN(1, "name '%s'\n", name);
-		return;
-	}
-
-	proc_entry_rundown(de);
-
-	WARN(pde_subdir_first(de),
-	     "%s: removing non-empty directory '%s/%s', leaking at least '%s'\n",
-	     __func__, de->parent->name, de->name, pde_subdir_first(de)->name);
-	pde_put(de);
-}
-EXPORT_SYMBOL(remove_proc_entry);
-
-int remove_proc_subtree(const char *name, struct proc_dir_entry *parent)
-{
-	struct proc_dir_entry *root = NULL, *de, *next;
-	const char *fn = name;
-	unsigned int len;
-
-	write_lock(&proc_subdir_lock);
-	if (__xlate_proc_name(name, &parent, &fn) != 0) {
-		write_unlock(&proc_subdir_lock);
-		return -ENOENT;
-	}
-	len = strlen(fn);
-
-	root = pde_subdir_find(parent, fn, len);
-	if (!root) {
-		write_unlock(&proc_subdir_lock);
-		return -ENOENT;
-	}
-	if (unlikely(pde_is_permanent(root))) {
-		write_unlock(&proc_subdir_lock);
-		WARN(1, "removing permanent /proc entry '%s/%s'",
-			root->parent->name, root->name);
-		return -EINVAL;
-	}
-	rb_erase(&root->subdir_node, &parent->subdir);
-
-	de = root;
-	while (1) {
-		next = pde_subdir_first(de);
-		if (next) {
-			if (unlikely(pde_is_permanent(next))) {
-				write_unlock(&proc_subdir_lock);
-				WARN(1, "removing permanent /proc entry '%s/%s'",
-					next->parent->name, next->name);
-				return -EINVAL;
-			}
-			rb_erase(&next->subdir_node, &de->subdir);
-			de = next;
-			continue;
-		}
-		next = de->parent;
-		if (S_ISDIR(de->mode))
-			next->nlink--;
-		write_unlock(&proc_subdir_lock);
-
-		proc_entry_rundown(de);
-		if (de == root)
-			break;
-		pde_put(de);
-
-		write_lock(&proc_subdir_lock);
-		de = next;
-	}
-	pde_put(root);
-	return 0;
-}
-EXPORT_SYMBOL(remove_proc_subtree);
-
-void *proc_get_parent_data(const struct inode *inode)
-{
-	struct proc_dir_entry *de = PDE(inode);
-	return de->parent->data;
-}
-EXPORT_SYMBOL_GPL(proc_get_parent_data);
-
-void proc_remove(struct proc_dir_entry *de)
-{
-	if (de)
-		remove_proc_subtree(de->name, de->parent);
-}
-EXPORT_SYMBOL(proc_remove);
-
-/*
- * Pull a user buffer into memory and pass it to the file's write handler if
- * one is supplied.  The ->write() method is permitted to modify the
- * kernel-side buffer.
- */
-ssize_t proc_simple_write(struct file *f, const char __user *ubuf, size_t size,
-			  loff_t *_pos)
-{
-	struct proc_dir_entry *pde = PDE(file_inode(f));
-	char *buf;
-	int ret;
-
-	if (!pde->write)
-		return -EACCES;
-	if (size == 0 || size > PAGE_SIZE - 1)
-		return -EINVAL;
-	buf = memdup_user_nul(ubuf, size);
-	if (IS_ERR(buf))
-		return PTR_ERR(buf);
-	ret = pde->write(f, buf, size);
-	kfree(buf);
-	return ret == 0 ? size : ret;
-}
diff -Nrup linux-6.16.7/fs/proc/generic.c.rej linux-lenovo-x13s-linux-6.16.y/fs/proc/generic.c.rej
--- linux-6.16.7/fs/proc/generic.c.rej	2025-09-13 16:15:43.479015562 -0600
+++ linux-lenovo-x13s-linux-6.16.y/fs/proc/generic.c.rej	1969-12-31 17:00:00.000000000 -0700
@@ -1,82 +0,0 @@
---- fs/proc/generic.c
-+++ fs/proc/generic.c
-@@ -367,6 +367,25 @@ static const struct inode_operations proc_dir_inode_operations = {
- 	.setattr	= proc_notify_change,
- };
- 
-+static void pde_set_flags(struct proc_dir_entry *pde)
-+{
-+	const struct proc_ops *proc_ops = pde->proc_ops;
-+
-+	if (!proc_ops)
-+		return;
-+
-+	if (proc_ops->proc_flags & PROC_ENTRY_PERMANENT)
-+		pde->flags |= PROC_ENTRY_PERMANENT;
-+	if (proc_ops->proc_read_iter)
-+		pde->flags |= PROC_ENTRY_proc_read_iter;
-+#ifdef CONFIG_COMPAT
-+	if (proc_ops->proc_compat_ioctl)
-+		pde->flags |= PROC_ENTRY_proc_compat_ioctl;
-+#endif
-+	if (proc_ops->proc_lseek)
-+		pde->flags |= PROC_ENTRY_proc_lseek;
-+}
-+
- /* returns the registered entry, or frees dp and returns NULL on failure */
- struct proc_dir_entry *proc_register(struct proc_dir_entry *dir,
- 		struct proc_dir_entry *dp)
-@@ -374,6 +393,8 @@ struct proc_dir_entry *proc_register(struct proc_dir_entry *dir,
- 	if (proc_alloc_inum(&dp->low_ino))
- 		goto out_free_entry;
- 
-+	pde_set_flags(dp);
-+
- 	write_lock(&proc_subdir_lock);
- 	dp->parent = dir;
- 	if (pde_subdir_insert(dir, dp) == false) {
-@@ -561,20 +582,6 @@ struct proc_dir_entry *proc_create_reg(const char *name, umode_t mode,
- 	return p;
- }
- 
--static void pde_set_flags(struct proc_dir_entry *pde)
--{
--	if (pde->proc_ops->proc_flags & PROC_ENTRY_PERMANENT)
--		pde->flags |= PROC_ENTRY_PERMANENT;
--	if (pde->proc_ops->proc_read_iter)
--		pde->flags |= PROC_ENTRY_proc_read_iter;
--#ifdef CONFIG_COMPAT
--	if (pde->proc_ops->proc_compat_ioctl)
--		pde->flags |= PROC_ENTRY_proc_compat_ioctl;
--#endif
--	if (pde->proc_ops->proc_lseek)
--		pde->flags |= PROC_ENTRY_proc_lseek;
--}
--
- struct proc_dir_entry *proc_create_data(const char *name, umode_t mode,
- 		struct proc_dir_entry *parent,
- 		const struct proc_ops *proc_ops, void *data)
-@@ -585,7 +592,6 @@ struct proc_dir_entry *proc_create_data(const char *name, umode_t mode,
- 	if (!p)
- 		return NULL;
- 	p->proc_ops = proc_ops;
--	pde_set_flags(p);
- 	return proc_register(parent, p);
- }
- EXPORT_SYMBOL(proc_create_data);
-@@ -636,7 +642,6 @@ struct proc_dir_entry *proc_create_seq_private(const char *name, umode_t mode,
- 	p->proc_ops = &proc_seq_ops;
- 	p->seq_ops = ops;
- 	p->state_size = state_size;
--	pde_set_flags(p);
- 	return proc_register(parent, p);
- }
- EXPORT_SYMBOL(proc_create_seq_private);
-@@ -667,7 +672,6 @@ struct proc_dir_entry *proc_create_single_data(const char *name, umode_t mode,
- 		return NULL;
- 	p->proc_ops = &proc_single_ops;
- 	p->single_show = show;
--	pde_set_flags(p);
- 	return proc_register(parent, p);
- }
- EXPORT_SYMBOL(proc_create_single_data);
diff -Nrup linux-6.16.7/include/dt-bindings/clock/qcom,dispcc-sm8150.h linux-lenovo-x13s-linux-6.16.y/include/dt-bindings/clock/qcom,dispcc-sm8150.h
--- linux-6.16.7/include/dt-bindings/clock/qcom,dispcc-sm8150.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/include/dt-bindings/clock/qcom,dispcc-sm8150.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,76 +1 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.
- */
-
-#ifndef _DT_BINDINGS_CLK_QCOM_DISP_CC_SM8250_H
-#define _DT_BINDINGS_CLK_QCOM_DISP_CC_SM8250_H
-
-/* DISP_CC clock registers */
-#define DISP_CC_MDSS_AHB_CLK			0
-#define DISP_CC_MDSS_AHB_CLK_SRC		1
-#define DISP_CC_MDSS_BYTE0_CLK			2
-#define DISP_CC_MDSS_BYTE0_CLK_SRC		3
-#define DISP_CC_MDSS_BYTE0_DIV_CLK_SRC		4
-#define DISP_CC_MDSS_BYTE0_INTF_CLK		5
-#define DISP_CC_MDSS_BYTE1_CLK			6
-#define DISP_CC_MDSS_BYTE1_CLK_SRC		7
-#define DISP_CC_MDSS_BYTE1_DIV_CLK_SRC		8
-#define DISP_CC_MDSS_BYTE1_INTF_CLK		9
-#define DISP_CC_MDSS_DP_AUX1_CLK		10
-#define DISP_CC_MDSS_DP_AUX1_CLK_SRC		11
-#define DISP_CC_MDSS_DP_AUX_CLK			12
-#define DISP_CC_MDSS_DP_AUX_CLK_SRC		13
-#define DISP_CC_MDSS_DP_LINK1_CLK		14
-#define DISP_CC_MDSS_DP_LINK1_CLK_SRC		15
-#define DISP_CC_MDSS_DP_LINK1_DIV_CLK_SRC	16
-#define DISP_CC_MDSS_DP_LINK1_INTF_CLK		17
-#define DISP_CC_MDSS_DP_LINK_CLK		18
-#define DISP_CC_MDSS_DP_LINK_CLK_SRC		19
-#define DISP_CC_MDSS_DP_LINK_DIV_CLK_SRC	20
-#define DISP_CC_MDSS_DP_LINK_INTF_CLK		21
-#define DISP_CC_MDSS_DP_PIXEL1_CLK		22
-#define DISP_CC_MDSS_DP_PIXEL1_CLK_SRC		23
-#define DISP_CC_MDSS_DP_PIXEL2_CLK		24
-#define DISP_CC_MDSS_DP_PIXEL2_CLK_SRC		25
-#define DISP_CC_MDSS_DP_PIXEL_CLK		26
-#define DISP_CC_MDSS_DP_PIXEL_CLK_SRC		27
-#define DISP_CC_MDSS_ESC0_CLK			28
-#define DISP_CC_MDSS_ESC0_CLK_SRC		29
-#define DISP_CC_MDSS_ESC1_CLK			30
-#define DISP_CC_MDSS_ESC1_CLK_SRC		31
-#define DISP_CC_MDSS_MDP_CLK			32
-#define DISP_CC_MDSS_MDP_CLK_SRC		33
-#define DISP_CC_MDSS_MDP_LUT_CLK		34
-#define DISP_CC_MDSS_NON_GDSC_AHB_CLK		35
-#define DISP_CC_MDSS_PCLK0_CLK			36
-#define DISP_CC_MDSS_PCLK0_CLK_SRC		37
-#define DISP_CC_MDSS_PCLK1_CLK			38
-#define DISP_CC_MDSS_PCLK1_CLK_SRC		39
-#define DISP_CC_MDSS_ROT_CLK			40
-#define DISP_CC_MDSS_ROT_CLK_SRC		41
-#define DISP_CC_MDSS_RSCC_AHB_CLK		42
-#define DISP_CC_MDSS_RSCC_VSYNC_CLK		43
-#define DISP_CC_MDSS_VSYNC_CLK			44
-#define DISP_CC_MDSS_VSYNC_CLK_SRC		45
-#define DISP_CC_PLL0				46
-#define DISP_CC_PLL1				47
-#define DISP_CC_MDSS_EDP_AUX_CLK		48
-#define DISP_CC_MDSS_EDP_AUX_CLK_SRC		49
-#define DISP_CC_MDSS_EDP_GTC_CLK		50
-#define DISP_CC_MDSS_EDP_GTC_CLK_SRC		51
-#define DISP_CC_MDSS_EDP_LINK_CLK		52
-#define DISP_CC_MDSS_EDP_LINK_CLK_SRC		53
-#define DISP_CC_MDSS_EDP_LINK_INTF_CLK		54
-#define DISP_CC_MDSS_EDP_PIXEL_CLK		55
-#define DISP_CC_MDSS_EDP_PIXEL_CLK_SRC		56
-#define DISP_CC_MDSS_EDP_LINK_DIV_CLK_SRC	57
-
-/* DISP_CC Reset */
-#define DISP_CC_MDSS_CORE_BCR			0
-#define DISP_CC_MDSS_RSCC_BCR			1
-
-/* DISP_CC GDSCR */
-#define MDSS_GDSC				0
-
-#endif
+qcom,dispcc-sm8250.h
\ No newline at end of file
diff -Nrup linux-6.16.7/include/dt-bindings/clock/qcom,dispcc-sm8350.h linux-lenovo-x13s-linux-6.16.y/include/dt-bindings/clock/qcom,dispcc-sm8350.h
--- linux-6.16.7/include/dt-bindings/clock/qcom,dispcc-sm8350.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/include/dt-bindings/clock/qcom,dispcc-sm8350.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,76 +1 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.
- */
-
-#ifndef _DT_BINDINGS_CLK_QCOM_DISP_CC_SM8250_H
-#define _DT_BINDINGS_CLK_QCOM_DISP_CC_SM8250_H
-
-/* DISP_CC clock registers */
-#define DISP_CC_MDSS_AHB_CLK			0
-#define DISP_CC_MDSS_AHB_CLK_SRC		1
-#define DISP_CC_MDSS_BYTE0_CLK			2
-#define DISP_CC_MDSS_BYTE0_CLK_SRC		3
-#define DISP_CC_MDSS_BYTE0_DIV_CLK_SRC		4
-#define DISP_CC_MDSS_BYTE0_INTF_CLK		5
-#define DISP_CC_MDSS_BYTE1_CLK			6
-#define DISP_CC_MDSS_BYTE1_CLK_SRC		7
-#define DISP_CC_MDSS_BYTE1_DIV_CLK_SRC		8
-#define DISP_CC_MDSS_BYTE1_INTF_CLK		9
-#define DISP_CC_MDSS_DP_AUX1_CLK		10
-#define DISP_CC_MDSS_DP_AUX1_CLK_SRC		11
-#define DISP_CC_MDSS_DP_AUX_CLK			12
-#define DISP_CC_MDSS_DP_AUX_CLK_SRC		13
-#define DISP_CC_MDSS_DP_LINK1_CLK		14
-#define DISP_CC_MDSS_DP_LINK1_CLK_SRC		15
-#define DISP_CC_MDSS_DP_LINK1_DIV_CLK_SRC	16
-#define DISP_CC_MDSS_DP_LINK1_INTF_CLK		17
-#define DISP_CC_MDSS_DP_LINK_CLK		18
-#define DISP_CC_MDSS_DP_LINK_CLK_SRC		19
-#define DISP_CC_MDSS_DP_LINK_DIV_CLK_SRC	20
-#define DISP_CC_MDSS_DP_LINK_INTF_CLK		21
-#define DISP_CC_MDSS_DP_PIXEL1_CLK		22
-#define DISP_CC_MDSS_DP_PIXEL1_CLK_SRC		23
-#define DISP_CC_MDSS_DP_PIXEL2_CLK		24
-#define DISP_CC_MDSS_DP_PIXEL2_CLK_SRC		25
-#define DISP_CC_MDSS_DP_PIXEL_CLK		26
-#define DISP_CC_MDSS_DP_PIXEL_CLK_SRC		27
-#define DISP_CC_MDSS_ESC0_CLK			28
-#define DISP_CC_MDSS_ESC0_CLK_SRC		29
-#define DISP_CC_MDSS_ESC1_CLK			30
-#define DISP_CC_MDSS_ESC1_CLK_SRC		31
-#define DISP_CC_MDSS_MDP_CLK			32
-#define DISP_CC_MDSS_MDP_CLK_SRC		33
-#define DISP_CC_MDSS_MDP_LUT_CLK		34
-#define DISP_CC_MDSS_NON_GDSC_AHB_CLK		35
-#define DISP_CC_MDSS_PCLK0_CLK			36
-#define DISP_CC_MDSS_PCLK0_CLK_SRC		37
-#define DISP_CC_MDSS_PCLK1_CLK			38
-#define DISP_CC_MDSS_PCLK1_CLK_SRC		39
-#define DISP_CC_MDSS_ROT_CLK			40
-#define DISP_CC_MDSS_ROT_CLK_SRC		41
-#define DISP_CC_MDSS_RSCC_AHB_CLK		42
-#define DISP_CC_MDSS_RSCC_VSYNC_CLK		43
-#define DISP_CC_MDSS_VSYNC_CLK			44
-#define DISP_CC_MDSS_VSYNC_CLK_SRC		45
-#define DISP_CC_PLL0				46
-#define DISP_CC_PLL1				47
-#define DISP_CC_MDSS_EDP_AUX_CLK		48
-#define DISP_CC_MDSS_EDP_AUX_CLK_SRC		49
-#define DISP_CC_MDSS_EDP_GTC_CLK		50
-#define DISP_CC_MDSS_EDP_GTC_CLK_SRC		51
-#define DISP_CC_MDSS_EDP_LINK_CLK		52
-#define DISP_CC_MDSS_EDP_LINK_CLK_SRC		53
-#define DISP_CC_MDSS_EDP_LINK_INTF_CLK		54
-#define DISP_CC_MDSS_EDP_PIXEL_CLK		55
-#define DISP_CC_MDSS_EDP_PIXEL_CLK_SRC		56
-#define DISP_CC_MDSS_EDP_LINK_DIV_CLK_SRC	57
-
-/* DISP_CC Reset */
-#define DISP_CC_MDSS_CORE_BCR			0
-#define DISP_CC_MDSS_RSCC_BCR			1
-
-/* DISP_CC GDSCR */
-#define MDSS_GDSC				0
-
-#endif
+qcom,dispcc-sm8250.h
\ No newline at end of file
diff -Nrup linux-6.16.7/include/dt-bindings/clock/qcom,sm8650-dispcc.h linux-lenovo-x13s-linux-6.16.y/include/dt-bindings/clock/qcom,sm8650-dispcc.h
--- linux-6.16.7/include/dt-bindings/clock/qcom,sm8650-dispcc.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/include/dt-bindings/clock/qcom,sm8650-dispcc.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,101 +1 @@
-/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */
-/*
- * Copyright (c) 2022, The Linux Foundation. All rights reserved.
- */
-
-#ifndef _DT_BINDINGS_CLK_QCOM_SM8550_DISP_CC_H
-#define _DT_BINDINGS_CLK_QCOM_SM8550_DISP_CC_H
-
-/* DISP_CC clocks */
-#define DISP_CC_MDSS_ACCU_CLK					0
-#define DISP_CC_MDSS_AHB1_CLK					1
-#define DISP_CC_MDSS_AHB_CLK					2
-#define DISP_CC_MDSS_AHB_CLK_SRC				3
-#define DISP_CC_MDSS_BYTE0_CLK					4
-#define DISP_CC_MDSS_BYTE0_CLK_SRC				5
-#define DISP_CC_MDSS_BYTE0_DIV_CLK_SRC				6
-#define DISP_CC_MDSS_BYTE0_INTF_CLK				7
-#define DISP_CC_MDSS_BYTE1_CLK					8
-#define DISP_CC_MDSS_BYTE1_CLK_SRC				9
-#define DISP_CC_MDSS_BYTE1_DIV_CLK_SRC				10
-#define DISP_CC_MDSS_BYTE1_INTF_CLK				11
-#define DISP_CC_MDSS_DPTX0_AUX_CLK				12
-#define DISP_CC_MDSS_DPTX0_AUX_CLK_SRC				13
-#define DISP_CC_MDSS_DPTX0_CRYPTO_CLK				14
-#define DISP_CC_MDSS_DPTX0_LINK_CLK				15
-#define DISP_CC_MDSS_DPTX0_LINK_CLK_SRC				16
-#define DISP_CC_MDSS_DPTX0_LINK_DIV_CLK_SRC			17
-#define DISP_CC_MDSS_DPTX0_LINK_INTF_CLK			18
-#define DISP_CC_MDSS_DPTX0_PIXEL0_CLK				19
-#define DISP_CC_MDSS_DPTX0_PIXEL0_CLK_SRC			20
-#define DISP_CC_MDSS_DPTX0_PIXEL1_CLK				21
-#define DISP_CC_MDSS_DPTX0_PIXEL1_CLK_SRC			22
-#define DISP_CC_MDSS_DPTX0_USB_ROUTER_LINK_INTF_CLK		23
-#define DISP_CC_MDSS_DPTX1_AUX_CLK				24
-#define DISP_CC_MDSS_DPTX1_AUX_CLK_SRC				25
-#define DISP_CC_MDSS_DPTX1_CRYPTO_CLK				26
-#define DISP_CC_MDSS_DPTX1_LINK_CLK				27
-#define DISP_CC_MDSS_DPTX1_LINK_CLK_SRC				28
-#define DISP_CC_MDSS_DPTX1_LINK_DIV_CLK_SRC			29
-#define DISP_CC_MDSS_DPTX1_LINK_INTF_CLK			30
-#define DISP_CC_MDSS_DPTX1_PIXEL0_CLK				31
-#define DISP_CC_MDSS_DPTX1_PIXEL0_CLK_SRC			32
-#define DISP_CC_MDSS_DPTX1_PIXEL1_CLK				33
-#define DISP_CC_MDSS_DPTX1_PIXEL1_CLK_SRC			34
-#define DISP_CC_MDSS_DPTX1_USB_ROUTER_LINK_INTF_CLK		35
-#define DISP_CC_MDSS_DPTX2_AUX_CLK				36
-#define DISP_CC_MDSS_DPTX2_AUX_CLK_SRC				37
-#define DISP_CC_MDSS_DPTX2_CRYPTO_CLK				38
-#define DISP_CC_MDSS_DPTX2_LINK_CLK				39
-#define DISP_CC_MDSS_DPTX2_LINK_CLK_SRC				40
-#define DISP_CC_MDSS_DPTX2_LINK_DIV_CLK_SRC			41
-#define DISP_CC_MDSS_DPTX2_LINK_INTF_CLK			42
-#define DISP_CC_MDSS_DPTX2_PIXEL0_CLK				43
-#define DISP_CC_MDSS_DPTX2_PIXEL0_CLK_SRC			44
-#define DISP_CC_MDSS_DPTX2_PIXEL1_CLK				45
-#define DISP_CC_MDSS_DPTX2_PIXEL1_CLK_SRC			46
-#define DISP_CC_MDSS_DPTX3_AUX_CLK				47
-#define DISP_CC_MDSS_DPTX3_AUX_CLK_SRC				48
-#define DISP_CC_MDSS_DPTX3_CRYPTO_CLK				49
-#define DISP_CC_MDSS_DPTX3_LINK_CLK				50
-#define DISP_CC_MDSS_DPTX3_LINK_CLK_SRC				51
-#define DISP_CC_MDSS_DPTX3_LINK_DIV_CLK_SRC			52
-#define DISP_CC_MDSS_DPTX3_LINK_INTF_CLK			53
-#define DISP_CC_MDSS_DPTX3_PIXEL0_CLK				54
-#define DISP_CC_MDSS_DPTX3_PIXEL0_CLK_SRC			55
-#define DISP_CC_MDSS_ESC0_CLK					56
-#define DISP_CC_MDSS_ESC0_CLK_SRC				57
-#define DISP_CC_MDSS_ESC1_CLK					58
-#define DISP_CC_MDSS_ESC1_CLK_SRC				59
-#define DISP_CC_MDSS_MDP1_CLK					60
-#define DISP_CC_MDSS_MDP_CLK					61
-#define DISP_CC_MDSS_MDP_CLK_SRC				62
-#define DISP_CC_MDSS_MDP_LUT1_CLK				63
-#define DISP_CC_MDSS_MDP_LUT_CLK				64
-#define DISP_CC_MDSS_NON_GDSC_AHB_CLK				65
-#define DISP_CC_MDSS_PCLK0_CLK					66
-#define DISP_CC_MDSS_PCLK0_CLK_SRC				67
-#define DISP_CC_MDSS_PCLK1_CLK					68
-#define DISP_CC_MDSS_PCLK1_CLK_SRC				69
-#define DISP_CC_MDSS_RSCC_AHB_CLK				70
-#define DISP_CC_MDSS_RSCC_VSYNC_CLK				71
-#define DISP_CC_MDSS_VSYNC1_CLK					72
-#define DISP_CC_MDSS_VSYNC_CLK					73
-#define DISP_CC_MDSS_VSYNC_CLK_SRC				74
-#define DISP_CC_PLL0						75
-#define DISP_CC_PLL1						76
-#define DISP_CC_SLEEP_CLK					77
-#define DISP_CC_SLEEP_CLK_SRC					78
-#define DISP_CC_XO_CLK						79
-#define DISP_CC_XO_CLK_SRC					80
-
-/* DISP_CC resets */
-#define DISP_CC_MDSS_CORE_BCR					0
-#define DISP_CC_MDSS_CORE_INT2_BCR				1
-#define DISP_CC_MDSS_RSCC_BCR					2
-
-/* DISP_CC GDSCR */
-#define MDSS_GDSC						0
-#define MDSS_INT2_GDSC						1
-
-#endif
+qcom,sm8550-dispcc.h
\ No newline at end of file
diff -Nrup linux-6.16.7/include/dt-bindings/input/linux-event-codes.h linux-lenovo-x13s-linux-6.16.y/include/dt-bindings/input/linux-event-codes.h
--- linux-6.16.7/include/dt-bindings/input/linux-event-codes.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/include/dt-bindings/input/linux-event-codes.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,982 +1 @@
-/* SPDX-License-Identifier: GPL-2.0-only WITH Linux-syscall-note */
-/*
- * Input event codes
- *
- *    *** IMPORTANT ***
- * This file is not only included from C-code but also from devicetree source
- * files. As such this file MUST only contain comments and defines.
- *
- * Copyright (c) 1999-2002 Vojtech Pavlik
- * Copyright (c) 2015 Hans de Goede <hdegoede@redhat.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published by
- * the Free Software Foundation.
- */
-#ifndef _UAPI_INPUT_EVENT_CODES_H
-#define _UAPI_INPUT_EVENT_CODES_H
-
-/*
- * Device properties and quirks
- */
-
-#define INPUT_PROP_POINTER		0x00	/* needs a pointer */
-#define INPUT_PROP_DIRECT		0x01	/* direct input devices */
-#define INPUT_PROP_BUTTONPAD		0x02	/* has button(s) under pad */
-#define INPUT_PROP_SEMI_MT		0x03	/* touch rectangle only */
-#define INPUT_PROP_TOPBUTTONPAD		0x04	/* softbuttons at top of pad */
-#define INPUT_PROP_POINTING_STICK	0x05	/* is a pointing stick */
-#define INPUT_PROP_ACCELEROMETER	0x06	/* has accelerometer */
-
-#define INPUT_PROP_MAX			0x1f
-#define INPUT_PROP_CNT			(INPUT_PROP_MAX + 1)
-
-/*
- * Event types
- */
-
-#define EV_SYN			0x00
-#define EV_KEY			0x01
-#define EV_REL			0x02
-#define EV_ABS			0x03
-#define EV_MSC			0x04
-#define EV_SW			0x05
-#define EV_LED			0x11
-#define EV_SND			0x12
-#define EV_REP			0x14
-#define EV_FF			0x15
-#define EV_PWR			0x16
-#define EV_FF_STATUS		0x17
-#define EV_MAX			0x1f
-#define EV_CNT			(EV_MAX+1)
-
-/*
- * Synchronization events.
- */
-
-#define SYN_REPORT		0
-#define SYN_CONFIG		1
-#define SYN_MT_REPORT		2
-#define SYN_DROPPED		3
-#define SYN_MAX			0xf
-#define SYN_CNT			(SYN_MAX+1)
-
-/*
- * Keys and buttons
- *
- * Most of the keys/buttons are modeled after USB HUT 1.12
- * (see http://www.usb.org/developers/hidpage).
- * Abbreviations in the comments:
- * AC - Application Control
- * AL - Application Launch Button
- * SC - System Control
- */
-
-#define KEY_RESERVED		0
-#define KEY_ESC			1
-#define KEY_1			2
-#define KEY_2			3
-#define KEY_3			4
-#define KEY_4			5
-#define KEY_5			6
-#define KEY_6			7
-#define KEY_7			8
-#define KEY_8			9
-#define KEY_9			10
-#define KEY_0			11
-#define KEY_MINUS		12
-#define KEY_EQUAL		13
-#define KEY_BACKSPACE		14
-#define KEY_TAB			15
-#define KEY_Q			16
-#define KEY_W			17
-#define KEY_E			18
-#define KEY_R			19
-#define KEY_T			20
-#define KEY_Y			21
-#define KEY_U			22
-#define KEY_I			23
-#define KEY_O			24
-#define KEY_P			25
-#define KEY_LEFTBRACE		26
-#define KEY_RIGHTBRACE		27
-#define KEY_ENTER		28
-#define KEY_LEFTCTRL		29
-#define KEY_A			30
-#define KEY_S			31
-#define KEY_D			32
-#define KEY_F			33
-#define KEY_G			34
-#define KEY_H			35
-#define KEY_J			36
-#define KEY_K			37
-#define KEY_L			38
-#define KEY_SEMICOLON		39
-#define KEY_APOSTROPHE		40
-#define KEY_GRAVE		41
-#define KEY_LEFTSHIFT		42
-#define KEY_BACKSLASH		43
-#define KEY_Z			44
-#define KEY_X			45
-#define KEY_C			46
-#define KEY_V			47
-#define KEY_B			48
-#define KEY_N			49
-#define KEY_M			50
-#define KEY_COMMA		51
-#define KEY_DOT			52
-#define KEY_SLASH		53
-#define KEY_RIGHTSHIFT		54
-#define KEY_KPASTERISK		55
-#define KEY_LEFTALT		56
-#define KEY_SPACE		57
-#define KEY_CAPSLOCK		58
-#define KEY_F1			59
-#define KEY_F2			60
-#define KEY_F3			61
-#define KEY_F4			62
-#define KEY_F5			63
-#define KEY_F6			64
-#define KEY_F7			65
-#define KEY_F8			66
-#define KEY_F9			67
-#define KEY_F10			68
-#define KEY_NUMLOCK		69
-#define KEY_SCROLLLOCK		70
-#define KEY_KP7			71
-#define KEY_KP8			72
-#define KEY_KP9			73
-#define KEY_KPMINUS		74
-#define KEY_KP4			75
-#define KEY_KP5			76
-#define KEY_KP6			77
-#define KEY_KPPLUS		78
-#define KEY_KP1			79
-#define KEY_KP2			80
-#define KEY_KP3			81
-#define KEY_KP0			82
-#define KEY_KPDOT		83
-
-#define KEY_ZENKAKUHANKAKU	85
-#define KEY_102ND		86
-#define KEY_F11			87
-#define KEY_F12			88
-#define KEY_RO			89
-#define KEY_KATAKANA		90
-#define KEY_HIRAGANA		91
-#define KEY_HENKAN		92
-#define KEY_KATAKANAHIRAGANA	93
-#define KEY_MUHENKAN		94
-#define KEY_KPJPCOMMA		95
-#define KEY_KPENTER		96
-#define KEY_RIGHTCTRL		97
-#define KEY_KPSLASH		98
-#define KEY_SYSRQ		99
-#define KEY_RIGHTALT		100
-#define KEY_LINEFEED		101
-#define KEY_HOME		102
-#define KEY_UP			103
-#define KEY_PAGEUP		104
-#define KEY_LEFT		105
-#define KEY_RIGHT		106
-#define KEY_END			107
-#define KEY_DOWN		108
-#define KEY_PAGEDOWN		109
-#define KEY_INSERT		110
-#define KEY_DELETE		111
-#define KEY_MACRO		112
-#define KEY_MUTE		113
-#define KEY_VOLUMEDOWN		114
-#define KEY_VOLUMEUP		115
-#define KEY_POWER		116	/* SC System Power Down */
-#define KEY_KPEQUAL		117
-#define KEY_KPPLUSMINUS		118
-#define KEY_PAUSE		119
-#define KEY_SCALE		120	/* AL Compiz Scale (Expose) */
-
-#define KEY_KPCOMMA		121
-#define KEY_HANGEUL		122
-#define KEY_HANGUEL		KEY_HANGEUL
-#define KEY_HANJA		123
-#define KEY_YEN			124
-#define KEY_LEFTMETA		125
-#define KEY_RIGHTMETA		126
-#define KEY_COMPOSE		127
-
-#define KEY_STOP		128	/* AC Stop */
-#define KEY_AGAIN		129
-#define KEY_PROPS		130	/* AC Properties */
-#define KEY_UNDO		131	/* AC Undo */
-#define KEY_FRONT		132
-#define KEY_COPY		133	/* AC Copy */
-#define KEY_OPEN		134	/* AC Open */
-#define KEY_PASTE		135	/* AC Paste */
-#define KEY_FIND		136	/* AC Search */
-#define KEY_CUT			137	/* AC Cut */
-#define KEY_HELP		138	/* AL Integrated Help Center */
-#define KEY_MENU		139	/* Menu (show menu) */
-#define KEY_CALC		140	/* AL Calculator */
-#define KEY_SETUP		141
-#define KEY_SLEEP		142	/* SC System Sleep */
-#define KEY_WAKEUP		143	/* System Wake Up */
-#define KEY_FILE		144	/* AL Local Machine Browser */
-#define KEY_SENDFILE		145
-#define KEY_DELETEFILE		146
-#define KEY_XFER		147
-#define KEY_PROG1		148
-#define KEY_PROG2		149
-#define KEY_WWW			150	/* AL Internet Browser */
-#define KEY_MSDOS		151
-#define KEY_COFFEE		152	/* AL Terminal Lock/Screensaver */
-#define KEY_SCREENLOCK		KEY_COFFEE
-#define KEY_ROTATE_DISPLAY	153	/* Display orientation for e.g. tablets */
-#define KEY_DIRECTION		KEY_ROTATE_DISPLAY
-#define KEY_CYCLEWINDOWS	154
-#define KEY_MAIL		155
-#define KEY_BOOKMARKS		156	/* AC Bookmarks */
-#define KEY_COMPUTER		157
-#define KEY_BACK		158	/* AC Back */
-#define KEY_FORWARD		159	/* AC Forward */
-#define KEY_CLOSECD		160
-#define KEY_EJECTCD		161
-#define KEY_EJECTCLOSECD	162
-#define KEY_NEXTSONG		163
-#define KEY_PLAYPAUSE		164
-#define KEY_PREVIOUSSONG	165
-#define KEY_STOPCD		166
-#define KEY_RECORD		167
-#define KEY_REWIND		168
-#define KEY_PHONE		169	/* Media Select Telephone */
-#define KEY_ISO			170
-#define KEY_CONFIG		171	/* AL Consumer Control Configuration */
-#define KEY_HOMEPAGE		172	/* AC Home */
-#define KEY_REFRESH		173	/* AC Refresh */
-#define KEY_EXIT		174	/* AC Exit */
-#define KEY_MOVE		175
-#define KEY_EDIT		176
-#define KEY_SCROLLUP		177
-#define KEY_SCROLLDOWN		178
-#define KEY_KPLEFTPAREN		179
-#define KEY_KPRIGHTPAREN	180
-#define KEY_NEW			181	/* AC New */
-#define KEY_REDO		182	/* AC Redo/Repeat */
-
-#define KEY_F13			183
-#define KEY_F14			184
-#define KEY_F15			185
-#define KEY_F16			186
-#define KEY_F17			187
-#define KEY_F18			188
-#define KEY_F19			189
-#define KEY_F20			190
-#define KEY_F21			191
-#define KEY_F22			192
-#define KEY_F23			193
-#define KEY_F24			194
-
-#define KEY_PLAYCD		200
-#define KEY_PAUSECD		201
-#define KEY_PROG3		202
-#define KEY_PROG4		203
-#define KEY_ALL_APPLICATIONS	204	/* AC Desktop Show All Applications */
-#define KEY_DASHBOARD		KEY_ALL_APPLICATIONS
-#define KEY_SUSPEND		205
-#define KEY_CLOSE		206	/* AC Close */
-#define KEY_PLAY		207
-#define KEY_FASTFORWARD		208
-#define KEY_BASSBOOST		209
-#define KEY_PRINT		210	/* AC Print */
-#define KEY_HP			211
-#define KEY_CAMERA		212
-#define KEY_SOUND		213
-#define KEY_QUESTION		214
-#define KEY_EMAIL		215
-#define KEY_CHAT		216
-#define KEY_SEARCH		217
-#define KEY_CONNECT		218
-#define KEY_FINANCE		219	/* AL Checkbook/Finance */
-#define KEY_SPORT		220
-#define KEY_SHOP		221
-#define KEY_ALTERASE		222
-#define KEY_CANCEL		223	/* AC Cancel */
-#define KEY_BRIGHTNESSDOWN	224
-#define KEY_BRIGHTNESSUP	225
-#define KEY_MEDIA		226
-
-#define KEY_SWITCHVIDEOMODE	227	/* Cycle between available video
-					   outputs (Monitor/LCD/TV-out/etc) */
-#define KEY_KBDILLUMTOGGLE	228
-#define KEY_KBDILLUMDOWN	229
-#define KEY_KBDILLUMUP		230
-
-#define KEY_SEND		231	/* AC Send */
-#define KEY_REPLY		232	/* AC Reply */
-#define KEY_FORWARDMAIL		233	/* AC Forward Msg */
-#define KEY_SAVE		234	/* AC Save */
-#define KEY_DOCUMENTS		235
-
-#define KEY_BATTERY		236
-
-#define KEY_BLUETOOTH		237
-#define KEY_WLAN		238
-#define KEY_UWB			239
-
-#define KEY_UNKNOWN		240
-
-#define KEY_VIDEO_NEXT		241	/* drive next video source */
-#define KEY_VIDEO_PREV		242	/* drive previous video source */
-#define KEY_BRIGHTNESS_CYCLE	243	/* brightness up, after max is min */
-#define KEY_BRIGHTNESS_AUTO	244	/* Set Auto Brightness: manual
-					  brightness control is off,
-					  rely on ambient */
-#define KEY_BRIGHTNESS_ZERO	KEY_BRIGHTNESS_AUTO
-#define KEY_DISPLAY_OFF		245	/* display device to off state */
-
-#define KEY_WWAN		246	/* Wireless WAN (LTE, UMTS, GSM, etc.) */
-#define KEY_WIMAX		KEY_WWAN
-#define KEY_RFKILL		247	/* Key that controls all radios */
-
-#define KEY_MICMUTE		248	/* Mute / unmute the microphone */
-
-/* Code 255 is reserved for special needs of AT keyboard driver */
-
-#define BTN_MISC		0x100
-#define BTN_0			0x100
-#define BTN_1			0x101
-#define BTN_2			0x102
-#define BTN_3			0x103
-#define BTN_4			0x104
-#define BTN_5			0x105
-#define BTN_6			0x106
-#define BTN_7			0x107
-#define BTN_8			0x108
-#define BTN_9			0x109
-
-#define BTN_MOUSE		0x110
-#define BTN_LEFT		0x110
-#define BTN_RIGHT		0x111
-#define BTN_MIDDLE		0x112
-#define BTN_SIDE		0x113
-#define BTN_EXTRA		0x114
-#define BTN_FORWARD		0x115
-#define BTN_BACK		0x116
-#define BTN_TASK		0x117
-
-#define BTN_JOYSTICK		0x120
-#define BTN_TRIGGER		0x120
-#define BTN_THUMB		0x121
-#define BTN_THUMB2		0x122
-#define BTN_TOP			0x123
-#define BTN_TOP2		0x124
-#define BTN_PINKIE		0x125
-#define BTN_BASE		0x126
-#define BTN_BASE2		0x127
-#define BTN_BASE3		0x128
-#define BTN_BASE4		0x129
-#define BTN_BASE5		0x12a
-#define BTN_BASE6		0x12b
-#define BTN_DEAD		0x12f
-
-#define BTN_GAMEPAD		0x130
-#define BTN_SOUTH		0x130
-#define BTN_A			BTN_SOUTH
-#define BTN_EAST		0x131
-#define BTN_B			BTN_EAST
-#define BTN_C			0x132
-#define BTN_NORTH		0x133
-#define BTN_X			BTN_NORTH
-#define BTN_WEST		0x134
-#define BTN_Y			BTN_WEST
-#define BTN_Z			0x135
-#define BTN_TL			0x136
-#define BTN_TR			0x137
-#define BTN_TL2			0x138
-#define BTN_TR2			0x139
-#define BTN_SELECT		0x13a
-#define BTN_START		0x13b
-#define BTN_MODE		0x13c
-#define BTN_THUMBL		0x13d
-#define BTN_THUMBR		0x13e
-
-#define BTN_DIGI		0x140
-#define BTN_TOOL_PEN		0x140
-#define BTN_TOOL_RUBBER		0x141
-#define BTN_TOOL_BRUSH		0x142
-#define BTN_TOOL_PENCIL		0x143
-#define BTN_TOOL_AIRBRUSH	0x144
-#define BTN_TOOL_FINGER		0x145
-#define BTN_TOOL_MOUSE		0x146
-#define BTN_TOOL_LENS		0x147
-#define BTN_TOOL_QUINTTAP	0x148	/* Five fingers on trackpad */
-#define BTN_STYLUS3		0x149
-#define BTN_TOUCH		0x14a
-#define BTN_STYLUS		0x14b
-#define BTN_STYLUS2		0x14c
-#define BTN_TOOL_DOUBLETAP	0x14d
-#define BTN_TOOL_TRIPLETAP	0x14e
-#define BTN_TOOL_QUADTAP	0x14f	/* Four fingers on trackpad */
-
-#define BTN_WHEEL		0x150
-#define BTN_GEAR_DOWN		0x150
-#define BTN_GEAR_UP		0x151
-
-#define KEY_OK			0x160
-#define KEY_SELECT		0x161
-#define KEY_GOTO		0x162
-#define KEY_CLEAR		0x163
-#define KEY_POWER2		0x164
-#define KEY_OPTION		0x165
-#define KEY_INFO		0x166	/* AL OEM Features/Tips/Tutorial */
-#define KEY_TIME		0x167
-#define KEY_VENDOR		0x168
-#define KEY_ARCHIVE		0x169
-#define KEY_PROGRAM		0x16a	/* Media Select Program Guide */
-#define KEY_CHANNEL		0x16b
-#define KEY_FAVORITES		0x16c
-#define KEY_EPG			0x16d
-#define KEY_PVR			0x16e	/* Media Select Home */
-#define KEY_MHP			0x16f
-#define KEY_LANGUAGE		0x170
-#define KEY_TITLE		0x171
-#define KEY_SUBTITLE		0x172
-#define KEY_ANGLE		0x173
-#define KEY_FULL_SCREEN		0x174	/* AC View Toggle */
-#define KEY_ZOOM		KEY_FULL_SCREEN
-#define KEY_MODE		0x175
-#define KEY_KEYBOARD		0x176
-#define KEY_ASPECT_RATIO	0x177	/* HUTRR37: Aspect */
-#define KEY_SCREEN		KEY_ASPECT_RATIO
-#define KEY_PC			0x178	/* Media Select Computer */
-#define KEY_TV			0x179	/* Media Select TV */
-#define KEY_TV2			0x17a	/* Media Select Cable */
-#define KEY_VCR			0x17b	/* Media Select VCR */
-#define KEY_VCR2		0x17c	/* VCR Plus */
-#define KEY_SAT			0x17d	/* Media Select Satellite */
-#define KEY_SAT2		0x17e
-#define KEY_CD			0x17f	/* Media Select CD */
-#define KEY_TAPE		0x180	/* Media Select Tape */
-#define KEY_RADIO		0x181
-#define KEY_TUNER		0x182	/* Media Select Tuner */
-#define KEY_PLAYER		0x183
-#define KEY_TEXT		0x184
-#define KEY_DVD			0x185	/* Media Select DVD */
-#define KEY_AUX			0x186
-#define KEY_MP3			0x187
-#define KEY_AUDIO		0x188	/* AL Audio Browser */
-#define KEY_VIDEO		0x189	/* AL Movie Browser */
-#define KEY_DIRECTORY		0x18a
-#define KEY_LIST		0x18b
-#define KEY_MEMO		0x18c	/* Media Select Messages */
-#define KEY_CALENDAR		0x18d
-#define KEY_RED			0x18e
-#define KEY_GREEN		0x18f
-#define KEY_YELLOW		0x190
-#define KEY_BLUE		0x191
-#define KEY_CHANNELUP		0x192	/* Channel Increment */
-#define KEY_CHANNELDOWN		0x193	/* Channel Decrement */
-#define KEY_FIRST		0x194
-#define KEY_LAST		0x195	/* Recall Last */
-#define KEY_AB			0x196
-#define KEY_NEXT		0x197
-#define KEY_RESTART		0x198
-#define KEY_SLOW		0x199
-#define KEY_SHUFFLE		0x19a
-#define KEY_BREAK		0x19b
-#define KEY_PREVIOUS		0x19c
-#define KEY_DIGITS		0x19d
-#define KEY_TEEN		0x19e
-#define KEY_TWEN		0x19f
-#define KEY_VIDEOPHONE		0x1a0	/* Media Select Video Phone */
-#define KEY_GAMES		0x1a1	/* Media Select Games */
-#define KEY_ZOOMIN		0x1a2	/* AC Zoom In */
-#define KEY_ZOOMOUT		0x1a3	/* AC Zoom Out */
-#define KEY_ZOOMRESET		0x1a4	/* AC Zoom */
-#define KEY_WORDPROCESSOR	0x1a5	/* AL Word Processor */
-#define KEY_EDITOR		0x1a6	/* AL Text Editor */
-#define KEY_SPREADSHEET		0x1a7	/* AL Spreadsheet */
-#define KEY_GRAPHICSEDITOR	0x1a8	/* AL Graphics Editor */
-#define KEY_PRESENTATION	0x1a9	/* AL Presentation App */
-#define KEY_DATABASE		0x1aa	/* AL Database App */
-#define KEY_NEWS		0x1ab	/* AL Newsreader */
-#define KEY_VOICEMAIL		0x1ac	/* AL Voicemail */
-#define KEY_ADDRESSBOOK		0x1ad	/* AL Contacts/Address Book */
-#define KEY_MESSENGER		0x1ae	/* AL Instant Messaging */
-#define KEY_DISPLAYTOGGLE	0x1af	/* Turn display (LCD) on and off */
-#define KEY_BRIGHTNESS_TOGGLE	KEY_DISPLAYTOGGLE
-#define KEY_SPELLCHECK		0x1b0   /* AL Spell Check */
-#define KEY_LOGOFF		0x1b1   /* AL Logoff */
-
-#define KEY_DOLLAR		0x1b2
-#define KEY_EURO		0x1b3
-
-#define KEY_FRAMEBACK		0x1b4	/* Consumer - transport controls */
-#define KEY_FRAMEFORWARD	0x1b5
-#define KEY_CONTEXT_MENU	0x1b6	/* GenDesc - system context menu */
-#define KEY_MEDIA_REPEAT	0x1b7	/* Consumer - transport control */
-#define KEY_10CHANNELSUP	0x1b8	/* 10 channels up (10+) */
-#define KEY_10CHANNELSDOWN	0x1b9	/* 10 channels down (10-) */
-#define KEY_IMAGES		0x1ba	/* AL Image Browser */
-#define KEY_NOTIFICATION_CENTER	0x1bc	/* Show/hide the notification center */
-#define KEY_PICKUP_PHONE	0x1bd	/* Answer incoming call */
-#define KEY_HANGUP_PHONE	0x1be	/* Decline incoming call */
-#define KEY_LINK_PHONE		0x1bf   /* AL Phone Syncing */
-
-#define KEY_DEL_EOL		0x1c0
-#define KEY_DEL_EOS		0x1c1
-#define KEY_INS_LINE		0x1c2
-#define KEY_DEL_LINE		0x1c3
-
-#define KEY_FN			0x1d0
-#define KEY_FN_ESC		0x1d1
-#define KEY_FN_F1		0x1d2
-#define KEY_FN_F2		0x1d3
-#define KEY_FN_F3		0x1d4
-#define KEY_FN_F4		0x1d5
-#define KEY_FN_F5		0x1d6
-#define KEY_FN_F6		0x1d7
-#define KEY_FN_F7		0x1d8
-#define KEY_FN_F8		0x1d9
-#define KEY_FN_F9		0x1da
-#define KEY_FN_F10		0x1db
-#define KEY_FN_F11		0x1dc
-#define KEY_FN_F12		0x1dd
-#define KEY_FN_1		0x1de
-#define KEY_FN_2		0x1df
-#define KEY_FN_D		0x1e0
-#define KEY_FN_E		0x1e1
-#define KEY_FN_F		0x1e2
-#define KEY_FN_S		0x1e3
-#define KEY_FN_B		0x1e4
-#define KEY_FN_RIGHT_SHIFT	0x1e5
-
-#define KEY_BRL_DOT1		0x1f1
-#define KEY_BRL_DOT2		0x1f2
-#define KEY_BRL_DOT3		0x1f3
-#define KEY_BRL_DOT4		0x1f4
-#define KEY_BRL_DOT5		0x1f5
-#define KEY_BRL_DOT6		0x1f6
-#define KEY_BRL_DOT7		0x1f7
-#define KEY_BRL_DOT8		0x1f8
-#define KEY_BRL_DOT9		0x1f9
-#define KEY_BRL_DOT10		0x1fa
-
-#define KEY_NUMERIC_0		0x200	/* used by phones, remote controls, */
-#define KEY_NUMERIC_1		0x201	/* and other keypads */
-#define KEY_NUMERIC_2		0x202
-#define KEY_NUMERIC_3		0x203
-#define KEY_NUMERIC_4		0x204
-#define KEY_NUMERIC_5		0x205
-#define KEY_NUMERIC_6		0x206
-#define KEY_NUMERIC_7		0x207
-#define KEY_NUMERIC_8		0x208
-#define KEY_NUMERIC_9		0x209
-#define KEY_NUMERIC_STAR	0x20a
-#define KEY_NUMERIC_POUND	0x20b
-#define KEY_NUMERIC_A		0x20c	/* Phone key A - HUT Telephony 0xb9 */
-#define KEY_NUMERIC_B		0x20d
-#define KEY_NUMERIC_C		0x20e
-#define KEY_NUMERIC_D		0x20f
-
-#define KEY_CAMERA_FOCUS	0x210
-#define KEY_WPS_BUTTON		0x211	/* WiFi Protected Setup key */
-
-#define KEY_TOUCHPAD_TOGGLE	0x212	/* Request switch touchpad on or off */
-#define KEY_TOUCHPAD_ON		0x213
-#define KEY_TOUCHPAD_OFF	0x214
-
-#define KEY_CAMERA_ZOOMIN	0x215
-#define KEY_CAMERA_ZOOMOUT	0x216
-#define KEY_CAMERA_UP		0x217
-#define KEY_CAMERA_DOWN		0x218
-#define KEY_CAMERA_LEFT		0x219
-#define KEY_CAMERA_RIGHT	0x21a
-
-#define KEY_ATTENDANT_ON	0x21b
-#define KEY_ATTENDANT_OFF	0x21c
-#define KEY_ATTENDANT_TOGGLE	0x21d	/* Attendant call on or off */
-#define KEY_LIGHTS_TOGGLE	0x21e	/* Reading light on or off */
-
-#define BTN_DPAD_UP		0x220
-#define BTN_DPAD_DOWN		0x221
-#define BTN_DPAD_LEFT		0x222
-#define BTN_DPAD_RIGHT		0x223
-
-#define KEY_ALS_TOGGLE		0x230	/* Ambient light sensor */
-#define KEY_ROTATE_LOCK_TOGGLE	0x231	/* Display rotation lock */
-#define KEY_REFRESH_RATE_TOGGLE	0x232	/* Display refresh rate toggle */
-
-#define KEY_BUTTONCONFIG		0x240	/* AL Button Configuration */
-#define KEY_TASKMANAGER		0x241	/* AL Task/Project Manager */
-#define KEY_JOURNAL		0x242	/* AL Log/Journal/Timecard */
-#define KEY_CONTROLPANEL		0x243	/* AL Control Panel */
-#define KEY_APPSELECT		0x244	/* AL Select Task/Application */
-#define KEY_SCREENSAVER		0x245	/* AL Screen Saver */
-#define KEY_VOICECOMMAND		0x246	/* Listening Voice Command */
-#define KEY_ASSISTANT		0x247	/* AL Context-aware desktop assistant */
-#define KEY_KBD_LAYOUT_NEXT	0x248	/* AC Next Keyboard Layout Select */
-#define KEY_EMOJI_PICKER	0x249	/* Show/hide emoji picker (HUTRR101) */
-#define KEY_DICTATE		0x24a	/* Start or Stop Voice Dictation Session (HUTRR99) */
-#define KEY_CAMERA_ACCESS_ENABLE	0x24b	/* Enables programmatic access to camera devices. (HUTRR72) */
-#define KEY_CAMERA_ACCESS_DISABLE	0x24c	/* Disables programmatic access to camera devices. (HUTRR72) */
-#define KEY_CAMERA_ACCESS_TOGGLE	0x24d	/* Toggles the current state of the camera access control. (HUTRR72) */
-#define KEY_ACCESSIBILITY		0x24e	/* Toggles the system bound accessibility UI/command (HUTRR116) */
-#define KEY_DO_NOT_DISTURB		0x24f	/* Toggles the system-wide "Do Not Disturb" control (HUTRR94)*/
-
-#define KEY_BRIGHTNESS_MIN		0x250	/* Set Brightness to Minimum */
-#define KEY_BRIGHTNESS_MAX		0x251	/* Set Brightness to Maximum */
-
-#define KEY_KBDINPUTASSIST_PREV		0x260
-#define KEY_KBDINPUTASSIST_NEXT		0x261
-#define KEY_KBDINPUTASSIST_PREVGROUP		0x262
-#define KEY_KBDINPUTASSIST_NEXTGROUP		0x263
-#define KEY_KBDINPUTASSIST_ACCEPT		0x264
-#define KEY_KBDINPUTASSIST_CANCEL		0x265
-
-/* Diagonal movement keys */
-#define KEY_RIGHT_UP			0x266
-#define KEY_RIGHT_DOWN			0x267
-#define KEY_LEFT_UP			0x268
-#define KEY_LEFT_DOWN			0x269
-
-#define KEY_ROOT_MENU			0x26a /* Show Device's Root Menu */
-/* Show Top Menu of the Media (e.g. DVD) */
-#define KEY_MEDIA_TOP_MENU		0x26b
-#define KEY_NUMERIC_11			0x26c
-#define KEY_NUMERIC_12			0x26d
-/*
- * Toggle Audio Description: refers to an audio service that helps blind and
- * visually impaired consumers understand the action in a program. Note: in
- * some countries this is referred to as "Video Description".
- */
-#define KEY_AUDIO_DESC			0x26e
-#define KEY_3D_MODE			0x26f
-#define KEY_NEXT_FAVORITE		0x270
-#define KEY_STOP_RECORD			0x271
-#define KEY_PAUSE_RECORD		0x272
-#define KEY_VOD				0x273 /* Video on Demand */
-#define KEY_UNMUTE			0x274
-#define KEY_FASTREVERSE			0x275
-#define KEY_SLOWREVERSE			0x276
-/*
- * Control a data application associated with the currently viewed channel,
- * e.g. teletext or data broadcast application (MHEG, MHP, HbbTV, etc.)
- */
-#define KEY_DATA			0x277
-#define KEY_ONSCREEN_KEYBOARD		0x278
-/* Electronic privacy screen control */
-#define KEY_PRIVACY_SCREEN_TOGGLE	0x279
-
-/* Select an area of screen to be copied */
-#define KEY_SELECTIVE_SCREENSHOT	0x27a
-
-/* Move the focus to the next or previous user controllable element within a UI container */
-#define KEY_NEXT_ELEMENT               0x27b
-#define KEY_PREVIOUS_ELEMENT           0x27c
-
-/* Toggle Autopilot engagement */
-#define KEY_AUTOPILOT_ENGAGE_TOGGLE    0x27d
-
-/* Shortcut Keys */
-#define KEY_MARK_WAYPOINT              0x27e
-#define KEY_SOS                                0x27f
-#define KEY_NAV_CHART                  0x280
-#define KEY_FISHING_CHART              0x281
-#define KEY_SINGLE_RANGE_RADAR         0x282
-#define KEY_DUAL_RANGE_RADAR           0x283
-#define KEY_RADAR_OVERLAY              0x284
-#define KEY_TRADITIONAL_SONAR          0x285
-#define KEY_CLEARVU_SONAR              0x286
-#define KEY_SIDEVU_SONAR               0x287
-#define KEY_NAV_INFO                   0x288
-#define KEY_BRIGHTNESS_MENU            0x289
-
-/*
- * Some keyboards have keys which do not have a defined meaning, these keys
- * are intended to be programmed / bound to macros by the user. For most
- * keyboards with these macro-keys the key-sequence to inject, or action to
- * take, is all handled by software on the host side. So from the kernel's
- * point of view these are just normal keys.
- *
- * The KEY_MACRO# codes below are intended for such keys, which may be labeled
- * e.g. G1-G18, or S1 - S30. The KEY_MACRO# codes MUST NOT be used for keys
- * where the marking on the key does indicate a defined meaning / purpose.
- *
- * The KEY_MACRO# codes MUST also NOT be used as fallback for when no existing
- * KEY_FOO define matches the marking / purpose. In this case a new KEY_FOO
- * define MUST be added.
- */
-#define KEY_MACRO1			0x290
-#define KEY_MACRO2			0x291
-#define KEY_MACRO3			0x292
-#define KEY_MACRO4			0x293
-#define KEY_MACRO5			0x294
-#define KEY_MACRO6			0x295
-#define KEY_MACRO7			0x296
-#define KEY_MACRO8			0x297
-#define KEY_MACRO9			0x298
-#define KEY_MACRO10			0x299
-#define KEY_MACRO11			0x29a
-#define KEY_MACRO12			0x29b
-#define KEY_MACRO13			0x29c
-#define KEY_MACRO14			0x29d
-#define KEY_MACRO15			0x29e
-#define KEY_MACRO16			0x29f
-#define KEY_MACRO17			0x2a0
-#define KEY_MACRO18			0x2a1
-#define KEY_MACRO19			0x2a2
-#define KEY_MACRO20			0x2a3
-#define KEY_MACRO21			0x2a4
-#define KEY_MACRO22			0x2a5
-#define KEY_MACRO23			0x2a6
-#define KEY_MACRO24			0x2a7
-#define KEY_MACRO25			0x2a8
-#define KEY_MACRO26			0x2a9
-#define KEY_MACRO27			0x2aa
-#define KEY_MACRO28			0x2ab
-#define KEY_MACRO29			0x2ac
-#define KEY_MACRO30			0x2ad
-
-/*
- * Some keyboards with the macro-keys described above have some extra keys
- * for controlling the host-side software responsible for the macro handling:
- * -A macro recording start/stop key. Note that not all keyboards which emit
- *  KEY_MACRO_RECORD_START will also emit KEY_MACRO_RECORD_STOP if
- *  KEY_MACRO_RECORD_STOP is not advertised, then KEY_MACRO_RECORD_START
- *  should be interpreted as a recording start/stop toggle;
- * -Keys for switching between different macro (pre)sets, either a key for
- *  cycling through the configured presets or keys to directly select a preset.
- */
-#define KEY_MACRO_RECORD_START		0x2b0
-#define KEY_MACRO_RECORD_STOP		0x2b1
-#define KEY_MACRO_PRESET_CYCLE		0x2b2
-#define KEY_MACRO_PRESET1		0x2b3
-#define KEY_MACRO_PRESET2		0x2b4
-#define KEY_MACRO_PRESET3		0x2b5
-
-/*
- * Some keyboards have a buildin LCD panel where the contents are controlled
- * by the host. Often these have a number of keys directly below the LCD
- * intended for controlling a menu shown on the LCD. These keys often don't
- * have any labeling so we just name them KEY_KBD_LCD_MENU#
- */
-#define KEY_KBD_LCD_MENU1		0x2b8
-#define KEY_KBD_LCD_MENU2		0x2b9
-#define KEY_KBD_LCD_MENU3		0x2ba
-#define KEY_KBD_LCD_MENU4		0x2bb
-#define KEY_KBD_LCD_MENU5		0x2bc
-
-#define BTN_TRIGGER_HAPPY		0x2c0
-#define BTN_TRIGGER_HAPPY1		0x2c0
-#define BTN_TRIGGER_HAPPY2		0x2c1
-#define BTN_TRIGGER_HAPPY3		0x2c2
-#define BTN_TRIGGER_HAPPY4		0x2c3
-#define BTN_TRIGGER_HAPPY5		0x2c4
-#define BTN_TRIGGER_HAPPY6		0x2c5
-#define BTN_TRIGGER_HAPPY7		0x2c6
-#define BTN_TRIGGER_HAPPY8		0x2c7
-#define BTN_TRIGGER_HAPPY9		0x2c8
-#define BTN_TRIGGER_HAPPY10		0x2c9
-#define BTN_TRIGGER_HAPPY11		0x2ca
-#define BTN_TRIGGER_HAPPY12		0x2cb
-#define BTN_TRIGGER_HAPPY13		0x2cc
-#define BTN_TRIGGER_HAPPY14		0x2cd
-#define BTN_TRIGGER_HAPPY15		0x2ce
-#define BTN_TRIGGER_HAPPY16		0x2cf
-#define BTN_TRIGGER_HAPPY17		0x2d0
-#define BTN_TRIGGER_HAPPY18		0x2d1
-#define BTN_TRIGGER_HAPPY19		0x2d2
-#define BTN_TRIGGER_HAPPY20		0x2d3
-#define BTN_TRIGGER_HAPPY21		0x2d4
-#define BTN_TRIGGER_HAPPY22		0x2d5
-#define BTN_TRIGGER_HAPPY23		0x2d6
-#define BTN_TRIGGER_HAPPY24		0x2d7
-#define BTN_TRIGGER_HAPPY25		0x2d8
-#define BTN_TRIGGER_HAPPY26		0x2d9
-#define BTN_TRIGGER_HAPPY27		0x2da
-#define BTN_TRIGGER_HAPPY28		0x2db
-#define BTN_TRIGGER_HAPPY29		0x2dc
-#define BTN_TRIGGER_HAPPY30		0x2dd
-#define BTN_TRIGGER_HAPPY31		0x2de
-#define BTN_TRIGGER_HAPPY32		0x2df
-#define BTN_TRIGGER_HAPPY33		0x2e0
-#define BTN_TRIGGER_HAPPY34		0x2e1
-#define BTN_TRIGGER_HAPPY35		0x2e2
-#define BTN_TRIGGER_HAPPY36		0x2e3
-#define BTN_TRIGGER_HAPPY37		0x2e4
-#define BTN_TRIGGER_HAPPY38		0x2e5
-#define BTN_TRIGGER_HAPPY39		0x2e6
-#define BTN_TRIGGER_HAPPY40		0x2e7
-
-/* We avoid low common keys in module aliases so they don't get huge. */
-#define KEY_MIN_INTERESTING	KEY_MUTE
-#define KEY_MAX			0x2ff
-#define KEY_CNT			(KEY_MAX+1)
-
-/*
- * Relative axes
- */
-
-#define REL_X			0x00
-#define REL_Y			0x01
-#define REL_Z			0x02
-#define REL_RX			0x03
-#define REL_RY			0x04
-#define REL_RZ			0x05
-#define REL_HWHEEL		0x06
-#define REL_DIAL		0x07
-#define REL_WHEEL		0x08
-#define REL_MISC		0x09
-/*
- * 0x0a is reserved and should not be used in input drivers.
- * It was used by HID as REL_MISC+1 and userspace needs to detect if
- * the next REL_* event is correct or is just REL_MISC + n.
- * We define here REL_RESERVED so userspace can rely on it and detect
- * the situation described above.
- */
-#define REL_RESERVED		0x0a
-#define REL_WHEEL_HI_RES	0x0b
-#define REL_HWHEEL_HI_RES	0x0c
-#define REL_MAX			0x0f
-#define REL_CNT			(REL_MAX+1)
-
-/*
- * Absolute axes
- */
-
-#define ABS_X			0x00
-#define ABS_Y			0x01
-#define ABS_Z			0x02
-#define ABS_RX			0x03
-#define ABS_RY			0x04
-#define ABS_RZ			0x05
-#define ABS_THROTTLE		0x06
-#define ABS_RUDDER		0x07
-#define ABS_WHEEL		0x08
-#define ABS_GAS			0x09
-#define ABS_BRAKE		0x0a
-#define ABS_HAT0X		0x10
-#define ABS_HAT0Y		0x11
-#define ABS_HAT1X		0x12
-#define ABS_HAT1Y		0x13
-#define ABS_HAT2X		0x14
-#define ABS_HAT2Y		0x15
-#define ABS_HAT3X		0x16
-#define ABS_HAT3Y		0x17
-#define ABS_PRESSURE		0x18
-#define ABS_DISTANCE		0x19
-#define ABS_TILT_X		0x1a
-#define ABS_TILT_Y		0x1b
-#define ABS_TOOL_WIDTH		0x1c
-
-#define ABS_VOLUME		0x20
-#define ABS_PROFILE		0x21
-
-#define ABS_MISC		0x28
-
-/*
- * 0x2e is reserved and should not be used in input drivers.
- * It was used by HID as ABS_MISC+6 and userspace needs to detect if
- * the next ABS_* event is correct or is just ABS_MISC + n.
- * We define here ABS_RESERVED so userspace can rely on it and detect
- * the situation described above.
- */
-#define ABS_RESERVED		0x2e
-
-#define ABS_MT_SLOT		0x2f	/* MT slot being modified */
-#define ABS_MT_TOUCH_MAJOR	0x30	/* Major axis of touching ellipse */
-#define ABS_MT_TOUCH_MINOR	0x31	/* Minor axis (omit if circular) */
-#define ABS_MT_WIDTH_MAJOR	0x32	/* Major axis of approaching ellipse */
-#define ABS_MT_WIDTH_MINOR	0x33	/* Minor axis (omit if circular) */
-#define ABS_MT_ORIENTATION	0x34	/* Ellipse orientation */
-#define ABS_MT_POSITION_X	0x35	/* Center X touch position */
-#define ABS_MT_POSITION_Y	0x36	/* Center Y touch position */
-#define ABS_MT_TOOL_TYPE	0x37	/* Type of touching device */
-#define ABS_MT_BLOB_ID		0x38	/* Group a set of packets as a blob */
-#define ABS_MT_TRACKING_ID	0x39	/* Unique ID of initiated contact */
-#define ABS_MT_PRESSURE		0x3a	/* Pressure on contact area */
-#define ABS_MT_DISTANCE		0x3b	/* Contact hover distance */
-#define ABS_MT_TOOL_X		0x3c	/* Center X tool position */
-#define ABS_MT_TOOL_Y		0x3d	/* Center Y tool position */
-
-
-#define ABS_MAX			0x3f
-#define ABS_CNT			(ABS_MAX+1)
-
-/*
- * Switch events
- */
-
-#define SW_LID			0x00  /* set = lid shut */
-#define SW_TABLET_MODE		0x01  /* set = tablet mode */
-#define SW_HEADPHONE_INSERT	0x02  /* set = inserted */
-#define SW_RFKILL_ALL		0x03  /* rfkill master switch, type "any"
-					 set = radio enabled */
-#define SW_RADIO		SW_RFKILL_ALL	/* deprecated */
-#define SW_MICROPHONE_INSERT	0x04  /* set = inserted */
-#define SW_DOCK			0x05  /* set = plugged into dock */
-#define SW_LINEOUT_INSERT	0x06  /* set = inserted */
-#define SW_JACK_PHYSICAL_INSERT 0x07  /* set = mechanical switch set */
-#define SW_VIDEOOUT_INSERT	0x08  /* set = inserted */
-#define SW_CAMERA_LENS_COVER	0x09  /* set = lens covered */
-#define SW_KEYPAD_SLIDE		0x0a  /* set = keypad slide out */
-#define SW_FRONT_PROXIMITY	0x0b  /* set = front proximity sensor active */
-#define SW_ROTATE_LOCK		0x0c  /* set = rotate locked/disabled */
-#define SW_LINEIN_INSERT	0x0d  /* set = inserted */
-#define SW_MUTE_DEVICE		0x0e  /* set = device disabled */
-#define SW_PEN_INSERTED		0x0f  /* set = pen inserted */
-#define SW_MACHINE_COVER	0x10  /* set = cover closed */
-#define SW_USB_INSERT		0x11  /* set = USB audio device connected */
-#define SW_MAX			0x11
-#define SW_CNT			(SW_MAX+1)
-
-/*
- * Misc events
- */
-
-#define MSC_SERIAL		0x00
-#define MSC_PULSELED		0x01
-#define MSC_GESTURE		0x02
-#define MSC_RAW			0x03
-#define MSC_SCAN		0x04
-#define MSC_TIMESTAMP		0x05
-#define MSC_MAX			0x07
-#define MSC_CNT			(MSC_MAX+1)
-
-/*
- * LEDs
- */
-
-#define LED_NUML		0x00
-#define LED_CAPSL		0x01
-#define LED_SCROLLL		0x02
-#define LED_COMPOSE		0x03
-#define LED_KANA		0x04
-#define LED_SLEEP		0x05
-#define LED_SUSPEND		0x06
-#define LED_MUTE		0x07
-#define LED_MISC		0x08
-#define LED_MAIL		0x09
-#define LED_CHARGING		0x0a
-#define LED_MAX			0x0f
-#define LED_CNT			(LED_MAX+1)
-
-/*
- * Autorepeat values
- */
-
-#define REP_DELAY		0x00
-#define REP_PERIOD		0x01
-#define REP_MAX			0x01
-#define REP_CNT			(REP_MAX+1)
-
-/*
- * Sounds
- */
-
-#define SND_CLICK		0x00
-#define SND_BELL		0x01
-#define SND_TONE		0x02
-#define SND_MAX			0x07
-#define SND_CNT			(SND_MAX+1)
-
-#endif
+../../uapi/linux/input-event-codes.h
\ No newline at end of file
diff -Nrup linux-6.16.7/include/linux/cpu.h linux-lenovo-x13s-linux-6.16.y/include/linux/cpu.h
--- linux-6.16.7/include/linux/cpu.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/include/linux/cpu.h	2025-09-11 09:47:42.000000000 -0600
@@ -83,7 +83,6 @@ extern ssize_t cpu_show_old_microcode(st
 extern ssize_t cpu_show_indirect_target_selection(struct device *dev,
 						  struct device_attribute *attr, char *buf);
 extern ssize_t cpu_show_tsa(struct device *dev, struct device_attribute *attr, char *buf);
-extern ssize_t cpu_show_vmscape(struct device *dev, struct device_attribute *attr, char *buf);
 
 extern __printf(4, 5)
 struct device *cpu_device_create(struct device *parent, void *drvdata,
diff -Nrup linux-6.16.7/include/linux/leds.h linux-lenovo-x13s-linux-6.16.y/include/linux/leds.h
--- linux-6.16.7/include/linux/leds.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/include/linux/leds.h	2025-09-11 09:47:42.000000000 -0600
@@ -294,7 +294,6 @@ void led_remove_lookup(struct led_lookup
 struct led_classdev *__must_check led_get(struct device *dev, char *con_id);
 struct led_classdev *__must_check devm_led_get(struct device *dev, char *con_id);
 
-extern struct led_classdev *of_led_get(struct device_node *np, int index);
 extern void led_put(struct led_classdev *led_cdev);
 struct led_classdev *__must_check devm_of_led_get(struct device *dev,
 						  int index);
diff -Nrup linux-6.16.7/include/linux/sched/bore.h linux-lenovo-x13s-linux-6.16.y/include/linux/sched/bore.h
--- linux-6.16.7/include/linux/sched/bore.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-lenovo-x13s-linux-6.16.y/include/linux/sched/bore.h	2025-09-11 09:47:42.000000000 -0600
@@ -0,0 +1,39 @@
+#ifndef _KERNEL_SCHED_BORE_H
+#define _KERNEL_SCHED_BORE_H
+
+#include <linux/sched.h>
+#include <linux/sched/cputime.h>
+#include <linux/atomic.h>
+#include <linux/list.h>
+#include <linux/rcupdate.h>
+
+#define SCHED_BORE_AUTHOR   "Masahito Suzuki"
+#define SCHED_BORE_PROGNAME "BORE CPU Scheduler modification"
+
+#define SCHED_BORE_VERSION  "6.5.2"
+
+extern u8   __read_mostly sched_bore;
+extern u8   __read_mostly sched_burst_inherit_type;
+extern u8   __read_mostly sched_burst_smoothness;
+extern u8   __read_mostly sched_burst_penalty_offset;
+extern uint __read_mostly sched_burst_penalty_scale;
+extern uint __read_mostly sched_burst_cache_lifetime;
+
+extern u8   effective_prio_bore(struct task_struct *p);
+extern void update_curr_bore(struct task_struct *p, u64 delta_exec);
+extern void restart_burst_bore(struct task_struct *p);
+extern void restart_burst_rescale_deadline_bore(struct task_struct *p);
+extern void task_fork_bore(struct task_struct *p, struct task_struct *parent,
+													u64 clone_flags, u64 now);
+extern void sched_init_bore(void);
+extern void reset_task_bore(struct task_struct *p);
+
+extern int  sched_bore_update_handler(const struct ctl_table *table,
+	int write, void __user *buffer, size_t *lenp, loff_t *ppos);
+extern int  sched_burst_inherit_type_update_handler(const struct ctl_table *table,
+	int write, void __user *buffer, size_t *lenp, loff_t *ppos);
+
+extern void reweight_entity(
+	struct cfs_rq *cfs_rq, struct sched_entity *se, unsigned long weight);
+
+#endif /* _KERNEL_SCHED_BORE_H */
diff -Nrup linux-6.16.7/include/linux/sched.h linux-lenovo-x13s-linux-6.16.y/include/linux/sched.h
--- linux-6.16.7/include/linux/sched.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/include/linux/sched.h	2025-09-11 09:47:42.000000000 -0600
@@ -809,6 +809,32 @@ struct kmap_ctrl {
 #endif
 };
 
+#ifdef CONFIG_SCHED_BORE
+#define BORE_BC_TIMESTAMP_SHIFT 16
+
+struct bore_bc {
+	u64				timestamp:	48;
+	u64				penalty:	16;
+};
+
+struct bore_ctx {
+	struct bore_bc	subtree;
+	struct bore_bc	group;
+	u64				burst_time;
+	u16				prev_penalty;
+	u16				curr_penalty;
+	union {
+		u16			penalty;
+		struct {
+			u8		_;
+			u8		score;
+		};
+	};
+	bool			stop_update;
+	bool			futex_waiting;
+};
+#endif /* CONFIG_SCHED_BORE */
+
 struct task_struct {
 #ifdef CONFIG_THREAD_INFO_IN_TASK
 	/*
@@ -869,6 +895,9 @@ struct task_struct {
 #ifdef CONFIG_SCHED_CLASS_EXT
 	struct sched_ext_entity		scx;
 #endif
+#ifdef CONFIG_SCHED_BORE
+	struct bore_ctx			bore;
+#endif /* CONFIG_SCHED_BORE */
 	const struct sched_class	*sched_class;
 
 #ifdef CONFIG_SCHED_CORE
diff -Nrup linux-6.16.7/include/linux/soundwire/sdw.h linux-lenovo-x13s-linux-6.16.y/include/linux/soundwire/sdw.h
--- linux-6.16.7/include/linux/soundwire/sdw.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/include/linux/soundwire/sdw.h	2025-09-11 09:47:42.000000000 -0600
@@ -19,6 +19,7 @@
 
 struct dentry;
 struct fwnode_handle;
+struct device_node;
 
 struct sdw_bus;
 struct sdw_slave;
@@ -1086,6 +1087,10 @@ int sdw_stream_add_slave(struct sdw_slav
 int sdw_stream_remove_slave(struct sdw_slave *slave,
 			    struct sdw_stream_runtime *stream);
 
+struct device *of_sdw_find_device_by_node(struct device_node *np);
+
+int sdw_slave_get_current_bank(struct sdw_slave *sdev);
+
 int sdw_slave_get_scale_index(struct sdw_slave *slave, u8 *base);
 
 /* messaging and data APIs */
@@ -1117,6 +1122,18 @@ static inline int sdw_stream_remove_slav
 {
 	WARN_ONCE(1, "SoundWire API is disabled");
 	return -EINVAL;
+}
+
+static inline struct device *of_sdw_find_device_by_node(struct device_node *np)
+{
+	WARN_ONCE(1, "SoundWire API is disabled");
+	return NULL;
+}
+
+static inline int sdw_slave_get_current_bank(struct sdw_slave *sdev)
+{
+	WARN_ONCE(1, "SoundWire API is disabled");
+	return -EINVAL;
 }
 
 /* messaging and data APIs */
diff -Nrup linux-6.16.7/include/uapi/sound/snd_ar_tokens.h linux-lenovo-x13s-linux-6.16.y/include/uapi/sound/snd_ar_tokens.h
--- linux-6.16.7/include/uapi/sound/snd_ar_tokens.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/include/uapi/sound/snd_ar_tokens.h	2025-09-11 09:47:42.000000000 -0600
@@ -118,6 +118,12 @@ enum ar_event_types {
  *						LPAIF_WSA = 2,
  *						LPAIF_VA = 3,
  *						LPAIF_AXI = 4
+ * Possible values for MI2S
+ *						I2S_INTF_TYPE_PRIMARY = 0,
+ *						I2S_INTF_TYPE_SECONDARY = 1,
+ *						I2S_INTF_TYPE_TERTIARY = 2,
+ *						I2S_INTF_TYPE_QUATERNARY = 3,
+ *						I2S_INTF_TYPE_QUINARY = 4,
  *
  * %AR_TKN_U32_MODULE_FMT_INTERLEAVE:		PCM Interleaving
  *						PCM_INTERLEAVED = 1,
@@ -184,8 +190,8 @@ enum ar_event_types {
 #define AR_TKN_U32_MODULE_INSTANCE_ID		201
 #define AR_TKN_U32_MODULE_MAX_IP_PORTS		202
 #define AR_TKN_U32_MODULE_MAX_OP_PORTS		203
-#define AR_TKN_U32_MODULE_IN_PORTS		204
-#define AR_TKN_U32_MODULE_OUT_PORTS		205
+#define AR_TKN_U32_MODULE_IN_PORTS		204 /* deprecated */
+#define AR_TKN_U32_MODULE_OUT_PORTS		205 /* deprecated */
 #define AR_TKN_U32_MODULE_SRC_OP_PORT_ID	206
 #define AR_TKN_U32_MODULE_DST_IN_PORT_ID	207
 #define AR_TKN_U32_MODULE_SRC_INSTANCE_ID	208
@@ -232,4 +238,12 @@ enum ar_event_types {
 #define AR_TKN_U32_MODULE_LOG_TAP_POINT_ID	260
 #define AR_TKN_U32_MODULE_LOG_MODE		261
 
+#define SND_SOC_AR_TPLG_MODULE_CFG_TYPE 0x01001006
+struct audioreach_module_priv_data {
+	__le32 size;	/* size in bytes of the array, including all elements */
+	__le32 type;	/* SND_SOC_AR_TPLG_MODULE_CFG_TYPE */
+	__le32 priv[2];	/* Private data for future expansion */
+	__le32 data[0];	/* config data */
+};
+
 #endif /* __SND_AR_TOKENS_H__ */
diff -Nrup linux-6.16.7/init/Kconfig linux-lenovo-x13s-linux-6.16.y/init/Kconfig
--- linux-6.16.7/init/Kconfig	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/init/Kconfig	2025-09-11 09:47:42.000000000 -0600
@@ -1381,6 +1381,23 @@ config CHECKPOINT_RESTORE
 
 	  If unsure, say N here.
 
+config SCHED_BORE
+	bool "Burst-Oriented Response Enhancer"
+	default y
+	help
+	  In Desktop and Mobile computing, one might prefer interactive
+	  tasks to keep responsive no matter what they run in the background.
+
+	  Enabling this kernel feature modifies the scheduler to discriminate
+	  tasks by their burst time (runtime since it last went sleeping or
+	  yielding state) and prioritize those that run less bursty.
+	  Such tasks usually include window compositor, widgets backend,
+	  terminal emulator, video playback, games and so on.
+	  With a little impact to scheduling fairness, it may improve
+	  responsiveness especially under heavy background workload.
+
+	  If unsure, say Y here.
+
 config SCHED_AUTOGROUP
 	bool "Automatic process group scheduling"
 	select CGROUPS
diff -Nrup linux-6.16.7/Kconfig linux-lenovo-x13s-linux-6.16.y/Kconfig
--- linux-6.16.7/Kconfig	2025-09-13 16:15:46.056700351 -0600
+++ linux-lenovo-x13s-linux-6.16.y/Kconfig	2025-09-11 09:47:42.000000000 -0600
@@ -32,5 +32,3 @@ source "lib/Kconfig.debug"
 source "Documentation/Kconfig"
 
 source "io_uring/Kconfig"
-
-source "distro/Kconfig"
diff -Nrup linux-6.16.7/kernel/fork.c linux-lenovo-x13s-linux-6.16.y/kernel/fork.c
--- linux-6.16.7/kernel/fork.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/kernel/fork.c	2025-09-11 09:47:42.000000000 -0600
@@ -115,6 +115,10 @@
 /* For dup_mmap(). */
 #include "../mm/internal.h"
 
+#ifdef CONFIG_SCHED_BORE
+#include <linux/sched/bore.h>
+#endif /* CONFIG_SCHED_BORE */
+
 #include <trace/events/sched.h>
 
 #define CREATE_TRACE_POINTS
@@ -2313,6 +2317,10 @@ __latent_entropy struct task_struct *cop
 	 * Need tasklist lock for parent etc handling!
 	 */
 	write_lock_irq(&tasklist_lock);
+#ifdef CONFIG_SCHED_BORE
+	if (likely(p->pid))
+		task_fork_bore(p, current, clone_flags, p->start_time);
+#endif /* CONFIG_SCHED_BORE */
 
 	/* CLONE_PARENT re-uses the old parent */
 	if (clone_flags & (CLONE_PARENT|CLONE_THREAD)) {
diff -Nrup linux-6.16.7/kernel/futex/waitwake.c linux-lenovo-x13s-linux-6.16.y/kernel/futex/waitwake.c
--- linux-6.16.7/kernel/futex/waitwake.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/kernel/futex/waitwake.c	2025-09-11 09:47:42.000000000 -0600
@@ -4,6 +4,9 @@
 #include <linux/sched/task.h>
 #include <linux/sched/signal.h>
 #include <linux/freezer.h>
+#ifdef CONFIG_SCHED_BORE
+#include <linux/sched/bore.h>
+#endif // CONFIG_SCHED_BORE
 
 #include "futex.h"
 
@@ -355,7 +358,15 @@ void futex_do_wait(struct futex_q *q, st
 		 * is no timeout, or if it has yet to expire.
 		 */
 		if (!timeout || timeout->task)
+#ifdef CONFIG_SCHED_BORE
+		{
+			current->bore.futex_waiting = true;
+#endif // CONFIG_SCHED_BORE
 			schedule();
+#ifdef CONFIG_SCHED_BORE
+			current->bore.futex_waiting = false;
+		}
+#endif // CONFIG_SCHED_BORE
 	}
 	__set_current_state(TASK_RUNNING);
 }
diff -Nrup linux-6.16.7/kernel/Kconfig.hz linux-lenovo-x13s-linux-6.16.y/kernel/Kconfig.hz
--- linux-6.16.7/kernel/Kconfig.hz	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/kernel/Kconfig.hz	2025-09-11 09:47:42.000000000 -0600
@@ -57,3 +57,20 @@ config HZ
 
 config SCHED_HRTICK
 	def_bool HIGH_RES_TIMERS
+
+config MIN_BASE_SLICE_NS
+	int "Default value for min_base_slice_ns"
+	default 2000000
+	help
+	 The BORE Scheduler automatically calculates the optimal base
+	 slice for the configured HZ using the following equation:
+	 
+	 base_slice_ns =
+	 	1000000000/HZ * DIV_ROUNDUP(min_base_slice_ns, 1000000000/HZ)
+	 
+	 This option sets the default lower bound limit of the base slice
+	 to prevent the loss of task throughput due to overscheduling.
+	 
+	 Setting this value too high can cause the system to boot with
+	 an unnecessarily large base slice, resulting in high scheduling
+	 latency and poor system responsiveness.
diff -Nrup linux-6.16.7/kernel/sched/bore.c linux-lenovo-x13s-linux-6.16.y/kernel/sched/bore.c
--- linux-6.16.7/kernel/sched/bore.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-lenovo-x13s-linux-6.16.y/kernel/sched/bore.c	2025-09-11 09:47:42.000000000 -0600
@@ -0,0 +1,393 @@
+/*
+ *  Burst-Oriented Response Enhancer (BORE) CPU Scheduler
+ *  Copyright (C) 2021-2025 Masahito Suzuki <firelzrd@gmail.com>
+ */
+#include <linux/cpuset.h>
+#include <linux/sched/task.h>
+#include <linux/sched/bore.h>
+#include "sched.h"
+
+#ifdef CONFIG_SCHED_BORE
+u8   __read_mostly sched_bore                   = 1;
+u8   __read_mostly sched_burst_inherit_type     = 2;
+u8   __read_mostly sched_burst_smoothness       = 1;
+u8   __read_mostly sched_burst_penalty_offset   = 24;
+uint __read_mostly sched_burst_penalty_scale    = 1536;
+uint __read_mostly sched_burst_cache_lifetime   = 75000000;
+static int __maybe_unused maxval_prio    =   39;
+static int __maybe_unused maxval_6_bits  =   63;
+static int __maybe_unused maxval_8_bits  =  255;
+static int __maybe_unused maxval_12_bits = 4095;
+
+#define MAX_BURST_PENALTY ((40U << 8) - 1)
+#define BURST_CACHE_STOP_COUNT 63
+
+static u32 (*inherit_penalty_fn)(struct task_struct *, u64, u64);
+
+static inline u32 log2p1_u64_u32fp(u64 v, u8 fp) {
+	if (!v) return 0;
+	u32 exponent = fls64(v),
+		mantissa = (u32)(v << (64 - exponent) << 1 >> (64 - fp));
+	return exponent << fp | mantissa;
+}
+
+static inline u32 calc_burst_penalty(u64 burst_time) {
+	u32 greed = log2p1_u64_u32fp(burst_time, 8),
+		tolerance = sched_burst_penalty_offset << 8,
+		penalty = max(0, (s32)(greed - tolerance)),
+		scaled_penalty = penalty * sched_burst_penalty_scale >> 10;
+	return min(MAX_BURST_PENALTY, scaled_penalty);
+}
+
+static inline u64 rescale_slice(u64 delta, u8 old_prio, u8 new_prio) {
+	u64 unscaled, rescaled;
+	unscaled = mul_u64_u32_shr(delta   , sched_prio_to_weight[old_prio], 10);
+	rescaled = mul_u64_u32_shr(unscaled, sched_prio_to_wmult [new_prio], 22);
+	return rescaled;
+}
+
+static inline u32 binary_smooth(u32 new, u32 old) {
+	if (new <= old) return new;
+
+	u32 increment = new - old,
+		shift = sched_burst_smoothness,
+		divisor = 1U << shift;
+
+	return old + ((increment + divisor - 1) >> shift);
+}
+
+static void reweight_task_by_prio(struct task_struct *p, int prio) {
+	if (task_has_idle_policy(p)) return;
+
+	struct sched_entity *se = &p->se;
+	unsigned long weight = scale_load(sched_prio_to_weight[prio]);
+
+	if (se->on_rq) {
+		p->bore.stop_update = true;
+		reweight_entity(cfs_rq_of(se), se, weight);
+		p->bore.stop_update = false;
+	} else
+		se->load.weight = weight;
+	se->load.inv_weight = sched_prio_to_wmult[prio];
+}
+
+u8 effective_prio_bore(struct task_struct *p) {
+	int prio = p->static_prio - MAX_RT_PRIO;
+	if (likely(sched_bore))
+		prio += p->bore.score;
+	return (u8)clamp(prio, 0, maxval_prio);
+}
+
+static void update_penalty(struct task_struct *p) {
+	struct bore_ctx *ctx = &p->bore;
+
+	u8  prev_prio = effective_prio_bore(p);
+	u32 penalty = 0;
+
+	if (!(p->flags & PF_KTHREAD)) {
+		u32 curr_penalty = ctx->curr_penalty;
+		penalty = ctx->prev_penalty;
+		if (penalty < curr_penalty)
+			penalty = curr_penalty;
+	}
+	ctx->penalty = penalty;
+
+	u8 new_prio = effective_prio_bore(p);
+	if (new_prio != prev_prio)
+		reweight_task_by_prio(p, new_prio);
+}
+
+void update_curr_bore(struct task_struct *p, u64 delta_exec) {
+	struct bore_ctx *ctx = &p->bore;
+	if (ctx->stop_update) return;
+
+	ctx->burst_time += delta_exec;
+	u32 curr_penalty = ctx->curr_penalty = calc_burst_penalty(ctx->burst_time);
+
+	if (curr_penalty <= ctx->prev_penalty) return;
+	update_penalty(p);
+}
+
+void restart_burst_bore(struct task_struct *p) {
+	struct bore_ctx *ctx = &p->bore;
+	u32 new_penalty = binary_smooth(ctx->curr_penalty, ctx->prev_penalty);
+	ctx->prev_penalty = new_penalty;
+	ctx->curr_penalty = 0;
+	ctx->burst_time = 0;
+	update_penalty(p);
+}
+
+void restart_burst_rescale_deadline_bore(struct task_struct *p) {
+	struct sched_entity *se = &p->se;
+	s64 vscaled, vremain = se->deadline - se->vruntime;
+
+	u8 old_prio = effective_prio_bore(p);
+	restart_burst_bore(p);
+	u8 new_prio = effective_prio_bore(p);
+
+	if (old_prio > new_prio) {
+		vscaled = rescale_slice(abs(vremain), old_prio, new_prio);
+		if (unlikely(vremain < 0))
+			vscaled = -vscaled;
+		se->deadline = se->vruntime + vscaled;
+	}
+}
+
+static inline bool task_is_bore_eligible(struct task_struct *p)
+{return p && p->sched_class == &fair_sched_class && !p->exit_state;}
+
+#ifndef for_each_child_task
+#define for_each_child_task(p, t) \
+	list_for_each_entry(t, &(p)->children, sibling)
+#endif
+
+static inline u32 count_children_upto2(struct task_struct *p) {
+	struct list_head *head = &p->children;
+	struct list_head *next = head->next;
+	return (next != head) + (next->next != head);
+}
+
+static inline bool burst_cache_expired(struct bore_bc *bc, u64 now) {
+	u64 timestamp = bc->timestamp << BORE_BC_TIMESTAMP_SHIFT;
+	return now - timestamp > sched_burst_cache_lifetime;
+}
+
+static void update_burst_cache(struct bore_bc *bc,
+		struct task_struct *p, u32 count, u32 total, u64 now) {
+	u32 average = count ? total / count : 0;
+	bc->penalty = max(average, p->bore.penalty);
+	bc->timestamp = now >> BORE_BC_TIMESTAMP_SHIFT;
+}
+
+static u32 inherit_none(struct task_struct *parent,
+									u64 clone_flags, u64 now)
+{ return 0; }
+
+static u32 inherit_from_parent(struct task_struct *parent,
+									u64 clone_flags, u64 now) {
+	if (clone_flags & CLONE_PARENT)
+		parent = parent->real_parent;
+
+	struct bore_bc *bc = &parent->bore.subtree;
+
+	if (burst_cache_expired(bc, now)) {
+		struct task_struct *child;
+		u32 count = 0, total = 0;
+		for_each_child_task(parent, child) {
+			if (count >= BURST_CACHE_STOP_COUNT) break;
+
+			if (!task_is_bore_eligible(child)) continue;
+			count++;
+			total += child->bore.penalty;
+		}
+
+		update_burst_cache(bc, parent, count, total, now);
+	}
+
+	return bc->penalty;
+}
+
+static u32 inherit_from_ancestor_hub(struct task_struct *parent,
+										u64 clone_flags, u64 now) {
+	struct task_struct *ancestor = parent;
+	u32 sole_child_count = 0;
+
+	if (clone_flags & CLONE_PARENT) {
+		ancestor = ancestor->real_parent;
+		sole_child_count = 1;
+	}
+
+	for (struct task_struct *next;
+			(next = ancestor->real_parent) != ancestor &&
+			count_children_upto2(ancestor) <= sole_child_count;
+			ancestor = next, sole_child_count = 1) {}
+
+	struct bore_bc *bc = &ancestor->bore.subtree;
+
+	if (burst_cache_expired(bc, now)) {
+		struct task_struct *direct_child;
+		u32 count = 0, total = 0;
+		for_each_child_task(ancestor, direct_child) {
+			if (count >= BURST_CACHE_STOP_COUNT) break;
+
+			struct task_struct *descendant = direct_child;
+			while (count_children_upto2(descendant) == 1)
+				descendant = list_first_entry(&descendant->children,
+												struct task_struct, sibling);
+
+			if (!task_is_bore_eligible(descendant)) continue;
+			count++;
+			total += descendant->bore.penalty;
+		}
+
+		update_burst_cache(bc, ancestor, count, total, now);
+	}
+
+	return bc->penalty;
+}
+
+static u32 inherit_from_thread_group(struct task_struct *p, u64 now) {
+	struct task_struct *leader = p->group_leader;
+	struct bore_bc *bc = &leader->bore.group;
+
+	if (burst_cache_expired(bc, now)) {
+		struct task_struct *sibling;
+		u32 count = 0, total = 0;
+
+		for_each_thread(leader, sibling) {
+			if (count >= BURST_CACHE_STOP_COUNT) break;
+
+			if (!task_is_bore_eligible(sibling)) continue;
+			count++;
+			total += sibling->bore.penalty;
+		}
+
+		update_burst_cache(bc, leader, count, total, now);
+	}
+
+	return bc->penalty;
+}
+
+void task_fork_bore(struct task_struct *p,
+	               struct task_struct *parent, u64 clone_flags, u64 now) {
+	if (!task_is_bore_eligible(p) || unlikely(!sched_bore)) return;
+
+	struct bore_ctx *ctx = &p->bore;
+	u32 inherited_penalty = (clone_flags & CLONE_THREAD)?
+		inherit_from_thread_group(parent, now):
+		inherit_penalty_fn(parent, clone_flags, now);
+
+	if (ctx->prev_penalty < inherited_penalty)
+		ctx->prev_penalty = inherited_penalty;
+	ctx->curr_penalty  = 0;
+	ctx->burst_time    = 0;
+	ctx->stop_update   = false;
+	ctx->futex_waiting = false;
+	update_penalty(p);
+}
+
+void reset_task_bore(struct task_struct *p)
+{ memset(&p->bore, 0, sizeof(struct bore_ctx)); }
+
+static void update_inherit_type(void) {
+	switch(sched_burst_inherit_type) {
+	case 1:
+		inherit_penalty_fn = inherit_from_parent;
+		break;
+	case 2:
+		inherit_penalty_fn = inherit_from_ancestor_hub;
+		break;
+	default:
+		inherit_penalty_fn = inherit_none;
+	}
+}
+
+void __init sched_init_bore(void) {
+	printk(KERN_INFO "%s %s by %s\n",
+		SCHED_BORE_PROGNAME, SCHED_BORE_VERSION, SCHED_BORE_AUTHOR);
+
+	reset_task_bore(&init_task);
+	update_inherit_type();
+}
+
+static void readjust_all_task_weights(void) {
+	struct task_struct *task;
+	struct rq *rq;
+	struct rq_flags rf;
+
+	scoped_guard(write_lock_irq, &tasklist_lock)
+	for_each_process(task) {
+		if (!task_is_bore_eligible(task)) continue;
+		rq = task_rq_lock(task, &rf);
+		update_rq_clock(rq);
+		reweight_task_by_prio(task, effective_prio_bore(task));
+		task_rq_unlock(rq, task, &rf);
+	}
+}
+
+int sched_bore_update_handler(const struct ctl_table *table,
+		int write, void __user *buffer, size_t *lenp, loff_t *ppos) {
+	int ret = proc_dou8vec_minmax(table, write, buffer, lenp, ppos);
+	if (ret || !write)
+		return ret;
+
+	readjust_all_task_weights();
+
+	return 0;
+}
+
+int sched_burst_inherit_type_update_handler(const struct ctl_table *table,
+		int write, void __user *buffer, size_t *lenp, loff_t *ppos) {
+	int ret = proc_dou8vec_minmax(table, write, buffer, lenp, ppos);
+	if (ret || !write)
+		return ret;
+
+	update_inherit_type();
+
+	return 0;
+}
+
+#ifdef CONFIG_SYSCTL
+static struct ctl_table sched_bore_sysctls[] = {
+	{
+		.procname	= "sched_bore",
+		.data		= &sched_bore,
+		.maxlen		= sizeof(u8),
+		.mode		= 0644,
+		.proc_handler = sched_bore_update_handler,
+		.extra1		= SYSCTL_ZERO,
+		.extra2		= SYSCTL_ONE,
+	},
+	{
+		.procname	= "sched_burst_inherit_type",
+		.data		= &sched_burst_inherit_type,
+		.maxlen		= sizeof(u8),
+		.mode		= 0644,
+		.proc_handler = sched_burst_inherit_type_update_handler,
+		.extra1		= SYSCTL_ZERO,
+		.extra2		= SYSCTL_TWO,
+	},
+	{
+		.procname	= "sched_burst_smoothness",
+		.data		= &sched_burst_smoothness,
+		.maxlen		= sizeof(u8),
+		.mode		= 0644,
+		.proc_handler = proc_dou8vec_minmax,
+		.extra1		= SYSCTL_ZERO,
+		.extra2		= SYSCTL_THREE,
+	},
+	{
+		.procname	= "sched_burst_penalty_offset",
+		.data		= &sched_burst_penalty_offset,
+		.maxlen		= sizeof(u8),
+		.mode		= 0644,
+		.proc_handler = proc_dou8vec_minmax,
+		.extra1		= SYSCTL_ZERO,
+		.extra2		= &maxval_6_bits,
+	},
+	{
+		.procname	= "sched_burst_penalty_scale",
+		.data		= &sched_burst_penalty_scale,
+		.maxlen		= sizeof(uint),
+		.mode		= 0644,
+		.proc_handler = proc_douintvec_minmax,
+		.extra1		= SYSCTL_ZERO,
+		.extra2		= &maxval_12_bits,
+	},
+	{
+		.procname	= "sched_burst_cache_lifetime",
+		.data		= &sched_burst_cache_lifetime,
+		.maxlen		= sizeof(uint),
+		.mode		= 0644,
+		.proc_handler = proc_douintvec,
+	},
+};
+
+static int __init sched_bore_sysctl_init(void) {
+	register_sysctl_init("kernel", sched_bore_sysctls);
+	return 0;
+}
+late_initcall(sched_bore_sysctl_init);
+
+#endif // CONFIG_SYSCTL
+#endif /* CONFIG_SCHED_BORE */
diff -Nrup linux-6.16.7/kernel/sched/core.c linux-lenovo-x13s-linux-6.16.y/kernel/sched/core.c
--- linux-6.16.7/kernel/sched/core.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/kernel/sched/core.c	2025-09-11 09:47:42.000000000 -0600
@@ -97,6 +97,10 @@
 #include "../../io_uring/io-wq.h"
 #include "../smpboot.h"
 
+#ifdef CONFIG_SCHED_BORE
+#include <linux/sched/bore.h>
+#endif /* CONFIG_SCHED_BORE */
+
 EXPORT_TRACEPOINT_SYMBOL_GPL(ipi_send_cpu);
 EXPORT_TRACEPOINT_SYMBOL_GPL(ipi_send_cpumask);
 
@@ -1423,7 +1427,11 @@ int tg_nop(struct task_group *tg, void *
 
 void set_load_weight(struct task_struct *p, bool update_load)
 {
+#ifdef CONFIG_SCHED_BORE
+	int prio = effective_prio_bore(p);
+#else /* !CONFIG_SCHED_BORE */
 	int prio = p->static_prio - MAX_RT_PRIO;
+#endif /* CONFIG_SCHED_BORE */
 	struct load_weight lw;
 
 	if (task_has_idle_policy(p)) {
@@ -8523,6 +8531,10 @@ void __init sched_init(void)
 	BUG_ON(!sched_class_above(&ext_sched_class, &idle_sched_class));
 #endif
 
+#ifdef CONFIG_SCHED_BORE
+	sched_init_bore();
+#endif /* CONFIG_SCHED_BORE */
+
 	wait_bit_init();
 
 #ifdef CONFIG_FAIR_GROUP_SCHED
diff -Nrup linux-6.16.7/kernel/sched/debug.c linux-lenovo-x13s-linux-6.16.y/kernel/sched/debug.c
--- linux-6.16.7/kernel/sched/debug.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/kernel/sched/debug.c	2025-09-11 09:47:42.000000000 -0600
@@ -167,7 +167,53 @@ static const struct file_operations sche
 };
 
 #ifdef CONFIG_SMP
+#ifdef CONFIG_SCHED_BORE
+#define DEFINE_SYSCTL_SCHED_FUNC(name, update_func) \
+static ssize_t sched_##name##_write(struct file *filp, const char __user *ubuf, size_t cnt, loff_t *ppos) \
+{ \
+	char buf[16]; \
+	unsigned int value; \
+\
+	if (cnt > 15) \
+		cnt = 15; \
+\
+	if (copy_from_user(&buf, ubuf, cnt)) \
+		return -EFAULT; \
+	buf[cnt] = '\0'; \
+\
+	if (kstrtouint(buf, 10, &value)) \
+		return -EINVAL; \
+\
+	sysctl_sched_##name = value; \
+	sched_update_##update_func(); \
+\
+	*ppos += cnt; \
+	return cnt; \
+} \
+\
+static int sched_##name##_show(struct seq_file *m, void *v) \
+{ \
+	seq_printf(m, "%d\n", sysctl_sched_##name); \
+	return 0; \
+} \
+\
+static int sched_##name##_open(struct inode *inode, struct file *filp) \
+{ \
+	return single_open(filp, sched_##name##_show, NULL); \
+} \
+\
+static const struct file_operations sched_##name##_fops = { \
+	.open		= sched_##name##_open, \
+	.write		= sched_##name##_write, \
+	.read		= seq_read, \
+	.llseek		= seq_lseek, \
+	.release	= single_release, \
+};
+
+DEFINE_SYSCTL_SCHED_FUNC(min_base_slice, min_base_slice)
 
+#undef DEFINE_SYSCTL_SCHED_FUNC
+#else /* !CONFIG_SCHED_BORE */
 static ssize_t sched_scaling_write(struct file *filp, const char __user *ubuf,
 				   size_t cnt, loff_t *ppos)
 {
@@ -213,7 +259,7 @@ static const struct file_operations sche
 	.llseek		= seq_lseek,
 	.release	= single_release,
 };
-
+#endif /* CONFIG_SCHED_BORE */
 #endif /* SMP */
 
 #ifdef CONFIG_PREEMPT_DYNAMIC
@@ -507,13 +553,20 @@ static __init int sched_init_debug(void)
 	debugfs_create_file("preempt", 0644, debugfs_sched, NULL, &sched_dynamic_fops);
 #endif
 
+#ifdef CONFIG_SCHED_BORE
+	debugfs_create_file("min_base_slice_ns", 0644, debugfs_sched, NULL, &sched_min_base_slice_fops);
+	debugfs_create_u32("base_slice_ns", 0444, debugfs_sched, &sysctl_sched_base_slice);
+#else /* !CONFIG_SCHED_BORE */
 	debugfs_create_u32("base_slice_ns", 0644, debugfs_sched, &sysctl_sched_base_slice);
+#endif /* CONFIG_SCHED_BORE */
 
 	debugfs_create_u32("latency_warn_ms", 0644, debugfs_sched, &sysctl_resched_latency_warn_ms);
 	debugfs_create_u32("latency_warn_once", 0644, debugfs_sched, &sysctl_resched_latency_warn_once);
 
 #ifdef CONFIG_SMP
+#if !defined(CONFIG_SCHED_BORE)
 	debugfs_create_file("tunable_scaling", 0644, debugfs_sched, NULL, &sched_scaling_fops);
+#endif /* CONFIG_SCHED_BORE */
 	debugfs_create_u32("migration_cost_ns", 0644, debugfs_sched, &sysctl_sched_migration_cost);
 	debugfs_create_u32("nr_migrate", 0644, debugfs_sched, &sysctl_sched_nr_migrate);
 
@@ -762,6 +815,9 @@ print_task(struct seq_file *m, struct rq
 		SPLIT_NS(schedstat_val_or_zero(p->stats.sum_sleep_runtime)),
 		SPLIT_NS(schedstat_val_or_zero(p->stats.sum_block_runtime)));
 
+#ifdef CONFIG_SCHED_BORE
+	SEQ_printf(m, " %2d", p->bore.score);
+#endif /* CONFIG_SCHED_BORE */
 #ifdef CONFIG_NUMA_BALANCING
 	SEQ_printf(m, "   %d      %d", task_node(p), task_numa_group_id(p));
 #endif
@@ -1248,6 +1304,9 @@ void proc_sched_show_task(struct task_st
 
 	P(se.load.weight);
 #ifdef CONFIG_SMP
+#ifdef CONFIG_SCHED_BORE
+	P(bore.score);
+#endif /* CONFIG_SCHED_BORE */
 	P(se.avg.load_sum);
 	P(se.avg.runnable_sum);
 	P(se.avg.util_sum);
diff -Nrup linux-6.16.7/kernel/sched/fair.c linux-lenovo-x13s-linux-6.16.y/kernel/sched/fair.c
--- linux-6.16.7/kernel/sched/fair.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/kernel/sched/fair.c	2025-09-11 09:47:42.000000000 -0600
@@ -58,6 +58,10 @@
 #include "stats.h"
 #include "autogroup.h"
 
+#ifdef CONFIG_SCHED_BORE
+#include <linux/sched/bore.h>
+#endif /* CONFIG_SCHED_BORE */
+
 /*
  * The initial- and re-scaling of tunables is configurable
  *
@@ -67,17 +71,30 @@
  *   SCHED_TUNABLESCALING_LOG - scaled logarithmically, *1+ilog(ncpus)
  *   SCHED_TUNABLESCALING_LINEAR - scaled linear, *ncpus
  *
- * (default SCHED_TUNABLESCALING_LOG = *(1+ilog(ncpus))
+ * BORE : default SCHED_TUNABLESCALING_NONE = *1 constant
+ * EEVDF: default SCHED_TUNABLESCALING_LOG  = *(1+ilog(ncpus))
  */
+#ifdef CONFIG_SCHED_BORE
+unsigned int sysctl_sched_tunable_scaling = SCHED_TUNABLESCALING_NONE;
+#else /* !CONFIG_SCHED_BORE */
 unsigned int sysctl_sched_tunable_scaling = SCHED_TUNABLESCALING_LOG;
+#endif /* CONFIG_SCHED_BORE */
 
 /*
  * Minimal preemption granularity for CPU-bound tasks:
  *
- * (default: 0.70 msec * (1 + ilog(ncpus)), units: nanoseconds)
- */
+ * BORE : base_slice = minimum multiple of nsecs_per_tick >= min_base_slice
+ * (default min_base_slice = 2000000 constant, units: nanoseconds)
+ * EEVDF: default 0.70 msec * (1 + ilog(ncpus)), units: nanoseconds
+ */
+#ifdef CONFIG_SCHED_BORE
+static const unsigned int nsecs_per_tick       = 1000000000ULL / HZ;
+unsigned int sysctl_sched_min_base_slice       = CONFIG_MIN_BASE_SLICE_NS;
+__read_mostly uint sysctl_sched_base_slice     = nsecs_per_tick;
+#else /* !CONFIG_SCHED_BORE */
 unsigned int sysctl_sched_base_slice			= 700000ULL;
 static unsigned int normalized_sysctl_sched_base_slice	= 700000ULL;
+#endif /* CONFIG_SCHED_BORE */
 
 __read_mostly unsigned int sysctl_sched_migration_cost	= 500000UL;
 
@@ -191,6 +208,13 @@ static inline void update_load_set(struc
  *
  * This idea comes from the SD scheduler of Con Kolivas:
  */
+#ifdef CONFIG_SCHED_BORE
+static void update_sysctl(void) {
+	sysctl_sched_base_slice = nsecs_per_tick *
+		max(1UL, DIV_ROUND_UP(sysctl_sched_min_base_slice, nsecs_per_tick));
+}
+void sched_update_min_base_slice(void) { update_sysctl(); }
+#else /* !CONFIG_SCHED_BORE */
 static unsigned int get_update_sysctl_factor(void)
 {
 	unsigned int cpus = min_t(unsigned int, num_online_cpus(), 8);
@@ -221,6 +245,7 @@ static void update_sysctl(void)
 	SET_SYSCTL(sched_base_slice);
 #undef SET_SYSCTL
 }
+#endif /* CONFIG_SCHED_BORE */
 
 void __init sched_init_granularity(void)
 {
@@ -700,6 +725,9 @@ static void update_entity_lag(struct cfs
 
 	vlag = avg_vruntime(cfs_rq) - se->vruntime;
 	limit = calc_delta_fair(max_t(u64, 2*se->slice, TICK_NSEC), se);
+#ifdef CONFIG_SCHED_BORE
+	limit >>= !!sched_bore;
+#endif /* CONFIG_SCHED_BORE */
 
 	se->vlag = clamp(vlag, -limit, limit);
 }
@@ -939,7 +967,16 @@ static struct sched_entity *pick_eevdf(s
 	if (curr && (!curr->on_rq || !entity_eligible(cfs_rq, curr)))
 		curr = NULL;
 
+#if !defined(CONFIG_SCHED_BORE)
 	if (sched_feat(RUN_TO_PARITY) && curr && protect_slice(curr))
+#else /* CONFIG_SCHED_BORE */
+	bool run_to_parity = likely(sched_bore) ?
+		sched_feat(RUN_TO_PARITY_BORE) : sched_feat(RUN_TO_PARITY);
+	if (run_to_parity && curr && protect_slice(curr) &&
+		(!entity_is_task(curr) ||
+		 !task_of(curr)->bore.futex_waiting ||
+		 unlikely(!sched_bore)))
+#endif /* CONFIG_SCHED_BORE */
 		return curr;
 
 	/* Pick the leftmost entity if it's eligible */
@@ -997,6 +1034,7 @@ struct sched_entity *__pick_last_entity(
  * Scheduling class statistics methods:
  */
 #ifdef CONFIG_SMP
+#if !defined(CONFIG_SCHED_BORE)
 int sched_update_scaling(void)
 {
 	unsigned int factor = get_update_sysctl_factor();
@@ -1008,6 +1046,7 @@ int sched_update_scaling(void)
 
 	return 0;
 }
+#endif /* CONFIG_SCHED_BORE */
 #endif
 
 static void clear_buddies(struct cfs_rq *cfs_rq, struct sched_entity *se);
@@ -1244,6 +1283,9 @@ static void update_curr(struct cfs_rq *c
 	if (entity_is_task(curr)) {
 		struct task_struct *p = task_of(curr);
 
+#ifdef CONFIG_SCHED_BORE
+		update_curr_bore(p, delta_exec);
+#endif /* CONFIG_SCHED_BORE */
 		update_curr_task(p, delta_exec);
 
 		/*
@@ -3794,7 +3836,7 @@ dequeue_load_avg(struct cfs_rq *cfs_rq,
 
 static void place_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int flags);
 
-static void reweight_entity(struct cfs_rq *cfs_rq, struct sched_entity *se,
+void reweight_entity(struct cfs_rq *cfs_rq, struct sched_entity *se,
 			    unsigned long weight)
 {
 	bool curr = cfs_rq->curr == se;
@@ -5205,12 +5247,11 @@ void __setparam_fair(struct task_struct
 static void
 place_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int flags)
 {
-	u64 vslice, vruntime = avg_vruntime(cfs_rq);
+	u64 vslice = 0, vruntime = avg_vruntime(cfs_rq);
 	s64 lag = 0;
 
 	if (!se->custom_slice)
 		se->slice = sysctl_sched_base_slice;
-	vslice = calc_delta_fair(se->slice, se);
 
 	/*
 	 * Due to how V is constructed as the weighted average of entities,
@@ -5295,7 +5336,18 @@ place_entity(struct cfs_rq *cfs_rq, stru
 		se->rel_deadline = 0;
 		return;
 	}
-
+#ifdef CONFIG_SCHED_BORE
+	if (entity_is_task(se) &&
+			likely(sched_bore) &&
+			task_of(se)->bore.futex_waiting)
+		goto vslice_found;
+#endif /* !CONFIG_SCHED_BORE */
+	vslice = calc_delta_fair(se->slice, se);
+#ifdef CONFIG_SCHED_BORE
+	if (likely(sched_bore))
+		vslice >>= !!(flags & (ENQUEUE_INITIAL | ENQUEUE_WAKEUP));
+	else
+#endif /* CONFIG_SCHED_BORE */
 	/*
 	 * When joining the competition; the existing tasks will be,
 	 * on average, halfway through their slice, as such start tasks
@@ -5304,6 +5356,9 @@ place_entity(struct cfs_rq *cfs_rq, stru
 	if (sched_feat(PLACE_DEADLINE_INITIAL) && (flags & ENQUEUE_INITIAL))
 		vslice /= 2;
 
+#ifdef CONFIG_SCHED_BORE
+vslice_found:
+#endif /* CONFIG_SCHED_BORE */
 	/*
 	 * EEVDF: vd_i = ve_i + r_i/w_i
 	 */
@@ -5314,7 +5369,7 @@ static void check_enqueue_throttle(struc
 static inline int cfs_rq_throttled(struct cfs_rq *cfs_rq);
 
 static void
-requeue_delayed_entity(struct sched_entity *se);
+requeue_delayed_entity(struct sched_entity *se, int flags);
 
 static void
 enqueue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int flags)
@@ -5478,6 +5533,10 @@ dequeue_entity(struct cfs_rq *cfs_rq, st
 		if (sched_feat(DELAY_DEQUEUE) && delay &&
 		    !entity_eligible(cfs_rq, se)) {
 			update_load_avg(cfs_rq, se, 0);
+#ifdef CONFIG_SCHED_BORE
+			if (sched_feat(DELAY_ZERO) && likely(sched_bore))
+				update_entity_lag(cfs_rq, se);
+#endif /* CONFIG_SCHED_BORE */
 			set_delayed(se);
 			return false;
 		}
@@ -6894,7 +6953,7 @@ static int sched_idle_cpu(int cpu)
 #endif
 
 static void
-requeue_delayed_entity(struct sched_entity *se)
+requeue_delayed_entity(struct sched_entity *se, int flags)
 {
 	struct cfs_rq *cfs_rq = cfs_rq_of(se);
 
@@ -6907,13 +6966,22 @@ requeue_delayed_entity(struct sched_enti
 	WARN_ON_ONCE(!se->on_rq);
 
 	if (sched_feat(DELAY_ZERO)) {
+#ifdef CONFIG_SCHED_BORE
+		if (likely(sched_bore))
+			flags |= ENQUEUE_WAKEUP;
+		else {
+#endif /* CONFIG_SCHED_BORE */
+		flags = 0;
 		update_entity_lag(cfs_rq, se);
+#ifdef CONFIG_SCHED_BORE
+		}
+#endif /* CONFIG_SCHED_BORE */
 		if (se->vlag > 0) {
 			cfs_rq->nr_queued--;
 			if (se != cfs_rq->curr)
 				__dequeue_entity(cfs_rq, se);
 			se->vlag = 0;
-			place_entity(cfs_rq, se, 0);
+			place_entity(cfs_rq, se, flags);
 			if (se != cfs_rq->curr)
 				__enqueue_entity(cfs_rq, se);
 			cfs_rq->nr_queued++;
@@ -6950,7 +7018,7 @@ enqueue_task_fair(struct rq *rq, struct
 		util_est_enqueue(&rq->cfs, p);
 
 	if (flags & ENQUEUE_DELAYED) {
-		requeue_delayed_entity(se);
+		requeue_delayed_entity(se, flags);
 		return;
 	}
 
@@ -6968,7 +7036,7 @@ enqueue_task_fair(struct rq *rq, struct
 	for_each_sched_entity(se) {
 		if (se->on_rq) {
 			if (se->sched_delayed)
-				requeue_delayed_entity(se);
+				requeue_delayed_entity(se, flags);
 			break;
 		}
 		cfs_rq = cfs_rq_of(se);
@@ -7190,6 +7258,15 @@ static bool dequeue_task_fair(struct rq
 		util_est_dequeue(&rq->cfs, p);
 
 	util_est_update(&rq->cfs, p, flags & DEQUEUE_SLEEP);
+#ifdef CONFIG_SCHED_BORE
+	struct cfs_rq *cfs_rq = &rq->cfs;
+	struct sched_entity *se = &p->se;
+	if ((flags & DEQUEUE_SLEEP) && entity_is_task(se)) {
+		if (cfs_rq->curr == se)
+			update_curr(cfs_rq_of(&p->se));
+		restart_burst_bore(p);
+	}
+#endif /* CONFIG_SCHED_BORE */
 	if (dequeue_entities(rq, &p->se, flags) < 0)
 		return false;
 
@@ -7559,9 +7636,14 @@ static inline int sched_balance_find_dst
 	return new_cpu;
 }
 
+static inline bool is_idle_cpu(int cpu)
+{
+	return available_idle_cpu(cpu) || sched_idle_cpu(cpu);
+}
+
 static inline int __select_idle_cpu(int cpu, struct task_struct *p)
 {
-	if ((available_idle_cpu(cpu) || sched_idle_cpu(cpu)) &&
+	if (is_idle_cpu(cpu) &&
 	    sched_cpu_cookie_match(cpu_rq(cpu), p))
 		return cpu;
 
@@ -7572,6 +7654,24 @@ static inline int __select_idle_cpu(int
 DEFINE_STATIC_KEY_FALSE(sched_smt_present);
 EXPORT_SYMBOL_GPL(sched_smt_present);
 
+/*
+ * Return true if all the CPUs in the SMT core where @cpu belongs are idle,
+ * false otherwise.
+ */
+static bool is_idle_core(int cpu)
+{
+	int sibling;
+
+	if (!sched_smt_active())
+		return is_idle_cpu(cpu);
+
+	for_each_cpu(sibling, cpu_smt_mask(cpu))
+		if (!is_idle_cpu(sibling))
+			return false;
+
+	return true;
+}
+
 static inline void set_idle_cores(int cpu, int val)
 {
 	struct sched_domain_shared *sds;
@@ -7654,29 +7754,6 @@ static int select_idle_core(struct task_
 	return -1;
 }
 
-/*
- * Scan the local SMT mask for idle CPUs.
- */
-static int select_idle_smt(struct task_struct *p, struct sched_domain *sd, int target)
-{
-	int cpu;
-
-	for_each_cpu_and(cpu, cpu_smt_mask(target), p->cpus_ptr) {
-		if (cpu == target)
-			continue;
-		/*
-		 * Check if the CPU is in the LLC scheduling domain of @target.
-		 * Due to isolcpus, there is no guarantee that all the siblings are in the domain.
-		 */
-		if (!cpumask_test_cpu(cpu, sched_domain_span(sd)))
-			continue;
-		if (available_idle_cpu(cpu) || sched_idle_cpu(cpu))
-			return cpu;
-	}
-
-	return -1;
-}
-
 #else /* CONFIG_SCHED_SMT */
 
 static inline void set_idle_cores(int cpu, int val)
@@ -7693,9 +7770,9 @@ static inline int select_idle_core(struc
 	return __select_idle_cpu(core, p);
 }
 
-static inline int select_idle_smt(struct task_struct *p, struct sched_domain *sd, int target)
+static inline bool is_idle_core(int cpu)
 {
-	return -1;
+	return is_idle_cpu(cpu);
 }
 
 #endif /* CONFIG_SCHED_SMT */
@@ -7792,7 +7869,7 @@ select_idle_capacity(struct task_struct
 	for_each_cpu_wrap(cpu, cpus, target) {
 		unsigned long cpu_cap = capacity_of(cpu);
 
-		if (!available_idle_cpu(cpu) && !sched_idle_cpu(cpu))
+		if (!is_idle_cpu(cpu))
 			continue;
 
 		fits = util_fits_cpu(task_util, util_min, util_max, cpu);
@@ -7863,7 +7940,7 @@ static int select_idle_sibling(struct ta
 	 */
 	lockdep_assert_irqs_disabled();
 
-	if ((available_idle_cpu(target) || sched_idle_cpu(target)) &&
+	if (is_idle_core(target) &&
 	    asym_fits_cpu(task_util, util_min, util_max, target))
 		return target;
 
@@ -7871,7 +7948,7 @@ static int select_idle_sibling(struct ta
 	 * If the previous CPU is cache affine and idle, don't be stupid:
 	 */
 	if (prev != target && cpus_share_cache(prev, target) &&
-	    (available_idle_cpu(prev) || sched_idle_cpu(prev)) &&
+	    is_idle_core(prev) &&
 	    asym_fits_cpu(task_util, util_min, util_max, prev)) {
 
 		if (!static_branch_unlikely(&sched_cluster_active) ||
@@ -7903,7 +7980,7 @@ static int select_idle_sibling(struct ta
 	if (recent_used_cpu != prev &&
 	    recent_used_cpu != target &&
 	    cpus_share_cache(recent_used_cpu, target) &&
-	    (available_idle_cpu(recent_used_cpu) || sched_idle_cpu(recent_used_cpu)) &&
+	    is_idle_core(recent_used_cpu) &&
 	    cpumask_test_cpu(recent_used_cpu, p->cpus_ptr) &&
 	    asym_fits_cpu(task_util, util_min, util_max, recent_used_cpu)) {
 
@@ -7939,16 +8016,9 @@ static int select_idle_sibling(struct ta
 	if (!sd)
 		return target;
 
-	if (sched_smt_active()) {
+	if (sched_smt_active())
 		has_idle_core = test_idle_cores(target);
 
-		if (!has_idle_core && cpus_share_cache(prev, target)) {
-			i = select_idle_smt(p, sd, prev);
-			if ((unsigned int)i < nr_cpumask_bits)
-				return i;
-		}
-	}
-
 	i = select_idle_cpu(p, sd, has_idle_core, target);
 	if ((unsigned)i < nr_cpumask_bits)
 		return i;
@@ -9019,16 +9089,25 @@ static void yield_task_fair(struct rq *r
 	/*
 	 * Are we the only task in the tree?
 	 */
+#if !defined(CONFIG_SCHED_BORE)
 	if (unlikely(rq->nr_running == 1))
 		return;
 
 	clear_buddies(cfs_rq, se);
+#endif /* CONFIG_SCHED_BORE */
 
 	update_rq_clock(rq);
 	/*
 	 * Update run-time statistics of the 'current'.
 	 */
 	update_curr(cfs_rq);
+#ifdef CONFIG_SCHED_BORE
+	restart_burst_rescale_deadline_bore(curr);
+	if (unlikely(rq->nr_running == 1))
+		return;
+
+	clear_buddies(cfs_rq, se);
+#endif /* CONFIG_SCHED_BORE */
 	/*
 	 * Tell update_rq_clock() that we've just updated,
 	 * so we don't do microscopic update in schedule()
@@ -13273,6 +13352,9 @@ static void switched_to_fair(struct rq *
 	WARN_ON_ONCE(p->se.sched_delayed);
 
 	attach_task_cfs_rq(p);
+#ifdef CONFIG_SCHED_BORE
+	reset_task_bore(p);
+#endif /* CONFIG_SCHED_BORE */
 
 	set_task_max_allowed_capacity(p);
 
diff -Nrup linux-6.16.7/kernel/sched/features.h linux-lenovo-x13s-linux-6.16.y/kernel/sched/features.h
--- linux-6.16.7/kernel/sched/features.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/kernel/sched/features.h	2025-09-11 09:47:42.000000000 -0600
@@ -18,6 +18,9 @@ SCHED_FEAT(PLACE_REL_DEADLINE, true)
  * 0-lag point or until is has exhausted it's slice.
  */
 SCHED_FEAT(RUN_TO_PARITY, true)
+#ifdef CONFIG_SCHED_BORE
+SCHED_FEAT(RUN_TO_PARITY_BORE, false)
+#endif /* CONFIG_SCHED_BORE */
 /*
  * Allow wakeup of tasks with a shorter slice to cancel RUN_TO_PARITY for
  * current.
diff -Nrup linux-6.16.7/kernel/sched/Makefile linux-lenovo-x13s-linux-6.16.y/kernel/sched/Makefile
--- linux-6.16.7/kernel/sched/Makefile	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/kernel/sched/Makefile	2025-09-11 09:47:42.000000000 -0600
@@ -37,3 +37,4 @@ obj-y += core.o
 obj-y += fair.o
 obj-y += build_policy.o
 obj-y += build_utility.o
+obj-$(CONFIG_SCHED_BORE) += bore.o
diff -Nrup linux-6.16.7/kernel/sched/sched.h linux-lenovo-x13s-linux-6.16.y/kernel/sched/sched.h
--- linux-6.16.7/kernel/sched/sched.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/kernel/sched/sched.h	2025-09-11 09:47:42.000000000 -0600
@@ -2119,7 +2119,11 @@ extern int group_balance_cpu(struct sche
 extern void update_sched_domain_debugfs(void);
 extern void dirty_sched_domain_sysctl(int cpu);
 
+#ifdef CONFIG_SCHED_BORE
+extern void sched_update_min_base_slice(void);
+#else /* !CONFIG_SCHED_BORE */
 extern int sched_update_scaling(void);
+#endif /* CONFIG_SCHED_BORE */
 
 static inline const struct cpumask *task_user_cpus(struct task_struct *p)
 {
@@ -2825,7 +2829,12 @@ extern void wakeup_preempt(struct rq *rq
 extern __read_mostly unsigned int sysctl_sched_nr_migrate;
 extern __read_mostly unsigned int sysctl_sched_migration_cost;
 
+#ifdef CONFIG_SCHED_BORE
+extern unsigned int sysctl_sched_min_base_slice;
+extern __read_mostly uint sysctl_sched_base_slice;
+#else /* !CONFIG_SCHED_BORE */
 extern unsigned int sysctl_sched_base_slice;
+#endif /* CONFIG_SCHED_BORE */
 
 extern int sysctl_resched_latency_warn_ms;
 extern int sysctl_resched_latency_warn_once;
diff -Nrup linux-6.16.7/kernel/sys.c linux-lenovo-x13s-linux-6.16.y/kernel/sys.c
--- linux-6.16.7/kernel/sys.c	2025-09-13 16:15:37.961397732 -0600
+++ linux-lenovo-x13s-linux-6.16.y/kernel/sys.c	2025-09-11 09:47:42.000000000 -0600
@@ -2749,16 +2749,10 @@ SYSCALL_DEFINE5(prctl, int, option, unsi
 		break;
 #endif
 	case PR_SET_MDWE:
-		if (IS_ENABLED(CONFIG_PARISC))
-			error = -EINVAL;
-		else
-			error = prctl_set_mdwe(arg2, arg3, arg4, arg5);
+		error = prctl_set_mdwe(arg2, arg3, arg4, arg5);
 		break;
 	case PR_GET_MDWE:
-		if (IS_ENABLED(CONFIG_PARISC))
-			error = -EINVAL;
-		else
-			error = prctl_get_mdwe(arg2, arg3, arg4, arg5);
+		error = prctl_get_mdwe(arg2, arg3, arg4, arg5);
 		break;
 	case PR_PPC_GET_DEXCR:
 		if (arg3 || arg4 || arg5)
diff -Nrup linux-6.16.7/kernel/sys.c.orig linux-lenovo-x13s-linux-6.16.y/kernel/sys.c.orig
--- linux-6.16.7/kernel/sys.c.orig	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/kernel/sys.c.orig	1969-12-31 17:00:00.000000000 -0700
@@ -1,2992 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- *  linux/kernel/sys.c
- *
- *  Copyright (C) 1991, 1992  Linus Torvalds
- */
-
-#include <linux/export.h>
-#include <linux/mm.h>
-#include <linux/mm_inline.h>
-#include <linux/utsname.h>
-#include <linux/mman.h>
-#include <linux/reboot.h>
-#include <linux/prctl.h>
-#include <linux/highuid.h>
-#include <linux/fs.h>
-#include <linux/kmod.h>
-#include <linux/ksm.h>
-#include <linux/perf_event.h>
-#include <linux/resource.h>
-#include <linux/kernel.h>
-#include <linux/workqueue.h>
-#include <linux/capability.h>
-#include <linux/device.h>
-#include <linux/key.h>
-#include <linux/times.h>
-#include <linux/posix-timers.h>
-#include <linux/security.h>
-#include <linux/random.h>
-#include <linux/suspend.h>
-#include <linux/tty.h>
-#include <linux/signal.h>
-#include <linux/cn_proc.h>
-#include <linux/getcpu.h>
-#include <linux/task_io_accounting_ops.h>
-#include <linux/seccomp.h>
-#include <linux/cpu.h>
-#include <linux/personality.h>
-#include <linux/ptrace.h>
-#include <linux/fs_struct.h>
-#include <linux/file.h>
-#include <linux/mount.h>
-#include <linux/gfp.h>
-#include <linux/syscore_ops.h>
-#include <linux/version.h>
-#include <linux/ctype.h>
-#include <linux/syscall_user_dispatch.h>
-
-#include <linux/compat.h>
-#include <linux/syscalls.h>
-#include <linux/kprobes.h>
-#include <linux/user_namespace.h>
-#include <linux/time_namespace.h>
-#include <linux/binfmts.h>
-#include <linux/futex.h>
-
-#include <linux/sched.h>
-#include <linux/sched/autogroup.h>
-#include <linux/sched/loadavg.h>
-#include <linux/sched/stat.h>
-#include <linux/sched/mm.h>
-#include <linux/sched/coredump.h>
-#include <linux/sched/task.h>
-#include <linux/sched/cputime.h>
-#include <linux/rcupdate.h>
-#include <linux/uidgid.h>
-#include <linux/cred.h>
-
-#include <linux/nospec.h>
-
-#include <linux/kmsg_dump.h>
-/* Move somewhere else to avoid recompiling? */
-#include <generated/utsrelease.h>
-
-#include <linux/uaccess.h>
-#include <asm/io.h>
-#include <asm/unistd.h>
-
-#include <trace/events/task.h>
-
-#include "uid16.h"
-
-#ifndef SET_UNALIGN_CTL
-# define SET_UNALIGN_CTL(a, b)	(-EINVAL)
-#endif
-#ifndef GET_UNALIGN_CTL
-# define GET_UNALIGN_CTL(a, b)	(-EINVAL)
-#endif
-#ifndef SET_FPEMU_CTL
-# define SET_FPEMU_CTL(a, b)	(-EINVAL)
-#endif
-#ifndef GET_FPEMU_CTL
-# define GET_FPEMU_CTL(a, b)	(-EINVAL)
-#endif
-#ifndef SET_FPEXC_CTL
-# define SET_FPEXC_CTL(a, b)	(-EINVAL)
-#endif
-#ifndef GET_FPEXC_CTL
-# define GET_FPEXC_CTL(a, b)	(-EINVAL)
-#endif
-#ifndef GET_ENDIAN
-# define GET_ENDIAN(a, b)	(-EINVAL)
-#endif
-#ifndef SET_ENDIAN
-# define SET_ENDIAN(a, b)	(-EINVAL)
-#endif
-#ifndef GET_TSC_CTL
-# define GET_TSC_CTL(a)		(-EINVAL)
-#endif
-#ifndef SET_TSC_CTL
-# define SET_TSC_CTL(a)		(-EINVAL)
-#endif
-#ifndef GET_FP_MODE
-# define GET_FP_MODE(a)		(-EINVAL)
-#endif
-#ifndef SET_FP_MODE
-# define SET_FP_MODE(a,b)	(-EINVAL)
-#endif
-#ifndef SVE_SET_VL
-# define SVE_SET_VL(a)		(-EINVAL)
-#endif
-#ifndef SVE_GET_VL
-# define SVE_GET_VL()		(-EINVAL)
-#endif
-#ifndef SME_SET_VL
-# define SME_SET_VL(a)		(-EINVAL)
-#endif
-#ifndef SME_GET_VL
-# define SME_GET_VL()		(-EINVAL)
-#endif
-#ifndef PAC_RESET_KEYS
-# define PAC_RESET_KEYS(a, b)	(-EINVAL)
-#endif
-#ifndef PAC_SET_ENABLED_KEYS
-# define PAC_SET_ENABLED_KEYS(a, b, c)	(-EINVAL)
-#endif
-#ifndef PAC_GET_ENABLED_KEYS
-# define PAC_GET_ENABLED_KEYS(a)	(-EINVAL)
-#endif
-#ifndef SET_TAGGED_ADDR_CTRL
-# define SET_TAGGED_ADDR_CTRL(a)	(-EINVAL)
-#endif
-#ifndef GET_TAGGED_ADDR_CTRL
-# define GET_TAGGED_ADDR_CTRL()		(-EINVAL)
-#endif
-#ifndef RISCV_V_SET_CONTROL
-# define RISCV_V_SET_CONTROL(a)		(-EINVAL)
-#endif
-#ifndef RISCV_V_GET_CONTROL
-# define RISCV_V_GET_CONTROL()		(-EINVAL)
-#endif
-#ifndef RISCV_SET_ICACHE_FLUSH_CTX
-# define RISCV_SET_ICACHE_FLUSH_CTX(a, b)	(-EINVAL)
-#endif
-#ifndef PPC_GET_DEXCR_ASPECT
-# define PPC_GET_DEXCR_ASPECT(a, b)	(-EINVAL)
-#endif
-#ifndef PPC_SET_DEXCR_ASPECT
-# define PPC_SET_DEXCR_ASPECT(a, b, c)	(-EINVAL)
-#endif
-
-/*
- * this is where the system-wide overflow UID and GID are defined, for
- * architectures that now have 32-bit UID/GID but didn't in the past
- */
-
-int overflowuid = DEFAULT_OVERFLOWUID;
-int overflowgid = DEFAULT_OVERFLOWGID;
-
-EXPORT_SYMBOL(overflowuid);
-EXPORT_SYMBOL(overflowgid);
-
-/*
- * the same as above, but for filesystems which can only store a 16-bit
- * UID and GID. as such, this is needed on all architectures
- */
-
-int fs_overflowuid = DEFAULT_FS_OVERFLOWUID;
-int fs_overflowgid = DEFAULT_FS_OVERFLOWGID;
-
-EXPORT_SYMBOL(fs_overflowuid);
-EXPORT_SYMBOL(fs_overflowgid);
-
-/*
- * Returns true if current's euid is same as p's uid or euid,
- * or has CAP_SYS_NICE to p's user_ns.
- *
- * Called with rcu_read_lock, creds are safe
- */
-static bool set_one_prio_perm(struct task_struct *p)
-{
-	const struct cred *cred = current_cred(), *pcred = __task_cred(p);
-
-	if (uid_eq(pcred->uid,  cred->euid) ||
-	    uid_eq(pcred->euid, cred->euid))
-		return true;
-	if (ns_capable(pcred->user_ns, CAP_SYS_NICE))
-		return true;
-	return false;
-}
-
-/*
- * set the priority of a task
- * - the caller must hold the RCU read lock
- */
-static int set_one_prio(struct task_struct *p, int niceval, int error)
-{
-	int no_nice;
-
-	if (!set_one_prio_perm(p)) {
-		error = -EPERM;
-		goto out;
-	}
-	if (niceval < task_nice(p) && !can_nice(p, niceval)) {
-		error = -EACCES;
-		goto out;
-	}
-	no_nice = security_task_setnice(p, niceval);
-	if (no_nice) {
-		error = no_nice;
-		goto out;
-	}
-	if (error == -ESRCH)
-		error = 0;
-	set_user_nice(p, niceval);
-out:
-	return error;
-}
-
-SYSCALL_DEFINE3(setpriority, int, which, int, who, int, niceval)
-{
-	struct task_struct *g, *p;
-	struct user_struct *user;
-	const struct cred *cred = current_cred();
-	int error = -EINVAL;
-	struct pid *pgrp;
-	kuid_t uid;
-
-	if (which > PRIO_USER || which < PRIO_PROCESS)
-		goto out;
-
-	/* normalize: avoid signed division (rounding problems) */
-	error = -ESRCH;
-	if (niceval < MIN_NICE)
-		niceval = MIN_NICE;
-	if (niceval > MAX_NICE)
-		niceval = MAX_NICE;
-
-	rcu_read_lock();
-	switch (which) {
-	case PRIO_PROCESS:
-		if (who)
-			p = find_task_by_vpid(who);
-		else
-			p = current;
-		if (p)
-			error = set_one_prio(p, niceval, error);
-		break;
-	case PRIO_PGRP:
-		if (who)
-			pgrp = find_vpid(who);
-		else
-			pgrp = task_pgrp(current);
-		read_lock(&tasklist_lock);
-		do_each_pid_thread(pgrp, PIDTYPE_PGID, p) {
-			error = set_one_prio(p, niceval, error);
-		} while_each_pid_thread(pgrp, PIDTYPE_PGID, p);
-		read_unlock(&tasklist_lock);
-		break;
-	case PRIO_USER:
-		uid = make_kuid(cred->user_ns, who);
-		user = cred->user;
-		if (!who)
-			uid = cred->uid;
-		else if (!uid_eq(uid, cred->uid)) {
-			user = find_user(uid);
-			if (!user)
-				goto out_unlock;	/* No processes for this user */
-		}
-		for_each_process_thread(g, p) {
-			if (uid_eq(task_uid(p), uid) && task_pid_vnr(p))
-				error = set_one_prio(p, niceval, error);
-		}
-		if (!uid_eq(uid, cred->uid))
-			free_uid(user);		/* For find_user() */
-		break;
-	}
-out_unlock:
-	rcu_read_unlock();
-out:
-	return error;
-}
-
-/*
- * Ugh. To avoid negative return values, "getpriority()" will
- * not return the normal nice-value, but a negated value that
- * has been offset by 20 (ie it returns 40..1 instead of -20..19)
- * to stay compatible.
- */
-SYSCALL_DEFINE2(getpriority, int, which, int, who)
-{
-	struct task_struct *g, *p;
-	struct user_struct *user;
-	const struct cred *cred = current_cred();
-	long niceval, retval = -ESRCH;
-	struct pid *pgrp;
-	kuid_t uid;
-
-	if (which > PRIO_USER || which < PRIO_PROCESS)
-		return -EINVAL;
-
-	rcu_read_lock();
-	switch (which) {
-	case PRIO_PROCESS:
-		if (who)
-			p = find_task_by_vpid(who);
-		else
-			p = current;
-		if (p) {
-			niceval = nice_to_rlimit(task_nice(p));
-			if (niceval > retval)
-				retval = niceval;
-		}
-		break;
-	case PRIO_PGRP:
-		if (who)
-			pgrp = find_vpid(who);
-		else
-			pgrp = task_pgrp(current);
-		read_lock(&tasklist_lock);
-		do_each_pid_thread(pgrp, PIDTYPE_PGID, p) {
-			niceval = nice_to_rlimit(task_nice(p));
-			if (niceval > retval)
-				retval = niceval;
-		} while_each_pid_thread(pgrp, PIDTYPE_PGID, p);
-		read_unlock(&tasklist_lock);
-		break;
-	case PRIO_USER:
-		uid = make_kuid(cred->user_ns, who);
-		user = cred->user;
-		if (!who)
-			uid = cred->uid;
-		else if (!uid_eq(uid, cred->uid)) {
-			user = find_user(uid);
-			if (!user)
-				goto out_unlock;	/* No processes for this user */
-		}
-		for_each_process_thread(g, p) {
-			if (uid_eq(task_uid(p), uid) && task_pid_vnr(p)) {
-				niceval = nice_to_rlimit(task_nice(p));
-				if (niceval > retval)
-					retval = niceval;
-			}
-		}
-		if (!uid_eq(uid, cred->uid))
-			free_uid(user);		/* for find_user() */
-		break;
-	}
-out_unlock:
-	rcu_read_unlock();
-
-	return retval;
-}
-
-/*
- * Unprivileged users may change the real gid to the effective gid
- * or vice versa.  (BSD-style)
- *
- * If you set the real gid at all, or set the effective gid to a value not
- * equal to the real gid, then the saved gid is set to the new effective gid.
- *
- * This makes it possible for a setgid program to completely drop its
- * privileges, which is often a useful assertion to make when you are doing
- * a security audit over a program.
- *
- * The general idea is that a program which uses just setregid() will be
- * 100% compatible with BSD.  A program which uses just setgid() will be
- * 100% compatible with POSIX with saved IDs.
- *
- * SMP: There are not races, the GIDs are checked only by filesystem
- *      operations (as far as semantic preservation is concerned).
- */
-#ifdef CONFIG_MULTIUSER
-long __sys_setregid(gid_t rgid, gid_t egid)
-{
-	struct user_namespace *ns = current_user_ns();
-	const struct cred *old;
-	struct cred *new;
-	int retval;
-	kgid_t krgid, kegid;
-
-	krgid = make_kgid(ns, rgid);
-	kegid = make_kgid(ns, egid);
-
-	if ((rgid != (gid_t) -1) && !gid_valid(krgid))
-		return -EINVAL;
-	if ((egid != (gid_t) -1) && !gid_valid(kegid))
-		return -EINVAL;
-
-	new = prepare_creds();
-	if (!new)
-		return -ENOMEM;
-	old = current_cred();
-
-	retval = -EPERM;
-	if (rgid != (gid_t) -1) {
-		if (gid_eq(old->gid, krgid) ||
-		    gid_eq(old->egid, krgid) ||
-		    ns_capable_setid(old->user_ns, CAP_SETGID))
-			new->gid = krgid;
-		else
-			goto error;
-	}
-	if (egid != (gid_t) -1) {
-		if (gid_eq(old->gid, kegid) ||
-		    gid_eq(old->egid, kegid) ||
-		    gid_eq(old->sgid, kegid) ||
-		    ns_capable_setid(old->user_ns, CAP_SETGID))
-			new->egid = kegid;
-		else
-			goto error;
-	}
-
-	if (rgid != (gid_t) -1 ||
-	    (egid != (gid_t) -1 && !gid_eq(kegid, old->gid)))
-		new->sgid = new->egid;
-	new->fsgid = new->egid;
-
-	retval = security_task_fix_setgid(new, old, LSM_SETID_RE);
-	if (retval < 0)
-		goto error;
-
-	return commit_creds(new);
-
-error:
-	abort_creds(new);
-	return retval;
-}
-
-SYSCALL_DEFINE2(setregid, gid_t, rgid, gid_t, egid)
-{
-	return __sys_setregid(rgid, egid);
-}
-
-/*
- * setgid() is implemented like SysV w/ SAVED_IDS
- *
- * SMP: Same implicit races as above.
- */
-long __sys_setgid(gid_t gid)
-{
-	struct user_namespace *ns = current_user_ns();
-	const struct cred *old;
-	struct cred *new;
-	int retval;
-	kgid_t kgid;
-
-	kgid = make_kgid(ns, gid);
-	if (!gid_valid(kgid))
-		return -EINVAL;
-
-	new = prepare_creds();
-	if (!new)
-		return -ENOMEM;
-	old = current_cred();
-
-	retval = -EPERM;
-	if (ns_capable_setid(old->user_ns, CAP_SETGID))
-		new->gid = new->egid = new->sgid = new->fsgid = kgid;
-	else if (gid_eq(kgid, old->gid) || gid_eq(kgid, old->sgid))
-		new->egid = new->fsgid = kgid;
-	else
-		goto error;
-
-	retval = security_task_fix_setgid(new, old, LSM_SETID_ID);
-	if (retval < 0)
-		goto error;
-
-	return commit_creds(new);
-
-error:
-	abort_creds(new);
-	return retval;
-}
-
-SYSCALL_DEFINE1(setgid, gid_t, gid)
-{
-	return __sys_setgid(gid);
-}
-
-/*
- * change the user struct in a credentials set to match the new UID
- */
-static int set_user(struct cred *new)
-{
-	struct user_struct *new_user;
-
-	new_user = alloc_uid(new->uid);
-	if (!new_user)
-		return -EAGAIN;
-
-	free_uid(new->user);
-	new->user = new_user;
-	return 0;
-}
-
-static void flag_nproc_exceeded(struct cred *new)
-{
-	if (new->ucounts == current_ucounts())
-		return;
-
-	/*
-	 * We don't fail in case of NPROC limit excess here because too many
-	 * poorly written programs don't check set*uid() return code, assuming
-	 * it never fails if called by root.  We may still enforce NPROC limit
-	 * for programs doing set*uid()+execve() by harmlessly deferring the
-	 * failure to the execve() stage.
-	 */
-	if (is_rlimit_overlimit(new->ucounts, UCOUNT_RLIMIT_NPROC, rlimit(RLIMIT_NPROC)) &&
-			new->user != INIT_USER)
-		current->flags |= PF_NPROC_EXCEEDED;
-	else
-		current->flags &= ~PF_NPROC_EXCEEDED;
-}
-
-/*
- * Unprivileged users may change the real uid to the effective uid
- * or vice versa.  (BSD-style)
- *
- * If you set the real uid at all, or set the effective uid to a value not
- * equal to the real uid, then the saved uid is set to the new effective uid.
- *
- * This makes it possible for a setuid program to completely drop its
- * privileges, which is often a useful assertion to make when you are doing
- * a security audit over a program.
- *
- * The general idea is that a program which uses just setreuid() will be
- * 100% compatible with BSD.  A program which uses just setuid() will be
- * 100% compatible with POSIX with saved IDs.
- */
-long __sys_setreuid(uid_t ruid, uid_t euid)
-{
-	struct user_namespace *ns = current_user_ns();
-	const struct cred *old;
-	struct cred *new;
-	int retval;
-	kuid_t kruid, keuid;
-
-	kruid = make_kuid(ns, ruid);
-	keuid = make_kuid(ns, euid);
-
-	if ((ruid != (uid_t) -1) && !uid_valid(kruid))
-		return -EINVAL;
-	if ((euid != (uid_t) -1) && !uid_valid(keuid))
-		return -EINVAL;
-
-	new = prepare_creds();
-	if (!new)
-		return -ENOMEM;
-	old = current_cred();
-
-	retval = -EPERM;
-	if (ruid != (uid_t) -1) {
-		new->uid = kruid;
-		if (!uid_eq(old->uid, kruid) &&
-		    !uid_eq(old->euid, kruid) &&
-		    !ns_capable_setid(old->user_ns, CAP_SETUID))
-			goto error;
-	}
-
-	if (euid != (uid_t) -1) {
-		new->euid = keuid;
-		if (!uid_eq(old->uid, keuid) &&
-		    !uid_eq(old->euid, keuid) &&
-		    !uid_eq(old->suid, keuid) &&
-		    !ns_capable_setid(old->user_ns, CAP_SETUID))
-			goto error;
-	}
-
-	if (!uid_eq(new->uid, old->uid)) {
-		retval = set_user(new);
-		if (retval < 0)
-			goto error;
-	}
-	if (ruid != (uid_t) -1 ||
-	    (euid != (uid_t) -1 && !uid_eq(keuid, old->uid)))
-		new->suid = new->euid;
-	new->fsuid = new->euid;
-
-	retval = security_task_fix_setuid(new, old, LSM_SETID_RE);
-	if (retval < 0)
-		goto error;
-
-	retval = set_cred_ucounts(new);
-	if (retval < 0)
-		goto error;
-
-	flag_nproc_exceeded(new);
-	return commit_creds(new);
-
-error:
-	abort_creds(new);
-	return retval;
-}
-
-SYSCALL_DEFINE2(setreuid, uid_t, ruid, uid_t, euid)
-{
-	return __sys_setreuid(ruid, euid);
-}
-
-/*
- * setuid() is implemented like SysV with SAVED_IDS
- *
- * Note that SAVED_ID's is deficient in that a setuid root program
- * like sendmail, for example, cannot set its uid to be a normal
- * user and then switch back, because if you're root, setuid() sets
- * the saved uid too.  If you don't like this, blame the bright people
- * in the POSIX committee and/or USG.  Note that the BSD-style setreuid()
- * will allow a root program to temporarily drop privileges and be able to
- * regain them by swapping the real and effective uid.
- */
-long __sys_setuid(uid_t uid)
-{
-	struct user_namespace *ns = current_user_ns();
-	const struct cred *old;
-	struct cred *new;
-	int retval;
-	kuid_t kuid;
-
-	kuid = make_kuid(ns, uid);
-	if (!uid_valid(kuid))
-		return -EINVAL;
-
-	new = prepare_creds();
-	if (!new)
-		return -ENOMEM;
-	old = current_cred();
-
-	retval = -EPERM;
-	if (ns_capable_setid(old->user_ns, CAP_SETUID)) {
-		new->suid = new->uid = kuid;
-		if (!uid_eq(kuid, old->uid)) {
-			retval = set_user(new);
-			if (retval < 0)
-				goto error;
-		}
-	} else if (!uid_eq(kuid, old->uid) && !uid_eq(kuid, new->suid)) {
-		goto error;
-	}
-
-	new->fsuid = new->euid = kuid;
-
-	retval = security_task_fix_setuid(new, old, LSM_SETID_ID);
-	if (retval < 0)
-		goto error;
-
-	retval = set_cred_ucounts(new);
-	if (retval < 0)
-		goto error;
-
-	flag_nproc_exceeded(new);
-	return commit_creds(new);
-
-error:
-	abort_creds(new);
-	return retval;
-}
-
-SYSCALL_DEFINE1(setuid, uid_t, uid)
-{
-	return __sys_setuid(uid);
-}
-
-
-/*
- * This function implements a generic ability to update ruid, euid,
- * and suid.  This allows you to implement the 4.4 compatible seteuid().
- */
-long __sys_setresuid(uid_t ruid, uid_t euid, uid_t suid)
-{
-	struct user_namespace *ns = current_user_ns();
-	const struct cred *old;
-	struct cred *new;
-	int retval;
-	kuid_t kruid, keuid, ksuid;
-	bool ruid_new, euid_new, suid_new;
-
-	kruid = make_kuid(ns, ruid);
-	keuid = make_kuid(ns, euid);
-	ksuid = make_kuid(ns, suid);
-
-	if ((ruid != (uid_t) -1) && !uid_valid(kruid))
-		return -EINVAL;
-
-	if ((euid != (uid_t) -1) && !uid_valid(keuid))
-		return -EINVAL;
-
-	if ((suid != (uid_t) -1) && !uid_valid(ksuid))
-		return -EINVAL;
-
-	old = current_cred();
-
-	/* check for no-op */
-	if ((ruid == (uid_t) -1 || uid_eq(kruid, old->uid)) &&
-	    (euid == (uid_t) -1 || (uid_eq(keuid, old->euid) &&
-				    uid_eq(keuid, old->fsuid))) &&
-	    (suid == (uid_t) -1 || uid_eq(ksuid, old->suid)))
-		return 0;
-
-	ruid_new = ruid != (uid_t) -1        && !uid_eq(kruid, old->uid) &&
-		   !uid_eq(kruid, old->euid) && !uid_eq(kruid, old->suid);
-	euid_new = euid != (uid_t) -1        && !uid_eq(keuid, old->uid) &&
-		   !uid_eq(keuid, old->euid) && !uid_eq(keuid, old->suid);
-	suid_new = suid != (uid_t) -1        && !uid_eq(ksuid, old->uid) &&
-		   !uid_eq(ksuid, old->euid) && !uid_eq(ksuid, old->suid);
-	if ((ruid_new || euid_new || suid_new) &&
-	    !ns_capable_setid(old->user_ns, CAP_SETUID))
-		return -EPERM;
-
-	new = prepare_creds();
-	if (!new)
-		return -ENOMEM;
-
-	if (ruid != (uid_t) -1) {
-		new->uid = kruid;
-		if (!uid_eq(kruid, old->uid)) {
-			retval = set_user(new);
-			if (retval < 0)
-				goto error;
-		}
-	}
-	if (euid != (uid_t) -1)
-		new->euid = keuid;
-	if (suid != (uid_t) -1)
-		new->suid = ksuid;
-	new->fsuid = new->euid;
-
-	retval = security_task_fix_setuid(new, old, LSM_SETID_RES);
-	if (retval < 0)
-		goto error;
-
-	retval = set_cred_ucounts(new);
-	if (retval < 0)
-		goto error;
-
-	flag_nproc_exceeded(new);
-	return commit_creds(new);
-
-error:
-	abort_creds(new);
-	return retval;
-}
-
-SYSCALL_DEFINE3(setresuid, uid_t, ruid, uid_t, euid, uid_t, suid)
-{
-	return __sys_setresuid(ruid, euid, suid);
-}
-
-SYSCALL_DEFINE3(getresuid, uid_t __user *, ruidp, uid_t __user *, euidp, uid_t __user *, suidp)
-{
-	const struct cred *cred = current_cred();
-	int retval;
-	uid_t ruid, euid, suid;
-
-	ruid = from_kuid_munged(cred->user_ns, cred->uid);
-	euid = from_kuid_munged(cred->user_ns, cred->euid);
-	suid = from_kuid_munged(cred->user_ns, cred->suid);
-
-	retval = put_user(ruid, ruidp);
-	if (!retval) {
-		retval = put_user(euid, euidp);
-		if (!retval)
-			return put_user(suid, suidp);
-	}
-	return retval;
-}
-
-/*
- * Same as above, but for rgid, egid, sgid.
- */
-long __sys_setresgid(gid_t rgid, gid_t egid, gid_t sgid)
-{
-	struct user_namespace *ns = current_user_ns();
-	const struct cred *old;
-	struct cred *new;
-	int retval;
-	kgid_t krgid, kegid, ksgid;
-	bool rgid_new, egid_new, sgid_new;
-
-	krgid = make_kgid(ns, rgid);
-	kegid = make_kgid(ns, egid);
-	ksgid = make_kgid(ns, sgid);
-
-	if ((rgid != (gid_t) -1) && !gid_valid(krgid))
-		return -EINVAL;
-	if ((egid != (gid_t) -1) && !gid_valid(kegid))
-		return -EINVAL;
-	if ((sgid != (gid_t) -1) && !gid_valid(ksgid))
-		return -EINVAL;
-
-	old = current_cred();
-
-	/* check for no-op */
-	if ((rgid == (gid_t) -1 || gid_eq(krgid, old->gid)) &&
-	    (egid == (gid_t) -1 || (gid_eq(kegid, old->egid) &&
-				    gid_eq(kegid, old->fsgid))) &&
-	    (sgid == (gid_t) -1 || gid_eq(ksgid, old->sgid)))
-		return 0;
-
-	rgid_new = rgid != (gid_t) -1        && !gid_eq(krgid, old->gid) &&
-		   !gid_eq(krgid, old->egid) && !gid_eq(krgid, old->sgid);
-	egid_new = egid != (gid_t) -1        && !gid_eq(kegid, old->gid) &&
-		   !gid_eq(kegid, old->egid) && !gid_eq(kegid, old->sgid);
-	sgid_new = sgid != (gid_t) -1        && !gid_eq(ksgid, old->gid) &&
-		   !gid_eq(ksgid, old->egid) && !gid_eq(ksgid, old->sgid);
-	if ((rgid_new || egid_new || sgid_new) &&
-	    !ns_capable_setid(old->user_ns, CAP_SETGID))
-		return -EPERM;
-
-	new = prepare_creds();
-	if (!new)
-		return -ENOMEM;
-
-	if (rgid != (gid_t) -1)
-		new->gid = krgid;
-	if (egid != (gid_t) -1)
-		new->egid = kegid;
-	if (sgid != (gid_t) -1)
-		new->sgid = ksgid;
-	new->fsgid = new->egid;
-
-	retval = security_task_fix_setgid(new, old, LSM_SETID_RES);
-	if (retval < 0)
-		goto error;
-
-	return commit_creds(new);
-
-error:
-	abort_creds(new);
-	return retval;
-}
-
-SYSCALL_DEFINE3(setresgid, gid_t, rgid, gid_t, egid, gid_t, sgid)
-{
-	return __sys_setresgid(rgid, egid, sgid);
-}
-
-SYSCALL_DEFINE3(getresgid, gid_t __user *, rgidp, gid_t __user *, egidp, gid_t __user *, sgidp)
-{
-	const struct cred *cred = current_cred();
-	int retval;
-	gid_t rgid, egid, sgid;
-
-	rgid = from_kgid_munged(cred->user_ns, cred->gid);
-	egid = from_kgid_munged(cred->user_ns, cred->egid);
-	sgid = from_kgid_munged(cred->user_ns, cred->sgid);
-
-	retval = put_user(rgid, rgidp);
-	if (!retval) {
-		retval = put_user(egid, egidp);
-		if (!retval)
-			retval = put_user(sgid, sgidp);
-	}
-
-	return retval;
-}
-
-
-/*
- * "setfsuid()" sets the fsuid - the uid used for filesystem checks. This
- * is used for "access()" and for the NFS daemon (letting nfsd stay at
- * whatever uid it wants to). It normally shadows "euid", except when
- * explicitly set by setfsuid() or for access..
- */
-long __sys_setfsuid(uid_t uid)
-{
-	const struct cred *old;
-	struct cred *new;
-	uid_t old_fsuid;
-	kuid_t kuid;
-
-	old = current_cred();
-	old_fsuid = from_kuid_munged(old->user_ns, old->fsuid);
-
-	kuid = make_kuid(old->user_ns, uid);
-	if (!uid_valid(kuid))
-		return old_fsuid;
-
-	new = prepare_creds();
-	if (!new)
-		return old_fsuid;
-
-	if (uid_eq(kuid, old->uid)  || uid_eq(kuid, old->euid)  ||
-	    uid_eq(kuid, old->suid) || uid_eq(kuid, old->fsuid) ||
-	    ns_capable_setid(old->user_ns, CAP_SETUID)) {
-		if (!uid_eq(kuid, old->fsuid)) {
-			new->fsuid = kuid;
-			if (security_task_fix_setuid(new, old, LSM_SETID_FS) == 0)
-				goto change_okay;
-		}
-	}
-
-	abort_creds(new);
-	return old_fsuid;
-
-change_okay:
-	commit_creds(new);
-	return old_fsuid;
-}
-
-SYSCALL_DEFINE1(setfsuid, uid_t, uid)
-{
-	return __sys_setfsuid(uid);
-}
-
-/*
- * Samma p svenska..
- */
-long __sys_setfsgid(gid_t gid)
-{
-	const struct cred *old;
-	struct cred *new;
-	gid_t old_fsgid;
-	kgid_t kgid;
-
-	old = current_cred();
-	old_fsgid = from_kgid_munged(old->user_ns, old->fsgid);
-
-	kgid = make_kgid(old->user_ns, gid);
-	if (!gid_valid(kgid))
-		return old_fsgid;
-
-	new = prepare_creds();
-	if (!new)
-		return old_fsgid;
-
-	if (gid_eq(kgid, old->gid)  || gid_eq(kgid, old->egid)  ||
-	    gid_eq(kgid, old->sgid) || gid_eq(kgid, old->fsgid) ||
-	    ns_capable_setid(old->user_ns, CAP_SETGID)) {
-		if (!gid_eq(kgid, old->fsgid)) {
-			new->fsgid = kgid;
-			if (security_task_fix_setgid(new,old,LSM_SETID_FS) == 0)
-				goto change_okay;
-		}
-	}
-
-	abort_creds(new);
-	return old_fsgid;
-
-change_okay:
-	commit_creds(new);
-	return old_fsgid;
-}
-
-SYSCALL_DEFINE1(setfsgid, gid_t, gid)
-{
-	return __sys_setfsgid(gid);
-}
-#endif /* CONFIG_MULTIUSER */
-
-/**
- * sys_getpid - return the thread group id of the current process
- *
- * Note, despite the name, this returns the tgid not the pid.  The tgid and
- * the pid are identical unless CLONE_THREAD was specified on clone() in
- * which case the tgid is the same in all threads of the same group.
- *
- * This is SMP safe as current->tgid does not change.
- */
-SYSCALL_DEFINE0(getpid)
-{
-	return task_tgid_vnr(current);
-}
-
-/* Thread ID - the internal kernel "pid" */
-SYSCALL_DEFINE0(gettid)
-{
-	return task_pid_vnr(current);
-}
-
-/*
- * Accessing ->real_parent is not SMP-safe, it could
- * change from under us. However, we can use a stale
- * value of ->real_parent under rcu_read_lock(), see
- * release_task()->call_rcu(delayed_put_task_struct).
- */
-SYSCALL_DEFINE0(getppid)
-{
-	int pid;
-
-	rcu_read_lock();
-	pid = task_tgid_vnr(rcu_dereference(current->real_parent));
-	rcu_read_unlock();
-
-	return pid;
-}
-
-SYSCALL_DEFINE0(getuid)
-{
-	/* Only we change this so SMP safe */
-	return from_kuid_munged(current_user_ns(), current_uid());
-}
-
-SYSCALL_DEFINE0(geteuid)
-{
-	/* Only we change this so SMP safe */
-	return from_kuid_munged(current_user_ns(), current_euid());
-}
-
-SYSCALL_DEFINE0(getgid)
-{
-	/* Only we change this so SMP safe */
-	return from_kgid_munged(current_user_ns(), current_gid());
-}
-
-SYSCALL_DEFINE0(getegid)
-{
-	/* Only we change this so SMP safe */
-	return from_kgid_munged(current_user_ns(), current_egid());
-}
-
-static void do_sys_times(struct tms *tms)
-{
-	u64 tgutime, tgstime, cutime, cstime;
-
-	thread_group_cputime_adjusted(current, &tgutime, &tgstime);
-	cutime = current->signal->cutime;
-	cstime = current->signal->cstime;
-	tms->tms_utime = nsec_to_clock_t(tgutime);
-	tms->tms_stime = nsec_to_clock_t(tgstime);
-	tms->tms_cutime = nsec_to_clock_t(cutime);
-	tms->tms_cstime = nsec_to_clock_t(cstime);
-}
-
-SYSCALL_DEFINE1(times, struct tms __user *, tbuf)
-{
-	if (tbuf) {
-		struct tms tmp;
-
-		do_sys_times(&tmp);
-		if (copy_to_user(tbuf, &tmp, sizeof(struct tms)))
-			return -EFAULT;
-	}
-	force_successful_syscall_return();
-	return (long) jiffies_64_to_clock_t(get_jiffies_64());
-}
-
-#ifdef CONFIG_COMPAT
-static compat_clock_t clock_t_to_compat_clock_t(clock_t x)
-{
-	return compat_jiffies_to_clock_t(clock_t_to_jiffies(x));
-}
-
-COMPAT_SYSCALL_DEFINE1(times, struct compat_tms __user *, tbuf)
-{
-	if (tbuf) {
-		struct tms tms;
-		struct compat_tms tmp;
-
-		do_sys_times(&tms);
-		/* Convert our struct tms to the compat version. */
-		tmp.tms_utime = clock_t_to_compat_clock_t(tms.tms_utime);
-		tmp.tms_stime = clock_t_to_compat_clock_t(tms.tms_stime);
-		tmp.tms_cutime = clock_t_to_compat_clock_t(tms.tms_cutime);
-		tmp.tms_cstime = clock_t_to_compat_clock_t(tms.tms_cstime);
-		if (copy_to_user(tbuf, &tmp, sizeof(tmp)))
-			return -EFAULT;
-	}
-	force_successful_syscall_return();
-	return compat_jiffies_to_clock_t(jiffies);
-}
-#endif
-
-/*
- * This needs some heavy checking ...
- * I just haven't the stomach for it. I also don't fully
- * understand sessions/pgrp etc. Let somebody who does explain it.
- *
- * OK, I think I have the protection semantics right.... this is really
- * only important on a multi-user system anyway, to make sure one user
- * can't send a signal to a process owned by another.  -TYT, 12/12/91
- *
- * !PF_FORKNOEXEC check to conform completely to POSIX.
- */
-SYSCALL_DEFINE2(setpgid, pid_t, pid, pid_t, pgid)
-{
-	struct task_struct *p;
-	struct task_struct *group_leader = current->group_leader;
-	struct pid *pids[PIDTYPE_MAX] = { 0 };
-	struct pid *pgrp;
-	int err;
-
-	if (!pid)
-		pid = task_pid_vnr(group_leader);
-	if (!pgid)
-		pgid = pid;
-	if (pgid < 0)
-		return -EINVAL;
-	rcu_read_lock();
-
-	/* From this point forward we keep holding onto the tasklist lock
-	 * so that our parent does not change from under us. -DaveM
-	 */
-	write_lock_irq(&tasklist_lock);
-
-	err = -ESRCH;
-	p = find_task_by_vpid(pid);
-	if (!p)
-		goto out;
-
-	err = -EINVAL;
-	if (!thread_group_leader(p))
-		goto out;
-
-	if (same_thread_group(p->real_parent, group_leader)) {
-		err = -EPERM;
-		if (task_session(p) != task_session(group_leader))
-			goto out;
-		err = -EACCES;
-		if (!(p->flags & PF_FORKNOEXEC))
-			goto out;
-	} else {
-		err = -ESRCH;
-		if (p != group_leader)
-			goto out;
-	}
-
-	err = -EPERM;
-	if (p->signal->leader)
-		goto out;
-
-	pgrp = task_pid(p);
-	if (pgid != pid) {
-		struct task_struct *g;
-
-		pgrp = find_vpid(pgid);
-		g = pid_task(pgrp, PIDTYPE_PGID);
-		if (!g || task_session(g) != task_session(group_leader))
-			goto out;
-	}
-
-	err = security_task_setpgid(p, pgid);
-	if (err)
-		goto out;
-
-	if (task_pgrp(p) != pgrp)
-		change_pid(pids, p, PIDTYPE_PGID, pgrp);
-
-	err = 0;
-out:
-	/* All paths lead to here, thus we are safe. -DaveM */
-	write_unlock_irq(&tasklist_lock);
-	rcu_read_unlock();
-	free_pids(pids);
-	return err;
-}
-
-static int do_getpgid(pid_t pid)
-{
-	struct task_struct *p;
-	struct pid *grp;
-	int retval;
-
-	rcu_read_lock();
-	if (!pid)
-		grp = task_pgrp(current);
-	else {
-		retval = -ESRCH;
-		p = find_task_by_vpid(pid);
-		if (!p)
-			goto out;
-		grp = task_pgrp(p);
-		if (!grp)
-			goto out;
-
-		retval = security_task_getpgid(p);
-		if (retval)
-			goto out;
-	}
-	retval = pid_vnr(grp);
-out:
-	rcu_read_unlock();
-	return retval;
-}
-
-SYSCALL_DEFINE1(getpgid, pid_t, pid)
-{
-	return do_getpgid(pid);
-}
-
-#ifdef __ARCH_WANT_SYS_GETPGRP
-
-SYSCALL_DEFINE0(getpgrp)
-{
-	return do_getpgid(0);
-}
-
-#endif
-
-SYSCALL_DEFINE1(getsid, pid_t, pid)
-{
-	struct task_struct *p;
-	struct pid *sid;
-	int retval;
-
-	rcu_read_lock();
-	if (!pid)
-		sid = task_session(current);
-	else {
-		retval = -ESRCH;
-		p = find_task_by_vpid(pid);
-		if (!p)
-			goto out;
-		sid = task_session(p);
-		if (!sid)
-			goto out;
-
-		retval = security_task_getsid(p);
-		if (retval)
-			goto out;
-	}
-	retval = pid_vnr(sid);
-out:
-	rcu_read_unlock();
-	return retval;
-}
-
-static void set_special_pids(struct pid **pids, struct pid *pid)
-{
-	struct task_struct *curr = current->group_leader;
-
-	if (task_session(curr) != pid)
-		change_pid(pids, curr, PIDTYPE_SID, pid);
-
-	if (task_pgrp(curr) != pid)
-		change_pid(pids, curr, PIDTYPE_PGID, pid);
-}
-
-int ksys_setsid(void)
-{
-	struct task_struct *group_leader = current->group_leader;
-	struct pid *sid = task_pid(group_leader);
-	struct pid *pids[PIDTYPE_MAX] = { 0 };
-	pid_t session = pid_vnr(sid);
-	int err = -EPERM;
-
-	write_lock_irq(&tasklist_lock);
-	/* Fail if I am already a session leader */
-	if (group_leader->signal->leader)
-		goto out;
-
-	/* Fail if a process group id already exists that equals the
-	 * proposed session id.
-	 */
-	if (pid_task(sid, PIDTYPE_PGID))
-		goto out;
-
-	group_leader->signal->leader = 1;
-	set_special_pids(pids, sid);
-
-	proc_clear_tty(group_leader);
-
-	err = session;
-out:
-	write_unlock_irq(&tasklist_lock);
-	free_pids(pids);
-	if (err > 0) {
-		proc_sid_connector(group_leader);
-		sched_autogroup_create_attach(group_leader);
-	}
-	return err;
-}
-
-SYSCALL_DEFINE0(setsid)
-{
-	return ksys_setsid();
-}
-
-DECLARE_RWSEM(uts_sem);
-
-#ifdef COMPAT_UTS_MACHINE
-#define override_architecture(name) \
-	(personality(current->personality) == PER_LINUX32 && \
-	 copy_to_user(name->machine, COMPAT_UTS_MACHINE, \
-		      sizeof(COMPAT_UTS_MACHINE)))
-#else
-#define override_architecture(name)	0
-#endif
-
-/*
- * Work around broken programs that cannot handle "Linux 3.0".
- * Instead we map 3.x to 2.6.40+x, so e.g. 3.0 would be 2.6.40
- * And we map 4.x and later versions to 2.6.60+x, so 4.0/5.0/6.0/... would be
- * 2.6.60.
- */
-static int override_release(char __user *release, size_t len)
-{
-	int ret = 0;
-
-	if (current->personality & UNAME26) {
-		const char *rest = UTS_RELEASE;
-		char buf[65] = { 0 };
-		int ndots = 0;
-		unsigned v;
-		size_t copy;
-
-		while (*rest) {
-			if (*rest == '.' && ++ndots >= 3)
-				break;
-			if (!isdigit(*rest) && *rest != '.')
-				break;
-			rest++;
-		}
-		v = LINUX_VERSION_PATCHLEVEL + 60;
-		copy = clamp_t(size_t, len, 1, sizeof(buf));
-		copy = scnprintf(buf, copy, "2.6.%u%s", v, rest);
-		ret = copy_to_user(release, buf, copy + 1);
-	}
-	return ret;
-}
-
-SYSCALL_DEFINE1(newuname, struct new_utsname __user *, name)
-{
-	struct new_utsname tmp;
-
-	down_read(&uts_sem);
-	memcpy(&tmp, utsname(), sizeof(tmp));
-	up_read(&uts_sem);
-	if (copy_to_user(name, &tmp, sizeof(tmp)))
-		return -EFAULT;
-
-	if (override_release(name->release, sizeof(name->release)))
-		return -EFAULT;
-	if (override_architecture(name))
-		return -EFAULT;
-	return 0;
-}
-
-#ifdef __ARCH_WANT_SYS_OLD_UNAME
-/*
- * Old cruft
- */
-SYSCALL_DEFINE1(uname, struct old_utsname __user *, name)
-{
-	struct old_utsname tmp;
-
-	if (!name)
-		return -EFAULT;
-
-	down_read(&uts_sem);
-	memcpy(&tmp, utsname(), sizeof(tmp));
-	up_read(&uts_sem);
-	if (copy_to_user(name, &tmp, sizeof(tmp)))
-		return -EFAULT;
-
-	if (override_release(name->release, sizeof(name->release)))
-		return -EFAULT;
-	if (override_architecture(name))
-		return -EFAULT;
-	return 0;
-}
-
-SYSCALL_DEFINE1(olduname, struct oldold_utsname __user *, name)
-{
-	struct oldold_utsname tmp;
-
-	if (!name)
-		return -EFAULT;
-
-	memset(&tmp, 0, sizeof(tmp));
-
-	down_read(&uts_sem);
-	memcpy(&tmp.sysname, &utsname()->sysname, __OLD_UTS_LEN);
-	memcpy(&tmp.nodename, &utsname()->nodename, __OLD_UTS_LEN);
-	memcpy(&tmp.release, &utsname()->release, __OLD_UTS_LEN);
-	memcpy(&tmp.version, &utsname()->version, __OLD_UTS_LEN);
-	memcpy(&tmp.machine, &utsname()->machine, __OLD_UTS_LEN);
-	up_read(&uts_sem);
-	if (copy_to_user(name, &tmp, sizeof(tmp)))
-		return -EFAULT;
-
-	if (override_architecture(name))
-		return -EFAULT;
-	if (override_release(name->release, sizeof(name->release)))
-		return -EFAULT;
-	return 0;
-}
-#endif
-
-SYSCALL_DEFINE2(sethostname, char __user *, name, int, len)
-{
-	int errno;
-	char tmp[__NEW_UTS_LEN];
-
-	if (!ns_capable(current->nsproxy->uts_ns->user_ns, CAP_SYS_ADMIN))
-		return -EPERM;
-
-	if (len < 0 || len > __NEW_UTS_LEN)
-		return -EINVAL;
-	errno = -EFAULT;
-	if (!copy_from_user(tmp, name, len)) {
-		struct new_utsname *u;
-
-		add_device_randomness(tmp, len);
-		down_write(&uts_sem);
-		u = utsname();
-		memcpy(u->nodename, tmp, len);
-		memset(u->nodename + len, 0, sizeof(u->nodename) - len);
-		errno = 0;
-		uts_proc_notify(UTS_PROC_HOSTNAME);
-		up_write(&uts_sem);
-	}
-	return errno;
-}
-
-#ifdef __ARCH_WANT_SYS_GETHOSTNAME
-
-SYSCALL_DEFINE2(gethostname, char __user *, name, int, len)
-{
-	int i;
-	struct new_utsname *u;
-	char tmp[__NEW_UTS_LEN + 1];
-
-	if (len < 0)
-		return -EINVAL;
-	down_read(&uts_sem);
-	u = utsname();
-	i = 1 + strlen(u->nodename);
-	if (i > len)
-		i = len;
-	memcpy(tmp, u->nodename, i);
-	up_read(&uts_sem);
-	if (copy_to_user(name, tmp, i))
-		return -EFAULT;
-	return 0;
-}
-
-#endif
-
-/*
- * Only setdomainname; getdomainname can be implemented by calling
- * uname()
- */
-SYSCALL_DEFINE2(setdomainname, char __user *, name, int, len)
-{
-	int errno;
-	char tmp[__NEW_UTS_LEN];
-
-	if (!ns_capable(current->nsproxy->uts_ns->user_ns, CAP_SYS_ADMIN))
-		return -EPERM;
-	if (len < 0 || len > __NEW_UTS_LEN)
-		return -EINVAL;
-
-	errno = -EFAULT;
-	if (!copy_from_user(tmp, name, len)) {
-		struct new_utsname *u;
-
-		add_device_randomness(tmp, len);
-		down_write(&uts_sem);
-		u = utsname();
-		memcpy(u->domainname, tmp, len);
-		memset(u->domainname + len, 0, sizeof(u->domainname) - len);
-		errno = 0;
-		uts_proc_notify(UTS_PROC_DOMAINNAME);
-		up_write(&uts_sem);
-	}
-	return errno;
-}
-
-/* make sure you are allowed to change @tsk limits before calling this */
-static int do_prlimit(struct task_struct *tsk, unsigned int resource,
-		      struct rlimit *new_rlim, struct rlimit *old_rlim)
-{
-	struct rlimit *rlim;
-	int retval = 0;
-
-	if (resource >= RLIM_NLIMITS)
-		return -EINVAL;
-	resource = array_index_nospec(resource, RLIM_NLIMITS);
-
-	if (new_rlim) {
-		if (new_rlim->rlim_cur > new_rlim->rlim_max)
-			return -EINVAL;
-		if (resource == RLIMIT_NOFILE &&
-				new_rlim->rlim_max > sysctl_nr_open)
-			return -EPERM;
-	}
-
-	/* Holding a refcount on tsk protects tsk->signal from disappearing. */
-	rlim = tsk->signal->rlim + resource;
-	task_lock(tsk->group_leader);
-	if (new_rlim) {
-		/*
-		 * Keep the capable check against init_user_ns until cgroups can
-		 * contain all limits.
-		 */
-		if (new_rlim->rlim_max > rlim->rlim_max &&
-				!capable(CAP_SYS_RESOURCE))
-			retval = -EPERM;
-		if (!retval)
-			retval = security_task_setrlimit(tsk, resource, new_rlim);
-	}
-	if (!retval) {
-		if (old_rlim)
-			*old_rlim = *rlim;
-		if (new_rlim)
-			*rlim = *new_rlim;
-	}
-	task_unlock(tsk->group_leader);
-
-	/*
-	 * RLIMIT_CPU handling. Arm the posix CPU timer if the limit is not
-	 * infinite. In case of RLIM_INFINITY the posix CPU timer code
-	 * ignores the rlimit.
-	 */
-	if (!retval && new_rlim && resource == RLIMIT_CPU &&
-	    new_rlim->rlim_cur != RLIM_INFINITY &&
-	    IS_ENABLED(CONFIG_POSIX_TIMERS)) {
-		/*
-		 * update_rlimit_cpu can fail if the task is exiting, but there
-		 * may be other tasks in the thread group that are not exiting,
-		 * and they need their cpu timers adjusted.
-		 *
-		 * The group_leader is the last task to be released, so if we
-		 * cannot update_rlimit_cpu on it, then the entire process is
-		 * exiting and we do not need to update at all.
-		 */
-		update_rlimit_cpu(tsk->group_leader, new_rlim->rlim_cur);
-	}
-
-	return retval;
-}
-
-SYSCALL_DEFINE2(getrlimit, unsigned int, resource, struct rlimit __user *, rlim)
-{
-	struct rlimit value;
-	int ret;
-
-	ret = do_prlimit(current, resource, NULL, &value);
-	if (!ret)
-		ret = copy_to_user(rlim, &value, sizeof(*rlim)) ? -EFAULT : 0;
-
-	return ret;
-}
-
-#ifdef CONFIG_COMPAT
-
-COMPAT_SYSCALL_DEFINE2(setrlimit, unsigned int, resource,
-		       struct compat_rlimit __user *, rlim)
-{
-	struct rlimit r;
-	struct compat_rlimit r32;
-
-	if (copy_from_user(&r32, rlim, sizeof(struct compat_rlimit)))
-		return -EFAULT;
-
-	if (r32.rlim_cur == COMPAT_RLIM_INFINITY)
-		r.rlim_cur = RLIM_INFINITY;
-	else
-		r.rlim_cur = r32.rlim_cur;
-	if (r32.rlim_max == COMPAT_RLIM_INFINITY)
-		r.rlim_max = RLIM_INFINITY;
-	else
-		r.rlim_max = r32.rlim_max;
-	return do_prlimit(current, resource, &r, NULL);
-}
-
-COMPAT_SYSCALL_DEFINE2(getrlimit, unsigned int, resource,
-		       struct compat_rlimit __user *, rlim)
-{
-	struct rlimit r;
-	int ret;
-
-	ret = do_prlimit(current, resource, NULL, &r);
-	if (!ret) {
-		struct compat_rlimit r32;
-		if (r.rlim_cur > COMPAT_RLIM_INFINITY)
-			r32.rlim_cur = COMPAT_RLIM_INFINITY;
-		else
-			r32.rlim_cur = r.rlim_cur;
-		if (r.rlim_max > COMPAT_RLIM_INFINITY)
-			r32.rlim_max = COMPAT_RLIM_INFINITY;
-		else
-			r32.rlim_max = r.rlim_max;
-
-		if (copy_to_user(rlim, &r32, sizeof(struct compat_rlimit)))
-			return -EFAULT;
-	}
-	return ret;
-}
-
-#endif
-
-#ifdef __ARCH_WANT_SYS_OLD_GETRLIMIT
-
-/*
- *	Back compatibility for getrlimit. Needed for some apps.
- */
-SYSCALL_DEFINE2(old_getrlimit, unsigned int, resource,
-		struct rlimit __user *, rlim)
-{
-	struct rlimit x;
-	if (resource >= RLIM_NLIMITS)
-		return -EINVAL;
-
-	resource = array_index_nospec(resource, RLIM_NLIMITS);
-	task_lock(current->group_leader);
-	x = current->signal->rlim[resource];
-	task_unlock(current->group_leader);
-	if (x.rlim_cur > 0x7FFFFFFF)
-		x.rlim_cur = 0x7FFFFFFF;
-	if (x.rlim_max > 0x7FFFFFFF)
-		x.rlim_max = 0x7FFFFFFF;
-	return copy_to_user(rlim, &x, sizeof(x)) ? -EFAULT : 0;
-}
-
-#ifdef CONFIG_COMPAT
-COMPAT_SYSCALL_DEFINE2(old_getrlimit, unsigned int, resource,
-		       struct compat_rlimit __user *, rlim)
-{
-	struct rlimit r;
-
-	if (resource >= RLIM_NLIMITS)
-		return -EINVAL;
-
-	resource = array_index_nospec(resource, RLIM_NLIMITS);
-	task_lock(current->group_leader);
-	r = current->signal->rlim[resource];
-	task_unlock(current->group_leader);
-	if (r.rlim_cur > 0x7FFFFFFF)
-		r.rlim_cur = 0x7FFFFFFF;
-	if (r.rlim_max > 0x7FFFFFFF)
-		r.rlim_max = 0x7FFFFFFF;
-
-	if (put_user(r.rlim_cur, &rlim->rlim_cur) ||
-	    put_user(r.rlim_max, &rlim->rlim_max))
-		return -EFAULT;
-	return 0;
-}
-#endif
-
-#endif
-
-static inline bool rlim64_is_infinity(__u64 rlim64)
-{
-#if BITS_PER_LONG < 64
-	return rlim64 >= ULONG_MAX;
-#else
-	return rlim64 == RLIM64_INFINITY;
-#endif
-}
-
-static void rlim_to_rlim64(const struct rlimit *rlim, struct rlimit64 *rlim64)
-{
-	if (rlim->rlim_cur == RLIM_INFINITY)
-		rlim64->rlim_cur = RLIM64_INFINITY;
-	else
-		rlim64->rlim_cur = rlim->rlim_cur;
-	if (rlim->rlim_max == RLIM_INFINITY)
-		rlim64->rlim_max = RLIM64_INFINITY;
-	else
-		rlim64->rlim_max = rlim->rlim_max;
-}
-
-static void rlim64_to_rlim(const struct rlimit64 *rlim64, struct rlimit *rlim)
-{
-	if (rlim64_is_infinity(rlim64->rlim_cur))
-		rlim->rlim_cur = RLIM_INFINITY;
-	else
-		rlim->rlim_cur = (unsigned long)rlim64->rlim_cur;
-	if (rlim64_is_infinity(rlim64->rlim_max))
-		rlim->rlim_max = RLIM_INFINITY;
-	else
-		rlim->rlim_max = (unsigned long)rlim64->rlim_max;
-}
-
-/* rcu lock must be held */
-static int check_prlimit_permission(struct task_struct *task,
-				    unsigned int flags)
-{
-	const struct cred *cred = current_cred(), *tcred;
-	bool id_match;
-
-	if (current == task)
-		return 0;
-
-	tcred = __task_cred(task);
-	id_match = (uid_eq(cred->uid, tcred->euid) &&
-		    uid_eq(cred->uid, tcred->suid) &&
-		    uid_eq(cred->uid, tcred->uid)  &&
-		    gid_eq(cred->gid, tcred->egid) &&
-		    gid_eq(cred->gid, tcred->sgid) &&
-		    gid_eq(cred->gid, tcred->gid));
-	if (!id_match && !ns_capable(tcred->user_ns, CAP_SYS_RESOURCE))
-		return -EPERM;
-
-	return security_task_prlimit(cred, tcred, flags);
-}
-
-SYSCALL_DEFINE4(prlimit64, pid_t, pid, unsigned int, resource,
-		const struct rlimit64 __user *, new_rlim,
-		struct rlimit64 __user *, old_rlim)
-{
-	struct rlimit64 old64, new64;
-	struct rlimit old, new;
-	struct task_struct *tsk;
-	unsigned int checkflags = 0;
-	int ret;
-
-	if (old_rlim)
-		checkflags |= LSM_PRLIMIT_READ;
-
-	if (new_rlim) {
-		if (copy_from_user(&new64, new_rlim, sizeof(new64)))
-			return -EFAULT;
-		rlim64_to_rlim(&new64, &new);
-		checkflags |= LSM_PRLIMIT_WRITE;
-	}
-
-	rcu_read_lock();
-	tsk = pid ? find_task_by_vpid(pid) : current;
-	if (!tsk) {
-		rcu_read_unlock();
-		return -ESRCH;
-	}
-	ret = check_prlimit_permission(tsk, checkflags);
-	if (ret) {
-		rcu_read_unlock();
-		return ret;
-	}
-	get_task_struct(tsk);
-	rcu_read_unlock();
-
-	ret = do_prlimit(tsk, resource, new_rlim ? &new : NULL,
-			old_rlim ? &old : NULL);
-
-	if (!ret && old_rlim) {
-		rlim_to_rlim64(&old, &old64);
-		if (copy_to_user(old_rlim, &old64, sizeof(old64)))
-			ret = -EFAULT;
-	}
-
-	put_task_struct(tsk);
-	return ret;
-}
-
-SYSCALL_DEFINE2(setrlimit, unsigned int, resource, struct rlimit __user *, rlim)
-{
-	struct rlimit new_rlim;
-
-	if (copy_from_user(&new_rlim, rlim, sizeof(*rlim)))
-		return -EFAULT;
-	return do_prlimit(current, resource, &new_rlim, NULL);
-}
-
-/*
- * It would make sense to put struct rusage in the task_struct,
- * except that would make the task_struct be *really big*.  After
- * task_struct gets moved into malloc'ed memory, it would
- * make sense to do this.  It will make moving the rest of the information
- * a lot simpler!  (Which we're not doing right now because we're not
- * measuring them yet).
- *
- * When sampling multiple threads for RUSAGE_SELF, under SMP we might have
- * races with threads incrementing their own counters.  But since word
- * reads are atomic, we either get new values or old values and we don't
- * care which for the sums.  We always take the siglock to protect reading
- * the c* fields from p->signal from races with exit.c updating those
- * fields when reaping, so a sample either gets all the additions of a
- * given child after it's reaped, or none so this sample is before reaping.
- *
- * Locking:
- * We need to take the siglock for CHILDEREN, SELF and BOTH
- * for  the cases current multithreaded, non-current single threaded
- * non-current multithreaded.  Thread traversal is now safe with
- * the siglock held.
- * Strictly speaking, we donot need to take the siglock if we are current and
- * single threaded,  as no one else can take our signal_struct away, no one
- * else can  reap the  children to update signal->c* counters, and no one else
- * can race with the signal-> fields. If we do not take any lock, the
- * signal-> fields could be read out of order while another thread was just
- * exiting. So we should  place a read memory barrier when we avoid the lock.
- * On the writer side,  write memory barrier is implied in  __exit_signal
- * as __exit_signal releases  the siglock spinlock after updating the signal->
- * fields. But we don't do this yet to keep things simple.
- *
- */
-
-static void accumulate_thread_rusage(struct task_struct *t, struct rusage *r)
-{
-	r->ru_nvcsw += t->nvcsw;
-	r->ru_nivcsw += t->nivcsw;
-	r->ru_minflt += t->min_flt;
-	r->ru_majflt += t->maj_flt;
-	r->ru_inblock += task_io_get_inblock(t);
-	r->ru_oublock += task_io_get_oublock(t);
-}
-
-void getrusage(struct task_struct *p, int who, struct rusage *r)
-{
-	struct task_struct *t;
-	unsigned long flags;
-	u64 tgutime, tgstime, utime, stime;
-	unsigned long maxrss;
-	struct mm_struct *mm;
-	struct signal_struct *sig = p->signal;
-	unsigned int seq = 0;
-
-retry:
-	memset(r, 0, sizeof(*r));
-	utime = stime = 0;
-	maxrss = 0;
-
-	if (who == RUSAGE_THREAD) {
-		task_cputime_adjusted(current, &utime, &stime);
-		accumulate_thread_rusage(p, r);
-		maxrss = sig->maxrss;
-		goto out_thread;
-	}
-
-	flags = read_seqbegin_or_lock_irqsave(&sig->stats_lock, &seq);
-
-	switch (who) {
-	case RUSAGE_BOTH:
-	case RUSAGE_CHILDREN:
-		utime = sig->cutime;
-		stime = sig->cstime;
-		r->ru_nvcsw = sig->cnvcsw;
-		r->ru_nivcsw = sig->cnivcsw;
-		r->ru_minflt = sig->cmin_flt;
-		r->ru_majflt = sig->cmaj_flt;
-		r->ru_inblock = sig->cinblock;
-		r->ru_oublock = sig->coublock;
-		maxrss = sig->cmaxrss;
-
-		if (who == RUSAGE_CHILDREN)
-			break;
-		fallthrough;
-
-	case RUSAGE_SELF:
-		r->ru_nvcsw += sig->nvcsw;
-		r->ru_nivcsw += sig->nivcsw;
-		r->ru_minflt += sig->min_flt;
-		r->ru_majflt += sig->maj_flt;
-		r->ru_inblock += sig->inblock;
-		r->ru_oublock += sig->oublock;
-		if (maxrss < sig->maxrss)
-			maxrss = sig->maxrss;
-
-		rcu_read_lock();
-		__for_each_thread(sig, t)
-			accumulate_thread_rusage(t, r);
-		rcu_read_unlock();
-
-		break;
-
-	default:
-		BUG();
-	}
-
-	if (need_seqretry(&sig->stats_lock, seq)) {
-		seq = 1;
-		goto retry;
-	}
-	done_seqretry_irqrestore(&sig->stats_lock, seq, flags);
-
-	if (who == RUSAGE_CHILDREN)
-		goto out_children;
-
-	thread_group_cputime_adjusted(p, &tgutime, &tgstime);
-	utime += tgutime;
-	stime += tgstime;
-
-out_thread:
-	mm = get_task_mm(p);
-	if (mm) {
-		setmax_mm_hiwater_rss(&maxrss, mm);
-		mmput(mm);
-	}
-
-out_children:
-	r->ru_maxrss = maxrss * (PAGE_SIZE / 1024); /* convert pages to KBs */
-	r->ru_utime = ns_to_kernel_old_timeval(utime);
-	r->ru_stime = ns_to_kernel_old_timeval(stime);
-}
-
-SYSCALL_DEFINE2(getrusage, int, who, struct rusage __user *, ru)
-{
-	struct rusage r;
-
-	if (who != RUSAGE_SELF && who != RUSAGE_CHILDREN &&
-	    who != RUSAGE_THREAD)
-		return -EINVAL;
-
-	getrusage(current, who, &r);
-	return copy_to_user(ru, &r, sizeof(r)) ? -EFAULT : 0;
-}
-
-#ifdef CONFIG_COMPAT
-COMPAT_SYSCALL_DEFINE2(getrusage, int, who, struct compat_rusage __user *, ru)
-{
-	struct rusage r;
-
-	if (who != RUSAGE_SELF && who != RUSAGE_CHILDREN &&
-	    who != RUSAGE_THREAD)
-		return -EINVAL;
-
-	getrusage(current, who, &r);
-	return put_compat_rusage(&r, ru);
-}
-#endif
-
-SYSCALL_DEFINE1(umask, int, mask)
-{
-	mask = xchg(&current->fs->umask, mask & S_IRWXUGO);
-	return mask;
-}
-
-static int prctl_set_mm_exe_file(struct mm_struct *mm, unsigned int fd)
-{
-	CLASS(fd, exe)(fd);
-	struct inode *inode;
-	int err;
-
-	if (fd_empty(exe))
-		return -EBADF;
-
-	inode = file_inode(fd_file(exe));
-
-	/*
-	 * Because the original mm->exe_file points to executable file, make
-	 * sure that this one is executable as well, to avoid breaking an
-	 * overall picture.
-	 */
-	if (!S_ISREG(inode->i_mode) || path_noexec(&fd_file(exe)->f_path))
-		return -EACCES;
-
-	err = file_permission(fd_file(exe), MAY_EXEC);
-	if (err)
-		return err;
-
-	return replace_mm_exe_file(mm, fd_file(exe));
-}
-
-/*
- * Check arithmetic relations of passed addresses.
- *
- * WARNING: we don't require any capability here so be very careful
- * in what is allowed for modification from userspace.
- */
-static int validate_prctl_map_addr(struct prctl_mm_map *prctl_map)
-{
-	unsigned long mmap_max_addr = TASK_SIZE;
-	int error = -EINVAL, i;
-
-	static const unsigned char offsets[] = {
-		offsetof(struct prctl_mm_map, start_code),
-		offsetof(struct prctl_mm_map, end_code),
-		offsetof(struct prctl_mm_map, start_data),
-		offsetof(struct prctl_mm_map, end_data),
-		offsetof(struct prctl_mm_map, start_brk),
-		offsetof(struct prctl_mm_map, brk),
-		offsetof(struct prctl_mm_map, start_stack),
-		offsetof(struct prctl_mm_map, arg_start),
-		offsetof(struct prctl_mm_map, arg_end),
-		offsetof(struct prctl_mm_map, env_start),
-		offsetof(struct prctl_mm_map, env_end),
-	};
-
-	/*
-	 * Make sure the members are not somewhere outside
-	 * of allowed address space.
-	 */
-	for (i = 0; i < ARRAY_SIZE(offsets); i++) {
-		u64 val = *(u64 *)((char *)prctl_map + offsets[i]);
-
-		if ((unsigned long)val >= mmap_max_addr ||
-		    (unsigned long)val < mmap_min_addr)
-			goto out;
-	}
-
-	/*
-	 * Make sure the pairs are ordered.
-	 */
-#define __prctl_check_order(__m1, __op, __m2)				\
-	((unsigned long)prctl_map->__m1 __op				\
-	 (unsigned long)prctl_map->__m2) ? 0 : -EINVAL
-	error  = __prctl_check_order(start_code, <, end_code);
-	error |= __prctl_check_order(start_data,<=, end_data);
-	error |= __prctl_check_order(start_brk, <=, brk);
-	error |= __prctl_check_order(arg_start, <=, arg_end);
-	error |= __prctl_check_order(env_start, <=, env_end);
-	if (error)
-		goto out;
-#undef __prctl_check_order
-
-	error = -EINVAL;
-
-	/*
-	 * Neither we should allow to override limits if they set.
-	 */
-	if (check_data_rlimit(rlimit(RLIMIT_DATA), prctl_map->brk,
-			      prctl_map->start_brk, prctl_map->end_data,
-			      prctl_map->start_data))
-			goto out;
-
-	error = 0;
-out:
-	return error;
-}
-
-#ifdef CONFIG_CHECKPOINT_RESTORE
-static int prctl_set_mm_map(int opt, const void __user *addr, unsigned long data_size)
-{
-	struct prctl_mm_map prctl_map = { .exe_fd = (u32)-1, };
-	unsigned long user_auxv[AT_VECTOR_SIZE];
-	struct mm_struct *mm = current->mm;
-	int error;
-
-	BUILD_BUG_ON(sizeof(user_auxv) != sizeof(mm->saved_auxv));
-	BUILD_BUG_ON(sizeof(struct prctl_mm_map) > 256);
-
-	if (opt == PR_SET_MM_MAP_SIZE)
-		return put_user((unsigned int)sizeof(prctl_map),
-				(unsigned int __user *)addr);
-
-	if (data_size != sizeof(prctl_map))
-		return -EINVAL;
-
-	if (copy_from_user(&prctl_map, addr, sizeof(prctl_map)))
-		return -EFAULT;
-
-	error = validate_prctl_map_addr(&prctl_map);
-	if (error)
-		return error;
-
-	if (prctl_map.auxv_size) {
-		/*
-		 * Someone is trying to cheat the auxv vector.
-		 */
-		if (!prctl_map.auxv ||
-				prctl_map.auxv_size > sizeof(mm->saved_auxv))
-			return -EINVAL;
-
-		memset(user_auxv, 0, sizeof(user_auxv));
-		if (copy_from_user(user_auxv,
-				   (const void __user *)prctl_map.auxv,
-				   prctl_map.auxv_size))
-			return -EFAULT;
-
-		/* Last entry must be AT_NULL as specification requires */
-		user_auxv[AT_VECTOR_SIZE - 2] = AT_NULL;
-		user_auxv[AT_VECTOR_SIZE - 1] = AT_NULL;
-	}
-
-	if (prctl_map.exe_fd != (u32)-1) {
-		/*
-		 * Check if the current user is checkpoint/restore capable.
-		 * At the time of this writing, it checks for CAP_SYS_ADMIN
-		 * or CAP_CHECKPOINT_RESTORE.
-		 * Note that a user with access to ptrace can masquerade an
-		 * arbitrary program as any executable, even setuid ones.
-		 * This may have implications in the tomoyo subsystem.
-		 */
-		if (!checkpoint_restore_ns_capable(current_user_ns()))
-			return -EPERM;
-
-		error = prctl_set_mm_exe_file(mm, prctl_map.exe_fd);
-		if (error)
-			return error;
-	}
-
-	/*
-	 * arg_lock protects concurrent updates but we still need mmap_lock for
-	 * read to exclude races with sys_brk.
-	 */
-	mmap_read_lock(mm);
-
-	/*
-	 * We don't validate if these members are pointing to
-	 * real present VMAs because application may have correspond
-	 * VMAs already unmapped and kernel uses these members for statistics
-	 * output in procfs mostly, except
-	 *
-	 *  - @start_brk/@brk which are used in do_brk_flags but kernel lookups
-	 *    for VMAs when updating these members so anything wrong written
-	 *    here cause kernel to swear at userspace program but won't lead
-	 *    to any problem in kernel itself
-	 */
-
-	spin_lock(&mm->arg_lock);
-	mm->start_code	= prctl_map.start_code;
-	mm->end_code	= prctl_map.end_code;
-	mm->start_data	= prctl_map.start_data;
-	mm->end_data	= prctl_map.end_data;
-	mm->start_brk	= prctl_map.start_brk;
-	mm->brk		= prctl_map.brk;
-	mm->start_stack	= prctl_map.start_stack;
-	mm->arg_start	= prctl_map.arg_start;
-	mm->arg_end	= prctl_map.arg_end;
-	mm->env_start	= prctl_map.env_start;
-	mm->env_end	= prctl_map.env_end;
-	spin_unlock(&mm->arg_lock);
-
-	/*
-	 * Note this update of @saved_auxv is lockless thus
-	 * if someone reads this member in procfs while we're
-	 * updating -- it may get partly updated results. It's
-	 * known and acceptable trade off: we leave it as is to
-	 * not introduce additional locks here making the kernel
-	 * more complex.
-	 */
-	if (prctl_map.auxv_size)
-		memcpy(mm->saved_auxv, user_auxv, sizeof(user_auxv));
-
-	mmap_read_unlock(mm);
-	return 0;
-}
-#endif /* CONFIG_CHECKPOINT_RESTORE */
-
-static int prctl_set_auxv(struct mm_struct *mm, unsigned long addr,
-			  unsigned long len)
-{
-	/*
-	 * This doesn't move the auxiliary vector itself since it's pinned to
-	 * mm_struct, but it permits filling the vector with new values.  It's
-	 * up to the caller to provide sane values here, otherwise userspace
-	 * tools which use this vector might be unhappy.
-	 */
-	unsigned long user_auxv[AT_VECTOR_SIZE] = {};
-
-	if (len > sizeof(user_auxv))
-		return -EINVAL;
-
-	if (copy_from_user(user_auxv, (const void __user *)addr, len))
-		return -EFAULT;
-
-	/* Make sure the last entry is always AT_NULL */
-	user_auxv[AT_VECTOR_SIZE - 2] = 0;
-	user_auxv[AT_VECTOR_SIZE - 1] = 0;
-
-	BUILD_BUG_ON(sizeof(user_auxv) != sizeof(mm->saved_auxv));
-
-	task_lock(current);
-	memcpy(mm->saved_auxv, user_auxv, len);
-	task_unlock(current);
-
-	return 0;
-}
-
-static int prctl_set_mm(int opt, unsigned long addr,
-			unsigned long arg4, unsigned long arg5)
-{
-	struct mm_struct *mm = current->mm;
-	struct prctl_mm_map prctl_map = {
-		.auxv = NULL,
-		.auxv_size = 0,
-		.exe_fd = -1,
-	};
-	struct vm_area_struct *vma;
-	int error;
-
-	if (arg5 || (arg4 && (opt != PR_SET_MM_AUXV &&
-			      opt != PR_SET_MM_MAP &&
-			      opt != PR_SET_MM_MAP_SIZE)))
-		return -EINVAL;
-
-#ifdef CONFIG_CHECKPOINT_RESTORE
-	if (opt == PR_SET_MM_MAP || opt == PR_SET_MM_MAP_SIZE)
-		return prctl_set_mm_map(opt, (const void __user *)addr, arg4);
-#endif
-
-	if (!capable(CAP_SYS_RESOURCE))
-		return -EPERM;
-
-	if (opt == PR_SET_MM_EXE_FILE)
-		return prctl_set_mm_exe_file(mm, (unsigned int)addr);
-
-	if (opt == PR_SET_MM_AUXV)
-		return prctl_set_auxv(mm, addr, arg4);
-
-	if (addr >= TASK_SIZE || addr < mmap_min_addr)
-		return -EINVAL;
-
-	error = -EINVAL;
-
-	/*
-	 * arg_lock protects concurrent updates of arg boundaries, we need
-	 * mmap_lock for a) concurrent sys_brk, b) finding VMA for addr
-	 * validation.
-	 */
-	mmap_read_lock(mm);
-	vma = find_vma(mm, addr);
-
-	spin_lock(&mm->arg_lock);
-	prctl_map.start_code	= mm->start_code;
-	prctl_map.end_code	= mm->end_code;
-	prctl_map.start_data	= mm->start_data;
-	prctl_map.end_data	= mm->end_data;
-	prctl_map.start_brk	= mm->start_brk;
-	prctl_map.brk		= mm->brk;
-	prctl_map.start_stack	= mm->start_stack;
-	prctl_map.arg_start	= mm->arg_start;
-	prctl_map.arg_end	= mm->arg_end;
-	prctl_map.env_start	= mm->env_start;
-	prctl_map.env_end	= mm->env_end;
-
-	switch (opt) {
-	case PR_SET_MM_START_CODE:
-		prctl_map.start_code = addr;
-		break;
-	case PR_SET_MM_END_CODE:
-		prctl_map.end_code = addr;
-		break;
-	case PR_SET_MM_START_DATA:
-		prctl_map.start_data = addr;
-		break;
-	case PR_SET_MM_END_DATA:
-		prctl_map.end_data = addr;
-		break;
-	case PR_SET_MM_START_STACK:
-		prctl_map.start_stack = addr;
-		break;
-	case PR_SET_MM_START_BRK:
-		prctl_map.start_brk = addr;
-		break;
-	case PR_SET_MM_BRK:
-		prctl_map.brk = addr;
-		break;
-	case PR_SET_MM_ARG_START:
-		prctl_map.arg_start = addr;
-		break;
-	case PR_SET_MM_ARG_END:
-		prctl_map.arg_end = addr;
-		break;
-	case PR_SET_MM_ENV_START:
-		prctl_map.env_start = addr;
-		break;
-	case PR_SET_MM_ENV_END:
-		prctl_map.env_end = addr;
-		break;
-	default:
-		goto out;
-	}
-
-	error = validate_prctl_map_addr(&prctl_map);
-	if (error)
-		goto out;
-
-	switch (opt) {
-	/*
-	 * If command line arguments and environment
-	 * are placed somewhere else on stack, we can
-	 * set them up here, ARG_START/END to setup
-	 * command line arguments and ENV_START/END
-	 * for environment.
-	 */
-	case PR_SET_MM_START_STACK:
-	case PR_SET_MM_ARG_START:
-	case PR_SET_MM_ARG_END:
-	case PR_SET_MM_ENV_START:
-	case PR_SET_MM_ENV_END:
-		if (!vma) {
-			error = -EFAULT;
-			goto out;
-		}
-	}
-
-	mm->start_code	= prctl_map.start_code;
-	mm->end_code	= prctl_map.end_code;
-	mm->start_data	= prctl_map.start_data;
-	mm->end_data	= prctl_map.end_data;
-	mm->start_brk	= prctl_map.start_brk;
-	mm->brk		= prctl_map.brk;
-	mm->start_stack	= prctl_map.start_stack;
-	mm->arg_start	= prctl_map.arg_start;
-	mm->arg_end	= prctl_map.arg_end;
-	mm->env_start	= prctl_map.env_start;
-	mm->env_end	= prctl_map.env_end;
-
-	error = 0;
-out:
-	spin_unlock(&mm->arg_lock);
-	mmap_read_unlock(mm);
-	return error;
-}
-
-#ifdef CONFIG_CHECKPOINT_RESTORE
-static int prctl_get_tid_address(struct task_struct *me, int __user * __user *tid_addr)
-{
-	return put_user(me->clear_child_tid, tid_addr);
-}
-#else
-static int prctl_get_tid_address(struct task_struct *me, int __user * __user *tid_addr)
-{
-	return -EINVAL;
-}
-#endif
-
-static int propagate_has_child_subreaper(struct task_struct *p, void *data)
-{
-	/*
-	 * If task has has_child_subreaper - all its descendants
-	 * already have these flag too and new descendants will
-	 * inherit it on fork, skip them.
-	 *
-	 * If we've found child_reaper - skip descendants in
-	 * it's subtree as they will never get out pidns.
-	 */
-	if (p->signal->has_child_subreaper ||
-	    is_child_reaper(task_pid(p)))
-		return 0;
-
-	p->signal->has_child_subreaper = 1;
-	return 1;
-}
-
-int __weak arch_prctl_spec_ctrl_get(struct task_struct *t, unsigned long which)
-{
-	return -EINVAL;
-}
-
-int __weak arch_prctl_spec_ctrl_set(struct task_struct *t, unsigned long which,
-				    unsigned long ctrl)
-{
-	return -EINVAL;
-}
-
-int __weak arch_get_shadow_stack_status(struct task_struct *t, unsigned long __user *status)
-{
-	return -EINVAL;
-}
-
-int __weak arch_set_shadow_stack_status(struct task_struct *t, unsigned long status)
-{
-	return -EINVAL;
-}
-
-int __weak arch_lock_shadow_stack_status(struct task_struct *t, unsigned long status)
-{
-	return -EINVAL;
-}
-
-#define PR_IO_FLUSHER (PF_MEMALLOC_NOIO | PF_LOCAL_THROTTLE)
-
-#ifdef CONFIG_ANON_VMA_NAME
-
-#define ANON_VMA_NAME_MAX_LEN		80
-#define ANON_VMA_NAME_INVALID_CHARS	"\\`$[]"
-
-static inline bool is_valid_name_char(char ch)
-{
-	/* printable ascii characters, excluding ANON_VMA_NAME_INVALID_CHARS */
-	return ch > 0x1f && ch < 0x7f &&
-		!strchr(ANON_VMA_NAME_INVALID_CHARS, ch);
-}
-
-static int prctl_set_vma(unsigned long opt, unsigned long addr,
-			 unsigned long size, unsigned long arg)
-{
-	struct mm_struct *mm = current->mm;
-	const char __user *uname;
-	struct anon_vma_name *anon_name = NULL;
-	int error;
-
-	switch (opt) {
-	case PR_SET_VMA_ANON_NAME:
-		uname = (const char __user *)arg;
-		if (uname) {
-			char *name, *pch;
-
-			name = strndup_user(uname, ANON_VMA_NAME_MAX_LEN);
-			if (IS_ERR(name))
-				return PTR_ERR(name);
-
-			for (pch = name; *pch != '\0'; pch++) {
-				if (!is_valid_name_char(*pch)) {
-					kfree(name);
-					return -EINVAL;
-				}
-			}
-			/* anon_vma has its own copy */
-			anon_name = anon_vma_name_alloc(name);
-			kfree(name);
-			if (!anon_name)
-				return -ENOMEM;
-
-		}
-
-		mmap_write_lock(mm);
-		error = madvise_set_anon_name(mm, addr, size, anon_name);
-		mmap_write_unlock(mm);
-		anon_vma_name_put(anon_name);
-		break;
-	default:
-		error = -EINVAL;
-	}
-
-	return error;
-}
-
-#else /* CONFIG_ANON_VMA_NAME */
-static int prctl_set_vma(unsigned long opt, unsigned long start,
-			 unsigned long size, unsigned long arg)
-{
-	return -EINVAL;
-}
-#endif /* CONFIG_ANON_VMA_NAME */
-
-static inline unsigned long get_current_mdwe(void)
-{
-	unsigned long ret = 0;
-
-	if (test_bit(MMF_HAS_MDWE, &current->mm->flags))
-		ret |= PR_MDWE_REFUSE_EXEC_GAIN;
-	if (test_bit(MMF_HAS_MDWE_NO_INHERIT, &current->mm->flags))
-		ret |= PR_MDWE_NO_INHERIT;
-
-	return ret;
-}
-
-static inline int prctl_set_mdwe(unsigned long bits, unsigned long arg3,
-				 unsigned long arg4, unsigned long arg5)
-{
-	unsigned long current_bits;
-
-	if (arg3 || arg4 || arg5)
-		return -EINVAL;
-
-	if (bits & ~(PR_MDWE_REFUSE_EXEC_GAIN | PR_MDWE_NO_INHERIT))
-		return -EINVAL;
-
-	/* NO_INHERIT only makes sense with REFUSE_EXEC_GAIN */
-	if (bits & PR_MDWE_NO_INHERIT && !(bits & PR_MDWE_REFUSE_EXEC_GAIN))
-		return -EINVAL;
-
-	/*
-	 * EOPNOTSUPP might be more appropriate here in principle, but
-	 * existing userspace depends on EINVAL specifically.
-	 */
-	if (!arch_memory_deny_write_exec_supported())
-		return -EINVAL;
-
-	current_bits = get_current_mdwe();
-	if (current_bits && current_bits != bits)
-		return -EPERM; /* Cannot unset the flags */
-
-	if (bits & PR_MDWE_NO_INHERIT)
-		set_bit(MMF_HAS_MDWE_NO_INHERIT, &current->mm->flags);
-	if (bits & PR_MDWE_REFUSE_EXEC_GAIN)
-		set_bit(MMF_HAS_MDWE, &current->mm->flags);
-
-	return 0;
-}
-
-static inline int prctl_get_mdwe(unsigned long arg2, unsigned long arg3,
-				 unsigned long arg4, unsigned long arg5)
-{
-	if (arg2 || arg3 || arg4 || arg5)
-		return -EINVAL;
-	return get_current_mdwe();
-}
-
-static int prctl_get_auxv(void __user *addr, unsigned long len)
-{
-	struct mm_struct *mm = current->mm;
-	unsigned long size = min_t(unsigned long, sizeof(mm->saved_auxv), len);
-
-	if (size && copy_to_user(addr, mm->saved_auxv, size))
-		return -EFAULT;
-	return sizeof(mm->saved_auxv);
-}
-
-SYSCALL_DEFINE5(prctl, int, option, unsigned long, arg2, unsigned long, arg3,
-		unsigned long, arg4, unsigned long, arg5)
-{
-	struct task_struct *me = current;
-	unsigned char comm[sizeof(me->comm)];
-	long error;
-
-	error = security_task_prctl(option, arg2, arg3, arg4, arg5);
-	if (error != -ENOSYS)
-		return error;
-
-	error = 0;
-	switch (option) {
-	case PR_SET_PDEATHSIG:
-		if (!valid_signal(arg2)) {
-			error = -EINVAL;
-			break;
-		}
-		me->pdeath_signal = arg2;
-		break;
-	case PR_GET_PDEATHSIG:
-		error = put_user(me->pdeath_signal, (int __user *)arg2);
-		break;
-	case PR_GET_DUMPABLE:
-		error = get_dumpable(me->mm);
-		break;
-	case PR_SET_DUMPABLE:
-		if (arg2 != SUID_DUMP_DISABLE && arg2 != SUID_DUMP_USER) {
-			error = -EINVAL;
-			break;
-		}
-		set_dumpable(me->mm, arg2);
-		break;
-
-	case PR_SET_UNALIGN:
-		error = SET_UNALIGN_CTL(me, arg2);
-		break;
-	case PR_GET_UNALIGN:
-		error = GET_UNALIGN_CTL(me, arg2);
-		break;
-	case PR_SET_FPEMU:
-		error = SET_FPEMU_CTL(me, arg2);
-		break;
-	case PR_GET_FPEMU:
-		error = GET_FPEMU_CTL(me, arg2);
-		break;
-	case PR_SET_FPEXC:
-		error = SET_FPEXC_CTL(me, arg2);
-		break;
-	case PR_GET_FPEXC:
-		error = GET_FPEXC_CTL(me, arg2);
-		break;
-	case PR_GET_TIMING:
-		error = PR_TIMING_STATISTICAL;
-		break;
-	case PR_SET_TIMING:
-		if (arg2 != PR_TIMING_STATISTICAL)
-			error = -EINVAL;
-		break;
-	case PR_SET_NAME:
-		comm[sizeof(me->comm) - 1] = 0;
-		if (strncpy_from_user(comm, (char __user *)arg2,
-				      sizeof(me->comm) - 1) < 0)
-			return -EFAULT;
-		set_task_comm(me, comm);
-		proc_comm_connector(me);
-		break;
-	case PR_GET_NAME:
-		get_task_comm(comm, me);
-		if (copy_to_user((char __user *)arg2, comm, sizeof(comm)))
-			return -EFAULT;
-		break;
-	case PR_GET_ENDIAN:
-		error = GET_ENDIAN(me, arg2);
-		break;
-	case PR_SET_ENDIAN:
-		error = SET_ENDIAN(me, arg2);
-		break;
-	case PR_GET_SECCOMP:
-		error = prctl_get_seccomp();
-		break;
-	case PR_SET_SECCOMP:
-		error = prctl_set_seccomp(arg2, (char __user *)arg3);
-		break;
-	case PR_GET_TSC:
-		error = GET_TSC_CTL(arg2);
-		break;
-	case PR_SET_TSC:
-		error = SET_TSC_CTL(arg2);
-		break;
-	case PR_TASK_PERF_EVENTS_DISABLE:
-		error = perf_event_task_disable();
-		break;
-	case PR_TASK_PERF_EVENTS_ENABLE:
-		error = perf_event_task_enable();
-		break;
-	case PR_GET_TIMERSLACK:
-		if (current->timer_slack_ns > ULONG_MAX)
-			error = ULONG_MAX;
-		else
-			error = current->timer_slack_ns;
-		break;
-	case PR_SET_TIMERSLACK:
-		if (rt_or_dl_task_policy(current))
-			break;
-		if (arg2 <= 0)
-			current->timer_slack_ns =
-					current->default_timer_slack_ns;
-		else
-			current->timer_slack_ns = arg2;
-		break;
-	case PR_MCE_KILL:
-		if (arg4 | arg5)
-			return -EINVAL;
-		switch (arg2) {
-		case PR_MCE_KILL_CLEAR:
-			if (arg3 != 0)
-				return -EINVAL;
-			current->flags &= ~PF_MCE_PROCESS;
-			break;
-		case PR_MCE_KILL_SET:
-			current->flags |= PF_MCE_PROCESS;
-			if (arg3 == PR_MCE_KILL_EARLY)
-				current->flags |= PF_MCE_EARLY;
-			else if (arg3 == PR_MCE_KILL_LATE)
-				current->flags &= ~PF_MCE_EARLY;
-			else if (arg3 == PR_MCE_KILL_DEFAULT)
-				current->flags &=
-						~(PF_MCE_EARLY|PF_MCE_PROCESS);
-			else
-				return -EINVAL;
-			break;
-		default:
-			return -EINVAL;
-		}
-		break;
-	case PR_MCE_KILL_GET:
-		if (arg2 | arg3 | arg4 | arg5)
-			return -EINVAL;
-		if (current->flags & PF_MCE_PROCESS)
-			error = (current->flags & PF_MCE_EARLY) ?
-				PR_MCE_KILL_EARLY : PR_MCE_KILL_LATE;
-		else
-			error = PR_MCE_KILL_DEFAULT;
-		break;
-	case PR_SET_MM:
-		error = prctl_set_mm(arg2, arg3, arg4, arg5);
-		break;
-	case PR_GET_TID_ADDRESS:
-		error = prctl_get_tid_address(me, (int __user * __user *)arg2);
-		break;
-	case PR_SET_CHILD_SUBREAPER:
-		me->signal->is_child_subreaper = !!arg2;
-		if (!arg2)
-			break;
-
-		walk_process_tree(me, propagate_has_child_subreaper, NULL);
-		break;
-	case PR_GET_CHILD_SUBREAPER:
-		error = put_user(me->signal->is_child_subreaper,
-				 (int __user *)arg2);
-		break;
-	case PR_SET_NO_NEW_PRIVS:
-		if (arg2 != 1 || arg3 || arg4 || arg5)
-			return -EINVAL;
-
-		task_set_no_new_privs(current);
-		break;
-	case PR_GET_NO_NEW_PRIVS:
-		if (arg2 || arg3 || arg4 || arg5)
-			return -EINVAL;
-		return task_no_new_privs(current) ? 1 : 0;
-	case PR_GET_THP_DISABLE:
-		if (arg2 || arg3 || arg4 || arg5)
-			return -EINVAL;
-		error = !!test_bit(MMF_DISABLE_THP, &me->mm->flags);
-		break;
-	case PR_SET_THP_DISABLE:
-		if (arg3 || arg4 || arg5)
-			return -EINVAL;
-		if (mmap_write_lock_killable(me->mm))
-			return -EINTR;
-		if (arg2)
-			set_bit(MMF_DISABLE_THP, &me->mm->flags);
-		else
-			clear_bit(MMF_DISABLE_THP, &me->mm->flags);
-		mmap_write_unlock(me->mm);
-		break;
-	case PR_MPX_ENABLE_MANAGEMENT:
-	case PR_MPX_DISABLE_MANAGEMENT:
-		/* No longer implemented: */
-		return -EINVAL;
-	case PR_SET_FP_MODE:
-		error = SET_FP_MODE(me, arg2);
-		break;
-	case PR_GET_FP_MODE:
-		error = GET_FP_MODE(me);
-		break;
-	case PR_SVE_SET_VL:
-		error = SVE_SET_VL(arg2);
-		break;
-	case PR_SVE_GET_VL:
-		error = SVE_GET_VL();
-		break;
-	case PR_SME_SET_VL:
-		error = SME_SET_VL(arg2);
-		break;
-	case PR_SME_GET_VL:
-		error = SME_GET_VL();
-		break;
-	case PR_GET_SPECULATION_CTRL:
-		if (arg3 || arg4 || arg5)
-			return -EINVAL;
-		error = arch_prctl_spec_ctrl_get(me, arg2);
-		break;
-	case PR_SET_SPECULATION_CTRL:
-		if (arg4 || arg5)
-			return -EINVAL;
-		error = arch_prctl_spec_ctrl_set(me, arg2, arg3);
-		break;
-	case PR_PAC_RESET_KEYS:
-		if (arg3 || arg4 || arg5)
-			return -EINVAL;
-		error = PAC_RESET_KEYS(me, arg2);
-		break;
-	case PR_PAC_SET_ENABLED_KEYS:
-		if (arg4 || arg5)
-			return -EINVAL;
-		error = PAC_SET_ENABLED_KEYS(me, arg2, arg3);
-		break;
-	case PR_PAC_GET_ENABLED_KEYS:
-		if (arg2 || arg3 || arg4 || arg5)
-			return -EINVAL;
-		error = PAC_GET_ENABLED_KEYS(me);
-		break;
-	case PR_SET_TAGGED_ADDR_CTRL:
-		if (arg3 || arg4 || arg5)
-			return -EINVAL;
-		error = SET_TAGGED_ADDR_CTRL(arg2);
-		break;
-	case PR_GET_TAGGED_ADDR_CTRL:
-		if (arg2 || arg3 || arg4 || arg5)
-			return -EINVAL;
-		error = GET_TAGGED_ADDR_CTRL();
-		break;
-	case PR_SET_IO_FLUSHER:
-		if (!capable(CAP_SYS_RESOURCE))
-			return -EPERM;
-
-		if (arg3 || arg4 || arg5)
-			return -EINVAL;
-
-		if (arg2 == 1)
-			current->flags |= PR_IO_FLUSHER;
-		else if (!arg2)
-			current->flags &= ~PR_IO_FLUSHER;
-		else
-			return -EINVAL;
-		break;
-	case PR_GET_IO_FLUSHER:
-		if (!capable(CAP_SYS_RESOURCE))
-			return -EPERM;
-
-		if (arg2 || arg3 || arg4 || arg5)
-			return -EINVAL;
-
-		error = (current->flags & PR_IO_FLUSHER) == PR_IO_FLUSHER;
-		break;
-	case PR_SET_SYSCALL_USER_DISPATCH:
-		error = set_syscall_user_dispatch(arg2, arg3, arg4,
-						  (char __user *) arg5);
-		break;
-#ifdef CONFIG_SCHED_CORE
-	case PR_SCHED_CORE:
-		error = sched_core_share_pid(arg2, arg3, arg4, arg5);
-		break;
-#endif
-	case PR_SET_MDWE:
-		error = prctl_set_mdwe(arg2, arg3, arg4, arg5);
-		break;
-	case PR_GET_MDWE:
-		error = prctl_get_mdwe(arg2, arg3, arg4, arg5);
-		break;
-	case PR_PPC_GET_DEXCR:
-		if (arg3 || arg4 || arg5)
-			return -EINVAL;
-		error = PPC_GET_DEXCR_ASPECT(me, arg2);
-		break;
-	case PR_PPC_SET_DEXCR:
-		if (arg4 || arg5)
-			return -EINVAL;
-		error = PPC_SET_DEXCR_ASPECT(me, arg2, arg3);
-		break;
-	case PR_SET_VMA:
-		error = prctl_set_vma(arg2, arg3, arg4, arg5);
-		break;
-	case PR_GET_AUXV:
-		if (arg4 || arg5)
-			return -EINVAL;
-		error = prctl_get_auxv((void __user *)arg2, arg3);
-		break;
-#ifdef CONFIG_KSM
-	case PR_SET_MEMORY_MERGE:
-		if (arg3 || arg4 || arg5)
-			return -EINVAL;
-		if (mmap_write_lock_killable(me->mm))
-			return -EINTR;
-
-		if (arg2)
-			error = ksm_enable_merge_any(me->mm);
-		else
-			error = ksm_disable_merge_any(me->mm);
-		mmap_write_unlock(me->mm);
-		break;
-	case PR_GET_MEMORY_MERGE:
-		if (arg2 || arg3 || arg4 || arg5)
-			return -EINVAL;
-
-		error = !!test_bit(MMF_VM_MERGE_ANY, &me->mm->flags);
-		break;
-#endif
-	case PR_RISCV_V_SET_CONTROL:
-		error = RISCV_V_SET_CONTROL(arg2);
-		break;
-	case PR_RISCV_V_GET_CONTROL:
-		error = RISCV_V_GET_CONTROL();
-		break;
-	case PR_RISCV_SET_ICACHE_FLUSH_CTX:
-		error = RISCV_SET_ICACHE_FLUSH_CTX(arg2, arg3);
-		break;
-	case PR_GET_SHADOW_STACK_STATUS:
-		if (arg3 || arg4 || arg5)
-			return -EINVAL;
-		error = arch_get_shadow_stack_status(me, (unsigned long __user *) arg2);
-		break;
-	case PR_SET_SHADOW_STACK_STATUS:
-		if (arg3 || arg4 || arg5)
-			return -EINVAL;
-		error = arch_set_shadow_stack_status(me, arg2);
-		break;
-	case PR_LOCK_SHADOW_STACK_STATUS:
-		if (arg3 || arg4 || arg5)
-			return -EINVAL;
-		error = arch_lock_shadow_stack_status(me, arg2);
-		break;
-	case PR_TIMER_CREATE_RESTORE_IDS:
-		if (arg3 || arg4 || arg5)
-			return -EINVAL;
-		error = posixtimer_create_prctl(arg2);
-		break;
-	case PR_FUTEX_HASH:
-		error = futex_hash_prctl(arg2, arg3, arg4);
-		break;
-	default:
-		trace_task_prctl_unknown(option, arg2, arg3, arg4, arg5);
-		error = -EINVAL;
-		break;
-	}
-	return error;
-}
-
-SYSCALL_DEFINE3(getcpu, unsigned __user *, cpup, unsigned __user *, nodep,
-		struct getcpu_cache __user *, unused)
-{
-	int err = 0;
-	int cpu = raw_smp_processor_id();
-
-	if (cpup)
-		err |= put_user(cpu, cpup);
-	if (nodep)
-		err |= put_user(cpu_to_node(cpu), nodep);
-	return err ? -EFAULT : 0;
-}
-
-/**
- * do_sysinfo - fill in sysinfo struct
- * @info: pointer to buffer to fill
- */
-static int do_sysinfo(struct sysinfo *info)
-{
-	unsigned long mem_total, sav_total;
-	unsigned int mem_unit, bitcount;
-	struct timespec64 tp;
-
-	memset(info, 0, sizeof(struct sysinfo));
-
-	ktime_get_boottime_ts64(&tp);
-	timens_add_boottime(&tp);
-	info->uptime = tp.tv_sec + (tp.tv_nsec ? 1 : 0);
-
-	get_avenrun(info->loads, 0, SI_LOAD_SHIFT - FSHIFT);
-
-	info->procs = nr_threads;
-
-	si_meminfo(info);
-	si_swapinfo(info);
-
-	/*
-	 * If the sum of all the available memory (i.e. ram + swap)
-	 * is less than can be stored in a 32 bit unsigned long then
-	 * we can be binary compatible with 2.2.x kernels.  If not,
-	 * well, in that case 2.2.x was broken anyways...
-	 *
-	 *  -Erik Andersen <andersee@debian.org>
-	 */
-
-	mem_total = info->totalram + info->totalswap;
-	if (mem_total < info->totalram || mem_total < info->totalswap)
-		goto out;
-	bitcount = 0;
-	mem_unit = info->mem_unit;
-	while (mem_unit > 1) {
-		bitcount++;
-		mem_unit >>= 1;
-		sav_total = mem_total;
-		mem_total <<= 1;
-		if (mem_total < sav_total)
-			goto out;
-	}
-
-	/*
-	 * If mem_total did not overflow, multiply all memory values by
-	 * info->mem_unit and set it to 1.  This leaves things compatible
-	 * with 2.2.x, and also retains compatibility with earlier 2.4.x
-	 * kernels...
-	 */
-
-	info->mem_unit = 1;
-	info->totalram <<= bitcount;
-	info->freeram <<= bitcount;
-	info->sharedram <<= bitcount;
-	info->bufferram <<= bitcount;
-	info->totalswap <<= bitcount;
-	info->freeswap <<= bitcount;
-	info->totalhigh <<= bitcount;
-	info->freehigh <<= bitcount;
-
-out:
-	return 0;
-}
-
-SYSCALL_DEFINE1(sysinfo, struct sysinfo __user *, info)
-{
-	struct sysinfo val;
-
-	do_sysinfo(&val);
-
-	if (copy_to_user(info, &val, sizeof(struct sysinfo)))
-		return -EFAULT;
-
-	return 0;
-}
-
-#ifdef CONFIG_COMPAT
-struct compat_sysinfo {
-	s32 uptime;
-	u32 loads[3];
-	u32 totalram;
-	u32 freeram;
-	u32 sharedram;
-	u32 bufferram;
-	u32 totalswap;
-	u32 freeswap;
-	u16 procs;
-	u16 pad;
-	u32 totalhigh;
-	u32 freehigh;
-	u32 mem_unit;
-	char _f[20-2*sizeof(u32)-sizeof(int)];
-};
-
-COMPAT_SYSCALL_DEFINE1(sysinfo, struct compat_sysinfo __user *, info)
-{
-	struct sysinfo s;
-	struct compat_sysinfo s_32;
-
-	do_sysinfo(&s);
-
-	/* Check to see if any memory value is too large for 32-bit and scale
-	 *  down if needed
-	 */
-	if (upper_32_bits(s.totalram) || upper_32_bits(s.totalswap)) {
-		int bitcount = 0;
-
-		while (s.mem_unit < PAGE_SIZE) {
-			s.mem_unit <<= 1;
-			bitcount++;
-		}
-
-		s.totalram >>= bitcount;
-		s.freeram >>= bitcount;
-		s.sharedram >>= bitcount;
-		s.bufferram >>= bitcount;
-		s.totalswap >>= bitcount;
-		s.freeswap >>= bitcount;
-		s.totalhigh >>= bitcount;
-		s.freehigh >>= bitcount;
-	}
-
-	memset(&s_32, 0, sizeof(s_32));
-	s_32.uptime = s.uptime;
-	s_32.loads[0] = s.loads[0];
-	s_32.loads[1] = s.loads[1];
-	s_32.loads[2] = s.loads[2];
-	s_32.totalram = s.totalram;
-	s_32.freeram = s.freeram;
-	s_32.sharedram = s.sharedram;
-	s_32.bufferram = s.bufferram;
-	s_32.totalswap = s.totalswap;
-	s_32.freeswap = s.freeswap;
-	s_32.procs = s.procs;
-	s_32.totalhigh = s.totalhigh;
-	s_32.freehigh = s.freehigh;
-	s_32.mem_unit = s.mem_unit;
-	if (copy_to_user(info, &s_32, sizeof(s_32)))
-		return -EFAULT;
-	return 0;
-}
-#endif /* CONFIG_COMPAT */
diff -Nrup linux-6.16.7/Makefile linux-lenovo-x13s-linux-6.16.y/Makefile
--- linux-6.16.7/Makefile	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/Makefile	2025-09-11 09:47:42.000000000 -0600
@@ -1,7 +1,7 @@
 # SPDX-License-Identifier: GPL-2.0
 VERSION = 6
 PATCHLEVEL = 16
-SUBLEVEL = 7
+SUBLEVEL = 6
 EXTRAVERSION =
 NAME = Baby Opossum Posse
 
diff -Nrup linux-6.16.7/mm/Kconfig linux-lenovo-x13s-linux-6.16.y/mm/Kconfig
--- linux-6.16.7/mm/Kconfig	2025-09-13 16:15:46.057484155 -0600
+++ linux-lenovo-x13s-linux-6.16.y/mm/Kconfig	2025-09-11 09:47:42.000000000 -0600
@@ -753,8 +753,6 @@ config KSM
 config DEFAULT_MMAP_MIN_ADDR
 	int "Low address space to protect from user allocation"
 	depends on MMU
-	default 65536 if ( X86_64 || X86_32 || PPC64 || IA64 ) && GENTOO_KERNEL_SELF_PROTECTION
-	default 32768 if ( ARM64 || ARM ) && GENTOO_KERNEL_SELF_PROTECTION
 	default 4096
 	help
 	  This is the portion of low virtual memory which should be protected
diff -Nrup linux-6.16.7/mm/Kconfig.orig linux-lenovo-x13s-linux-6.16.y/mm/Kconfig.orig
--- linux-6.16.7/mm/Kconfig.orig	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/mm/Kconfig.orig	1969-12-31 17:00:00.000000000 -0700
@@ -1,1387 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0-only
-
-menu "Memory Management options"
-
-#
-# For some reason microblaze and nios2 hard code SWAP=n.  Hopefully we can
-# add proper SWAP support to them, in which case this can be remove.
-#
-config ARCH_NO_SWAP
-	bool
-
-config ZPOOL
-	bool
-
-menuconfig SWAP
-	bool "Support for paging of anonymous memory (swap)"
-	depends on MMU && BLOCK && !ARCH_NO_SWAP
-	default y
-	help
-	  This option allows you to choose whether you want to have support
-	  for so called swap devices or swap files in your kernel that are
-	  used to provide more virtual memory than the actual RAM present
-	  in your computer.  If unsure say Y.
-
-config ZSWAP
-	bool "Compressed cache for swap pages"
-	depends on SWAP
-	select CRYPTO
-	select ZPOOL
-	help
-	  A lightweight compressed cache for swap pages.  It takes
-	  pages that are in the process of being swapped out and attempts to
-	  compress them into a dynamically allocated RAM-based memory pool.
-	  This can result in a significant I/O reduction on swap device and,
-	  in the case where decompressing from RAM is faster than swap device
-	  reads, can also improve workload performance.
-
-config ZSWAP_DEFAULT_ON
-	bool "Enable the compressed cache for swap pages by default"
-	depends on ZSWAP
-	help
-	  If selected, the compressed cache for swap pages will be enabled
-	  at boot, otherwise it will be disabled.
-
-	  The selection made here can be overridden by using the kernel
-	  command line 'zswap.enabled=' option.
-
-config ZSWAP_SHRINKER_DEFAULT_ON
-	bool "Shrink the zswap pool on memory pressure"
-	depends on ZSWAP
-	default n
-	help
-	  If selected, the zswap shrinker will be enabled, and the pages
-	  stored in the zswap pool will become available for reclaim (i.e
-	  written back to the backing swap device) on memory pressure.
-
-	  This means that zswap writeback could happen even if the pool is
-	  not yet full, or the cgroup zswap limit has not been reached,
-	  reducing the chance that cold pages will reside in the zswap pool
-	  and consume memory indefinitely.
-
-choice
-	prompt "Default compressor"
-	depends on ZSWAP
-	default ZSWAP_COMPRESSOR_DEFAULT_LZO
-	help
-	  Selects the default compression algorithm for the compressed cache
-	  for swap pages.
-
-	  For an overview what kind of performance can be expected from
-	  a particular compression algorithm please refer to the benchmarks
-	  available at the following LWN page:
-	  https://lwn.net/Articles/751795/
-
-	  If in doubt, select 'LZO'.
-
-	  The selection made here can be overridden by using the kernel
-	  command line 'zswap.compressor=' option.
-
-config ZSWAP_COMPRESSOR_DEFAULT_DEFLATE
-	bool "Deflate"
-	select CRYPTO_DEFLATE
-	help
-	  Use the Deflate algorithm as the default compression algorithm.
-
-config ZSWAP_COMPRESSOR_DEFAULT_LZO
-	bool "LZO"
-	select CRYPTO_LZO
-	help
-	  Use the LZO algorithm as the default compression algorithm.
-
-config ZSWAP_COMPRESSOR_DEFAULT_842
-	bool "842"
-	select CRYPTO_842
-	help
-	  Use the 842 algorithm as the default compression algorithm.
-
-config ZSWAP_COMPRESSOR_DEFAULT_LZ4
-	bool "LZ4"
-	select CRYPTO_LZ4
-	help
-	  Use the LZ4 algorithm as the default compression algorithm.
-
-config ZSWAP_COMPRESSOR_DEFAULT_LZ4HC
-	bool "LZ4HC"
-	select CRYPTO_LZ4HC
-	help
-	  Use the LZ4HC algorithm as the default compression algorithm.
-
-config ZSWAP_COMPRESSOR_DEFAULT_ZSTD
-	bool "zstd"
-	select CRYPTO_ZSTD
-	help
-	  Use the zstd algorithm as the default compression algorithm.
-endchoice
-
-config ZSWAP_COMPRESSOR_DEFAULT
-       string
-       depends on ZSWAP
-       default "deflate" if ZSWAP_COMPRESSOR_DEFAULT_DEFLATE
-       default "lzo" if ZSWAP_COMPRESSOR_DEFAULT_LZO
-       default "842" if ZSWAP_COMPRESSOR_DEFAULT_842
-       default "lz4" if ZSWAP_COMPRESSOR_DEFAULT_LZ4
-       default "lz4hc" if ZSWAP_COMPRESSOR_DEFAULT_LZ4HC
-       default "zstd" if ZSWAP_COMPRESSOR_DEFAULT_ZSTD
-       default ""
-
-choice
-	prompt "Default allocator"
-	depends on ZSWAP
-	default ZSWAP_ZPOOL_DEFAULT_ZSMALLOC if MMU
-	help
-	  Selects the default allocator for the compressed cache for
-	  swap pages.
-	  The default is 'zbud' for compatibility, however please do
-	  read the description of each of the allocators below before
-	  making a right choice.
-
-	  The selection made here can be overridden by using the kernel
-	  command line 'zswap.zpool=' option.
-
-config ZSWAP_ZPOOL_DEFAULT_ZSMALLOC
-	bool "zsmalloc"
-	select ZSMALLOC
-	help
-	  Use the zsmalloc allocator as the default allocator.
-endchoice
-
-config ZSWAP_ZPOOL_DEFAULT
-       string
-       depends on ZSWAP
-       default "zsmalloc" if ZSWAP_ZPOOL_DEFAULT_ZSMALLOC
-       default ""
-
-config ZSMALLOC
-	tristate
-	prompt "N:1 compression allocator (zsmalloc)" if (ZSWAP || ZRAM)
-	depends on MMU
-	help
-	  zsmalloc is a slab-based memory allocator designed to store
-	  pages of various compression levels efficiently. It achieves
-	  the highest storage density with the least amount of fragmentation.
-
-config ZSMALLOC_STAT
-	bool "Export zsmalloc statistics"
-	depends on ZSMALLOC
-	select DEBUG_FS
-	help
-	  This option enables code in the zsmalloc to collect various
-	  statistics about what's happening in zsmalloc and exports that
-	  information to userspace via debugfs.
-	  If unsure, say N.
-
-config ZSMALLOC_CHAIN_SIZE
-	int "Maximum number of physical pages per-zspage"
-	default 8
-	range 4 16
-	depends on ZSMALLOC
-	help
-	  This option sets the upper limit on the number of physical pages
-	  that a zmalloc page (zspage) can consist of. The optimal zspage
-	  chain size is calculated for each size class during the
-	  initialization of the pool.
-
-	  Changing this option can alter the characteristics of size classes,
-	  such as the number of pages per zspage and the number of objects
-	  per zspage. This can also result in different configurations of
-	  the pool, as zsmalloc merges size classes with similar
-	  characteristics.
-
-	  For more information, see zsmalloc documentation.
-
-menu "Slab allocator options"
-
-config SLUB
-	def_bool y
-
-config KVFREE_RCU_BATCHED
-	def_bool y
-	depends on !SLUB_TINY && !TINY_RCU
-
-config SLUB_TINY
-	bool "Configure for minimal memory footprint"
-	depends on EXPERT && !COMPILE_TEST
-	select SLAB_MERGE_DEFAULT
-	help
-	   Configures the slab allocator in a way to achieve minimal memory
-	   footprint, sacrificing scalability, debugging and other features.
-	   This is intended only for the smallest system that had used the
-	   SLOB allocator and is not recommended for systems with more than
-	   16MB RAM.
-
-	   If unsure, say N.
-
-config SLAB_MERGE_DEFAULT
-	bool "Allow slab caches to be merged"
-	default y
-	help
-	  For reduced kernel memory fragmentation, slab caches can be
-	  merged when they share the same size and other characteristics.
-	  This carries a risk of kernel heap overflows being able to
-	  overwrite objects from merged caches (and more easily control
-	  cache layout), which makes such heap attacks easier to exploit
-	  by attackers. By keeping caches unmerged, these kinds of exploits
-	  can usually only damage objects in the same cache. To disable
-	  merging at runtime, "slab_nomerge" can be passed on the kernel
-	  command line.
-
-config SLAB_FREELIST_RANDOM
-	bool "Randomize slab freelist"
-	depends on !SLUB_TINY
-	help
-	  Randomizes the freelist order used on creating new pages. This
-	  security feature reduces the predictability of the kernel slab
-	  allocator against heap overflows.
-
-config SLAB_FREELIST_HARDENED
-	bool "Harden slab freelist metadata"
-	depends on !SLUB_TINY
-	help
-	  Many kernel heap attacks try to target slab cache metadata and
-	  other infrastructure. This options makes minor performance
-	  sacrifices to harden the kernel slab allocator against common
-	  freelist exploit methods.
-
-config SLAB_BUCKETS
-	bool "Support allocation from separate kmalloc buckets"
-	depends on !SLUB_TINY
-	default SLAB_FREELIST_HARDENED
-	help
-	  Kernel heap attacks frequently depend on being able to create
-	  specifically-sized allocations with user-controlled contents
-	  that will be allocated into the same kmalloc bucket as a
-	  target object. To avoid sharing these allocation buckets,
-	  provide an explicitly separated set of buckets to be used for
-	  user-controlled allocations. This may very slightly increase
-	  memory fragmentation, though in practice it's only a handful
-	  of extra pages since the bulk of user-controlled allocations
-	  are relatively long-lived.
-
-	  If unsure, say Y.
-
-config SLUB_STATS
-	default n
-	bool "Enable performance statistics"
-	depends on SYSFS && !SLUB_TINY
-	help
-	  The statistics are useful to debug slab allocation behavior in
-	  order find ways to optimize the allocator. This should never be
-	  enabled for production use since keeping statistics slows down
-	  the allocator by a few percentage points. The slabinfo command
-	  supports the determination of the most active slabs to figure
-	  out which slabs are relevant to a particular load.
-	  Try running: slabinfo -DA
-
-config SLUB_CPU_PARTIAL
-	default y
-	depends on SMP && !SLUB_TINY
-	bool "Enable per cpu partial caches"
-	help
-	  Per cpu partial caches accelerate objects allocation and freeing
-	  that is local to a processor at the price of more indeterminism
-	  in the latency of the free. On overflow these caches will be cleared
-	  which requires the taking of locks that may cause latency spikes.
-	  Typically one would choose no for a realtime system.
-
-config RANDOM_KMALLOC_CACHES
-	default n
-	depends on !SLUB_TINY
-	bool "Randomize slab caches for normal kmalloc"
-	help
-	  A hardening feature that creates multiple copies of slab caches for
-	  normal kmalloc allocation and makes kmalloc randomly pick one based
-	  on code address, which makes the attackers more difficult to spray
-	  vulnerable memory objects on the heap for the purpose of exploiting
-	  memory vulnerabilities.
-
-	  Currently the number of copies is set to 16, a reasonably large value
-	  that effectively diverges the memory objects allocated for different
-	  subsystems or modules into different caches, at the expense of a
-	  limited degree of memory and CPU overhead that relates to hardware and
-	  system workload.
-
-endmenu # Slab allocator options
-
-config SHUFFLE_PAGE_ALLOCATOR
-	bool "Page allocator randomization"
-	default SLAB_FREELIST_RANDOM && ACPI_NUMA
-	help
-	  Randomization of the page allocator improves the average
-	  utilization of a direct-mapped memory-side-cache. See section
-	  5.2.27 Heterogeneous Memory Attribute Table (HMAT) in the ACPI
-	  6.2a specification for an example of how a platform advertises
-	  the presence of a memory-side-cache. There are also incidental
-	  security benefits as it reduces the predictability of page
-	  allocations to compliment SLAB_FREELIST_RANDOM, but the
-	  default granularity of shuffling on the MAX_PAGE_ORDER i.e, 10th
-	  order of pages is selected based on cache utilization benefits
-	  on x86.
-
-	  While the randomization improves cache utilization it may
-	  negatively impact workloads on platforms without a cache. For
-	  this reason, by default, the randomization is not enabled even
-	  if SHUFFLE_PAGE_ALLOCATOR=y. The randomization may be force enabled
-	  with the 'page_alloc.shuffle' kernel command line parameter.
-
-	  Say Y if unsure.
-
-config COMPAT_BRK
-	bool "Disable heap randomization"
-	default y
-	help
-	  Randomizing heap placement makes heap exploits harder, but it
-	  also breaks ancient binaries (including anything libc5 based).
-	  This option changes the bootup default to heap randomization
-	  disabled, and can be overridden at runtime by setting
-	  /proc/sys/kernel/randomize_va_space to 2.
-
-	  On non-ancient distros (post-2000 ones) N is usually a safe choice.
-
-config MMAP_ALLOW_UNINITIALIZED
-	bool "Allow mmapped anonymous memory to be uninitialized"
-	depends on EXPERT && !MMU
-	default n
-	help
-	  Normally, and according to the Linux spec, anonymous memory obtained
-	  from mmap() has its contents cleared before it is passed to
-	  userspace.  Enabling this config option allows you to request that
-	  mmap() skip that if it is given an MAP_UNINITIALIZED flag, thus
-	  providing a huge performance boost.  If this option is not enabled,
-	  then the flag will be ignored.
-
-	  This is taken advantage of by uClibc's malloc(), and also by
-	  ELF-FDPIC binfmt's brk and stack allocator.
-
-	  Because of the obvious security issues, this option should only be
-	  enabled on embedded devices where you control what is run in
-	  userspace.  Since that isn't generally a problem on no-MMU systems,
-	  it is normally safe to say Y here.
-
-	  See Documentation/admin-guide/mm/nommu-mmap.rst for more information.
-
-config SELECT_MEMORY_MODEL
-	def_bool y
-	depends on ARCH_SELECT_MEMORY_MODEL
-
-choice
-	prompt "Memory model"
-	depends on SELECT_MEMORY_MODEL
-	default SPARSEMEM_MANUAL if ARCH_SPARSEMEM_DEFAULT
-	default FLATMEM_MANUAL
-	help
-	  This option allows you to change some of the ways that
-	  Linux manages its memory internally. Most users will
-	  only have one option here selected by the architecture
-	  configuration. This is normal.
-
-config FLATMEM_MANUAL
-	bool "Flat Memory"
-	depends on !ARCH_SPARSEMEM_ENABLE || ARCH_FLATMEM_ENABLE
-	help
-	  This option is best suited for non-NUMA systems with
-	  flat address space. The FLATMEM is the most efficient
-	  system in terms of performance and resource consumption
-	  and it is the best option for smaller systems.
-
-	  For systems that have holes in their physical address
-	  spaces and for features like NUMA and memory hotplug,
-	  choose "Sparse Memory".
-
-	  If unsure, choose this option (Flat Memory) over any other.
-
-config SPARSEMEM_MANUAL
-	bool "Sparse Memory"
-	depends on ARCH_SPARSEMEM_ENABLE
-	help
-	  This will be the only option for some systems, including
-	  memory hot-plug systems.  This is normal.
-
-	  This option provides efficient support for systems with
-	  holes is their physical address space and allows memory
-	  hot-plug and hot-remove.
-
-	  If unsure, choose "Flat Memory" over this option.
-
-endchoice
-
-config SPARSEMEM
-	def_bool y
-	depends on (!SELECT_MEMORY_MODEL && ARCH_SPARSEMEM_ENABLE) || SPARSEMEM_MANUAL
-
-config FLATMEM
-	def_bool y
-	depends on !SPARSEMEM || FLATMEM_MANUAL
-
-#
-# SPARSEMEM_EXTREME (which is the default) does some bootmem
-# allocations when sparse_init() is called.  If this cannot
-# be done on your architecture, select this option.  However,
-# statically allocating the mem_section[] array can potentially
-# consume vast quantities of .bss, so be careful.
-#
-# This option will also potentially produce smaller runtime code
-# with gcc 3.4 and later.
-#
-config SPARSEMEM_STATIC
-	bool
-
-#
-# Architecture platforms which require a two level mem_section in SPARSEMEM
-# must select this option. This is usually for architecture platforms with
-# an extremely sparse physical address space.
-#
-config SPARSEMEM_EXTREME
-	def_bool y
-	depends on SPARSEMEM && !SPARSEMEM_STATIC
-
-config SPARSEMEM_VMEMMAP_ENABLE
-	bool
-
-config SPARSEMEM_VMEMMAP
-	bool "Sparse Memory virtual memmap"
-	depends on SPARSEMEM && SPARSEMEM_VMEMMAP_ENABLE
-	default y
-	help
-	  SPARSEMEM_VMEMMAP uses a virtually mapped memmap to optimise
-	  pfn_to_page and page_to_pfn operations.  This is the most
-	  efficient option when sufficient kernel resources are available.
-
-config SPARSEMEM_VMEMMAP_PREINIT
-	bool
-#
-# Select this config option from the architecture Kconfig, if it is preferred
-# to enable the feature of HugeTLB/dev_dax vmemmap optimization.
-#
-config ARCH_WANT_OPTIMIZE_DAX_VMEMMAP
-	bool
-
-config ARCH_WANT_OPTIMIZE_HUGETLB_VMEMMAP
-	bool
-
-config ARCH_WANT_HUGETLB_VMEMMAP_PREINIT
-	bool
-
-config HAVE_MEMBLOCK_PHYS_MAP
-	bool
-
-config HAVE_GUP_FAST
-	depends on MMU
-	bool
-
-# Enable memblock support for scratch memory which is needed for kexec handover
-config MEMBLOCK_KHO_SCRATCH
-	bool
-
-# Don't discard allocated memory used to track "memory" and "reserved" memblocks
-# after early boot, so it can still be used to test for validity of memory.
-# Also, memblocks are updated with memory hot(un)plug.
-config ARCH_KEEP_MEMBLOCK
-	bool
-
-# Keep arch NUMA mapping infrastructure post-init.
-config NUMA_KEEP_MEMINFO
-	bool
-
-config MEMORY_ISOLATION
-	bool
-
-# IORESOURCE_SYSTEM_RAM regions in the kernel resource tree that are marked
-# IORESOURCE_EXCLUSIVE cannot be mapped to user space, for example, via
-# /dev/mem.
-config EXCLUSIVE_SYSTEM_RAM
-	def_bool y
-	depends on !DEVMEM || STRICT_DEVMEM
-
-#
-# Only be set on architectures that have completely implemented memory hotplug
-# feature. If you are not sure, don't touch it.
-#
-config HAVE_BOOTMEM_INFO_NODE
-	def_bool n
-
-config ARCH_ENABLE_MEMORY_HOTPLUG
-	bool
-
-config ARCH_ENABLE_MEMORY_HOTREMOVE
-	bool
-
-# eventually, we can have this option just 'select SPARSEMEM'
-menuconfig MEMORY_HOTPLUG
-	bool "Memory hotplug"
-	select MEMORY_ISOLATION
-	depends on SPARSEMEM
-	depends on ARCH_ENABLE_MEMORY_HOTPLUG
-	depends on 64BIT
-	select NUMA_KEEP_MEMINFO if NUMA
-
-if MEMORY_HOTPLUG
-
-choice
-	prompt "Memory Hotplug Default Online Type"
-	default MHP_DEFAULT_ONLINE_TYPE_OFFLINE
-	help
-	  Default memory type for hotplugged memory.
-
-	  This option sets the default policy setting for memory hotplug
-	  onlining policy (/sys/devices/system/memory/auto_online_blocks) which
-	  determines what happens to newly added memory regions. Policy setting
-	  can always be changed at runtime.
-
-	  The default is 'offline'.
-
-	  Select offline to defer onlining to drivers and user policy.
-	  Select auto to let the kernel choose what zones to utilize.
-	  Select online_kernel to generally allow kernel usage of this memory.
-	  Select online_movable to generally disallow kernel usage of this memory.
-
-	  Example kernel usage would be page structs and page tables.
-
-	  See Documentation/admin-guide/mm/memory-hotplug.rst for more information.
-
-config MHP_DEFAULT_ONLINE_TYPE_OFFLINE
-	bool "offline"
-	help
-	  Hotplugged memory will not be onlined by default.
-	  Choose this for systems with drivers and user policy that
-	  handle onlining of hotplug memory policy.
-
-config MHP_DEFAULT_ONLINE_TYPE_ONLINE_AUTO
-	bool "auto"
-	help
-	  Select this if you want the kernel to automatically online
-	  hotplugged memory into the zone it thinks is reasonable.
-	  This memory may be utilized for kernel data.
-
-config MHP_DEFAULT_ONLINE_TYPE_ONLINE_KERNEL
-	bool "kernel"
-	help
-	  Select this if you want the kernel to automatically online
-	  hotplugged memory into a zone capable of being used for kernel
-	  data. This typically means ZONE_NORMAL.
-
-config MHP_DEFAULT_ONLINE_TYPE_ONLINE_MOVABLE
-	bool "movable"
-	help
-	  Select this if you want the kernel to automatically online
-	  hotplug memory into ZONE_MOVABLE. This memory will generally
-	  not be utilized for kernel data.
-
-	  This should only be used when the admin knows sufficient
-	  ZONE_NORMAL memory is available to describe hotplug memory,
-	  otherwise hotplug memory may fail to online. For example,
-	  sufficient kernel-capable memory (ZONE_NORMAL) must be
-	  available to allocate page structs to describe ZONE_MOVABLE.
-
-endchoice
-
-config MEMORY_HOTREMOVE
-	bool "Allow for memory hot remove"
-	select HAVE_BOOTMEM_INFO_NODE if (X86_64 || PPC64)
-	depends on MEMORY_HOTPLUG && ARCH_ENABLE_MEMORY_HOTREMOVE
-	depends on MIGRATION
-
-config MHP_MEMMAP_ON_MEMORY
-	def_bool y
-	depends on MEMORY_HOTPLUG && SPARSEMEM_VMEMMAP
-	depends on ARCH_MHP_MEMMAP_ON_MEMORY_ENABLE
-
-endif # MEMORY_HOTPLUG
-
-config ARCH_MHP_MEMMAP_ON_MEMORY_ENABLE
-       bool
-
-# Heavily threaded applications may benefit from splitting the mm-wide
-# page_table_lock, so that faults on different parts of the user address
-# space can be handled with less contention: split it at this NR_CPUS.
-# Default to 4 for wider testing, though 8 might be more appropriate.
-# ARM's adjust_pte (unused if VIPT) depends on mm-wide page_table_lock.
-# PA-RISC 7xxx's spinlock_t would enlarge struct page from 32 to 44 bytes.
-# SPARC32 allocates multiple pte tables within a single page, and therefore
-# a per-page lock leads to problems when multiple tables need to be locked
-# at the same time (e.g. copy_page_range()).
-# DEBUG_SPINLOCK and DEBUG_LOCK_ALLOC spinlock_t also enlarge struct page.
-#
-config SPLIT_PTE_PTLOCKS
-	def_bool y
-	depends on MMU
-	depends on SMP
-	depends on NR_CPUS >= 4
-	depends on !ARM || CPU_CACHE_VIPT
-	depends on !PARISC || PA20
-	depends on !SPARC32
-
-config ARCH_ENABLE_SPLIT_PMD_PTLOCK
-	bool
-
-config SPLIT_PMD_PTLOCKS
-	def_bool y
-	depends on SPLIT_PTE_PTLOCKS && ARCH_ENABLE_SPLIT_PMD_PTLOCK
-
-#
-# support for memory balloon
-config MEMORY_BALLOON
-	bool
-
-#
-# support for memory balloon compaction
-config BALLOON_COMPACTION
-	bool "Allow for balloon memory compaction/migration"
-	default y
-	depends on COMPACTION && MEMORY_BALLOON
-	help
-	  Memory fragmentation introduced by ballooning might reduce
-	  significantly the number of 2MB contiguous memory blocks that can be
-	  used within a guest, thus imposing performance penalties associated
-	  with the reduced number of transparent huge pages that could be used
-	  by the guest workload. Allowing the compaction & migration for memory
-	  pages enlisted as being part of memory balloon devices avoids the
-	  scenario aforementioned and helps improving memory defragmentation.
-
-#
-# support for memory compaction
-config COMPACTION
-	bool "Allow for memory compaction"
-	default y
-	select MIGRATION
-	depends on MMU
-	help
-	  Compaction is the only memory management component to form
-	  high order (larger physically contiguous) memory blocks
-	  reliably. The page allocator relies on compaction heavily and
-	  the lack of the feature can lead to unexpected OOM killer
-	  invocations for high order memory requests. You shouldn't
-	  disable this option unless there really is a strong reason for
-	  it and then we would be really interested to hear about that at
-	  linux-mm@kvack.org.
-
-config COMPACT_UNEVICTABLE_DEFAULT
-	int
-	depends on COMPACTION
-	default 0 if PREEMPT_RT
-	default 1
-
-#
-# support for free page reporting
-config PAGE_REPORTING
-	bool "Free page reporting"
-	help
-	  Free page reporting allows for the incremental acquisition of
-	  free pages from the buddy allocator for the purpose of reporting
-	  those pages to another entity, such as a hypervisor, so that the
-	  memory can be freed within the host for other uses.
-
-#
-# support for page migration
-#
-config MIGRATION
-	bool "Page migration"
-	default y
-	depends on (NUMA || ARCH_ENABLE_MEMORY_HOTREMOVE || COMPACTION || CMA) && MMU
-	help
-	  Allows the migration of the physical location of pages of processes
-	  while the virtual addresses are not changed. This is useful in
-	  two situations. The first is on NUMA systems to put pages nearer
-	  to the processors accessing. The second is when allocating huge
-	  pages as migration can relocate pages to satisfy a huge page
-	  allocation instead of reclaiming.
-
-config DEVICE_MIGRATION
-	def_bool MIGRATION && ZONE_DEVICE
-
-config ARCH_ENABLE_HUGEPAGE_MIGRATION
-	bool
-
-config ARCH_ENABLE_THP_MIGRATION
-	bool
-
-config HUGETLB_PAGE_SIZE_VARIABLE
-	def_bool n
-	help
-	  Allows the pageblock_order value to be dynamic instead of just standard
-	  HUGETLB_PAGE_ORDER when there are multiple HugeTLB page sizes available
-	  on a platform.
-
-	  Note that the pageblock_order cannot exceed MAX_PAGE_ORDER and will be
-	  clamped down to MAX_PAGE_ORDER.
-
-config CONTIG_ALLOC
-	def_bool (MEMORY_ISOLATION && COMPACTION) || CMA
-
-config PCP_BATCH_SCALE_MAX
-	int "Maximum scale factor of PCP (Per-CPU pageset) batch allocate/free"
-	default 5
-	range 0 6
-	help
-	  In page allocator, PCP (Per-CPU pageset) is refilled and drained in
-	  batches.  The batch number is scaled automatically to improve page
-	  allocation/free throughput.  But too large scale factor may hurt
-	  latency.  This option sets the upper limit of scale factor to limit
-	  the maximum latency.
-
-config PHYS_ADDR_T_64BIT
-	def_bool 64BIT
-
-config BOUNCE
-	bool "Enable bounce buffers"
-	default y
-	depends on BLOCK && MMU && HIGHMEM
-	help
-	  Enable bounce buffers for devices that cannot access the full range of
-	  memory available to the CPU. Enabled by default when HIGHMEM is
-	  selected, but you may say n to override this.
-
-config MMU_NOTIFIER
-	bool
-	select INTERVAL_TREE
-
-config KSM
-	bool "Enable KSM for page merging"
-	depends on MMU
-	select XXHASH
-	help
-	  Enable Kernel Samepage Merging: KSM periodically scans those areas
-	  of an application's address space that an app has advised may be
-	  mergeable.  When it finds pages of identical content, it replaces
-	  the many instances by a single page with that content, so
-	  saving memory until one or another app needs to modify the content.
-	  Recommended for use with KVM, or with other duplicative applications.
-	  See Documentation/mm/ksm.rst for more information: KSM is inactive
-	  until a program has madvised that an area is MADV_MERGEABLE, and
-	  root has set /sys/kernel/mm/ksm/run to 1 (if CONFIG_SYSFS is set).
-
-config DEFAULT_MMAP_MIN_ADDR
-	int "Low address space to protect from user allocation"
-	depends on MMU
-	default 4096
-	help
-	  This is the portion of low virtual memory which should be protected
-	  from userspace allocation.  Keeping a user from writing to low pages
-	  can help reduce the impact of kernel NULL pointer bugs.
-
-	  For most arm64, ppc64 and x86 users with lots of address space
-	  a value of 65536 is reasonable and should cause no problems.
-	  On arm and other archs it should not be higher than 32768.
-	  Programs which use vm86 functionality or have some need to map
-	  this low address space will need CAP_SYS_RAWIO or disable this
-	  protection by setting the value to 0.
-
-	  This value can be changed after boot using the
-	  /proc/sys/vm/mmap_min_addr tunable.
-
-config ARCH_SUPPORTS_MEMORY_FAILURE
-	bool
-
-config MEMORY_FAILURE
-	depends on MMU
-	depends on ARCH_SUPPORTS_MEMORY_FAILURE
-	bool "Enable recovery from hardware memory errors"
-	select MEMORY_ISOLATION
-	select RAS
-	help
-	  Enables code to recover from some memory failures on systems
-	  with MCA recovery. This allows a system to continue running
-	  even when some of its memory has uncorrected errors. This requires
-	  special hardware support and typically ECC memory.
-
-config HWPOISON_INJECT
-	tristate "HWPoison pages injector"
-	depends on MEMORY_FAILURE && DEBUG_KERNEL && PROC_FS
-	select PROC_PAGE_MONITOR
-
-config NOMMU_INITIAL_TRIM_EXCESS
-	int "Turn on mmap() excess space trimming before booting"
-	depends on !MMU
-	default 1
-	help
-	  The NOMMU mmap() frequently needs to allocate large contiguous chunks
-	  of memory on which to store mappings, but it can only ask the system
-	  allocator for chunks in 2^N*PAGE_SIZE amounts - which is frequently
-	  more than it requires.  To deal with this, mmap() is able to trim off
-	  the excess and return it to the allocator.
-
-	  If trimming is enabled, the excess is trimmed off and returned to the
-	  system allocator, which can cause extra fragmentation, particularly
-	  if there are a lot of transient processes.
-
-	  If trimming is disabled, the excess is kept, but not used, which for
-	  long-term mappings means that the space is wasted.
-
-	  Trimming can be dynamically controlled through a sysctl option
-	  (/proc/sys/vm/nr_trim_pages) which specifies the minimum number of
-	  excess pages there must be before trimming should occur, or zero if
-	  no trimming is to occur.
-
-	  This option specifies the initial value of this option.  The default
-	  of 1 says that all excess pages should be trimmed.
-
-	  See Documentation/admin-guide/mm/nommu-mmap.rst for more information.
-
-config ARCH_WANT_GENERAL_HUGETLB
-	bool
-
-config ARCH_WANTS_THP_SWAP
-	def_bool n
-
-config MM_ID
-	def_bool n
-
-menuconfig TRANSPARENT_HUGEPAGE
-	bool "Transparent Hugepage Support"
-	depends on HAVE_ARCH_TRANSPARENT_HUGEPAGE && !PREEMPT_RT
-	select COMPACTION
-	select XARRAY_MULTI
-	select MM_ID
-	help
-	  Transparent Hugepages allows the kernel to use huge pages and
-	  huge tlb transparently to the applications whenever possible.
-	  This feature can improve computing performance to certain
-	  applications by speeding up page faults during memory
-	  allocation, by reducing the number of tlb misses and by speeding
-	  up the pagetable walking.
-
-	  If memory constrained on embedded, you may want to say N.
-
-if TRANSPARENT_HUGEPAGE
-
-choice
-	prompt "Transparent Hugepage Support sysfs defaults"
-	depends on TRANSPARENT_HUGEPAGE
-	default TRANSPARENT_HUGEPAGE_ALWAYS
-	help
-	  Selects the sysfs defaults for Transparent Hugepage Support.
-
-	config TRANSPARENT_HUGEPAGE_ALWAYS
-		bool "always"
-	help
-	  Enabling Transparent Hugepage always, can increase the
-	  memory footprint of applications without a guaranteed
-	  benefit but it will work automatically for all applications.
-
-	config TRANSPARENT_HUGEPAGE_MADVISE
-		bool "madvise"
-	help
-	  Enabling Transparent Hugepage madvise, will only provide a
-	  performance improvement benefit to the applications using
-	  madvise(MADV_HUGEPAGE) but it won't risk to increase the
-	  memory footprint of applications without a guaranteed
-	  benefit.
-
-	config TRANSPARENT_HUGEPAGE_NEVER
-		bool "never"
-	help
-	  Disable Transparent Hugepage by default. It can still be
-	  enabled at runtime via sysfs.
-endchoice
-
-config THP_SWAP
-	def_bool y
-	depends on TRANSPARENT_HUGEPAGE && ARCH_WANTS_THP_SWAP && SWAP && 64BIT
-	help
-	  Swap transparent huge pages in one piece, without splitting.
-	  XXX: For now, swap cluster backing transparent huge page
-	  will be split after swapout.
-
-	  For selection by architectures with reasonable THP sizes.
-
-config READ_ONLY_THP_FOR_FS
-	bool "Read-only THP for filesystems (EXPERIMENTAL)"
-	depends on TRANSPARENT_HUGEPAGE
-
-	help
-	  Allow khugepaged to put read-only file-backed pages in THP.
-
-	  This is marked experimental because it is a new feature. Write
-	  support of file THPs will be developed in the next few release
-	  cycles.
-
-config NO_PAGE_MAPCOUNT
-	bool "No per-page mapcount (EXPERIMENTAL)"
-	help
-	  Do not maintain per-page mapcounts for pages part of larger
-	  allocations, such as transparent huge pages.
-
-	  When this config option is enabled, some interfaces that relied on
-	  this information will rely on less-precise per-allocation information
-	  instead: for example, using the average per-page mapcount in such
-	  a large allocation instead of the per-page mapcount.
-
-	  EXPERIMENTAL because the impact of some changes is still unclear.
-
-endif # TRANSPARENT_HUGEPAGE
-
-# simple helper to make the code a bit easier to read
-config PAGE_MAPCOUNT
-	def_bool !NO_PAGE_MAPCOUNT
-
-#
-# The architecture supports pgtable leaves that is larger than PAGE_SIZE
-#
-config PGTABLE_HAS_HUGE_LEAVES
-	def_bool TRANSPARENT_HUGEPAGE || HUGETLB_PAGE
-
-# TODO: Allow to be enabled without THP
-config ARCH_SUPPORTS_HUGE_PFNMAP
-	def_bool n
-	depends on TRANSPARENT_HUGEPAGE
-
-config ARCH_SUPPORTS_PMD_PFNMAP
-	def_bool y
-	depends on ARCH_SUPPORTS_HUGE_PFNMAP && HAVE_ARCH_TRANSPARENT_HUGEPAGE
-
-config ARCH_SUPPORTS_PUD_PFNMAP
-	def_bool y
-	depends on ARCH_SUPPORTS_HUGE_PFNMAP && HAVE_ARCH_TRANSPARENT_HUGEPAGE_PUD
-
-#
-# UP and nommu archs use km based percpu allocator
-#
-config NEED_PER_CPU_KM
-	depends on !SMP || !MMU
-	bool
-	default y
-
-config NEED_PER_CPU_EMBED_FIRST_CHUNK
-	bool
-
-config NEED_PER_CPU_PAGE_FIRST_CHUNK
-	bool
-
-config USE_PERCPU_NUMA_NODE_ID
-	bool
-
-config HAVE_SETUP_PER_CPU_AREA
-	bool
-
-config CMA
-	bool "Contiguous Memory Allocator"
-	depends on MMU
-	select MIGRATION
-	select MEMORY_ISOLATION
-	help
-	  This enables the Contiguous Memory Allocator which allows other
-	  subsystems to allocate big physically-contiguous blocks of memory.
-	  CMA reserves a region of memory and allows only movable pages to
-	  be allocated from it. This way, the kernel can use the memory for
-	  pagecache and when a subsystem requests for contiguous area, the
-	  allocated pages are migrated away to serve the contiguous request.
-
-	  If unsure, say "n".
-
-config CMA_DEBUGFS
-	bool "CMA debugfs interface"
-	depends on CMA && DEBUG_FS
-	help
-	  Turns on the DebugFS interface for CMA.
-
-config CMA_SYSFS
-	bool "CMA information through sysfs interface"
-	depends on CMA && SYSFS
-	help
-	  This option exposes some sysfs attributes to get information
-	  from CMA.
-
-config CMA_AREAS
-	int "Maximum count of the CMA areas"
-	depends on CMA
-	default 20 if NUMA
-	default 8
-	help
-	  CMA allows to create CMA areas for particular purpose, mainly,
-	  used as device private area. This parameter sets the maximum
-	  number of CMA area in the system.
-
-	  If unsure, leave the default value "8" in UMA and "20" in NUMA.
-
-#
-# Select this config option from the architecture Kconfig, if available, to set
-# the max page order for physically contiguous allocations.
-#
-config ARCH_FORCE_MAX_ORDER
-	int
-
-#
-# When ARCH_FORCE_MAX_ORDER is not defined,
-# the default page block order is MAX_PAGE_ORDER (10) as per
-# include/linux/mmzone.h.
-#
-config PAGE_BLOCK_ORDER
-	int "Page Block Order"
-	range 1 10 if ARCH_FORCE_MAX_ORDER = 0
-	default 10 if ARCH_FORCE_MAX_ORDER = 0
-	range 1 ARCH_FORCE_MAX_ORDER if ARCH_FORCE_MAX_ORDER != 0
-	default ARCH_FORCE_MAX_ORDER if ARCH_FORCE_MAX_ORDER != 0
-	help
-	  The page block order refers to the power of two number of pages that
-	  are physically contiguous and can have a migrate type associated to
-	  them. The maximum size of the page block order is limited by
-	  ARCH_FORCE_MAX_ORDER.
-
-	  This config allows overriding the default page block order when the
-	  page block order is required to be smaller than ARCH_FORCE_MAX_ORDER
-	  or MAX_PAGE_ORDER.
-
-	  Reducing pageblock order can negatively impact THP generation
-	  success rate. If your workloads uses THP heavily, please use this
-	  option with caution.
-
-	  Don't change if unsure.
-
-config MEM_SOFT_DIRTY
-	bool "Track memory changes"
-	depends on CHECKPOINT_RESTORE && HAVE_ARCH_SOFT_DIRTY && PROC_FS
-	select PROC_PAGE_MONITOR
-	help
-	  This option enables memory changes tracking by introducing a
-	  soft-dirty bit on pte-s. This bit it set when someone writes
-	  into a page just as regular dirty bit, but unlike the latter
-	  it can be cleared by hands.
-
-	  See Documentation/admin-guide/mm/soft-dirty.rst for more details.
-
-config GENERIC_EARLY_IOREMAP
-	bool
-
-config STACK_MAX_DEFAULT_SIZE_MB
-	int "Default maximum user stack size for 32-bit processes (MB)"
-	default 100
-	range 8 2048
-	depends on STACK_GROWSUP && (!64BIT || COMPAT)
-	help
-	  This is the maximum stack size in Megabytes in the VM layout of 32-bit
-	  user processes when the stack grows upwards (currently only on parisc
-	  arch) when the RLIMIT_STACK hard limit is unlimited.
-
-	  A sane initial value is 100 MB.
-
-config DEFERRED_STRUCT_PAGE_INIT
-	bool "Defer initialisation of struct pages to kthreads"
-	depends on SPARSEMEM
-	depends on !NEED_PER_CPU_KM
-	depends on 64BIT
-	depends on !KMSAN
-	select PADATA
-	help
-	  Ordinarily all struct pages are initialised during early boot in a
-	  single thread. On very large machines this can take a considerable
-	  amount of time. If this option is set, large machines will bring up
-	  a subset of memmap at boot and then initialise the rest in parallel.
-	  This has a potential performance impact on tasks running early in the
-	  lifetime of the system until these kthreads finish the
-	  initialisation.
-
-config PAGE_IDLE_FLAG
-	bool
-	select PAGE_EXTENSION if !64BIT
-	help
-	  This adds PG_idle and PG_young flags to 'struct page'.  PTE Accessed
-	  bit writers can set the state of the bit in the flags so that PTE
-	  Accessed bit readers may avoid disturbance.
-
-config IDLE_PAGE_TRACKING
-	bool "Enable idle page tracking"
-	depends on SYSFS && MMU
-	select PAGE_IDLE_FLAG
-	help
-	  This feature allows to estimate the amount of user pages that have
-	  not been touched during a given period of time. This information can
-	  be useful to tune memory cgroup limits and/or for job placement
-	  within a compute cluster.
-
-	  See Documentation/admin-guide/mm/idle_page_tracking.rst for
-	  more details.
-
-# Architectures which implement cpu_dcache_is_aliasing() to query
-# whether the data caches are aliased (VIVT or VIPT with dcache
-# aliasing) need to select this.
-config ARCH_HAS_CPU_CACHE_ALIASING
-	bool
-
-config ARCH_HAS_CACHE_LINE_SIZE
-	bool
-
-config ARCH_HAS_CURRENT_STACK_POINTER
-	bool
-	help
-	  In support of HARDENED_USERCOPY performing stack variable lifetime
-	  checking, an architecture-agnostic way to find the stack pointer
-	  is needed. Once an architecture defines an unsigned long global
-	  register alias named "current_stack_pointer", this config can be
-	  selected.
-
-config ARCH_HAS_PTE_DEVMAP
-	bool
-
-config ARCH_HAS_ZONE_DMA_SET
-	bool
-
-config ZONE_DMA
-	bool "Support DMA zone" if ARCH_HAS_ZONE_DMA_SET
-	default y if ARM64 || X86
-
-config ZONE_DMA32
-	bool "Support DMA32 zone" if ARCH_HAS_ZONE_DMA_SET
-	depends on !X86_32
-	default y if ARM64
-
-config ZONE_DEVICE
-	bool "Device memory (pmem, HMM, etc...) hotplug support"
-	depends on MEMORY_HOTPLUG
-	depends on MEMORY_HOTREMOVE
-	depends on SPARSEMEM_VMEMMAP
-	depends on ARCH_HAS_PTE_DEVMAP
-	select XARRAY_MULTI
-
-	help
-	  Device memory hotplug support allows for establishing pmem,
-	  or other device driver discovered memory regions, in the
-	  memmap. This allows pfn_to_page() lookups of otherwise
-	  "device-physical" addresses which is needed for using a DAX
-	  mapping in an O_DIRECT operation, among other things.
-
-	  If FS_DAX is enabled, then say Y.
-
-#
-# Helpers to mirror range of the CPU page tables of a process into device page
-# tables.
-#
-config HMM_MIRROR
-	bool
-	depends on MMU
-
-config GET_FREE_REGION
-	bool
-
-config DEVICE_PRIVATE
-	bool "Unaddressable device memory (GPU memory, ...)"
-	depends on ZONE_DEVICE
-	select GET_FREE_REGION
-
-	help
-	  Allows creation of struct pages to represent unaddressable device
-	  memory; i.e., memory that is only accessible from the device (or
-	  group of devices). You likely also want to select HMM_MIRROR.
-
-config VMAP_PFN
-	bool
-
-config ARCH_USES_HIGH_VMA_FLAGS
-	bool
-config ARCH_HAS_PKEYS
-	bool
-
-config ARCH_USES_PG_ARCH_2
-	bool
-config ARCH_USES_PG_ARCH_3
-	bool
-
-config VM_EVENT_COUNTERS
-	default y
-	bool "Enable VM event counters for /proc/vmstat" if EXPERT
-	help
-	  VM event counters are needed for event counts to be shown.
-	  This option allows the disabling of the VM event counters
-	  on EXPERT systems.  /proc/vmstat will only show page counts
-	  if VM event counters are disabled.
-
-config PERCPU_STATS
-	bool "Collect percpu memory statistics"
-	help
-	  This feature collects and exposes statistics via debugfs. The
-	  information includes global and per chunk statistics, which can
-	  be used to help understand percpu memory usage.
-
-config GUP_TEST
-	bool "Enable infrastructure for get_user_pages()-related unit tests"
-	depends on DEBUG_FS
-	help
-	  Provides /sys/kernel/debug/gup_test, which in turn provides a way
-	  to make ioctl calls that can launch kernel-based unit tests for
-	  the get_user_pages*() and pin_user_pages*() family of API calls.
-
-	  These tests include benchmark testing of the _fast variants of
-	  get_user_pages*() and pin_user_pages*(), as well as smoke tests of
-	  the non-_fast variants.
-
-	  There is also a sub-test that allows running dump_page() on any
-	  of up to eight pages (selected by command line args) within the
-	  range of user-space addresses. These pages are either pinned via
-	  pin_user_pages*(), or pinned via get_user_pages*(), as specified
-	  by other command line arguments.
-
-	  See tools/testing/selftests/mm/gup_test.c
-
-comment "GUP_TEST needs to have DEBUG_FS enabled"
-	depends on !GUP_TEST && !DEBUG_FS
-
-config GUP_GET_PXX_LOW_HIGH
-	bool
-
-config DMAPOOL_TEST
-	tristate "Enable a module to run time tests on dma_pool"
-	depends on HAS_DMA
-	help
-	  Provides a test module that will allocate and free many blocks of
-	  various sizes and report how long it takes. This is intended to
-	  provide a consistent way to measure how changes to the
-	  dma_pool_alloc/free routines affect performance.
-
-config ARCH_HAS_PTE_SPECIAL
-	bool
-
-config MAPPING_DIRTY_HELPERS
-        bool
-
-config KMAP_LOCAL
-	bool
-
-config KMAP_LOCAL_NON_LINEAR_PTE_ARRAY
-	bool
-
-# struct io_mapping based helper.  Selected by drivers that need them
-config IO_MAPPING
-	bool
-
-config MEMFD_CREATE
-	bool "Enable memfd_create() system call" if EXPERT
-
-config SECRETMEM
-	default y
-	bool "Enable memfd_secret() system call" if EXPERT
-	depends on ARCH_HAS_SET_DIRECT_MAP
-	help
-	  Enable the memfd_secret() system call with the ability to create
-	  memory areas visible only in the context of the owning process and
-	  not mapped to other processes and other kernel page tables.
-
-config ANON_VMA_NAME
-	bool "Anonymous VMA name support"
-	depends on PROC_FS && ADVISE_SYSCALLS && MMU
-
-	help
-	  Allow naming anonymous virtual memory areas.
-
-	  This feature allows assigning names to virtual memory areas. Assigned
-	  names can be later retrieved from /proc/pid/maps and /proc/pid/smaps
-	  and help identifying individual anonymous memory areas.
-	  Assigning a name to anonymous virtual memory area might prevent that
-	  area from being merged with adjacent virtual memory areas due to the
-	  difference in their name.
-
-config HAVE_ARCH_USERFAULTFD_WP
-	bool
-	help
-	  Arch has userfaultfd write protection support
-
-config HAVE_ARCH_USERFAULTFD_MINOR
-	bool
-	help
-	  Arch has userfaultfd minor fault support
-
-menuconfig USERFAULTFD
-	bool "Enable userfaultfd() system call"
-	depends on MMU
-	help
-	  Enable the userfaultfd() system call that allows to intercept and
-	  handle page faults in userland.
-
-if USERFAULTFD
-config PTE_MARKER_UFFD_WP
-	bool "Userfaultfd write protection support for shmem/hugetlbfs"
-	default y
-	depends on HAVE_ARCH_USERFAULTFD_WP
-
-	help
-	  Allows to create marker PTEs for userfaultfd write protection
-	  purposes.  It is required to enable userfaultfd write protection on
-	  file-backed memory types like shmem and hugetlbfs.
-endif # USERFAULTFD
-
-# multi-gen LRU {
-config LRU_GEN
-	bool "Multi-Gen LRU"
-	depends on MMU
-	# make sure folio->flags has enough spare bits
-	depends on 64BIT || !SPARSEMEM || SPARSEMEM_VMEMMAP
-	help
-	  A high performance LRU implementation to overcommit memory. See
-	  Documentation/admin-guide/mm/multigen_lru.rst for details.
-
-config LRU_GEN_ENABLED
-	bool "Enable by default"
-	depends on LRU_GEN
-	help
-	  This option enables the multi-gen LRU by default.
-
-config LRU_GEN_STATS
-	bool "Full stats for debugging"
-	depends on LRU_GEN
-	help
-	  Do not enable this option unless you plan to look at historical stats
-	  from evicted generations for debugging purpose.
-
-	  This option has a per-memcg and per-node memory overhead.
-
-config LRU_GEN_WALKS_MMU
-	def_bool y
-	depends on LRU_GEN && ARCH_HAS_HW_PTE_YOUNG
-# }
-
-config ARCH_SUPPORTS_PER_VMA_LOCK
-       def_bool n
-
-config PER_VMA_LOCK
-	def_bool y
-	depends on ARCH_SUPPORTS_PER_VMA_LOCK && MMU && SMP
-	help
-	  Allow per-vma locking during page fault handling.
-
-	  This feature allows locking each virtual memory area separately when
-	  handling page faults instead of taking mmap_lock.
-
-config LOCK_MM_AND_FIND_VMA
-	bool
-	depends on !STACK_GROWSUP
-
-config IOMMU_MM_DATA
-	bool
-
-config EXECMEM
-	bool
-
-config NUMA_MEMBLKS
-	bool
-
-config NUMA_EMU
-	bool "NUMA emulation"
-	depends on NUMA_MEMBLKS
-	depends on X86 || GENERIC_ARCH_NUMA
-	help
-	  Enable NUMA emulation. A flat machine will be split
-	  into virtual nodes when booted with "numa=fake=N", where N is the
-	  number of nodes. This is only useful for debugging.
-
-config ARCH_HAS_USER_SHADOW_STACK
-	bool
-	help
-	  The architecture has hardware support for userspace shadow call
-          stacks (eg, x86 CET, arm64 GCS or RISC-V Zicfiss).
-
-config ARCH_SUPPORTS_PT_RECLAIM
-	def_bool n
-
-config PT_RECLAIM
-	bool "reclaim empty user page table pages"
-	default y
-	depends on ARCH_SUPPORTS_PT_RECLAIM && MMU && SMP
-	select MMU_GATHER_RCU_TABLE_FREE
-	help
-	  Try to reclaim empty user page table pages in paths other than munmap
-	  and exit_mmap path.
-
-	  Note: now only empty user PTE page table pages will be reclaimed.
-
-
-source "mm/damon/Kconfig"
-
-endmenu
diff -Nrup linux-6.16.7/net/bluetooth/hci_conn.c linux-lenovo-x13s-linux-6.16.y/net/bluetooth/hci_conn.c
--- linux-6.16.7/net/bluetooth/hci_conn.c	2025-09-13 16:15:43.485173815 -0600
+++ linux-lenovo-x13s-linux-6.16.y/net/bluetooth/hci_conn.c	2025-09-11 09:47:42.000000000 -0600
@@ -2366,13 +2366,8 @@ int hci_conn_check_link_mode(struct hci_
 		return 0;
 	}
 
-	/* If Secure Simple Pairing is not enabled, then legacy connection
-	 * setup is used and no encryption or key sizes can be enforced.
-	 */
-	if (!hci_conn_ssp_enabled(conn))
-		return 1;
-
-	if (!test_bit(HCI_CONN_ENCRYPT, &conn->flags))
+	if (hci_conn_ssp_enabled(conn) &&
+	    !test_bit(HCI_CONN_ENCRYPT, &conn->flags))
 		return 0;
 
 	return 1;
diff -Nrup linux-6.16.7/net/bluetooth/hci_conn.c.orig linux-lenovo-x13s-linux-6.16.y/net/bluetooth/hci_conn.c.orig
--- linux-6.16.7/net/bluetooth/hci_conn.c.orig	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/net/bluetooth/hci_conn.c.orig	1969-12-31 17:00:00.000000000 -0700
@@ -1,3139 +0,0 @@
-/*
-   BlueZ - Bluetooth protocol stack for Linux
-   Copyright (c) 2000-2001, 2010, Code Aurora Forum. All rights reserved.
-   Copyright 2023-2024 NXP
-
-   Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License version 2 as
-   published by the Free Software Foundation;
-
-   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
-   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.
-   IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) AND AUTHOR(S) BE LIABLE FOR ANY
-   CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES
-   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
-   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
-   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-
-   ALL LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PATENTS,
-   COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS
-   SOFTWARE IS DISCLAIMED.
-*/
-
-/* Bluetooth HCI connection handling. */
-
-#include <linux/export.h>
-#include <linux/debugfs.h>
-#include <linux/errqueue.h>
-
-#include <net/bluetooth/bluetooth.h>
-#include <net/bluetooth/hci_core.h>
-#include <net/bluetooth/l2cap.h>
-#include <net/bluetooth/iso.h>
-#include <net/bluetooth/mgmt.h>
-
-#include "smp.h"
-#include "eir.h"
-
-struct sco_param {
-	u16 pkt_type;
-	u16 max_latency;
-	u8  retrans_effort;
-};
-
-struct conn_handle_t {
-	struct hci_conn *conn;
-	__u16 handle;
-};
-
-static const struct sco_param esco_param_cvsd[] = {
-	{ EDR_ESCO_MASK & ~ESCO_2EV3, 0x000a,	0x01 }, /* S3 */
-	{ EDR_ESCO_MASK & ~ESCO_2EV3, 0x0007,	0x01 }, /* S2 */
-	{ EDR_ESCO_MASK | ESCO_EV3,   0x0007,	0x01 }, /* S1 */
-	{ EDR_ESCO_MASK | ESCO_HV3,   0xffff,	0x01 }, /* D1 */
-	{ EDR_ESCO_MASK | ESCO_HV1,   0xffff,	0x01 }, /* D0 */
-};
-
-static const struct sco_param sco_param_cvsd[] = {
-	{ EDR_ESCO_MASK | ESCO_HV3,   0xffff,	0xff }, /* D1 */
-	{ EDR_ESCO_MASK | ESCO_HV1,   0xffff,	0xff }, /* D0 */
-};
-
-static const struct sco_param esco_param_msbc[] = {
-	{ EDR_ESCO_MASK & ~ESCO_2EV3, 0x000d,	0x02 }, /* T2 */
-	{ EDR_ESCO_MASK | ESCO_EV3,   0x0008,	0x02 }, /* T1 */
-};
-
-/* This function requires the caller holds hdev->lock */
-void hci_connect_le_scan_cleanup(struct hci_conn *conn, u8 status)
-{
-	struct hci_conn_params *params;
-	struct hci_dev *hdev = conn->hdev;
-	struct smp_irk *irk;
-	bdaddr_t *bdaddr;
-	u8 bdaddr_type;
-
-	bdaddr = &conn->dst;
-	bdaddr_type = conn->dst_type;
-
-	/* Check if we need to convert to identity address */
-	irk = hci_get_irk(hdev, bdaddr, bdaddr_type);
-	if (irk) {
-		bdaddr = &irk->bdaddr;
-		bdaddr_type = irk->addr_type;
-	}
-
-	params = hci_pend_le_action_lookup(&hdev->pend_le_conns, bdaddr,
-					   bdaddr_type);
-	if (!params)
-		return;
-
-	if (params->conn) {
-		hci_conn_drop(params->conn);
-		hci_conn_put(params->conn);
-		params->conn = NULL;
-	}
-
-	if (!params->explicit_connect)
-		return;
-
-	/* If the status indicates successful cancellation of
-	 * the attempt (i.e. Unknown Connection Id) there's no point of
-	 * notifying failure since we'll go back to keep trying to
-	 * connect. The only exception is explicit connect requests
-	 * where a timeout + cancel does indicate an actual failure.
-	 */
-	if (status && status != HCI_ERROR_UNKNOWN_CONN_ID)
-		mgmt_connect_failed(hdev, conn, status);
-
-	/* The connection attempt was doing scan for new RPA, and is
-	 * in scan phase. If params are not associated with any other
-	 * autoconnect action, remove them completely. If they are, just unmark
-	 * them as waiting for connection, by clearing explicit_connect field.
-	 */
-	params->explicit_connect = false;
-
-	hci_pend_le_list_del_init(params);
-
-	switch (params->auto_connect) {
-	case HCI_AUTO_CONN_EXPLICIT:
-		hci_conn_params_del(hdev, bdaddr, bdaddr_type);
-		/* return instead of break to avoid duplicate scan update */
-		return;
-	case HCI_AUTO_CONN_DIRECT:
-	case HCI_AUTO_CONN_ALWAYS:
-		hci_pend_le_list_add(params, &hdev->pend_le_conns);
-		break;
-	case HCI_AUTO_CONN_REPORT:
-		hci_pend_le_list_add(params, &hdev->pend_le_reports);
-		break;
-	default:
-		break;
-	}
-
-	hci_update_passive_scan(hdev);
-}
-
-static void hci_conn_cleanup(struct hci_conn *conn)
-{
-	struct hci_dev *hdev = conn->hdev;
-
-	if (test_bit(HCI_CONN_PARAM_REMOVAL_PEND, &conn->flags))
-		hci_conn_params_del(conn->hdev, &conn->dst, conn->dst_type);
-
-	if (test_and_clear_bit(HCI_CONN_FLUSH_KEY, &conn->flags))
-		hci_remove_link_key(hdev, &conn->dst);
-
-	hci_chan_list_flush(conn);
-
-	if (HCI_CONN_HANDLE_UNSET(conn->handle))
-		ida_free(&hdev->unset_handle_ida, conn->handle);
-
-	if (conn->cleanup)
-		conn->cleanup(conn);
-
-	if (conn->type == SCO_LINK || conn->type == ESCO_LINK) {
-		switch (conn->setting & SCO_AIRMODE_MASK) {
-		case SCO_AIRMODE_CVSD:
-		case SCO_AIRMODE_TRANSP:
-			if (hdev->notify)
-				hdev->notify(hdev, HCI_NOTIFY_DISABLE_SCO);
-			break;
-		}
-	} else {
-		if (hdev->notify)
-			hdev->notify(hdev, HCI_NOTIFY_CONN_DEL);
-	}
-
-	debugfs_remove_recursive(conn->debugfs);
-
-	hci_conn_del_sysfs(conn);
-
-	hci_dev_put(hdev);
-}
-
-int hci_disconnect(struct hci_conn *conn, __u8 reason)
-{
-	BT_DBG("hcon %p", conn);
-
-	/* When we are central of an established connection and it enters
-	 * the disconnect timeout, then go ahead and try to read the
-	 * current clock offset.  Processing of the result is done
-	 * within the event handling and hci_clock_offset_evt function.
-	 */
-	if (conn->type == ACL_LINK && conn->role == HCI_ROLE_MASTER &&
-	    (conn->state == BT_CONNECTED || conn->state == BT_CONFIG)) {
-		struct hci_dev *hdev = conn->hdev;
-		struct hci_cp_read_clock_offset clkoff_cp;
-
-		clkoff_cp.handle = cpu_to_le16(conn->handle);
-		hci_send_cmd(hdev, HCI_OP_READ_CLOCK_OFFSET, sizeof(clkoff_cp),
-			     &clkoff_cp);
-	}
-
-	return hci_abort_conn(conn, reason);
-}
-
-static void hci_add_sco(struct hci_conn *conn, __u16 handle)
-{
-	struct hci_dev *hdev = conn->hdev;
-	struct hci_cp_add_sco cp;
-
-	BT_DBG("hcon %p", conn);
-
-	conn->state = BT_CONNECT;
-	conn->out = true;
-
-	conn->attempt++;
-
-	cp.handle   = cpu_to_le16(handle);
-	cp.pkt_type = cpu_to_le16(conn->pkt_type);
-
-	hci_send_cmd(hdev, HCI_OP_ADD_SCO, sizeof(cp), &cp);
-}
-
-static bool find_next_esco_param(struct hci_conn *conn,
-				 const struct sco_param *esco_param, int size)
-{
-	if (!conn->parent)
-		return false;
-
-	for (; conn->attempt <= size; conn->attempt++) {
-		if (lmp_esco_2m_capable(conn->parent) ||
-		    (esco_param[conn->attempt - 1].pkt_type & ESCO_2EV3))
-			break;
-		BT_DBG("hcon %p skipped attempt %d, eSCO 2M not supported",
-		       conn, conn->attempt);
-	}
-
-	return conn->attempt <= size;
-}
-
-static int configure_datapath_sync(struct hci_dev *hdev, struct bt_codec *codec)
-{
-	int err;
-	__u8 vnd_len, *vnd_data = NULL;
-	struct hci_op_configure_data_path *cmd = NULL;
-
-	/* Do not take below 2 checks as error since the 1st means user do not
-	 * want to use HFP offload mode and the 2nd means the vendor controller
-	 * do not need to send below HCI command for offload mode.
-	 */
-	if (!codec->data_path || !hdev->get_codec_config_data)
-		return 0;
-
-	err = hdev->get_codec_config_data(hdev, ESCO_LINK, codec, &vnd_len,
-					  &vnd_data);
-	if (err < 0)
-		goto error;
-
-	cmd = kzalloc(sizeof(*cmd) + vnd_len, GFP_KERNEL);
-	if (!cmd) {
-		err = -ENOMEM;
-		goto error;
-	}
-
-	err = hdev->get_data_path_id(hdev, &cmd->data_path_id);
-	if (err < 0)
-		goto error;
-
-	cmd->vnd_len = vnd_len;
-	memcpy(cmd->vnd_data, vnd_data, vnd_len);
-
-	cmd->direction = 0x00;
-	__hci_cmd_sync_status(hdev, HCI_CONFIGURE_DATA_PATH,
-			      sizeof(*cmd) + vnd_len, cmd, HCI_CMD_TIMEOUT);
-
-	cmd->direction = 0x01;
-	err = __hci_cmd_sync_status(hdev, HCI_CONFIGURE_DATA_PATH,
-				    sizeof(*cmd) + vnd_len, cmd,
-				    HCI_CMD_TIMEOUT);
-error:
-
-	kfree(cmd);
-	kfree(vnd_data);
-	return err;
-}
-
-static int hci_enhanced_setup_sync(struct hci_dev *hdev, void *data)
-{
-	struct conn_handle_t *conn_handle = data;
-	struct hci_conn *conn = conn_handle->conn;
-	__u16 handle = conn_handle->handle;
-	struct hci_cp_enhanced_setup_sync_conn cp;
-	const struct sco_param *param;
-
-	kfree(conn_handle);
-
-	if (!hci_conn_valid(hdev, conn))
-		return -ECANCELED;
-
-	bt_dev_dbg(hdev, "hcon %p", conn);
-
-	configure_datapath_sync(hdev, &conn->codec);
-
-	conn->state = BT_CONNECT;
-	conn->out = true;
-
-	conn->attempt++;
-
-	memset(&cp, 0x00, sizeof(cp));
-
-	cp.handle   = cpu_to_le16(handle);
-
-	cp.tx_bandwidth   = cpu_to_le32(0x00001f40);
-	cp.rx_bandwidth   = cpu_to_le32(0x00001f40);
-
-	switch (conn->codec.id) {
-	case BT_CODEC_MSBC:
-		if (!find_next_esco_param(conn, esco_param_msbc,
-					  ARRAY_SIZE(esco_param_msbc)))
-			return -EINVAL;
-
-		param = &esco_param_msbc[conn->attempt - 1];
-		cp.tx_coding_format.id = 0x05;
-		cp.rx_coding_format.id = 0x05;
-		cp.tx_codec_frame_size = __cpu_to_le16(60);
-		cp.rx_codec_frame_size = __cpu_to_le16(60);
-		cp.in_bandwidth = __cpu_to_le32(32000);
-		cp.out_bandwidth = __cpu_to_le32(32000);
-		cp.in_coding_format.id = 0x04;
-		cp.out_coding_format.id = 0x04;
-		cp.in_coded_data_size = __cpu_to_le16(16);
-		cp.out_coded_data_size = __cpu_to_le16(16);
-		cp.in_pcm_data_format = 2;
-		cp.out_pcm_data_format = 2;
-		cp.in_pcm_sample_payload_msb_pos = 0;
-		cp.out_pcm_sample_payload_msb_pos = 0;
-		cp.in_data_path = conn->codec.data_path;
-		cp.out_data_path = conn->codec.data_path;
-		cp.in_transport_unit_size = 1;
-		cp.out_transport_unit_size = 1;
-		break;
-
-	case BT_CODEC_TRANSPARENT:
-		if (!find_next_esco_param(conn, esco_param_msbc,
-					  ARRAY_SIZE(esco_param_msbc)))
-			return -EINVAL;
-
-		param = &esco_param_msbc[conn->attempt - 1];
-		cp.tx_coding_format.id = 0x03;
-		cp.rx_coding_format.id = 0x03;
-		cp.tx_codec_frame_size = __cpu_to_le16(60);
-		cp.rx_codec_frame_size = __cpu_to_le16(60);
-		cp.in_bandwidth = __cpu_to_le32(0x1f40);
-		cp.out_bandwidth = __cpu_to_le32(0x1f40);
-		cp.in_coding_format.id = 0x03;
-		cp.out_coding_format.id = 0x03;
-		cp.in_coded_data_size = __cpu_to_le16(16);
-		cp.out_coded_data_size = __cpu_to_le16(16);
-		cp.in_pcm_data_format = 2;
-		cp.out_pcm_data_format = 2;
-		cp.in_pcm_sample_payload_msb_pos = 0;
-		cp.out_pcm_sample_payload_msb_pos = 0;
-		cp.in_data_path = conn->codec.data_path;
-		cp.out_data_path = conn->codec.data_path;
-		cp.in_transport_unit_size = 1;
-		cp.out_transport_unit_size = 1;
-		break;
-
-	case BT_CODEC_CVSD:
-		if (conn->parent && lmp_esco_capable(conn->parent)) {
-			if (!find_next_esco_param(conn, esco_param_cvsd,
-						  ARRAY_SIZE(esco_param_cvsd)))
-				return -EINVAL;
-			param = &esco_param_cvsd[conn->attempt - 1];
-		} else {
-			if (conn->attempt > ARRAY_SIZE(sco_param_cvsd))
-				return -EINVAL;
-			param = &sco_param_cvsd[conn->attempt - 1];
-		}
-		cp.tx_coding_format.id = 2;
-		cp.rx_coding_format.id = 2;
-		cp.tx_codec_frame_size = __cpu_to_le16(60);
-		cp.rx_codec_frame_size = __cpu_to_le16(60);
-		cp.in_bandwidth = __cpu_to_le32(16000);
-		cp.out_bandwidth = __cpu_to_le32(16000);
-		cp.in_coding_format.id = 4;
-		cp.out_coding_format.id = 4;
-		cp.in_coded_data_size = __cpu_to_le16(16);
-		cp.out_coded_data_size = __cpu_to_le16(16);
-		cp.in_pcm_data_format = 2;
-		cp.out_pcm_data_format = 2;
-		cp.in_pcm_sample_payload_msb_pos = 0;
-		cp.out_pcm_sample_payload_msb_pos = 0;
-		cp.in_data_path = conn->codec.data_path;
-		cp.out_data_path = conn->codec.data_path;
-		cp.in_transport_unit_size = 16;
-		cp.out_transport_unit_size = 16;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	cp.retrans_effort = param->retrans_effort;
-	cp.pkt_type = __cpu_to_le16(param->pkt_type);
-	cp.max_latency = __cpu_to_le16(param->max_latency);
-
-	if (hci_send_cmd(hdev, HCI_OP_ENHANCED_SETUP_SYNC_CONN, sizeof(cp), &cp) < 0)
-		return -EIO;
-
-	return 0;
-}
-
-static bool hci_setup_sync_conn(struct hci_conn *conn, __u16 handle)
-{
-	struct hci_dev *hdev = conn->hdev;
-	struct hci_cp_setup_sync_conn cp;
-	const struct sco_param *param;
-
-	bt_dev_dbg(hdev, "hcon %p", conn);
-
-	conn->state = BT_CONNECT;
-	conn->out = true;
-
-	conn->attempt++;
-
-	cp.handle   = cpu_to_le16(handle);
-
-	cp.tx_bandwidth   = cpu_to_le32(0x00001f40);
-	cp.rx_bandwidth   = cpu_to_le32(0x00001f40);
-	cp.voice_setting  = cpu_to_le16(conn->setting);
-
-	switch (conn->setting & SCO_AIRMODE_MASK) {
-	case SCO_AIRMODE_TRANSP:
-		if (!find_next_esco_param(conn, esco_param_msbc,
-					  ARRAY_SIZE(esco_param_msbc)))
-			return false;
-		param = &esco_param_msbc[conn->attempt - 1];
-		break;
-	case SCO_AIRMODE_CVSD:
-		if (conn->parent && lmp_esco_capable(conn->parent)) {
-			if (!find_next_esco_param(conn, esco_param_cvsd,
-						  ARRAY_SIZE(esco_param_cvsd)))
-				return false;
-			param = &esco_param_cvsd[conn->attempt - 1];
-		} else {
-			if (conn->attempt > ARRAY_SIZE(sco_param_cvsd))
-				return false;
-			param = &sco_param_cvsd[conn->attempt - 1];
-		}
-		break;
-	default:
-		return false;
-	}
-
-	cp.retrans_effort = param->retrans_effort;
-	cp.pkt_type = __cpu_to_le16(param->pkt_type);
-	cp.max_latency = __cpu_to_le16(param->max_latency);
-
-	if (hci_send_cmd(hdev, HCI_OP_SETUP_SYNC_CONN, sizeof(cp), &cp) < 0)
-		return false;
-
-	return true;
-}
-
-bool hci_setup_sync(struct hci_conn *conn, __u16 handle)
-{
-	int result;
-	struct conn_handle_t *conn_handle;
-
-	if (enhanced_sync_conn_capable(conn->hdev)) {
-		conn_handle = kzalloc(sizeof(*conn_handle), GFP_KERNEL);
-
-		if (!conn_handle)
-			return false;
-
-		conn_handle->conn = conn;
-		conn_handle->handle = handle;
-		result = hci_cmd_sync_queue(conn->hdev, hci_enhanced_setup_sync,
-					    conn_handle, NULL);
-		if (result < 0)
-			kfree(conn_handle);
-
-		return result == 0;
-	}
-
-	return hci_setup_sync_conn(conn, handle);
-}
-
-u8 hci_le_conn_update(struct hci_conn *conn, u16 min, u16 max, u16 latency,
-		      u16 to_multiplier)
-{
-	struct hci_dev *hdev = conn->hdev;
-	struct hci_conn_params *params;
-	struct hci_cp_le_conn_update cp;
-
-	hci_dev_lock(hdev);
-
-	params = hci_conn_params_lookup(hdev, &conn->dst, conn->dst_type);
-	if (params) {
-		params->conn_min_interval = min;
-		params->conn_max_interval = max;
-		params->conn_latency = latency;
-		params->supervision_timeout = to_multiplier;
-	}
-
-	hci_dev_unlock(hdev);
-
-	memset(&cp, 0, sizeof(cp));
-	cp.handle		= cpu_to_le16(conn->handle);
-	cp.conn_interval_min	= cpu_to_le16(min);
-	cp.conn_interval_max	= cpu_to_le16(max);
-	cp.conn_latency		= cpu_to_le16(latency);
-	cp.supervision_timeout	= cpu_to_le16(to_multiplier);
-	cp.min_ce_len		= cpu_to_le16(0x0000);
-	cp.max_ce_len		= cpu_to_le16(0x0000);
-
-	hci_send_cmd(hdev, HCI_OP_LE_CONN_UPDATE, sizeof(cp), &cp);
-
-	if (params)
-		return 0x01;
-
-	return 0x00;
-}
-
-void hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __le64 rand,
-		      __u8 ltk[16], __u8 key_size)
-{
-	struct hci_dev *hdev = conn->hdev;
-	struct hci_cp_le_start_enc cp;
-
-	BT_DBG("hcon %p", conn);
-
-	memset(&cp, 0, sizeof(cp));
-
-	cp.handle = cpu_to_le16(conn->handle);
-	cp.rand = rand;
-	cp.ediv = ediv;
-	memcpy(cp.ltk, ltk, key_size);
-
-	hci_send_cmd(hdev, HCI_OP_LE_START_ENC, sizeof(cp), &cp);
-}
-
-/* Device _must_ be locked */
-void hci_sco_setup(struct hci_conn *conn, __u8 status)
-{
-	struct hci_link *link;
-
-	link = list_first_entry_or_null(&conn->link_list, struct hci_link, list);
-	if (!link || !link->conn)
-		return;
-
-	BT_DBG("hcon %p", conn);
-
-	if (!status) {
-		if (lmp_esco_capable(conn->hdev))
-			hci_setup_sync(link->conn, conn->handle);
-		else
-			hci_add_sco(link->conn, conn->handle);
-	} else {
-		hci_connect_cfm(link->conn, status);
-		hci_conn_del(link->conn);
-	}
-}
-
-static void hci_conn_timeout(struct work_struct *work)
-{
-	struct hci_conn *conn = container_of(work, struct hci_conn,
-					     disc_work.work);
-	int refcnt = atomic_read(&conn->refcnt);
-
-	BT_DBG("hcon %p state %s", conn, state_to_string(conn->state));
-
-	WARN_ON(refcnt < 0);
-
-	/* FIXME: It was observed that in pairing failed scenario, refcnt
-	 * drops below 0. Probably this is because l2cap_conn_del calls
-	 * l2cap_chan_del for each channel, and inside l2cap_chan_del conn is
-	 * dropped. After that loop hci_chan_del is called which also drops
-	 * conn. For now make sure that ACL is alive if refcnt is higher then 0,
-	 * otherwise drop it.
-	 */
-	if (refcnt > 0)
-		return;
-
-	hci_abort_conn(conn, hci_proto_disconn_ind(conn));
-}
-
-/* Enter sniff mode */
-static void hci_conn_idle(struct work_struct *work)
-{
-	struct hci_conn *conn = container_of(work, struct hci_conn,
-					     idle_work.work);
-	struct hci_dev *hdev = conn->hdev;
-
-	BT_DBG("hcon %p mode %d", conn, conn->mode);
-
-	if (!lmp_sniff_capable(hdev) || !lmp_sniff_capable(conn))
-		return;
-
-	if (conn->mode != HCI_CM_ACTIVE || !(conn->link_policy & HCI_LP_SNIFF))
-		return;
-
-	if (lmp_sniffsubr_capable(hdev) && lmp_sniffsubr_capable(conn)) {
-		struct hci_cp_sniff_subrate cp;
-		cp.handle             = cpu_to_le16(conn->handle);
-		cp.max_latency        = cpu_to_le16(0);
-		cp.min_remote_timeout = cpu_to_le16(0);
-		cp.min_local_timeout  = cpu_to_le16(0);
-		hci_send_cmd(hdev, HCI_OP_SNIFF_SUBRATE, sizeof(cp), &cp);
-	}
-
-	if (!test_and_set_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->flags)) {
-		struct hci_cp_sniff_mode cp;
-		cp.handle       = cpu_to_le16(conn->handle);
-		cp.max_interval = cpu_to_le16(hdev->sniff_max_interval);
-		cp.min_interval = cpu_to_le16(hdev->sniff_min_interval);
-		cp.attempt      = cpu_to_le16(4);
-		cp.timeout      = cpu_to_le16(1);
-		hci_send_cmd(hdev, HCI_OP_SNIFF_MODE, sizeof(cp), &cp);
-	}
-}
-
-static void hci_conn_auto_accept(struct work_struct *work)
-{
-	struct hci_conn *conn = container_of(work, struct hci_conn,
-					     auto_accept_work.work);
-
-	hci_send_cmd(conn->hdev, HCI_OP_USER_CONFIRM_REPLY, sizeof(conn->dst),
-		     &conn->dst);
-}
-
-static void le_disable_advertising(struct hci_dev *hdev)
-{
-	if (ext_adv_capable(hdev)) {
-		struct hci_cp_le_set_ext_adv_enable cp;
-
-		cp.enable = 0x00;
-		cp.num_of_sets = 0x00;
-
-		hci_send_cmd(hdev, HCI_OP_LE_SET_EXT_ADV_ENABLE, sizeof(cp),
-			     &cp);
-	} else {
-		u8 enable = 0x00;
-		hci_send_cmd(hdev, HCI_OP_LE_SET_ADV_ENABLE, sizeof(enable),
-			     &enable);
-	}
-}
-
-static void le_conn_timeout(struct work_struct *work)
-{
-	struct hci_conn *conn = container_of(work, struct hci_conn,
-					     le_conn_timeout.work);
-	struct hci_dev *hdev = conn->hdev;
-
-	BT_DBG("");
-
-	/* We could end up here due to having done directed advertising,
-	 * so clean up the state if necessary. This should however only
-	 * happen with broken hardware or if low duty cycle was used
-	 * (which doesn't have a timeout of its own).
-	 */
-	if (conn->role == HCI_ROLE_SLAVE) {
-		/* Disable LE Advertising */
-		le_disable_advertising(hdev);
-		hci_dev_lock(hdev);
-		hci_conn_failed(conn, HCI_ERROR_ADVERTISING_TIMEOUT);
-		hci_dev_unlock(hdev);
-		return;
-	}
-
-	hci_abort_conn(conn, HCI_ERROR_REMOTE_USER_TERM);
-}
-
-struct iso_list_data {
-	union {
-		u8  cig;
-		u8  big;
-	};
-	union {
-		u8  cis;
-		u8  bis;
-		u16 sync_handle;
-	};
-	int count;
-	bool big_term;
-	bool pa_sync_term;
-	bool big_sync_term;
-};
-
-static void bis_list(struct hci_conn *conn, void *data)
-{
-	struct iso_list_data *d = data;
-
-	/* Skip if not broadcast/ANY address */
-	if (bacmp(&conn->dst, BDADDR_ANY))
-		return;
-
-	if (d->big != conn->iso_qos.bcast.big || d->bis == BT_ISO_QOS_BIS_UNSET ||
-	    d->bis != conn->iso_qos.bcast.bis)
-		return;
-
-	d->count++;
-}
-
-static int terminate_big_sync(struct hci_dev *hdev, void *data)
-{
-	struct iso_list_data *d = data;
-
-	bt_dev_dbg(hdev, "big 0x%2.2x bis 0x%2.2x", d->big, d->bis);
-
-	hci_disable_per_advertising_sync(hdev, d->bis);
-	hci_remove_ext_adv_instance_sync(hdev, d->bis, NULL);
-
-	/* Only terminate BIG if it has been created */
-	if (!d->big_term)
-		return 0;
-
-	return hci_le_terminate_big_sync(hdev, d->big,
-					 HCI_ERROR_LOCAL_HOST_TERM);
-}
-
-static void terminate_big_destroy(struct hci_dev *hdev, void *data, int err)
-{
-	kfree(data);
-}
-
-static int hci_le_terminate_big(struct hci_dev *hdev, struct hci_conn *conn)
-{
-	struct iso_list_data *d;
-	int ret;
-
-	bt_dev_dbg(hdev, "big 0x%2.2x bis 0x%2.2x", conn->iso_qos.bcast.big,
-		   conn->iso_qos.bcast.bis);
-
-	d = kzalloc(sizeof(*d), GFP_KERNEL);
-	if (!d)
-		return -ENOMEM;
-
-	d->big = conn->iso_qos.bcast.big;
-	d->bis = conn->iso_qos.bcast.bis;
-	d->big_term = test_and_clear_bit(HCI_CONN_BIG_CREATED, &conn->flags);
-
-	ret = hci_cmd_sync_queue(hdev, terminate_big_sync, d,
-				 terminate_big_destroy);
-	if (ret)
-		kfree(d);
-
-	return ret;
-}
-
-static int big_terminate_sync(struct hci_dev *hdev, void *data)
-{
-	struct iso_list_data *d = data;
-
-	bt_dev_dbg(hdev, "big 0x%2.2x sync_handle 0x%4.4x", d->big,
-		   d->sync_handle);
-
-	if (d->big_sync_term)
-		hci_le_big_terminate_sync(hdev, d->big);
-
-	if (d->pa_sync_term)
-		return hci_le_pa_terminate_sync(hdev, d->sync_handle);
-
-	return 0;
-}
-
-static void find_bis(struct hci_conn *conn, void *data)
-{
-	struct iso_list_data *d = data;
-
-	/* Ignore if BIG doesn't match */
-	if (d->big != conn->iso_qos.bcast.big)
-		return;
-
-	d->count++;
-}
-
-static int hci_le_big_terminate(struct hci_dev *hdev, u8 big, struct hci_conn *conn)
-{
-	struct iso_list_data *d;
-	int ret;
-
-	bt_dev_dbg(hdev, "big 0x%2.2x sync_handle 0x%4.4x", big, conn->sync_handle);
-
-	d = kzalloc(sizeof(*d), GFP_KERNEL);
-	if (!d)
-		return -ENOMEM;
-
-	d->big = big;
-	d->sync_handle = conn->sync_handle;
-
-	if (test_and_clear_bit(HCI_CONN_PA_SYNC, &conn->flags)) {
-		hci_conn_hash_list_flag(hdev, find_bis, PA_LINK,
-					HCI_CONN_PA_SYNC, d);
-
-		if (!d->count)
-			d->pa_sync_term = true;
-
-		d->count = 0;
-	}
-
-	if (test_and_clear_bit(HCI_CONN_BIG_SYNC, &conn->flags)) {
-		hci_conn_hash_list_flag(hdev, find_bis, BIS_LINK,
-					HCI_CONN_BIG_SYNC, d);
-
-		if (!d->count)
-			d->big_sync_term = true;
-	}
-
-	ret = hci_cmd_sync_queue(hdev, big_terminate_sync, d,
-				 terminate_big_destroy);
-	if (ret)
-		kfree(d);
-
-	return ret;
-}
-
-/* Cleanup BIS connection
- *
- * Detects if there any BIS left connected in a BIG
- * broadcaster: Remove advertising instance and terminate BIG.
- * broadcaster receiver: Teminate BIG sync and terminate PA sync.
- */
-static void bis_cleanup(struct hci_conn *conn)
-{
-	struct hci_dev *hdev = conn->hdev;
-	struct hci_conn *bis;
-
-	bt_dev_dbg(hdev, "conn %p", conn);
-
-	if (conn->role == HCI_ROLE_MASTER) {
-		if (!test_and_clear_bit(HCI_CONN_PER_ADV, &conn->flags))
-			return;
-
-		/* Check if ISO connection is a BIS and terminate advertising
-		 * set and BIG if there are no other connections using it.
-		 */
-		bis = hci_conn_hash_lookup_big(hdev, conn->iso_qos.bcast.big);
-		if (bis)
-			return;
-
-		hci_le_terminate_big(hdev, conn);
-	} else {
-		hci_le_big_terminate(hdev, conn->iso_qos.bcast.big,
-				     conn);
-	}
-}
-
-static int remove_cig_sync(struct hci_dev *hdev, void *data)
-{
-	u8 handle = PTR_UINT(data);
-
-	return hci_le_remove_cig_sync(hdev, handle);
-}
-
-static int hci_le_remove_cig(struct hci_dev *hdev, u8 handle)
-{
-	bt_dev_dbg(hdev, "handle 0x%2.2x", handle);
-
-	return hci_cmd_sync_queue(hdev, remove_cig_sync, UINT_PTR(handle),
-				  NULL);
-}
-
-static void find_cis(struct hci_conn *conn, void *data)
-{
-	struct iso_list_data *d = data;
-
-	/* Ignore broadcast or if CIG don't match */
-	if (!bacmp(&conn->dst, BDADDR_ANY) || d->cig != conn->iso_qos.ucast.cig)
-		return;
-
-	d->count++;
-}
-
-/* Cleanup CIS connection:
- *
- * Detects if there any CIS left connected in a CIG and remove it.
- */
-static void cis_cleanup(struct hci_conn *conn)
-{
-	struct hci_dev *hdev = conn->hdev;
-	struct iso_list_data d;
-
-	if (conn->iso_qos.ucast.cig == BT_ISO_QOS_CIG_UNSET)
-		return;
-
-	memset(&d, 0, sizeof(d));
-	d.cig = conn->iso_qos.ucast.cig;
-
-	/* Check if ISO connection is a CIS and remove CIG if there are
-	 * no other connections using it.
-	 */
-	hci_conn_hash_list_state(hdev, find_cis, CIS_LINK, BT_BOUND, &d);
-	hci_conn_hash_list_state(hdev, find_cis, CIS_LINK, BT_CONNECT,
-				 &d);
-	hci_conn_hash_list_state(hdev, find_cis, CIS_LINK, BT_CONNECTED,
-				 &d);
-	if (d.count)
-		return;
-
-	hci_le_remove_cig(hdev, conn->iso_qos.ucast.cig);
-}
-
-static int hci_conn_hash_alloc_unset(struct hci_dev *hdev)
-{
-	return ida_alloc_range(&hdev->unset_handle_ida, HCI_CONN_HANDLE_MAX + 1,
-			       U16_MAX, GFP_ATOMIC);
-}
-
-static struct hci_conn *__hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst,
-				       u8 role, u16 handle)
-{
-	struct hci_conn *conn;
-
-	switch (type) {
-	case ACL_LINK:
-		if (!hdev->acl_mtu)
-			return ERR_PTR(-ECONNREFUSED);
-		break;
-	case CIS_LINK:
-	case BIS_LINK:
-	case PA_LINK:
-		if (hdev->iso_mtu)
-			/* Dedicated ISO Buffer exists */
-			break;
-		fallthrough;
-	case LE_LINK:
-		if (hdev->le_mtu && hdev->le_mtu < HCI_MIN_LE_MTU)
-			return ERR_PTR(-ECONNREFUSED);
-		if (!hdev->le_mtu && hdev->acl_mtu < HCI_MIN_LE_MTU)
-			return ERR_PTR(-ECONNREFUSED);
-		break;
-	case SCO_LINK:
-	case ESCO_LINK:
-		if (!hdev->sco_pkts)
-			/* Controller does not support SCO or eSCO over HCI */
-			return ERR_PTR(-ECONNREFUSED);
-		break;
-	default:
-		return ERR_PTR(-ECONNREFUSED);
-	}
-
-	bt_dev_dbg(hdev, "dst %pMR handle 0x%4.4x", dst, handle);
-
-	conn = kzalloc(sizeof(*conn), GFP_KERNEL);
-	if (!conn)
-		return ERR_PTR(-ENOMEM);
-
-	bacpy(&conn->dst, dst);
-	bacpy(&conn->src, &hdev->bdaddr);
-	conn->handle = handle;
-	conn->hdev  = hdev;
-	conn->type  = type;
-	conn->role  = role;
-	conn->mode  = HCI_CM_ACTIVE;
-	conn->state = BT_OPEN;
-	conn->auth_type = HCI_AT_GENERAL_BONDING;
-	conn->io_capability = hdev->io_capability;
-	conn->remote_auth = 0xff;
-	conn->key_type = 0xff;
-	conn->rssi = HCI_RSSI_INVALID;
-	conn->tx_power = HCI_TX_POWER_INVALID;
-	conn->max_tx_power = HCI_TX_POWER_INVALID;
-	conn->sync_handle = HCI_SYNC_HANDLE_INVALID;
-	conn->sid = HCI_SID_INVALID;
-
-	set_bit(HCI_CONN_POWER_SAVE, &conn->flags);
-	conn->disc_timeout = HCI_DISCONN_TIMEOUT;
-
-	/* Set Default Authenticated payload timeout to 30s */
-	conn->auth_payload_timeout = DEFAULT_AUTH_PAYLOAD_TIMEOUT;
-
-	if (conn->role == HCI_ROLE_MASTER)
-		conn->out = true;
-
-	switch (type) {
-	case ACL_LINK:
-		conn->pkt_type = hdev->pkt_type & ACL_PTYPE_MASK;
-		conn->mtu = hdev->acl_mtu;
-		break;
-	case LE_LINK:
-		/* conn->src should reflect the local identity address */
-		hci_copy_identity_address(hdev, &conn->src, &conn->src_type);
-		conn->mtu = hdev->le_mtu ? hdev->le_mtu : hdev->acl_mtu;
-		break;
-	case CIS_LINK:
-	case BIS_LINK:
-	case PA_LINK:
-		/* conn->src should reflect the local identity address */
-		hci_copy_identity_address(hdev, &conn->src, &conn->src_type);
-
-		/* set proper cleanup function */
-		if (!bacmp(dst, BDADDR_ANY))
-			conn->cleanup = bis_cleanup;
-		else if (conn->role == HCI_ROLE_MASTER)
-			conn->cleanup = cis_cleanup;
-
-		conn->mtu = hdev->iso_mtu ? hdev->iso_mtu :
-			    hdev->le_mtu ? hdev->le_mtu : hdev->acl_mtu;
-		break;
-	case SCO_LINK:
-		if (lmp_esco_capable(hdev))
-			conn->pkt_type = (hdev->esco_type & SCO_ESCO_MASK) |
-					(hdev->esco_type & EDR_ESCO_MASK);
-		else
-			conn->pkt_type = hdev->pkt_type & SCO_PTYPE_MASK;
-
-		conn->mtu = hdev->sco_mtu;
-		break;
-	case ESCO_LINK:
-		conn->pkt_type = hdev->esco_type & ~EDR_ESCO_MASK;
-		conn->mtu = hdev->sco_mtu;
-		break;
-	}
-
-	skb_queue_head_init(&conn->data_q);
-	skb_queue_head_init(&conn->tx_q.queue);
-
-	INIT_LIST_HEAD(&conn->chan_list);
-	INIT_LIST_HEAD(&conn->link_list);
-
-	INIT_DELAYED_WORK(&conn->disc_work, hci_conn_timeout);
-	INIT_DELAYED_WORK(&conn->auto_accept_work, hci_conn_auto_accept);
-	INIT_DELAYED_WORK(&conn->idle_work, hci_conn_idle);
-	INIT_DELAYED_WORK(&conn->le_conn_timeout, le_conn_timeout);
-
-	atomic_set(&conn->refcnt, 0);
-
-	hci_dev_hold(hdev);
-
-	hci_conn_hash_add(hdev, conn);
-
-	/* The SCO and eSCO connections will only be notified when their
-	 * setup has been completed. This is different to ACL links which
-	 * can be notified right away.
-	 */
-	if (conn->type != SCO_LINK && conn->type != ESCO_LINK) {
-		if (hdev->notify)
-			hdev->notify(hdev, HCI_NOTIFY_CONN_ADD);
-	}
-
-	hci_conn_init_sysfs(conn);
-	return conn;
-}
-
-struct hci_conn *hci_conn_add_unset(struct hci_dev *hdev, int type,
-				    bdaddr_t *dst, u8 role)
-{
-	int handle;
-
-	bt_dev_dbg(hdev, "dst %pMR", dst);
-
-	handle = hci_conn_hash_alloc_unset(hdev);
-	if (unlikely(handle < 0))
-		return ERR_PTR(-ECONNREFUSED);
-
-	return __hci_conn_add(hdev, type, dst, role, handle);
-}
-
-struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst,
-			      u8 role, u16 handle)
-{
-	if (handle > HCI_CONN_HANDLE_MAX)
-		return ERR_PTR(-EINVAL);
-
-	return __hci_conn_add(hdev, type, dst, role, handle);
-}
-
-static void hci_conn_cleanup_child(struct hci_conn *conn, u8 reason)
-{
-	if (!reason)
-		reason = HCI_ERROR_REMOTE_USER_TERM;
-
-	/* Due to race, SCO/ISO conn might be not established yet at this point,
-	 * and nothing else will clean it up. In other cases it is done via HCI
-	 * events.
-	 */
-	switch (conn->type) {
-	case SCO_LINK:
-	case ESCO_LINK:
-		if (HCI_CONN_HANDLE_UNSET(conn->handle))
-			hci_conn_failed(conn, reason);
-		break;
-	case CIS_LINK:
-	case BIS_LINK:
-	case PA_LINK:
-		if ((conn->state != BT_CONNECTED &&
-		    !test_bit(HCI_CONN_CREATE_CIS, &conn->flags)) ||
-		    test_bit(HCI_CONN_BIG_CREATED, &conn->flags))
-			hci_conn_failed(conn, reason);
-		break;
-	}
-}
-
-static void hci_conn_unlink(struct hci_conn *conn)
-{
-	struct hci_dev *hdev = conn->hdev;
-
-	bt_dev_dbg(hdev, "hcon %p", conn);
-
-	if (!conn->parent) {
-		struct hci_link *link, *t;
-
-		list_for_each_entry_safe(link, t, &conn->link_list, list) {
-			struct hci_conn *child = link->conn;
-
-			hci_conn_unlink(child);
-
-			/* If hdev is down it means
-			 * hci_dev_close_sync/hci_conn_hash_flush is in progress
-			 * and links don't need to be cleanup as all connections
-			 * would be cleanup.
-			 */
-			if (!test_bit(HCI_UP, &hdev->flags))
-				continue;
-
-			hci_conn_cleanup_child(child, conn->abort_reason);
-		}
-
-		return;
-	}
-
-	if (!conn->link)
-		return;
-
-	list_del_rcu(&conn->link->list);
-	synchronize_rcu();
-
-	hci_conn_drop(conn->parent);
-	hci_conn_put(conn->parent);
-	conn->parent = NULL;
-
-	kfree(conn->link);
-	conn->link = NULL;
-}
-
-void hci_conn_del(struct hci_conn *conn)
-{
-	struct hci_dev *hdev = conn->hdev;
-
-	BT_DBG("%s hcon %p handle %d", hdev->name, conn, conn->handle);
-
-	hci_conn_unlink(conn);
-
-	disable_delayed_work_sync(&conn->disc_work);
-	disable_delayed_work_sync(&conn->auto_accept_work);
-	disable_delayed_work_sync(&conn->idle_work);
-
-	/* Remove the connection from the list so unacked logic can detect when
-	 * a certain pool is not being utilized.
-	 */
-	hci_conn_hash_del(hdev, conn);
-
-	/* Handle unacked frames:
-	 *
-	 * - In case there are no connection, or if restoring the buffers
-	 *   considered in transist would overflow, restore all buffers to the
-	 *   pool.
-	 * - Otherwise restore just the buffers considered in transit for the
-	 *   hci_conn
-	 */
-	switch (conn->type) {
-	case ACL_LINK:
-		if (!hci_conn_num(hdev, ACL_LINK) ||
-		    hdev->acl_cnt + conn->sent > hdev->acl_pkts)
-			hdev->acl_cnt = hdev->acl_pkts;
-		else
-			hdev->acl_cnt += conn->sent;
-		break;
-	case LE_LINK:
-		cancel_delayed_work(&conn->le_conn_timeout);
-
-		if (hdev->le_pkts) {
-			if (!hci_conn_num(hdev, LE_LINK) ||
-			    hdev->le_cnt + conn->sent > hdev->le_pkts)
-				hdev->le_cnt = hdev->le_pkts;
-			else
-				hdev->le_cnt += conn->sent;
-		} else {
-			if ((!hci_conn_num(hdev, LE_LINK) &&
-			     !hci_conn_num(hdev, ACL_LINK)) ||
-			    hdev->acl_cnt + conn->sent > hdev->acl_pkts)
-				hdev->acl_cnt = hdev->acl_pkts;
-			else
-				hdev->acl_cnt += conn->sent;
-		}
-		break;
-	case CIS_LINK:
-	case BIS_LINK:
-	case PA_LINK:
-		if (!hci_iso_count(hdev) ||
-		    hdev->iso_cnt + conn->sent > hdev->iso_pkts)
-			hdev->iso_cnt = hdev->iso_pkts;
-		else
-			hdev->iso_cnt += conn->sent;
-		break;
-	}
-
-	skb_queue_purge(&conn->data_q);
-	skb_queue_purge(&conn->tx_q.queue);
-
-	/* Remove the connection from the list and cleanup its remaining
-	 * state. This is a separate function since for some cases like
-	 * BT_CONNECT_SCAN we *only* want the cleanup part without the
-	 * rest of hci_conn_del.
-	 */
-	hci_conn_cleanup(conn);
-
-	/* Dequeue callbacks using connection pointer as data */
-	hci_cmd_sync_dequeue(hdev, NULL, conn, NULL);
-}
-
-struct hci_dev *hci_get_route(bdaddr_t *dst, bdaddr_t *src, uint8_t src_type)
-{
-	int use_src = bacmp(src, BDADDR_ANY);
-	struct hci_dev *hdev = NULL, *d;
-
-	BT_DBG("%pMR -> %pMR", src, dst);
-
-	read_lock(&hci_dev_list_lock);
-
-	list_for_each_entry(d, &hci_dev_list, list) {
-		if (!test_bit(HCI_UP, &d->flags) ||
-		    hci_dev_test_flag(d, HCI_USER_CHANNEL))
-			continue;
-
-		/* Simple routing:
-		 *   No source address - find interface with bdaddr != dst
-		 *   Source address    - find interface with bdaddr == src
-		 */
-
-		if (use_src) {
-			bdaddr_t id_addr;
-			u8 id_addr_type;
-
-			if (src_type == BDADDR_BREDR) {
-				if (!lmp_bredr_capable(d))
-					continue;
-				bacpy(&id_addr, &d->bdaddr);
-				id_addr_type = BDADDR_BREDR;
-			} else {
-				if (!lmp_le_capable(d))
-					continue;
-
-				hci_copy_identity_address(d, &id_addr,
-							  &id_addr_type);
-
-				/* Convert from HCI to three-value type */
-				if (id_addr_type == ADDR_LE_DEV_PUBLIC)
-					id_addr_type = BDADDR_LE_PUBLIC;
-				else
-					id_addr_type = BDADDR_LE_RANDOM;
-			}
-
-			if (!bacmp(&id_addr, src) && id_addr_type == src_type) {
-				hdev = d; break;
-			}
-		} else {
-			if (bacmp(&d->bdaddr, dst)) {
-				hdev = d; break;
-			}
-		}
-	}
-
-	if (hdev)
-		hdev = hci_dev_hold(hdev);
-
-	read_unlock(&hci_dev_list_lock);
-	return hdev;
-}
-EXPORT_SYMBOL(hci_get_route);
-
-/* This function requires the caller holds hdev->lock */
-static void hci_le_conn_failed(struct hci_conn *conn, u8 status)
-{
-	struct hci_dev *hdev = conn->hdev;
-
-	hci_connect_le_scan_cleanup(conn, status);
-
-	/* Enable advertising in case this was a failed connection
-	 * attempt as a peripheral.
-	 */
-	hci_enable_advertising(hdev);
-}
-
-/* This function requires the caller holds hdev->lock */
-void hci_conn_failed(struct hci_conn *conn, u8 status)
-{
-	struct hci_dev *hdev = conn->hdev;
-
-	bt_dev_dbg(hdev, "status 0x%2.2x", status);
-
-	switch (conn->type) {
-	case LE_LINK:
-		hci_le_conn_failed(conn, status);
-		break;
-	case ACL_LINK:
-		mgmt_connect_failed(hdev, conn, status);
-		break;
-	}
-
-	/* In case of BIG/PA sync failed, clear conn flags so that
-	 * the conns will be correctly cleaned up by ISO layer
-	 */
-	test_and_clear_bit(HCI_CONN_BIG_SYNC_FAILED, &conn->flags);
-	test_and_clear_bit(HCI_CONN_PA_SYNC_FAILED, &conn->flags);
-
-	conn->state = BT_CLOSED;
-	hci_connect_cfm(conn, status);
-	hci_conn_del(conn);
-}
-
-/* This function requires the caller holds hdev->lock */
-u8 hci_conn_set_handle(struct hci_conn *conn, u16 handle)
-{
-	struct hci_dev *hdev = conn->hdev;
-
-	bt_dev_dbg(hdev, "hcon %p handle 0x%4.4x", conn, handle);
-
-	if (conn->handle == handle)
-		return 0;
-
-	if (handle > HCI_CONN_HANDLE_MAX) {
-		bt_dev_err(hdev, "Invalid handle: 0x%4.4x > 0x%4.4x",
-			   handle, HCI_CONN_HANDLE_MAX);
-		return HCI_ERROR_INVALID_PARAMETERS;
-	}
-
-	/* If abort_reason has been sent it means the connection is being
-	 * aborted and the handle shall not be changed.
-	 */
-	if (conn->abort_reason)
-		return conn->abort_reason;
-
-	if (HCI_CONN_HANDLE_UNSET(conn->handle))
-		ida_free(&hdev->unset_handle_ida, conn->handle);
-
-	conn->handle = handle;
-
-	return 0;
-}
-
-struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
-				u8 dst_type, bool dst_resolved, u8 sec_level,
-				u16 conn_timeout, u8 role, u8 phy, u8 sec_phy)
-{
-	struct hci_conn *conn;
-	struct smp_irk *irk;
-	int err;
-
-	/* Let's make sure that le is enabled.*/
-	if (!hci_dev_test_flag(hdev, HCI_LE_ENABLED)) {
-		if (lmp_le_capable(hdev))
-			return ERR_PTR(-ECONNREFUSED);
-
-		return ERR_PTR(-EOPNOTSUPP);
-	}
-
-	/* Since the controller supports only one LE connection attempt at a
-	 * time, we return -EBUSY if there is any connection attempt running.
-	 */
-	if (hci_lookup_le_connect(hdev))
-		return ERR_PTR(-EBUSY);
-
-	/* If there's already a connection object but it's not in
-	 * scanning state it means it must already be established, in
-	 * which case we can't do anything else except report a failure
-	 * to connect.
-	 */
-	conn = hci_conn_hash_lookup_le(hdev, dst, dst_type);
-	if (conn && !test_bit(HCI_CONN_SCANNING, &conn->flags)) {
-		return ERR_PTR(-EBUSY);
-	}
-
-	/* Check if the destination address has been resolved by the controller
-	 * since if it did then the identity address shall be used.
-	 */
-	if (!dst_resolved) {
-		/* When given an identity address with existing identity
-		 * resolving key, the connection needs to be established
-		 * to a resolvable random address.
-		 *
-		 * Storing the resolvable random address is required here
-		 * to handle connection failures. The address will later
-		 * be resolved back into the original identity address
-		 * from the connect request.
-		 */
-		irk = hci_find_irk_by_addr(hdev, dst, dst_type);
-		if (irk && bacmp(&irk->rpa, BDADDR_ANY)) {
-			dst = &irk->rpa;
-			dst_type = ADDR_LE_DEV_RANDOM;
-		}
-	}
-
-	if (conn) {
-		bacpy(&conn->dst, dst);
-	} else {
-		conn = hci_conn_add_unset(hdev, LE_LINK, dst, role);
-		if (IS_ERR(conn))
-			return conn;
-		hci_conn_hold(conn);
-		conn->pending_sec_level = sec_level;
-	}
-
-	conn->dst_type = dst_type;
-	conn->sec_level = BT_SECURITY_LOW;
-	conn->conn_timeout = conn_timeout;
-	conn->le_adv_phy = phy;
-	conn->le_adv_sec_phy = sec_phy;
-
-	err = hci_connect_le_sync(hdev, conn);
-	if (err) {
-		hci_conn_del(conn);
-		return ERR_PTR(err);
-	}
-
-	return conn;
-}
-
-static bool is_connected(struct hci_dev *hdev, bdaddr_t *addr, u8 type)
-{
-	struct hci_conn *conn;
-
-	conn = hci_conn_hash_lookup_le(hdev, addr, type);
-	if (!conn)
-		return false;
-
-	if (conn->state != BT_CONNECTED)
-		return false;
-
-	return true;
-}
-
-/* This function requires the caller holds hdev->lock */
-static int hci_explicit_conn_params_set(struct hci_dev *hdev,
-					bdaddr_t *addr, u8 addr_type)
-{
-	struct hci_conn_params *params;
-
-	if (is_connected(hdev, addr, addr_type))
-		return -EISCONN;
-
-	params = hci_conn_params_lookup(hdev, addr, addr_type);
-	if (!params) {
-		params = hci_conn_params_add(hdev, addr, addr_type);
-		if (!params)
-			return -ENOMEM;
-
-		/* If we created new params, mark them to be deleted in
-		 * hci_connect_le_scan_cleanup. It's different case than
-		 * existing disabled params, those will stay after cleanup.
-		 */
-		params->auto_connect = HCI_AUTO_CONN_EXPLICIT;
-	}
-
-	/* We're trying to connect, so make sure params are at pend_le_conns */
-	if (params->auto_connect == HCI_AUTO_CONN_DISABLED ||
-	    params->auto_connect == HCI_AUTO_CONN_REPORT ||
-	    params->auto_connect == HCI_AUTO_CONN_EXPLICIT) {
-		hci_pend_le_list_del_init(params);
-		hci_pend_le_list_add(params, &hdev->pend_le_conns);
-	}
-
-	params->explicit_connect = true;
-
-	BT_DBG("addr %pMR (type %u) auto_connect %u", addr, addr_type,
-	       params->auto_connect);
-
-	return 0;
-}
-
-static int qos_set_big(struct hci_dev *hdev, struct bt_iso_qos *qos)
-{
-	struct hci_conn *conn;
-	u8  big;
-
-	/* Allocate a BIG if not set */
-	if (qos->bcast.big == BT_ISO_QOS_BIG_UNSET) {
-		for (big = 0x00; big < 0xef; big++) {
-
-			conn = hci_conn_hash_lookup_big(hdev, big);
-			if (!conn)
-				break;
-		}
-
-		if (big == 0xef)
-			return -EADDRNOTAVAIL;
-
-		/* Update BIG */
-		qos->bcast.big = big;
-	}
-
-	return 0;
-}
-
-static int qos_set_bis(struct hci_dev *hdev, struct bt_iso_qos *qos)
-{
-	struct hci_conn *conn;
-	u8  bis;
-
-	/* Allocate BIS if not set */
-	if (qos->bcast.bis == BT_ISO_QOS_BIS_UNSET) {
-		if (qos->bcast.big != BT_ISO_QOS_BIG_UNSET) {
-			conn = hci_conn_hash_lookup_big(hdev, qos->bcast.big);
-
-			if (conn) {
-				/* If the BIG handle is already matched to an advertising
-				 * handle, do not allocate a new one.
-				 */
-				qos->bcast.bis = conn->iso_qos.bcast.bis;
-				return 0;
-			}
-		}
-
-		/* Find an unused adv set to advertise BIS, skip instance 0x00
-		 * since it is reserved as general purpose set.
-		 */
-		for (bis = 0x01; bis < hdev->le_num_of_adv_sets;
-		     bis++) {
-
-			conn = hci_conn_hash_lookup_bis(hdev, BDADDR_ANY, bis);
-			if (!conn)
-				break;
-		}
-
-		if (bis == hdev->le_num_of_adv_sets)
-			return -EADDRNOTAVAIL;
-
-		/* Update BIS */
-		qos->bcast.bis = bis;
-	}
-
-	return 0;
-}
-
-/* This function requires the caller holds hdev->lock */
-static struct hci_conn *hci_add_bis(struct hci_dev *hdev, bdaddr_t *dst,
-				    __u8 sid, struct bt_iso_qos *qos,
-				    __u8 base_len, __u8 *base)
-{
-	struct hci_conn *conn;
-	int err;
-
-	/* Let's make sure that le is enabled.*/
-	if (!hci_dev_test_flag(hdev, HCI_LE_ENABLED)) {
-		if (lmp_le_capable(hdev))
-			return ERR_PTR(-ECONNREFUSED);
-		return ERR_PTR(-EOPNOTSUPP);
-	}
-
-	err = qos_set_big(hdev, qos);
-	if (err)
-		return ERR_PTR(err);
-
-	err = qos_set_bis(hdev, qos);
-	if (err)
-		return ERR_PTR(err);
-
-	/* Check if the LE Create BIG command has already been sent */
-	conn = hci_conn_hash_lookup_per_adv_bis(hdev, dst, qos->bcast.big,
-						qos->bcast.big);
-	if (conn)
-		return ERR_PTR(-EADDRINUSE);
-
-	/* Check BIS settings against other bound BISes, since all
-	 * BISes in a BIG must have the same value for all parameters
-	 */
-	conn = hci_conn_hash_lookup_big(hdev, qos->bcast.big);
-
-	if (conn && (memcmp(qos, &conn->iso_qos, sizeof(*qos)) ||
-		     base_len != conn->le_per_adv_data_len ||
-		     memcmp(conn->le_per_adv_data, base, base_len)))
-		return ERR_PTR(-EADDRINUSE);
-
-	conn = hci_conn_add_unset(hdev, BIS_LINK, dst, HCI_ROLE_MASTER);
-	if (IS_ERR(conn))
-		return conn;
-
-	conn->state = BT_CONNECT;
-	conn->sid = sid;
-
-	hci_conn_hold(conn);
-	return conn;
-}
-
-/* This function requires the caller holds hdev->lock */
-struct hci_conn *hci_connect_le_scan(struct hci_dev *hdev, bdaddr_t *dst,
-				     u8 dst_type, u8 sec_level,
-				     u16 conn_timeout,
-				     enum conn_reasons conn_reason)
-{
-	struct hci_conn *conn;
-
-	/* Let's make sure that le is enabled.*/
-	if (!hci_dev_test_flag(hdev, HCI_LE_ENABLED)) {
-		if (lmp_le_capable(hdev))
-			return ERR_PTR(-ECONNREFUSED);
-
-		return ERR_PTR(-EOPNOTSUPP);
-	}
-
-	/* Some devices send ATT messages as soon as the physical link is
-	 * established. To be able to handle these ATT messages, the user-
-	 * space first establishes the connection and then starts the pairing
-	 * process.
-	 *
-	 * So if a hci_conn object already exists for the following connection
-	 * attempt, we simply update pending_sec_level and auth_type fields
-	 * and return the object found.
-	 */
-	conn = hci_conn_hash_lookup_le(hdev, dst, dst_type);
-	if (conn) {
-		if (conn->pending_sec_level < sec_level)
-			conn->pending_sec_level = sec_level;
-		goto done;
-	}
-
-	BT_DBG("requesting refresh of dst_addr");
-
-	conn = hci_conn_add_unset(hdev, LE_LINK, dst, HCI_ROLE_MASTER);
-	if (IS_ERR(conn))
-		return conn;
-
-	if (hci_explicit_conn_params_set(hdev, dst, dst_type) < 0) {
-		hci_conn_del(conn);
-		return ERR_PTR(-EBUSY);
-	}
-
-	conn->state = BT_CONNECT;
-	set_bit(HCI_CONN_SCANNING, &conn->flags);
-	conn->dst_type = dst_type;
-	conn->sec_level = BT_SECURITY_LOW;
-	conn->pending_sec_level = sec_level;
-	conn->conn_timeout = conn_timeout;
-	conn->conn_reason = conn_reason;
-
-	hci_update_passive_scan(hdev);
-
-done:
-	hci_conn_hold(conn);
-	return conn;
-}
-
-struct hci_conn *hci_connect_acl(struct hci_dev *hdev, bdaddr_t *dst,
-				 u8 sec_level, u8 auth_type,
-				 enum conn_reasons conn_reason, u16 timeout)
-{
-	struct hci_conn *acl;
-
-	if (!hci_dev_test_flag(hdev, HCI_BREDR_ENABLED)) {
-		if (lmp_bredr_capable(hdev))
-			return ERR_PTR(-ECONNREFUSED);
-
-		return ERR_PTR(-EOPNOTSUPP);
-	}
-
-	/* Reject outgoing connection to device with same BD ADDR against
-	 * CVE-2020-26555
-	 */
-	if (!bacmp(&hdev->bdaddr, dst)) {
-		bt_dev_dbg(hdev, "Reject connection with same BD_ADDR %pMR\n",
-			   dst);
-		return ERR_PTR(-ECONNREFUSED);
-	}
-
-	acl = hci_conn_hash_lookup_ba(hdev, ACL_LINK, dst);
-	if (!acl) {
-		acl = hci_conn_add_unset(hdev, ACL_LINK, dst, HCI_ROLE_MASTER);
-		if (IS_ERR(acl))
-			return acl;
-	}
-
-	hci_conn_hold(acl);
-
-	acl->conn_reason = conn_reason;
-	if (acl->state == BT_OPEN || acl->state == BT_CLOSED) {
-		int err;
-
-		acl->sec_level = BT_SECURITY_LOW;
-		acl->pending_sec_level = sec_level;
-		acl->auth_type = auth_type;
-		acl->conn_timeout = timeout;
-
-		err = hci_connect_acl_sync(hdev, acl);
-		if (err) {
-			hci_conn_del(acl);
-			return ERR_PTR(err);
-		}
-	}
-
-	return acl;
-}
-
-static struct hci_link *hci_conn_link(struct hci_conn *parent,
-				      struct hci_conn *conn)
-{
-	struct hci_dev *hdev = parent->hdev;
-	struct hci_link *link;
-
-	bt_dev_dbg(hdev, "parent %p hcon %p", parent, conn);
-
-	if (conn->link)
-		return conn->link;
-
-	if (conn->parent)
-		return NULL;
-
-	link = kzalloc(sizeof(*link), GFP_KERNEL);
-	if (!link)
-		return NULL;
-
-	link->conn = hci_conn_hold(conn);
-	conn->link = link;
-	conn->parent = hci_conn_get(parent);
-
-	/* Use list_add_tail_rcu append to the list */
-	list_add_tail_rcu(&link->list, &parent->link_list);
-
-	return link;
-}
-
-struct hci_conn *hci_connect_sco(struct hci_dev *hdev, int type, bdaddr_t *dst,
-				 __u16 setting, struct bt_codec *codec,
-				 u16 timeout)
-{
-	struct hci_conn *acl;
-	struct hci_conn *sco;
-	struct hci_link *link;
-
-	acl = hci_connect_acl(hdev, dst, BT_SECURITY_LOW, HCI_AT_NO_BONDING,
-			      CONN_REASON_SCO_CONNECT, timeout);
-	if (IS_ERR(acl))
-		return acl;
-
-	sco = hci_conn_hash_lookup_ba(hdev, type, dst);
-	if (!sco) {
-		sco = hci_conn_add_unset(hdev, type, dst, HCI_ROLE_MASTER);
-		if (IS_ERR(sco)) {
-			hci_conn_drop(acl);
-			return sco;
-		}
-	}
-
-	link = hci_conn_link(acl, sco);
-	if (!link) {
-		hci_conn_drop(acl);
-		hci_conn_drop(sco);
-		return ERR_PTR(-ENOLINK);
-	}
-
-	sco->setting = setting;
-	sco->codec = *codec;
-
-	if (acl->state == BT_CONNECTED &&
-	    (sco->state == BT_OPEN || sco->state == BT_CLOSED)) {
-		set_bit(HCI_CONN_POWER_SAVE, &acl->flags);
-		hci_conn_enter_active_mode(acl, BT_POWER_FORCE_ACTIVE_ON);
-
-		if (test_bit(HCI_CONN_MODE_CHANGE_PEND, &acl->flags)) {
-			/* defer SCO setup until mode change completed */
-			set_bit(HCI_CONN_SCO_SETUP_PEND, &acl->flags);
-			return sco;
-		}
-
-		hci_sco_setup(acl, 0x00);
-	}
-
-	return sco;
-}
-
-static int hci_le_create_big(struct hci_conn *conn, struct bt_iso_qos *qos)
-{
-	struct hci_dev *hdev = conn->hdev;
-	struct hci_cp_le_create_big cp;
-	struct iso_list_data data;
-
-	memset(&cp, 0, sizeof(cp));
-
-	data.big = qos->bcast.big;
-	data.bis = qos->bcast.bis;
-	data.count = 0;
-
-	/* Create a BIS for each bound connection */
-	hci_conn_hash_list_state(hdev, bis_list, BIS_LINK,
-				 BT_BOUND, &data);
-
-	cp.handle = qos->bcast.big;
-	cp.adv_handle = qos->bcast.bis;
-	cp.num_bis  = data.count;
-	hci_cpu_to_le24(qos->bcast.out.interval, cp.bis.sdu_interval);
-	cp.bis.sdu = cpu_to_le16(qos->bcast.out.sdu);
-	cp.bis.latency =  cpu_to_le16(qos->bcast.out.latency);
-	cp.bis.rtn  = qos->bcast.out.rtn;
-	cp.bis.phy  = qos->bcast.out.phy;
-	cp.bis.packing = qos->bcast.packing;
-	cp.bis.framing = qos->bcast.framing;
-	cp.bis.encryption = qos->bcast.encryption;
-	memcpy(cp.bis.bcode, qos->bcast.bcode, sizeof(cp.bis.bcode));
-
-	return hci_send_cmd(hdev, HCI_OP_LE_CREATE_BIG, sizeof(cp), &cp);
-}
-
-static int set_cig_params_sync(struct hci_dev *hdev, void *data)
-{
-	DEFINE_FLEX(struct hci_cp_le_set_cig_params, pdu, cis, num_cis, 0x1f);
-	u8 cig_id = PTR_UINT(data);
-	struct hci_conn *conn;
-	struct bt_iso_qos *qos;
-	u8 aux_num_cis = 0;
-	u8 cis_id;
-
-	conn = hci_conn_hash_lookup_cig(hdev, cig_id);
-	if (!conn)
-		return 0;
-
-	qos = &conn->iso_qos;
-	pdu->cig_id = cig_id;
-	hci_cpu_to_le24(qos->ucast.out.interval, pdu->c_interval);
-	hci_cpu_to_le24(qos->ucast.in.interval, pdu->p_interval);
-	pdu->sca = qos->ucast.sca;
-	pdu->packing = qos->ucast.packing;
-	pdu->framing = qos->ucast.framing;
-	pdu->c_latency = cpu_to_le16(qos->ucast.out.latency);
-	pdu->p_latency = cpu_to_le16(qos->ucast.in.latency);
-
-	/* Reprogram all CIS(s) with the same CIG, valid range are:
-	 * num_cis: 0x00 to 0x1F
-	 * cis_id: 0x00 to 0xEF
-	 */
-	for (cis_id = 0x00; cis_id < 0xf0 &&
-	     aux_num_cis < pdu->num_cis; cis_id++) {
-		struct hci_cis_params *cis;
-
-		conn = hci_conn_hash_lookup_cis(hdev, NULL, 0, cig_id, cis_id);
-		if (!conn)
-			continue;
-
-		qos = &conn->iso_qos;
-
-		cis = &pdu->cis[aux_num_cis++];
-		cis->cis_id = cis_id;
-		cis->c_sdu  = cpu_to_le16(conn->iso_qos.ucast.out.sdu);
-		cis->p_sdu  = cpu_to_le16(conn->iso_qos.ucast.in.sdu);
-		cis->c_phy  = qos->ucast.out.phy ? qos->ucast.out.phy :
-			      qos->ucast.in.phy;
-		cis->p_phy  = qos->ucast.in.phy ? qos->ucast.in.phy :
-			      qos->ucast.out.phy;
-		cis->c_rtn  = qos->ucast.out.rtn;
-		cis->p_rtn  = qos->ucast.in.rtn;
-	}
-	pdu->num_cis = aux_num_cis;
-
-	if (!pdu->num_cis)
-		return 0;
-
-	return __hci_cmd_sync_status(hdev, HCI_OP_LE_SET_CIG_PARAMS,
-				     struct_size(pdu, cis, pdu->num_cis),
-				     pdu, HCI_CMD_TIMEOUT);
-}
-
-static bool hci_le_set_cig_params(struct hci_conn *conn, struct bt_iso_qos *qos)
-{
-	struct hci_dev *hdev = conn->hdev;
-	struct iso_list_data data;
-
-	memset(&data, 0, sizeof(data));
-
-	/* Allocate first still reconfigurable CIG if not set */
-	if (qos->ucast.cig == BT_ISO_QOS_CIG_UNSET) {
-		for (data.cig = 0x00; data.cig < 0xf0; data.cig++) {
-			data.count = 0;
-
-			hci_conn_hash_list_state(hdev, find_cis, CIS_LINK,
-						 BT_CONNECT, &data);
-			if (data.count)
-				continue;
-
-			hci_conn_hash_list_state(hdev, find_cis, CIS_LINK,
-						 BT_CONNECTED, &data);
-			if (!data.count)
-				break;
-		}
-
-		if (data.cig == 0xf0)
-			return false;
-
-		/* Update CIG */
-		qos->ucast.cig = data.cig;
-	}
-
-	if (qos->ucast.cis != BT_ISO_QOS_CIS_UNSET) {
-		if (hci_conn_hash_lookup_cis(hdev, NULL, 0, qos->ucast.cig,
-					     qos->ucast.cis))
-			return false;
-		goto done;
-	}
-
-	/* Allocate first available CIS if not set */
-	for (data.cig = qos->ucast.cig, data.cis = 0x00; data.cis < 0xf0;
-	     data.cis++) {
-		if (!hci_conn_hash_lookup_cis(hdev, NULL, 0, data.cig,
-					      data.cis)) {
-			/* Update CIS */
-			qos->ucast.cis = data.cis;
-			break;
-		}
-	}
-
-	if (qos->ucast.cis == BT_ISO_QOS_CIS_UNSET)
-		return false;
-
-done:
-	if (hci_cmd_sync_queue(hdev, set_cig_params_sync,
-			       UINT_PTR(qos->ucast.cig), NULL) < 0)
-		return false;
-
-	return true;
-}
-
-struct hci_conn *hci_bind_cis(struct hci_dev *hdev, bdaddr_t *dst,
-			      __u8 dst_type, struct bt_iso_qos *qos)
-{
-	struct hci_conn *cis;
-
-	cis = hci_conn_hash_lookup_cis(hdev, dst, dst_type, qos->ucast.cig,
-				       qos->ucast.cis);
-	if (!cis) {
-		cis = hci_conn_add_unset(hdev, CIS_LINK, dst,
-					 HCI_ROLE_MASTER);
-		if (IS_ERR(cis))
-			return cis;
-		cis->cleanup = cis_cleanup;
-		cis->dst_type = dst_type;
-		cis->iso_qos.ucast.cig = BT_ISO_QOS_CIG_UNSET;
-		cis->iso_qos.ucast.cis = BT_ISO_QOS_CIS_UNSET;
-	}
-
-	if (cis->state == BT_CONNECTED)
-		return cis;
-
-	/* Check if CIS has been set and the settings matches */
-	if (cis->state == BT_BOUND &&
-	    !memcmp(&cis->iso_qos, qos, sizeof(*qos)))
-		return cis;
-
-	/* Update LINK PHYs according to QoS preference */
-	cis->le_tx_phy = qos->ucast.out.phy;
-	cis->le_rx_phy = qos->ucast.in.phy;
-
-	/* If output interval is not set use the input interval as it cannot be
-	 * 0x000000.
-	 */
-	if (!qos->ucast.out.interval)
-		qos->ucast.out.interval = qos->ucast.in.interval;
-
-	/* If input interval is not set use the output interval as it cannot be
-	 * 0x000000.
-	 */
-	if (!qos->ucast.in.interval)
-		qos->ucast.in.interval = qos->ucast.out.interval;
-
-	/* If output latency is not set use the input latency as it cannot be
-	 * 0x0000.
-	 */
-	if (!qos->ucast.out.latency)
-		qos->ucast.out.latency = qos->ucast.in.latency;
-
-	/* If input latency is not set use the output latency as it cannot be
-	 * 0x0000.
-	 */
-	if (!qos->ucast.in.latency)
-		qos->ucast.in.latency = qos->ucast.out.latency;
-
-	if (!hci_le_set_cig_params(cis, qos)) {
-		hci_conn_drop(cis);
-		return ERR_PTR(-EINVAL);
-	}
-
-	hci_conn_hold(cis);
-
-	cis->iso_qos = *qos;
-	cis->state = BT_BOUND;
-
-	return cis;
-}
-
-bool hci_iso_setup_path(struct hci_conn *conn)
-{
-	struct hci_dev *hdev = conn->hdev;
-	struct hci_cp_le_setup_iso_path cmd;
-
-	memset(&cmd, 0, sizeof(cmd));
-
-	if (conn->iso_qos.ucast.out.sdu) {
-		cmd.handle = cpu_to_le16(conn->handle);
-		cmd.direction = 0x00; /* Input (Host to Controller) */
-		cmd.path = 0x00; /* HCI path if enabled */
-		cmd.codec = 0x03; /* Transparent Data */
-
-		if (hci_send_cmd(hdev, HCI_OP_LE_SETUP_ISO_PATH, sizeof(cmd),
-				 &cmd) < 0)
-			return false;
-	}
-
-	if (conn->iso_qos.ucast.in.sdu) {
-		cmd.handle = cpu_to_le16(conn->handle);
-		cmd.direction = 0x01; /* Output (Controller to Host) */
-		cmd.path = 0x00; /* HCI path if enabled */
-		cmd.codec = 0x03; /* Transparent Data */
-
-		if (hci_send_cmd(hdev, HCI_OP_LE_SETUP_ISO_PATH, sizeof(cmd),
-				 &cmd) < 0)
-			return false;
-	}
-
-	return true;
-}
-
-int hci_conn_check_create_cis(struct hci_conn *conn)
-{
-	if (conn->type != CIS_LINK)
-		return -EINVAL;
-
-	if (!conn->parent || conn->parent->state != BT_CONNECTED ||
-	    conn->state != BT_CONNECT || HCI_CONN_HANDLE_UNSET(conn->handle))
-		return 1;
-
-	return 0;
-}
-
-static int hci_create_cis_sync(struct hci_dev *hdev, void *data)
-{
-	return hci_le_create_cis_sync(hdev);
-}
-
-int hci_le_create_cis_pending(struct hci_dev *hdev)
-{
-	struct hci_conn *conn;
-	bool pending = false;
-
-	rcu_read_lock();
-
-	list_for_each_entry_rcu(conn, &hdev->conn_hash.list, list) {
-		if (test_bit(HCI_CONN_CREATE_CIS, &conn->flags)) {
-			rcu_read_unlock();
-			return -EBUSY;
-		}
-
-		if (!hci_conn_check_create_cis(conn))
-			pending = true;
-	}
-
-	rcu_read_unlock();
-
-	if (!pending)
-		return 0;
-
-	/* Queue Create CIS */
-	return hci_cmd_sync_queue(hdev, hci_create_cis_sync, NULL, NULL);
-}
-
-static void hci_iso_qos_setup(struct hci_dev *hdev, struct hci_conn *conn,
-			      struct bt_iso_io_qos *qos, __u8 phy)
-{
-	/* Only set MTU if PHY is enabled */
-	if (!qos->sdu && qos->phy)
-		qos->sdu = conn->mtu;
-
-	/* Use the same PHY as ACL if set to any */
-	if (qos->phy == BT_ISO_PHY_ANY)
-		qos->phy = phy;
-
-	/* Use LE ACL connection interval if not set */
-	if (!qos->interval)
-		/* ACL interval unit in 1.25 ms to us */
-		qos->interval = conn->le_conn_interval * 1250;
-
-	/* Use LE ACL connection latency if not set */
-	if (!qos->latency)
-		qos->latency = conn->le_conn_latency;
-}
-
-static int create_big_sync(struct hci_dev *hdev, void *data)
-{
-	struct hci_conn *conn = data;
-	struct bt_iso_qos *qos = &conn->iso_qos;
-	u16 interval, sync_interval = 0;
-	u32 flags = 0;
-	int err;
-
-	if (qos->bcast.out.phy == 0x02)
-		flags |= MGMT_ADV_FLAG_SEC_2M;
-
-	/* Align intervals */
-	interval = (qos->bcast.out.interval / 1250) * qos->bcast.sync_factor;
-
-	if (qos->bcast.bis)
-		sync_interval = interval * 4;
-
-	err = hci_start_per_adv_sync(hdev, qos->bcast.bis, conn->sid,
-				     conn->le_per_adv_data_len,
-				     conn->le_per_adv_data, flags, interval,
-				     interval, sync_interval);
-	if (err)
-		return err;
-
-	return hci_le_create_big(conn, &conn->iso_qos);
-}
-
-struct hci_conn *hci_pa_create_sync(struct hci_dev *hdev, bdaddr_t *dst,
-				    __u8 dst_type, __u8 sid,
-				    struct bt_iso_qos *qos)
-{
-	struct hci_conn *conn;
-
-	bt_dev_dbg(hdev, "dst %pMR type %d sid %d", dst, dst_type, sid);
-
-	conn = hci_conn_add_unset(hdev, PA_LINK, dst, HCI_ROLE_SLAVE);
-	if (IS_ERR(conn))
-		return conn;
-
-	conn->iso_qos = *qos;
-	conn->dst_type = dst_type;
-	conn->sid = sid;
-	conn->state = BT_LISTEN;
-	conn->conn_timeout = msecs_to_jiffies(qos->bcast.sync_timeout * 10);
-
-	hci_conn_hold(conn);
-
-	hci_connect_pa_sync(hdev, conn);
-
-	return conn;
-}
-
-int hci_conn_big_create_sync(struct hci_dev *hdev, struct hci_conn *hcon,
-			     struct bt_iso_qos *qos, __u16 sync_handle,
-			     __u8 num_bis, __u8 bis[])
-{
-	int err;
-
-	if (num_bis < 0x01 || num_bis > ISO_MAX_NUM_BIS)
-		return -EINVAL;
-
-	err = qos_set_big(hdev, qos);
-	if (err)
-		return err;
-
-	if (hcon) {
-		/* Update hcon QoS */
-		hcon->iso_qos = *qos;
-
-		hcon->num_bis = num_bis;
-		memcpy(hcon->bis, bis, num_bis);
-		hcon->conn_timeout = msecs_to_jiffies(qos->bcast.timeout * 10);
-	}
-
-	return hci_connect_big_sync(hdev, hcon);
-}
-
-static void create_big_complete(struct hci_dev *hdev, void *data, int err)
-{
-	struct hci_conn *conn = data;
-
-	bt_dev_dbg(hdev, "conn %p", conn);
-
-	if (err) {
-		bt_dev_err(hdev, "Unable to create BIG: %d", err);
-		hci_connect_cfm(conn, err);
-		hci_conn_del(conn);
-	}
-}
-
-struct hci_conn *hci_bind_bis(struct hci_dev *hdev, bdaddr_t *dst, __u8 sid,
-			      struct bt_iso_qos *qos,
-			      __u8 base_len, __u8 *base)
-{
-	struct hci_conn *conn;
-	struct hci_conn *parent;
-	__u8 eir[HCI_MAX_PER_AD_LENGTH];
-	struct hci_link *link;
-
-	/* Look for any BIS that is open for rebinding */
-	conn = hci_conn_hash_lookup_big_state(hdev, qos->bcast.big, BT_OPEN,
-					      HCI_ROLE_MASTER);
-	if (conn) {
-		memcpy(qos, &conn->iso_qos, sizeof(*qos));
-		conn->state = BT_CONNECTED;
-		return conn;
-	}
-
-	if (base_len && base)
-		base_len = eir_append_service_data(eir, 0,  0x1851,
-						   base, base_len);
-
-	/* We need hci_conn object using the BDADDR_ANY as dst */
-	conn = hci_add_bis(hdev, dst, sid, qos, base_len, eir);
-	if (IS_ERR(conn))
-		return conn;
-
-	/* Update LINK PHYs according to QoS preference */
-	conn->le_tx_phy = qos->bcast.out.phy;
-	conn->le_tx_phy = qos->bcast.out.phy;
-
-	/* Add Basic Announcement into Peridic Adv Data if BASE is set */
-	if (base_len && base) {
-		memcpy(conn->le_per_adv_data,  eir, sizeof(eir));
-		conn->le_per_adv_data_len = base_len;
-	}
-
-	hci_iso_qos_setup(hdev, conn, &qos->bcast.out,
-			  conn->le_tx_phy ? conn->le_tx_phy :
-			  hdev->le_tx_def_phys);
-
-	conn->iso_qos = *qos;
-	conn->state = BT_BOUND;
-
-	/* Link BISes together */
-	parent = hci_conn_hash_lookup_big(hdev,
-					  conn->iso_qos.bcast.big);
-	if (parent && parent != conn) {
-		link = hci_conn_link(parent, conn);
-		hci_conn_drop(conn);
-		if (!link)
-			return ERR_PTR(-ENOLINK);
-	}
-
-	return conn;
-}
-
-static void bis_mark_per_adv(struct hci_conn *conn, void *data)
-{
-	struct iso_list_data *d = data;
-
-	/* Skip if not broadcast/ANY address */
-	if (bacmp(&conn->dst, BDADDR_ANY))
-		return;
-
-	if (d->big != conn->iso_qos.bcast.big ||
-	    d->bis == BT_ISO_QOS_BIS_UNSET ||
-	    d->bis != conn->iso_qos.bcast.bis)
-		return;
-
-	set_bit(HCI_CONN_PER_ADV, &conn->flags);
-}
-
-struct hci_conn *hci_connect_bis(struct hci_dev *hdev, bdaddr_t *dst,
-				 __u8 dst_type, __u8 sid,
-				 struct bt_iso_qos *qos,
-				 __u8 base_len, __u8 *base)
-{
-	struct hci_conn *conn;
-	int err;
-	struct iso_list_data data;
-
-	conn = hci_bind_bis(hdev, dst, sid, qos, base_len, base);
-	if (IS_ERR(conn))
-		return conn;
-
-	if (conn->state == BT_CONNECTED)
-		return conn;
-
-	/* Check if SID needs to be allocated then search for the first
-	 * available.
-	 */
-	if (conn->sid == HCI_SID_INVALID) {
-		u8 sid;
-
-		for (sid = 0; sid <= 0x0f; sid++) {
-			if (!hci_find_adv_sid(hdev, sid)) {
-				conn->sid = sid;
-				break;
-			}
-		}
-	}
-
-	data.big = qos->bcast.big;
-	data.bis = qos->bcast.bis;
-
-	/* Set HCI_CONN_PER_ADV for all bound connections, to mark that
-	 * the start periodic advertising and create BIG commands have
-	 * been queued
-	 */
-	hci_conn_hash_list_state(hdev, bis_mark_per_adv, PA_LINK,
-				 BT_BOUND, &data);
-
-	/* Queue start periodic advertising and create BIG */
-	err = hci_cmd_sync_queue(hdev, create_big_sync, conn,
-				 create_big_complete);
-	if (err < 0) {
-		hci_conn_drop(conn);
-		return ERR_PTR(err);
-	}
-
-	return conn;
-}
-
-struct hci_conn *hci_connect_cis(struct hci_dev *hdev, bdaddr_t *dst,
-				 __u8 dst_type, struct bt_iso_qos *qos)
-{
-	struct hci_conn *le;
-	struct hci_conn *cis;
-	struct hci_link *link;
-
-	if (hci_dev_test_flag(hdev, HCI_ADVERTISING))
-		le = hci_connect_le(hdev, dst, dst_type, false,
-				    BT_SECURITY_LOW,
-				    HCI_LE_CONN_TIMEOUT,
-				    HCI_ROLE_SLAVE, 0, 0);
-	else
-		le = hci_connect_le_scan(hdev, dst, dst_type,
-					 BT_SECURITY_LOW,
-					 HCI_LE_CONN_TIMEOUT,
-					 CONN_REASON_ISO_CONNECT);
-	if (IS_ERR(le))
-		return le;
-
-	hci_iso_qos_setup(hdev, le, &qos->ucast.out,
-			  le->le_tx_phy ? le->le_tx_phy : hdev->le_tx_def_phys);
-	hci_iso_qos_setup(hdev, le, &qos->ucast.in,
-			  le->le_rx_phy ? le->le_rx_phy : hdev->le_rx_def_phys);
-
-	cis = hci_bind_cis(hdev, dst, dst_type, qos);
-	if (IS_ERR(cis)) {
-		hci_conn_drop(le);
-		return cis;
-	}
-
-	link = hci_conn_link(le, cis);
-	hci_conn_drop(cis);
-	if (!link) {
-		hci_conn_drop(le);
-		return ERR_PTR(-ENOLINK);
-	}
-
-	cis->state = BT_CONNECT;
-
-	hci_le_create_cis_pending(hdev);
-
-	return cis;
-}
-
-/* Check link security requirement */
-int hci_conn_check_link_mode(struct hci_conn *conn)
-{
-	BT_DBG("hcon %p", conn);
-
-	/* In Secure Connections Only mode, it is required that Secure
-	 * Connections is used and the link is encrypted with AES-CCM
-	 * using a P-256 authenticated combination key.
-	 */
-	if (hci_dev_test_flag(conn->hdev, HCI_SC_ONLY)) {
-		if (!hci_conn_sc_enabled(conn) ||
-		    !test_bit(HCI_CONN_AES_CCM, &conn->flags) ||
-		    conn->key_type != HCI_LK_AUTH_COMBINATION_P256)
-			return 0;
-	}
-
-	 /* AES encryption is required for Level 4:
-	  *
-	  * BLUETOOTH CORE SPECIFICATION Version 5.2 | Vol 3, Part C
-	  * page 1319:
-	  *
-	  * 128-bit equivalent strength for link and encryption keys
-	  * required using FIPS approved algorithms (E0 not allowed,
-	  * SAFER+ not allowed, and P-192 not allowed; encryption key
-	  * not shortened)
-	  */
-	if (conn->sec_level == BT_SECURITY_FIPS &&
-	    !test_bit(HCI_CONN_AES_CCM, &conn->flags)) {
-		bt_dev_err(conn->hdev,
-			   "Invalid security: Missing AES-CCM usage");
-		return 0;
-	}
-
-	if (hci_conn_ssp_enabled(conn) &&
-	    !test_bit(HCI_CONN_ENCRYPT, &conn->flags))
-		return 0;
-
-	return 1;
-}
-
-/* Authenticate remote device */
-static int hci_conn_auth(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
-{
-	BT_DBG("hcon %p", conn);
-
-	if (conn->pending_sec_level > sec_level)
-		sec_level = conn->pending_sec_level;
-
-	if (sec_level > conn->sec_level)
-		conn->pending_sec_level = sec_level;
-	else if (test_bit(HCI_CONN_AUTH, &conn->flags))
-		return 1;
-
-	/* Make sure we preserve an existing MITM requirement*/
-	auth_type |= (conn->auth_type & 0x01);
-
-	conn->auth_type = auth_type;
-
-	if (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->flags)) {
-		struct hci_cp_auth_requested cp;
-
-		cp.handle = cpu_to_le16(conn->handle);
-		hci_send_cmd(conn->hdev, HCI_OP_AUTH_REQUESTED,
-			     sizeof(cp), &cp);
-
-		/* Set the ENCRYPT_PEND to trigger encryption after
-		 * authentication.
-		 */
-		if (!test_bit(HCI_CONN_ENCRYPT, &conn->flags))
-			set_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags);
-	}
-
-	return 0;
-}
-
-/* Encrypt the link */
-static void hci_conn_encrypt(struct hci_conn *conn)
-{
-	BT_DBG("hcon %p", conn);
-
-	if (!test_and_set_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags)) {
-		struct hci_cp_set_conn_encrypt cp;
-		cp.handle  = cpu_to_le16(conn->handle);
-		cp.encrypt = 0x01;
-		hci_send_cmd(conn->hdev, HCI_OP_SET_CONN_ENCRYPT, sizeof(cp),
-			     &cp);
-	}
-}
-
-/* Enable security */
-int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type,
-		      bool initiator)
-{
-	BT_DBG("hcon %p", conn);
-
-	if (conn->type == LE_LINK)
-		return smp_conn_security(conn, sec_level);
-
-	/* For sdp we don't need the link key. */
-	if (sec_level == BT_SECURITY_SDP)
-		return 1;
-
-	/* For non 2.1 devices and low security level we don't need the link
-	   key. */
-	if (sec_level == BT_SECURITY_LOW && !hci_conn_ssp_enabled(conn))
-		return 1;
-
-	/* For other security levels we need the link key. */
-	if (!test_bit(HCI_CONN_AUTH, &conn->flags))
-		goto auth;
-
-	switch (conn->key_type) {
-	case HCI_LK_AUTH_COMBINATION_P256:
-		/* An authenticated FIPS approved combination key has
-		 * sufficient security for security level 4 or lower.
-		 */
-		if (sec_level <= BT_SECURITY_FIPS)
-			goto encrypt;
-		break;
-	case HCI_LK_AUTH_COMBINATION_P192:
-		/* An authenticated combination key has sufficient security for
-		 * security level 3 or lower.
-		 */
-		if (sec_level <= BT_SECURITY_HIGH)
-			goto encrypt;
-		break;
-	case HCI_LK_UNAUTH_COMBINATION_P192:
-	case HCI_LK_UNAUTH_COMBINATION_P256:
-		/* An unauthenticated combination key has sufficient security
-		 * for security level 2 or lower.
-		 */
-		if (sec_level <= BT_SECURITY_MEDIUM)
-			goto encrypt;
-		break;
-	case HCI_LK_COMBINATION:
-		/* A combination key has always sufficient security for the
-		 * security levels 2 or lower. High security level requires the
-		 * combination key is generated using maximum PIN code length
-		 * (16). For pre 2.1 units.
-		 */
-		if (sec_level <= BT_SECURITY_MEDIUM || conn->pin_length == 16)
-			goto encrypt;
-		break;
-	default:
-		break;
-	}
-
-auth:
-	if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags))
-		return 0;
-
-	if (initiator)
-		set_bit(HCI_CONN_AUTH_INITIATOR, &conn->flags);
-
-	if (!hci_conn_auth(conn, sec_level, auth_type))
-		return 0;
-
-encrypt:
-	if (test_bit(HCI_CONN_ENCRYPT, &conn->flags)) {
-		/* Ensure that the encryption key size has been read,
-		 * otherwise stall the upper layer responses.
-		 */
-		if (!conn->enc_key_size)
-			return 0;
-
-		/* Nothing else needed, all requirements are met */
-		return 1;
-	}
-
-	hci_conn_encrypt(conn);
-	return 0;
-}
-EXPORT_SYMBOL(hci_conn_security);
-
-/* Check secure link requirement */
-int hci_conn_check_secure(struct hci_conn *conn, __u8 sec_level)
-{
-	BT_DBG("hcon %p", conn);
-
-	/* Accept if non-secure or higher security level is required */
-	if (sec_level != BT_SECURITY_HIGH && sec_level != BT_SECURITY_FIPS)
-		return 1;
-
-	/* Accept if secure or higher security level is already present */
-	if (conn->sec_level == BT_SECURITY_HIGH ||
-	    conn->sec_level == BT_SECURITY_FIPS)
-		return 1;
-
-	/* Reject not secure link */
-	return 0;
-}
-EXPORT_SYMBOL(hci_conn_check_secure);
-
-/* Switch role */
-int hci_conn_switch_role(struct hci_conn *conn, __u8 role)
-{
-	BT_DBG("hcon %p", conn);
-
-	if (role == conn->role)
-		return 1;
-
-	if (!test_and_set_bit(HCI_CONN_RSWITCH_PEND, &conn->flags)) {
-		struct hci_cp_switch_role cp;
-		bacpy(&cp.bdaddr, &conn->dst);
-		cp.role = role;
-		hci_send_cmd(conn->hdev, HCI_OP_SWITCH_ROLE, sizeof(cp), &cp);
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL(hci_conn_switch_role);
-
-/* Enter active mode */
-void hci_conn_enter_active_mode(struct hci_conn *conn, __u8 force_active)
-{
-	struct hci_dev *hdev = conn->hdev;
-
-	BT_DBG("hcon %p mode %d", conn, conn->mode);
-
-	if (conn->mode != HCI_CM_SNIFF)
-		goto timer;
-
-	if (!test_bit(HCI_CONN_POWER_SAVE, &conn->flags) && !force_active)
-		goto timer;
-
-	if (!test_and_set_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->flags)) {
-		struct hci_cp_exit_sniff_mode cp;
-		cp.handle = cpu_to_le16(conn->handle);
-		hci_send_cmd(hdev, HCI_OP_EXIT_SNIFF_MODE, sizeof(cp), &cp);
-	}
-
-timer:
-	if (hdev->idle_timeout > 0)
-		queue_delayed_work(hdev->workqueue, &conn->idle_work,
-				   msecs_to_jiffies(hdev->idle_timeout));
-}
-
-/* Drop all connection on the device */
-void hci_conn_hash_flush(struct hci_dev *hdev)
-{
-	struct list_head *head = &hdev->conn_hash.list;
-	struct hci_conn *conn;
-
-	BT_DBG("hdev %s", hdev->name);
-
-	/* We should not traverse the list here, because hci_conn_del
-	 * can remove extra links, which may cause the list traversal
-	 * to hit items that have already been released.
-	 */
-	while ((conn = list_first_entry_or_null(head,
-						struct hci_conn,
-						list)) != NULL) {
-		conn->state = BT_CLOSED;
-		hci_disconn_cfm(conn, HCI_ERROR_LOCAL_HOST_TERM);
-		hci_conn_del(conn);
-	}
-}
-
-static u32 get_link_mode(struct hci_conn *conn)
-{
-	u32 link_mode = 0;
-
-	if (conn->role == HCI_ROLE_MASTER)
-		link_mode |= HCI_LM_MASTER;
-
-	if (test_bit(HCI_CONN_ENCRYPT, &conn->flags))
-		link_mode |= HCI_LM_ENCRYPT;
-
-	if (test_bit(HCI_CONN_AUTH, &conn->flags))
-		link_mode |= HCI_LM_AUTH;
-
-	if (test_bit(HCI_CONN_SECURE, &conn->flags))
-		link_mode |= HCI_LM_SECURE;
-
-	if (test_bit(HCI_CONN_FIPS, &conn->flags))
-		link_mode |= HCI_LM_FIPS;
-
-	return link_mode;
-}
-
-int hci_get_conn_list(void __user *arg)
-{
-	struct hci_conn *c;
-	struct hci_conn_list_req req, *cl;
-	struct hci_conn_info *ci;
-	struct hci_dev *hdev;
-	int n = 0, size, err;
-
-	if (copy_from_user(&req, arg, sizeof(req)))
-		return -EFAULT;
-
-	if (!req.conn_num || req.conn_num > (PAGE_SIZE * 2) / sizeof(*ci))
-		return -EINVAL;
-
-	size = sizeof(req) + req.conn_num * sizeof(*ci);
-
-	cl = kmalloc(size, GFP_KERNEL);
-	if (!cl)
-		return -ENOMEM;
-
-	hdev = hci_dev_get(req.dev_id);
-	if (!hdev) {
-		kfree(cl);
-		return -ENODEV;
-	}
-
-	ci = cl->conn_info;
-
-	hci_dev_lock(hdev);
-	list_for_each_entry(c, &hdev->conn_hash.list, list) {
-		bacpy(&(ci + n)->bdaddr, &c->dst);
-		(ci + n)->handle = c->handle;
-		(ci + n)->type  = c->type;
-		(ci + n)->out   = c->out;
-		(ci + n)->state = c->state;
-		(ci + n)->link_mode = get_link_mode(c);
-		if (++n >= req.conn_num)
-			break;
-	}
-	hci_dev_unlock(hdev);
-
-	cl->dev_id = hdev->id;
-	cl->conn_num = n;
-	size = sizeof(req) + n * sizeof(*ci);
-
-	hci_dev_put(hdev);
-
-	err = copy_to_user(arg, cl, size);
-	kfree(cl);
-
-	return err ? -EFAULT : 0;
-}
-
-int hci_get_conn_info(struct hci_dev *hdev, void __user *arg)
-{
-	struct hci_conn_info_req req;
-	struct hci_conn_info ci;
-	struct hci_conn *conn;
-	char __user *ptr = arg + sizeof(req);
-
-	if (copy_from_user(&req, arg, sizeof(req)))
-		return -EFAULT;
-
-	hci_dev_lock(hdev);
-	conn = hci_conn_hash_lookup_ba(hdev, req.type, &req.bdaddr);
-	if (conn) {
-		bacpy(&ci.bdaddr, &conn->dst);
-		ci.handle = conn->handle;
-		ci.type  = conn->type;
-		ci.out   = conn->out;
-		ci.state = conn->state;
-		ci.link_mode = get_link_mode(conn);
-	}
-	hci_dev_unlock(hdev);
-
-	if (!conn)
-		return -ENOENT;
-
-	return copy_to_user(ptr, &ci, sizeof(ci)) ? -EFAULT : 0;
-}
-
-int hci_get_auth_info(struct hci_dev *hdev, void __user *arg)
-{
-	struct hci_auth_info_req req;
-	struct hci_conn *conn;
-
-	if (copy_from_user(&req, arg, sizeof(req)))
-		return -EFAULT;
-
-	hci_dev_lock(hdev);
-	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &req.bdaddr);
-	if (conn)
-		req.type = conn->auth_type;
-	hci_dev_unlock(hdev);
-
-	if (!conn)
-		return -ENOENT;
-
-	return copy_to_user(arg, &req, sizeof(req)) ? -EFAULT : 0;
-}
-
-struct hci_chan *hci_chan_create(struct hci_conn *conn)
-{
-	struct hci_dev *hdev = conn->hdev;
-	struct hci_chan *chan;
-
-	BT_DBG("%s hcon %p", hdev->name, conn);
-
-	if (test_bit(HCI_CONN_DROP, &conn->flags)) {
-		BT_DBG("Refusing to create new hci_chan");
-		return NULL;
-	}
-
-	chan = kzalloc(sizeof(*chan), GFP_KERNEL);
-	if (!chan)
-		return NULL;
-
-	chan->conn = hci_conn_get(conn);
-	skb_queue_head_init(&chan->data_q);
-	chan->state = BT_CONNECTED;
-
-	list_add_rcu(&chan->list, &conn->chan_list);
-
-	return chan;
-}
-
-void hci_chan_del(struct hci_chan *chan)
-{
-	struct hci_conn *conn = chan->conn;
-	struct hci_dev *hdev = conn->hdev;
-
-	BT_DBG("%s hcon %p chan %p", hdev->name, conn, chan);
-
-	list_del_rcu(&chan->list);
-
-	synchronize_rcu();
-
-	/* Prevent new hci_chan's to be created for this hci_conn */
-	set_bit(HCI_CONN_DROP, &conn->flags);
-
-	hci_conn_put(conn);
-
-	skb_queue_purge(&chan->data_q);
-	kfree(chan);
-}
-
-void hci_chan_list_flush(struct hci_conn *conn)
-{
-	struct hci_chan *chan, *n;
-
-	BT_DBG("hcon %p", conn);
-
-	list_for_each_entry_safe(chan, n, &conn->chan_list, list)
-		hci_chan_del(chan);
-}
-
-static struct hci_chan *__hci_chan_lookup_handle(struct hci_conn *hcon,
-						 __u16 handle)
-{
-	struct hci_chan *hchan;
-
-	list_for_each_entry(hchan, &hcon->chan_list, list) {
-		if (hchan->handle == handle)
-			return hchan;
-	}
-
-	return NULL;
-}
-
-struct hci_chan *hci_chan_lookup_handle(struct hci_dev *hdev, __u16 handle)
-{
-	struct hci_conn_hash *h = &hdev->conn_hash;
-	struct hci_conn *hcon;
-	struct hci_chan *hchan = NULL;
-
-	rcu_read_lock();
-
-	list_for_each_entry_rcu(hcon, &h->list, list) {
-		hchan = __hci_chan_lookup_handle(hcon, handle);
-		if (hchan)
-			break;
-	}
-
-	rcu_read_unlock();
-
-	return hchan;
-}
-
-u32 hci_conn_get_phy(struct hci_conn *conn)
-{
-	u32 phys = 0;
-
-	/* BLUETOOTH CORE SPECIFICATION Version 5.2 | Vol 2, Part B page 471:
-	 * Table 6.2: Packets defined for synchronous, asynchronous, and
-	 * CPB logical transport types.
-	 */
-	switch (conn->type) {
-	case SCO_LINK:
-		/* SCO logical transport (1 Mb/s):
-		 * HV1, HV2, HV3 and DV.
-		 */
-		phys |= BT_PHY_BR_1M_1SLOT;
-
-		break;
-
-	case ACL_LINK:
-		/* ACL logical transport (1 Mb/s) ptt=0:
-		 * DH1, DM3, DH3, DM5 and DH5.
-		 */
-		phys |= BT_PHY_BR_1M_1SLOT;
-
-		if (conn->pkt_type & (HCI_DM3 | HCI_DH3))
-			phys |= BT_PHY_BR_1M_3SLOT;
-
-		if (conn->pkt_type & (HCI_DM5 | HCI_DH5))
-			phys |= BT_PHY_BR_1M_5SLOT;
-
-		/* ACL logical transport (2 Mb/s) ptt=1:
-		 * 2-DH1, 2-DH3 and 2-DH5.
-		 */
-		if (!(conn->pkt_type & HCI_2DH1))
-			phys |= BT_PHY_EDR_2M_1SLOT;
-
-		if (!(conn->pkt_type & HCI_2DH3))
-			phys |= BT_PHY_EDR_2M_3SLOT;
-
-		if (!(conn->pkt_type & HCI_2DH5))
-			phys |= BT_PHY_EDR_2M_5SLOT;
-
-		/* ACL logical transport (3 Mb/s) ptt=1:
-		 * 3-DH1, 3-DH3 and 3-DH5.
-		 */
-		if (!(conn->pkt_type & HCI_3DH1))
-			phys |= BT_PHY_EDR_3M_1SLOT;
-
-		if (!(conn->pkt_type & HCI_3DH3))
-			phys |= BT_PHY_EDR_3M_3SLOT;
-
-		if (!(conn->pkt_type & HCI_3DH5))
-			phys |= BT_PHY_EDR_3M_5SLOT;
-
-		break;
-
-	case ESCO_LINK:
-		/* eSCO logical transport (1 Mb/s): EV3, EV4 and EV5 */
-		phys |= BT_PHY_BR_1M_1SLOT;
-
-		if (!(conn->pkt_type & (ESCO_EV4 | ESCO_EV5)))
-			phys |= BT_PHY_BR_1M_3SLOT;
-
-		/* eSCO logical transport (2 Mb/s): 2-EV3, 2-EV5 */
-		if (!(conn->pkt_type & ESCO_2EV3))
-			phys |= BT_PHY_EDR_2M_1SLOT;
-
-		if (!(conn->pkt_type & ESCO_2EV5))
-			phys |= BT_PHY_EDR_2M_3SLOT;
-
-		/* eSCO logical transport (3 Mb/s): 3-EV3, 3-EV5 */
-		if (!(conn->pkt_type & ESCO_3EV3))
-			phys |= BT_PHY_EDR_3M_1SLOT;
-
-		if (!(conn->pkt_type & ESCO_3EV5))
-			phys |= BT_PHY_EDR_3M_3SLOT;
-
-		break;
-
-	case LE_LINK:
-		if (conn->le_tx_phy & HCI_LE_SET_PHY_1M)
-			phys |= BT_PHY_LE_1M_TX;
-
-		if (conn->le_rx_phy & HCI_LE_SET_PHY_1M)
-			phys |= BT_PHY_LE_1M_RX;
-
-		if (conn->le_tx_phy & HCI_LE_SET_PHY_2M)
-			phys |= BT_PHY_LE_2M_TX;
-
-		if (conn->le_rx_phy & HCI_LE_SET_PHY_2M)
-			phys |= BT_PHY_LE_2M_RX;
-
-		if (conn->le_tx_phy & HCI_LE_SET_PHY_CODED)
-			phys |= BT_PHY_LE_CODED_TX;
-
-		if (conn->le_rx_phy & HCI_LE_SET_PHY_CODED)
-			phys |= BT_PHY_LE_CODED_RX;
-
-		break;
-	}
-
-	return phys;
-}
-
-static int abort_conn_sync(struct hci_dev *hdev, void *data)
-{
-	struct hci_conn *conn = data;
-
-	if (!hci_conn_valid(hdev, conn))
-		return -ECANCELED;
-
-	return hci_abort_conn_sync(hdev, conn, conn->abort_reason);
-}
-
-int hci_abort_conn(struct hci_conn *conn, u8 reason)
-{
-	struct hci_dev *hdev = conn->hdev;
-
-	/* If abort_reason has already been set it means the connection is
-	 * already being aborted so don't attempt to overwrite it.
-	 */
-	if (conn->abort_reason)
-		return 0;
-
-	bt_dev_dbg(hdev, "handle 0x%2.2x reason 0x%2.2x", conn->handle, reason);
-
-	conn->abort_reason = reason;
-
-	/* If the connection is pending check the command opcode since that
-	 * might be blocking on hci_cmd_sync_work while waiting its respective
-	 * event so we need to hci_cmd_sync_cancel to cancel it.
-	 *
-	 * hci_connect_le serializes the connection attempts so only one
-	 * connection can be in BT_CONNECT at time.
-	 */
-	if (conn->state == BT_CONNECT && hdev->req_status == HCI_REQ_PEND) {
-		switch (hci_skb_event(hdev->sent_cmd)) {
-		case HCI_EV_CONN_COMPLETE:
-		case HCI_EV_LE_CONN_COMPLETE:
-		case HCI_EV_LE_ENHANCED_CONN_COMPLETE:
-		case HCI_EVT_LE_CIS_ESTABLISHED:
-			hci_cmd_sync_cancel(hdev, ECANCELED);
-			break;
-		}
-	/* Cancel connect attempt if still queued/pending */
-	} else if (!hci_cancel_connect_sync(hdev, conn)) {
-		return 0;
-	}
-
-	/* Run immediately if on cmd_sync_work since this may be called
-	 * as a result to MGMT_OP_DISCONNECT/MGMT_OP_UNPAIR which does
-	 * already queue its callback on cmd_sync_work.
-	 */
-	return hci_cmd_sync_run_once(hdev, abort_conn_sync, conn, NULL);
-}
-
-void hci_setup_tx_timestamp(struct sk_buff *skb, size_t key_offset,
-			    const struct sockcm_cookie *sockc)
-{
-	struct sock *sk = skb ? skb->sk : NULL;
-	int key;
-
-	/* This shall be called on a single skb of those generated by user
-	 * sendmsg(), and only when the sendmsg() does not return error to
-	 * user. This is required for keeping the tskey that increments here in
-	 * sync with possible sendmsg() counting by user.
-	 *
-	 * Stream sockets shall set key_offset to sendmsg() length in bytes
-	 * and call with the last fragment, others to 1 and first fragment.
-	 */
-
-	if (!skb || !sockc || !sk || !key_offset)
-		return;
-
-	sock_tx_timestamp(sk, sockc, &skb_shinfo(skb)->tx_flags);
-
-	if (sk->sk_type == SOCK_STREAM)
-		key = atomic_add_return(key_offset, &sk->sk_tskey);
-
-	if (sockc->tsflags & SOF_TIMESTAMPING_OPT_ID &&
-	    sockc->tsflags & SOF_TIMESTAMPING_TX_RECORD_MASK) {
-		if (sockc->tsflags & SOCKCM_FLAG_TS_OPT_ID) {
-			skb_shinfo(skb)->tskey = sockc->ts_opt_id;
-		} else {
-			if (sk->sk_type != SOCK_STREAM)
-				key = atomic_inc_return(&sk->sk_tskey);
-			skb_shinfo(skb)->tskey = key - 1;
-		}
-	}
-}
-
-void hci_conn_tx_queue(struct hci_conn *conn, struct sk_buff *skb)
-{
-	struct tx_queue *comp = &conn->tx_q;
-	bool track = false;
-
-	/* Emit SND now, ie. just before sending to driver */
-	if (skb_shinfo(skb)->tx_flags & SKBTX_SW_TSTAMP)
-		__skb_tstamp_tx(skb, NULL, NULL, skb->sk, SCM_TSTAMP_SND);
-
-	/* COMPLETION tstamp is emitted for tracked skb later in Number of
-	 * Completed Packets event. Available only for flow controlled cases.
-	 *
-	 * TODO: SCO support without flowctl (needs to be done in drivers)
-	 */
-	switch (conn->type) {
-	case CIS_LINK:
-	case BIS_LINK:
-	case PA_LINK:
-	case ACL_LINK:
-	case LE_LINK:
-		break;
-	case SCO_LINK:
-	case ESCO_LINK:
-		if (!hci_dev_test_flag(conn->hdev, HCI_SCO_FLOWCTL))
-			return;
-		break;
-	default:
-		return;
-	}
-
-	if (skb->sk && (skb_shinfo(skb)->tx_flags & SKBTX_COMPLETION_TSTAMP))
-		track = true;
-
-	/* If nothing is tracked, just count extra skbs at the queue head */
-	if (!track && !comp->tracked) {
-		comp->extra++;
-		return;
-	}
-
-	if (track) {
-		skb = skb_clone_sk(skb);
-		if (!skb)
-			goto count_only;
-
-		comp->tracked++;
-	} else {
-		skb = skb_clone(skb, GFP_KERNEL);
-		if (!skb)
-			goto count_only;
-	}
-
-	skb_queue_tail(&comp->queue, skb);
-	return;
-
-count_only:
-	/* Stop tracking skbs, and only count. This will not emit timestamps for
-	 * the packets, but if we get here something is more seriously wrong.
-	 */
-	comp->tracked = 0;
-	comp->extra += skb_queue_len(&comp->queue) + 1;
-	skb_queue_purge(&comp->queue);
-}
-
-void hci_conn_tx_dequeue(struct hci_conn *conn)
-{
-	struct tx_queue *comp = &conn->tx_q;
-	struct sk_buff *skb;
-
-	/* If there are tracked skbs, the counted extra go before dequeuing real
-	 * skbs, to keep ordering. When nothing is tracked, the ordering doesn't
-	 * matter so dequeue real skbs first to get rid of them ASAP.
-	 */
-	if (comp->extra && (comp->tracked || skb_queue_empty(&comp->queue))) {
-		comp->extra--;
-		return;
-	}
-
-	skb = skb_dequeue(&comp->queue);
-	if (!skb)
-		return;
-
-	if (skb->sk) {
-		comp->tracked--;
-		__skb_tstamp_tx(skb, NULL, NULL, skb->sk,
-				SCM_TSTAMP_COMPLETION);
-	}
-
-	kfree_skb(skb);
-}
-
-u8 *hci_conn_key_enc_size(struct hci_conn *conn)
-{
-	if (conn->type == ACL_LINK) {
-		struct link_key *key;
-
-		key = hci_find_link_key(conn->hdev, &conn->dst);
-		if (!key)
-			return NULL;
-
-		return &key->pin_len;
-	} else if (conn->type == LE_LINK) {
-		struct smp_ltk *ltk;
-
-		ltk = hci_find_ltk(conn->hdev, &conn->dst, conn->dst_type,
-				   conn->role);
-		if (!ltk)
-			return NULL;
-
-		return &ltk->enc_size;
-	}
-
-	return NULL;
-}
-
-int hci_ethtool_ts_info(unsigned int index, int sk_proto,
-			struct kernel_ethtool_ts_info *info)
-{
-	struct hci_dev *hdev;
-
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return -ENODEV;
-
-	info->so_timestamping =
-		SOF_TIMESTAMPING_RX_SOFTWARE |
-		SOF_TIMESTAMPING_SOFTWARE;
-	info->phc_index = -1;
-	info->tx_types = BIT(HWTSTAMP_TX_OFF);
-	info->rx_filters = BIT(HWTSTAMP_FILTER_NONE);
-
-	switch (sk_proto) {
-	case BTPROTO_ISO:
-	case BTPROTO_L2CAP:
-		info->so_timestamping |= SOF_TIMESTAMPING_TX_SOFTWARE;
-		info->so_timestamping |= SOF_TIMESTAMPING_TX_COMPLETION;
-		break;
-	case BTPROTO_SCO:
-		info->so_timestamping |= SOF_TIMESTAMPING_TX_SOFTWARE;
-		if (hci_dev_test_flag(hdev, HCI_SCO_FLOWCTL))
-			info->so_timestamping |= SOF_TIMESTAMPING_TX_COMPLETION;
-		break;
-	}
-
-	hci_dev_put(hdev);
-	return 0;
-}
diff -Nrup linux-6.16.7/net/qrtr/mhi.c linux-lenovo-x13s-linux-6.16.y/net/qrtr/mhi.c
--- linux-6.16.7/net/qrtr/mhi.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/net/qrtr/mhi.c	2025-09-11 09:47:42.000000000 -0600
@@ -15,6 +15,7 @@ struct qrtr_mhi_dev {
 	struct qrtr_endpoint ep;
 	struct mhi_device *mhi_dev;
 	struct device *dev;
+	struct completion prepared;
 };
 
 /* From MHI to QRTR */
@@ -53,6 +54,10 @@ static int qcom_mhi_qrtr_send(struct qrt
 	if (skb->sk)
 		sock_hold(skb->sk);
 
+	rc = wait_for_completion_interruptible(&qdev->prepared);
+	if (rc)
+		goto free_skb;
+
 	rc = skb_linearize(skb);
 	if (rc)
 		goto free_skb;
@@ -85,6 +90,7 @@ static int qcom_mhi_qrtr_probe(struct mh
 	qdev->mhi_dev = mhi_dev;
 	qdev->dev = &mhi_dev->dev;
 	qdev->ep.xmit = qcom_mhi_qrtr_send;
+	init_completion(&qdev->prepared);
 
 	dev_set_drvdata(&mhi_dev->dev, qdev);
 	rc = qrtr_endpoint_register(&qdev->ep, QRTR_EP_NID_AUTO);
@@ -97,6 +103,7 @@ static int qcom_mhi_qrtr_probe(struct mh
 		qrtr_endpoint_unregister(&qdev->ep);
 		return rc;
 	}
+	complete_all(&qdev->prepared);
 
 	dev_dbg(qdev->dev, "Qualcomm MHI QRTR driver probed\n");
 
File linux-6.16.7/scripts/dtc/include-prefixes/arc is a directory while file linux-lenovo-x13s-linux-6.16.y/scripts/dtc/include-prefixes/arc is a regular file
File linux-6.16.7/scripts/dtc/include-prefixes/arm is a directory while file linux-lenovo-x13s-linux-6.16.y/scripts/dtc/include-prefixes/arm is a regular file
File linux-6.16.7/scripts/dtc/include-prefixes/arm64 is a directory while file linux-lenovo-x13s-linux-6.16.y/scripts/dtc/include-prefixes/arm64 is a regular file
File linux-6.16.7/scripts/dtc/include-prefixes/dt-bindings is a directory while file linux-lenovo-x13s-linux-6.16.y/scripts/dtc/include-prefixes/dt-bindings is a regular file
File linux-6.16.7/scripts/dtc/include-prefixes/microblaze is a directory while file linux-lenovo-x13s-linux-6.16.y/scripts/dtc/include-prefixes/microblaze is a regular file
File linux-6.16.7/scripts/dtc/include-prefixes/mips is a directory while file linux-lenovo-x13s-linux-6.16.y/scripts/dtc/include-prefixes/mips is a regular file
File linux-6.16.7/scripts/dtc/include-prefixes/nios2 is a directory while file linux-lenovo-x13s-linux-6.16.y/scripts/dtc/include-prefixes/nios2 is a regular file
File linux-6.16.7/scripts/dtc/include-prefixes/openrisc is a directory while file linux-lenovo-x13s-linux-6.16.y/scripts/dtc/include-prefixes/openrisc is a regular file
File linux-6.16.7/scripts/dtc/include-prefixes/powerpc is a directory while file linux-lenovo-x13s-linux-6.16.y/scripts/dtc/include-prefixes/powerpc is a regular file
File linux-6.16.7/scripts/dtc/include-prefixes/riscv is a directory while file linux-lenovo-x13s-linux-6.16.y/scripts/dtc/include-prefixes/riscv is a regular file
File linux-6.16.7/scripts/dtc/include-prefixes/sh is a directory while file linux-lenovo-x13s-linux-6.16.y/scripts/dtc/include-prefixes/sh is a regular file
File linux-6.16.7/scripts/dtc/include-prefixes/xtensa is a directory while file linux-lenovo-x13s-linux-6.16.y/scripts/dtc/include-prefixes/xtensa is a regular file
diff -Nrup linux-6.16.7/scripts/dummy-tools/nm linux-lenovo-x13s-linux-6.16.y/scripts/dummy-tools/nm
--- linux-6.16.7/scripts/dummy-tools/nm	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/scripts/dummy-tools/nm	2025-09-11 09:47:42.000000000 -0600
@@ -1,30 +1 @@
-#!/bin/sh
-# SPDX-License-Identifier: GPL-2.0-only
-
-# Dummy script that always succeeds.
-
-# Check if the first parameter appears in the rest. Succeeds if found.
-# This helper is useful if a particular option was passed to this script.
-# Typically used like this:
-#   arg_contain <word-you-are-searching-for> "$@"
-arg_contain ()
-{
-	search="$1"
-	shift
-
-	while [ $# -gt 0 ]
-	do
-		if [ "$search" = "$1" ]; then
-			return 0
-		fi
-		shift
-	done
-
-	return 1
-}
-
-if arg_contain --version "$@" || arg_contain -v "$@"; then
-	progname=$(basename $0)
-	echo "GNU $progname (scripts/dummy-tools/$progname) 2.50"
-	exit 0
-fi
+ld
\ No newline at end of file
diff -Nrup linux-6.16.7/scripts/dummy-tools/objcopy linux-lenovo-x13s-linux-6.16.y/scripts/dummy-tools/objcopy
--- linux-6.16.7/scripts/dummy-tools/objcopy	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/scripts/dummy-tools/objcopy	2025-09-11 09:47:42.000000000 -0600
@@ -1,30 +1 @@
-#!/bin/sh
-# SPDX-License-Identifier: GPL-2.0-only
-
-# Dummy script that always succeeds.
-
-# Check if the first parameter appears in the rest. Succeeds if found.
-# This helper is useful if a particular option was passed to this script.
-# Typically used like this:
-#   arg_contain <word-you-are-searching-for> "$@"
-arg_contain ()
-{
-	search="$1"
-	shift
-
-	while [ $# -gt 0 ]
-	do
-		if [ "$search" = "$1" ]; then
-			return 0
-		fi
-		shift
-	done
-
-	return 1
-}
-
-if arg_contain --version "$@" || arg_contain -v "$@"; then
-	progname=$(basename $0)
-	echo "GNU $progname (scripts/dummy-tools/$progname) 2.50"
-	exit 0
-fi
+ld
\ No newline at end of file
diff -Nrup linux-6.16.7/scripts/kconfig/lxdialog/dialog.h linux-lenovo-x13s-linux-6.16.y/scripts/kconfig/lxdialog/dialog.h
--- linux-6.16.7/scripts/kconfig/lxdialog/dialog.h	2025-09-13 16:15:46.041935250 -0600
+++ linux-lenovo-x13s-linux-6.16.y/scripts/kconfig/lxdialog/dialog.h	2025-09-11 09:47:42.000000000 -0600
@@ -58,8 +58,6 @@
 #define ACS_DARROW 'v'
 #endif
 
-#define KEY_ACTION_SORT 11
-
 /* error return codes */
 #define ERRDISPLAYTOOSMALL (KEY_MAX + 1)
 
@@ -129,7 +127,6 @@ void item_set_selected(int val);
 int item_activate_selected(void);
 void *item_data(void);
 char item_tag(void);
-void sort_items(void);
 
 /* item list manipulation for lxdialog use */
 #define MAXITEMSTR 200
@@ -199,7 +196,7 @@ int dialog_textbox(const char *title, co
 		   int initial_width, int *_vscroll, int *_hscroll,
 		   int (*extra_key_cb)(int, size_t, size_t, void *), void *data);
 int dialog_menu(const char *title, const char *prompt,
-		const void *selected, int *s_scroll, bool sort);
+		const void *selected, int *s_scroll);
 int dialog_checklist(const char *title, const char *prompt, int height,
 		     int width, int list_height);
 int dialog_inputbox(const char *title, const char *prompt, int height,
diff -Nrup linux-6.16.7/scripts/kconfig/lxdialog/menubox.c linux-lenovo-x13s-linux-6.16.y/scripts/kconfig/lxdialog/menubox.c
--- linux-6.16.7/scripts/kconfig/lxdialog/menubox.c	2025-09-13 16:15:46.042247314 -0600
+++ linux-lenovo-x13s-linux-6.16.y/scripts/kconfig/lxdialog/menubox.c	2025-09-11 09:47:42.000000000 -0600
@@ -161,7 +161,7 @@ static void do_scroll(WINDOW *win, int *
  * Display a menu for choosing among a number of options
  */
 int dialog_menu(const char *title, const char *prompt,
-		const void *selected, int *s_scroll, bool sort)
+		const void *selected, int *s_scroll)
 {
 	int i, j, x, y, box_x, box_y;
 	int height, width, menu_height;
@@ -181,9 +181,6 @@ do_resize:
 
 	max_choice = MIN(menu_height, item_count());
 
-	if (sort)
-		sort_items();
-
 	/* center dialog box on screen */
 	x = (getmaxx(stdscr) - width) / 2;
 	y = (getmaxy(stdscr) - height) / 2;
@@ -411,8 +408,6 @@ do_resize:
 			delwin(menu);
 			delwin(dialog);
 			goto do_resize;
-		case '>':
-			return KEY_ACTION_SORT;
 		}
 	}
 	delwin(menu);
diff -Nrup linux-6.16.7/scripts/kconfig/lxdialog/util.c linux-lenovo-x13s-linux-6.16.y/scripts/kconfig/lxdialog/util.c
--- linux-6.16.7/scripts/kconfig/lxdialog/util.c	2025-09-13 16:15:46.042621144 -0600
+++ linux-lenovo-x13s-linux-6.16.y/scripts/kconfig/lxdialog/util.c	2025-09-11 09:47:42.000000000 -0600
@@ -563,85 +563,6 @@ void item_reset(void)
 	item_cur = &item_nil;
 }
 
-/*
- * Function skips a part of the label to get the actual label text
- * (without the '[ ]'-like prefix).
- */
-static char *skip_spec_characters(char *s)
-{
-	bool unbalanced = false;
-
-	while (*s) {
-		if (isalnum(*s) && !unbalanced) {
-			break;
-		} else if (*s == '[' || *s == '<' || *s == '(') {
-			/*
-			 * '[', '<' or '(' means that we need to look for
-			 * closure
-			 */
-			unbalanced = true;
-		} else if (*s == '-') {
-			/*
-			 * Labels could start with "-*-", so '-' here either
-			 * opens or closes the "checkbox"
-			 */
-			unbalanced = !unbalanced;
-		} else if (*s == '>' || *s == ']' || *s == ')') {
-			unbalanced = false;
-		}
-		s++;
-	}
-	return s;
-}
-
-static int compare_labels(const void *a, const void *b)
-{
-	struct dialog_list *el1 = *((struct dialog_list **)a);
-	struct dialog_list *el2 = *((struct dialog_list **)b);
-
-	return strcasecmp(skip_spec_characters(el1->node.str),
-			  skip_spec_characters(el2->node.str));
-}
-
-void sort_items(void)
-{
-	struct dialog_list **arr;
-	struct dialog_list *cur;
-	size_t n, i;
-
-	n = item_count();
-	if (n == 0)
-		return;
-
-	/* Copy all items from linked list into array */
-	cur = item_head;
-	arr = malloc(sizeof(*arr) * n);
-
-	if (!arr) {
-		/* Don't have enough memory, so don't do anything */
-		return;
-	}
-
-	for (i = 0; i < n; i++) {
-		arr[i] = cur;
-		cur = cur->next;
-	}
-
-	qsort(arr, n, sizeof(struct dialog_list *), compare_labels);
-
-	/* Restore the linked list structure from the sorted array */
-	for (i = 0; i < n; i++) {
-		if (i < n - 1)
-			arr[i]->next = arr[i + 1];
-		else
-			arr[i]->next = NULL;
-	}
-
-	item_head = arr[0];
-
-	free(arr);
-}
-
 void item_make(const char *fmt, ...)
 {
 	va_list ap;
diff -Nrup linux-6.16.7/scripts/kconfig/mconf.c linux-lenovo-x13s-linux-6.16.y/scripts/kconfig/mconf.c
--- linux-6.16.7/scripts/kconfig/mconf.c	2025-09-13 16:15:46.043010026 -0600
+++ linux-lenovo-x13s-linux-6.16.y/scripts/kconfig/mconf.c	2025-09-11 09:47:42.000000000 -0600
@@ -750,7 +750,6 @@ static void conf_save(void)
 	}
 }
 
-static bool should_sort;
 static void conf(struct menu *menu, struct menu *active_menu)
 {
 	struct menu *submenu;
@@ -776,15 +775,9 @@ static void conf(struct menu *menu, stru
 		dialog_clear();
 		res = dialog_menu(prompt ? prompt : "Main Menu",
 				  menu_instructions,
-				  active_menu, &s_scroll, should_sort);
+				  active_menu, &s_scroll);
 		if (res == 1 || res == KEY_ESC || res == -ERRDISPLAYTOOSMALL)
 			break;
-
-		if (res == KEY_ACTION_SORT) {
-			should_sort = !should_sort;
-			continue;
-		}
-
 		if (item_count() != 0) {
 			if (!item_activate_selected())
 				continue;
diff -Nrup linux-6.16.7/scripts/kconfig/mconf.c.orig linux-lenovo-x13s-linux-6.16.y/scripts/kconfig/mconf.c.orig
--- linux-6.16.7/scripts/kconfig/mconf.c.orig	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/scripts/kconfig/mconf.c.orig	1969-12-31 17:00:00.000000000 -0700
@@ -1,963 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
- *
- * Introduced single menu mode (show all sub-menus in one large tree).
- * 2002-11-06 Petr Baudis <pasky@ucw.cz>
- *
- * i18n, 2005, Arnaldo Carvalho de Melo <acme@conectiva.com.br>
- */
-
-#include <ctype.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <limits.h>
-#include <stdarg.h>
-#include <stdlib.h>
-#include <string.h>
-#include <strings.h>
-#include <signal.h>
-#include <unistd.h>
-
-#include <list.h>
-#include <xalloc.h>
-#include "lkc.h"
-#include "lxdialog/dialog.h"
-#include "mnconf-common.h"
-
-static const char mconf_readme[] =
-"Overview\n"
-"--------\n"
-"This interface lets you select features and parameters for the build.\n"
-"Features can either be built-in, modularized, or ignored. Parameters\n"
-"must be entered in as decimal or hexadecimal numbers or text.\n"
-"\n"
-"Menu items beginning with following braces represent features that\n"
-"  [ ] can be built in or removed\n"
-"  < > can be built in, modularized or removed\n"
-"  { } can be built in or modularized (selected by other feature)\n"
-"  - - are selected by other feature,\n"
-"while *, M or whitespace inside braces means to build in, build as\n"
-"a module or to exclude the feature respectively.\n"
-"\n"
-"To change any of these features, highlight it with the cursor\n"
-"keys and press <Y> to build it in, <M> to make it a module or\n"
-"<N> to remove it.  You may also press the <Space Bar> to cycle\n"
-"through the available options (i.e. Y->N->M->Y).\n"
-"\n"
-"Some additional keyboard hints:\n"
-"\n"
-"Menus\n"
-"----------\n"
-"o  Use the Up/Down arrow keys (cursor keys) to highlight the item you\n"
-"   wish to change or the submenu you wish to select and press <Enter>.\n"
-"   Submenus are designated by \"--->\", empty ones by \"----\".\n"
-"\n"
-"   Shortcut: Press the option's highlighted letter (hotkey).\n"
-"             Pressing a hotkey more than once will sequence\n"
-"             through all visible items which use that hotkey.\n"
-"\n"
-"   You may also use the <PAGE UP> and <PAGE DOWN> keys to scroll\n"
-"   unseen options into view.\n"
-"\n"
-"o  To exit a menu use the cursor keys to highlight the <Exit> button\n"
-"   and press <ENTER>.\n"
-"\n"
-"   Shortcut: Press <ESC><ESC> or <E> or <X> if there is no hotkey\n"
-"             using those letters.  You may press a single <ESC>, but\n"
-"             there is a delayed response which you may find annoying.\n"
-"\n"
-"   Also, the <TAB> and cursor keys will cycle between <Select>,\n"
-"   <Exit>, <Help>, <Save>, and <Load>.\n"
-"\n"
-"o  To get help with an item, use the cursor keys to highlight <Help>\n"
-"   and press <ENTER>.\n"
-"\n"
-"   Shortcut: Press <H> or <?>.\n"
-"\n"
-"o  To toggle the display of hidden options, press <Z>.\n"
-"\n"
-"\n"
-"Radiolists  (Choice lists)\n"
-"-----------\n"
-"o  Use the cursor keys to select the option you wish to set and press\n"
-"   <S> or the <SPACE BAR>.\n"
-"\n"
-"   Shortcut: Press the first letter of the option you wish to set then\n"
-"             press <S> or <SPACE BAR>.\n"
-"\n"
-"o  To see available help for the item, use the cursor keys to highlight\n"
-"   <Help> and Press <ENTER>.\n"
-"\n"
-"   Shortcut: Press <H> or <?>.\n"
-"\n"
-"   Also, the <TAB> and cursor keys will cycle between <Select> and\n"
-"   <Help>\n"
-"\n"
-"\n"
-"Data Entry\n"
-"-----------\n"
-"o  Enter the requested information and press <ENTER>\n"
-"   If you are entering hexadecimal values, it is not necessary to\n"
-"   add the '0x' prefix to the entry.\n"
-"\n"
-"o  For help, use the <TAB> or cursor keys to highlight the help option\n"
-"   and press <ENTER>.  You can try <TAB><H> as well.\n"
-"\n"
-"\n"
-"Text Box    (Help Window)\n"
-"--------\n"
-"o  Use the cursor keys to scroll up/down/left/right.  The VI editor\n"
-"   keys h,j,k,l function here as do <u>, <d>, <SPACE BAR> and <B> for\n"
-"   those who are familiar with less and lynx.\n"
-"\n"
-"o  Press <E>, <X>, <q>, <Enter> or <Esc><Esc> to exit.\n"
-"\n"
-"\n"
-"Alternate Configuration Files\n"
-"-----------------------------\n"
-"Menuconfig supports the use of alternate configuration files for\n"
-"those who, for various reasons, find it necessary to switch\n"
-"between different configurations.\n"
-"\n"
-"The <Save> button will let you save the current configuration to\n"
-"a file of your choosing.  Use the <Load> button to load a previously\n"
-"saved alternate configuration.\n"
-"\n"
-"Even if you don't use alternate configuration files, but you find\n"
-"during a Menuconfig session that you have completely messed up your\n"
-"settings, you may use the <Load> button to restore your previously\n"
-"saved settings from \".config\" without restarting Menuconfig.\n"
-"\n"
-"Other information\n"
-"-----------------\n"
-"If you use Menuconfig in an XTERM window, make sure you have your\n"
-"$TERM variable set to point to an xterm definition which supports\n"
-"color.  Otherwise, Menuconfig will look rather bad.  Menuconfig will\n"
-"not display correctly in an RXVT window because rxvt displays only one\n"
-"intensity of color, bright.\n"
-"\n"
-"Menuconfig will display larger menus on screens or xterms which are\n"
-"set to display more than the standard 25 row by 80 column geometry.\n"
-"In order for this to work, the \"stty size\" command must be able to\n"
-"display the screen's current row and column geometry.  I STRONGLY\n"
-"RECOMMEND that you make sure you do NOT have the shell variables\n"
-"LINES and COLUMNS exported into your environment.  Some distributions\n"
-"export those variables via /etc/profile.  Some ncurses programs can\n"
-"become confused when those variables (LINES & COLUMNS) don't reflect\n"
-"the true screen size.\n"
-"\n"
-"Optional personality available\n"
-"------------------------------\n"
-"If you prefer to have all of the options listed in a single menu,\n"
-"rather than the default multimenu hierarchy, run the menuconfig with\n"
-"MENUCONFIG_MODE environment variable set to single_menu. Example:\n"
-"\n"
-"make MENUCONFIG_MODE=single_menu menuconfig\n"
-"\n"
-"<Enter> will then unroll the appropriate category, or enfold it if it\n"
-"is already unrolled.\n"
-"\n"
-"Note that this mode can eventually be a little more CPU expensive\n"
-"(especially with a larger number of unrolled categories) than the\n"
-"default mode.\n"
-"\n"
-
-"Search\n"
-"-------\n"
-"Pressing the forward-slash (/) anywhere brings up a search dialog box.\n"
-"\n"
-
-"Different color themes available\n"
-"--------------------------------\n"
-"It is possible to select different color themes using the variable\n"
-"MENUCONFIG_COLOR. To select a theme use:\n"
-"\n"
-"make MENUCONFIG_COLOR=<theme> menuconfig\n"
-"\n"
-"Available themes are\n"
-" mono       => selects colors suitable for monochrome displays\n"
-" blackbg    => selects a color scheme with black background\n"
-" classic    => theme with blue background. The classic look\n"
-" bluetitle  => an LCD friendly version of classic. (default)\n"
-"\n",
-menu_instructions[] =
-	"Arrow keys navigate the menu.  "
-	"<Enter> selects submenus ---> (or empty submenus ----).  "
-	"Highlighted letters are hotkeys.  "
-	"Pressing <Y> includes, <N> excludes, <M> modularizes features.  "
-	"Press <Esc><Esc> to exit, <?> for Help, </> for Search.  "
-	"Legend: [*] built-in  [ ] excluded  <M> module  < > module capable",
-radiolist_instructions[] =
-	"Use the arrow keys to navigate this window or "
-	"press the hotkey of the item you wish to select "
-	"followed by the <SPACE BAR>. "
-	"Press <?> for additional information about this option.",
-inputbox_instructions_int[] =
-	"Please enter a decimal value. "
-	"Fractions will not be accepted.  "
-	"Use the <TAB> key to move from the input field to the buttons below it.",
-inputbox_instructions_hex[] =
-	"Please enter a hexadecimal value. "
-	"Use the <TAB> key to move from the input field to the buttons below it.",
-inputbox_instructions_string[] =
-	"Please enter a string value. "
-	"Use the <TAB> key to move from the input field to the buttons below it.",
-setmod_text[] =
-	"This feature depends on another which has been configured as a module.\n"
-	"As a result, this feature will be built as a module.",
-load_config_text[] =
-	"Enter the name of the configuration file you wish to load.  "
-	"Accept the name shown to restore the configuration you "
-	"last retrieved.  Leave blank to abort.",
-load_config_help[] =
-	"\n"
-	"For various reasons, one may wish to keep several different\n"
-	"configurations available on a single machine.\n"
-	"\n"
-	"If you have saved a previous configuration in a file other than the\n"
-	"default one, entering its name here will allow you to modify that\n"
-	"configuration.\n"
-	"\n"
-	"If you are uncertain, then you have probably never used alternate\n"
-	"configuration files. You should therefore leave this blank to abort.\n",
-save_config_text[] =
-	"Enter a filename to which this configuration should be saved "
-	"as an alternate.  Leave blank to abort.",
-save_config_help[] =
-	"\n"
-	"For various reasons, one may wish to keep different configurations\n"
-	"available on a single machine.\n"
-	"\n"
-	"Entering a file name here will allow you to later retrieve, modify\n"
-	"and use the current configuration as an alternate to whatever\n"
-	"configuration options you have selected at that time.\n"
-	"\n"
-	"If you are uncertain what all this means then you should probably\n"
-	"leave this blank.\n",
-search_help[] =
-	"\n"
-	"Search for symbols and display their relations.\n"
-	"Regular expressions are allowed.\n"
-	"Example: search for \"^FOO\"\n"
-	"Result:\n"
-	"-----------------------------------------------------------------\n"
-	"Symbol: FOO [=m]\n"
-	"Type  : tristate\n"
-	"Prompt: Foo bus is used to drive the bar HW\n"
-	"  Location:\n"
-	"    -> Bus options (PCI, PCMCIA, EISA, ISA)\n"
-	"      -> PCI support (PCI [=y])\n"
-	"(1)     -> PCI access mode (<choice> [=y])\n"
-	"  Defined at drivers/pci/Kconfig:47\n"
-	"  Depends on: X86_LOCAL_APIC && X86_IO_APIC\n"
-	"  Selects: LIBCRC32\n"
-	"  Selected by: BAR [=n]\n"
-	"-----------------------------------------------------------------\n"
-	"o The line 'Type:' shows the type of the configuration option for\n"
-	"  this symbol (bool, tristate, string, ...)\n"
-	"o The line 'Prompt:' shows the text used in the menu structure for\n"
-	"  this symbol\n"
-	"o The 'Defined at' line tells at what file / line number the symbol\n"
-	"  is defined\n"
-	"o The 'Depends on:' line tells what symbols need to be defined for\n"
-	"  this symbol to be visible in the menu (selectable)\n"
-	"o The 'Location:' lines tells where in the menu structure this symbol\n"
-	"  is located\n"
-	"    A location followed by a [=y] indicates that this is a\n"
-	"    selectable menu item - and the current value is displayed inside\n"
-	"    brackets.\n"
-	"    Press the key in the (#) prefix to jump directly to that\n"
-	"    location. You will be returned to the current search results\n"
-	"    after exiting this new menu.\n"
-	"o The 'Selects:' line tells what symbols will be automatically\n"
-	"  selected if this symbol is selected (y or m)\n"
-	"o The 'Selected by' line tells what symbol has selected this symbol\n"
-	"\n"
-	"Only relevant lines are shown.\n"
-	"\n\n"
-	"Search examples:\n"
-	"Examples: USB	=> find all symbols containing USB\n"
-	"          ^USB => find all symbols starting with USB\n"
-	"          USB$ => find all symbols ending with USB\n"
-	"\n";
-
-static int indent;
-static struct menu *current_menu;
-static int child_count;
-static int single_menu_mode;
-static int show_all_options;
-static int save_and_exit;
-static int silent;
-
-static void conf(struct menu *menu, struct menu *active_menu);
-
-static char filename[PATH_MAX+1];
-static void set_config_filename(const char *config_filename)
-{
-	static char menu_backtitle[PATH_MAX+128];
-
-	snprintf(menu_backtitle, sizeof(menu_backtitle), "%s - %s",
-		 config_filename, rootmenu.prompt->text);
-	set_dialog_backtitle(menu_backtitle);
-
-	snprintf(filename, sizeof(filename), "%s", config_filename);
-}
-
-struct subtitle_part {
-	struct list_head entries;
-	const char *text;
-};
-static LIST_HEAD(trail);
-
-static struct subtitle_list *subtitles;
-static void set_subtitle(void)
-{
-	struct subtitle_part *sp;
-	struct subtitle_list *pos, *tmp;
-
-	for (pos = subtitles; pos != NULL; pos = tmp) {
-		tmp = pos->next;
-		free(pos);
-	}
-
-	subtitles = NULL;
-	list_for_each_entry(sp, &trail, entries) {
-		if (sp->text) {
-			if (pos) {
-				pos->next = xcalloc(1, sizeof(*pos));
-				pos = pos->next;
-			} else {
-				subtitles = pos = xcalloc(1, sizeof(*pos));
-			}
-			pos->text = sp->text;
-		}
-	}
-
-	set_dialog_subtitles(subtitles);
-}
-
-static void reset_subtitle(void)
-{
-	struct subtitle_list *pos, *tmp;
-
-	for (pos = subtitles; pos != NULL; pos = tmp) {
-		tmp = pos->next;
-		free(pos);
-	}
-	subtitles = NULL;
-	set_dialog_subtitles(subtitles);
-}
-
-static int show_textbox_ext(const char *title, const char *text, int r, int c,
-			    int *vscroll, int *hscroll,
-			    int (*extra_key_cb)(int, size_t, size_t, void *),
-			    void *data)
-{
-	dialog_clear();
-	return dialog_textbox(title, text, r, c, vscroll, hscroll,
-			      extra_key_cb, data);
-}
-
-static void show_textbox(const char *title, const char *text, int r, int c)
-{
-	show_textbox_ext(title, text, r, c, NULL, NULL, NULL, NULL);
-}
-
-static void show_helptext(const char *title, const char *text)
-{
-	show_textbox(title, text, 0, 0);
-}
-
-static void show_help(struct menu *menu)
-{
-	struct gstr help = str_new();
-
-	help.max_width = getmaxx(stdscr) - 10;
-	menu_get_ext_help(menu, &help);
-
-	show_helptext(menu_get_prompt(menu), str_get(&help));
-	str_free(&help);
-}
-
-static void search_conf(void)
-{
-	struct symbol **sym_arr;
-	struct gstr res;
-	struct gstr title;
-	char *dialog_input;
-	int dres, vscroll = 0, hscroll = 0;
-	bool again;
-	struct gstr sttext;
-	struct subtitle_part stpart;
-
-	title = str_new();
-	str_printf( &title, "Enter (sub)string or regexp to search for "
-			      "(with or without \"%s\")", CONFIG_);
-
-again:
-	dialog_clear();
-	dres = dialog_inputbox("Search Configuration Parameter",
-			      str_get(&title),
-			      10, 75, "");
-	switch (dres) {
-	case 0:
-		break;
-	case 1:
-		show_helptext("Search Configuration", search_help);
-		goto again;
-	default:
-		str_free(&title);
-		return;
-	}
-
-	/* strip the prefix if necessary */
-	dialog_input = dialog_input_result;
-	if (strncasecmp(dialog_input_result, CONFIG_, strlen(CONFIG_)) == 0)
-		dialog_input += strlen(CONFIG_);
-
-	sttext = str_new();
-	str_printf(&sttext, "Search (%s)", dialog_input_result);
-	stpart.text = str_get(&sttext);
-	list_add_tail(&stpart.entries, &trail);
-
-	sym_arr = sym_re_search(dialog_input);
-	do {
-		LIST_HEAD(head);
-		struct search_data data = {
-			.head = &head,
-		};
-		struct jump_key *pos, *tmp;
-
-		jump_key_char = 0;
-		res = get_relations_str(sym_arr, &head);
-		set_subtitle();
-		dres = show_textbox_ext("Search Results", str_get(&res), 0, 0,
-					&vscroll, &hscroll,
-					handle_search_keys, &data);
-		again = false;
-		if (dres >= '1' && dres <= '9') {
-			assert(data.target != NULL);
-			conf(data.target->parent, data.target);
-			again = true;
-		}
-		str_free(&res);
-		list_for_each_entry_safe(pos, tmp, &head, entries)
-			free(pos);
-	} while (again);
-	free(sym_arr);
-	str_free(&title);
-	list_del(trail.prev);
-	str_free(&sttext);
-}
-
-static void build_conf(struct menu *menu)
-{
-	struct symbol *sym;
-	struct property *prop;
-	struct menu *child;
-	int type, tmp, doint = 2;
-	tristate val;
-	char ch;
-	bool visible;
-
-	/*
-	 * note: menu_is_visible() has side effect that it will
-	 * recalc the value of the symbol.
-	 */
-	visible = menu_is_visible(menu);
-	if (show_all_options && !menu_has_prompt(menu))
-		return;
-	else if (!show_all_options && !visible)
-		return;
-
-	sym = menu->sym;
-	prop = menu->prompt;
-	if (!sym) {
-		if (prop && menu != current_menu) {
-			const char *prompt = menu_get_prompt(menu);
-			switch (prop->type) {
-			case P_MENU:
-				child_count++;
-				if (single_menu_mode) {
-					item_make("%s%*c%s",
-						  menu->data ? "-->" : "++>",
-						  indent + 1, ' ', prompt);
-				} else
-					item_make("   %*c%s  %s",
-						  indent + 1, ' ', prompt,
-						  menu_is_empty(menu) ? "----" : "--->");
-				item_set_tag('m');
-				item_set_data(menu);
-				if (single_menu_mode && menu->data)
-					goto conf_childs;
-				return;
-			case P_COMMENT:
-				if (prompt) {
-					child_count++;
-					item_make("   %*c*** %s ***", indent + 1, ' ', prompt);
-					item_set_tag(':');
-					item_set_data(menu);
-				}
-				break;
-			default:
-				if (prompt) {
-					child_count++;
-					item_make("---%*c%s", indent + 1, ' ', prompt);
-					item_set_tag(':');
-					item_set_data(menu);
-				}
-			}
-		} else
-			doint = 0;
-		goto conf_childs;
-	}
-
-	type = sym_get_type(sym);
-	if (sym_is_choice(sym)) {
-		struct symbol *def_sym = sym_calc_choice(menu);
-		struct menu *def_menu = NULL;
-
-		child_count++;
-		for (child = menu->list; child; child = child->next) {
-			if (menu_is_visible(child) && child->sym == def_sym)
-				def_menu = child;
-		}
-
-		item_make("   ");
-		item_set_tag(def_menu ? 't' : ':');
-		item_set_data(menu);
-
-		item_add_str("%*c%s", indent + 1, ' ', menu_get_prompt(menu));
-		if (def_menu)
-			item_add_str(" (%s)  --->", menu_get_prompt(def_menu));
-		return;
-	} else {
-		if (menu == current_menu) {
-			item_make("---%*c%s", indent + 1, ' ', menu_get_prompt(menu));
-			item_set_tag(':');
-			item_set_data(menu);
-			goto conf_childs;
-		}
-		child_count++;
-		val = sym_get_tristate_value(sym);
-		switch (type) {
-		case S_BOOLEAN:
-			if (sym_is_changeable(sym))
-				item_make("[%c]", val == no ? ' ' : '*');
-			else
-				item_make("-%c-", val == no ? ' ' : '*');
-			item_set_tag('t');
-			item_set_data(menu);
-			break;
-		case S_TRISTATE:
-			switch (val) {
-			case yes: ch = '*'; break;
-			case mod: ch = 'M'; break;
-			default:  ch = ' '; break;
-			}
-			if (sym_is_changeable(sym)) {
-				if (sym->rev_dep.tri == mod)
-					item_make("{%c}", ch);
-				else
-					item_make("<%c>", ch);
-			} else
-				item_make("-%c-", ch);
-			item_set_tag('t');
-			item_set_data(menu);
-			break;
-		default:
-			tmp = 2 + strlen(sym_get_string_value(sym)); /* () = 2 */
-			item_make("(%s)", sym_get_string_value(sym));
-			tmp = indent - tmp + 4;
-			if (tmp < 0)
-				tmp = 0;
-			item_add_str("%*c%s%s", tmp, ' ', menu_get_prompt(menu),
-				     (sym_has_value(sym) || !sym_is_changeable(sym)) ?
-				     "" : " (NEW)");
-			item_set_tag('s');
-			item_set_data(menu);
-			goto conf_childs;
-		}
-		item_add_str("%*c%s%s", indent + 1, ' ', menu_get_prompt(menu),
-			  (sym_has_value(sym) || !sym_is_changeable(sym)) ?
-			  "" : " (NEW)");
-		if (menu->prompt->type == P_MENU) {
-			item_add_str("  %s", menu_is_empty(menu) ? "----" : "--->");
-			return;
-		}
-	}
-
-conf_childs:
-	indent += doint;
-	for (child = menu->list; child; child = child->next)
-		build_conf(child);
-	indent -= doint;
-}
-
-static void conf_choice(struct menu *menu)
-{
-	const char *prompt = menu_get_prompt(menu);
-	struct menu *child;
-	struct symbol *active;
-
-	active = sym_calc_choice(menu);
-	while (1) {
-		int res;
-		int selected;
-		item_reset();
-
-		current_menu = menu;
-		for (child = menu->list; child; child = child->next) {
-			if (!menu_is_visible(child))
-				continue;
-			if (child->sym)
-				item_make("%s", menu_get_prompt(child));
-			else {
-				item_make("*** %s ***", menu_get_prompt(child));
-				item_set_tag(':');
-			}
-			item_set_data(child);
-			if (child->sym == active)
-				item_set_selected(1);
-			if (child->sym == sym_calc_choice(menu))
-				item_set_tag('X');
-		}
-		dialog_clear();
-		res = dialog_checklist(prompt ? prompt : "Main Menu",
-					radiolist_instructions,
-					MENUBOX_HEIGHT_MIN,
-					MENUBOX_WIDTH_MIN,
-					CHECKLIST_HEIGHT_MIN);
-		selected = item_activate_selected();
-		switch (res) {
-		case 0:
-			if (selected) {
-				child = item_data();
-				if (!child->sym)
-					break;
-
-				choice_set_value(menu, child->sym);
-			}
-			return;
-		case 1:
-			if (selected) {
-				child = item_data();
-				show_help(child);
-				active = child->sym;
-			} else
-				show_help(menu);
-			break;
-		case KEY_ESC:
-			return;
-		case -ERRDISPLAYTOOSMALL:
-			return;
-		}
-	}
-}
-
-static void conf_string(struct menu *menu)
-{
-	const char *prompt = menu_get_prompt(menu);
-
-	while (1) {
-		int res;
-		const char *heading;
-
-		switch (sym_get_type(menu->sym)) {
-		case S_INT:
-			heading = inputbox_instructions_int;
-			break;
-		case S_HEX:
-			heading = inputbox_instructions_hex;
-			break;
-		case S_STRING:
-			heading = inputbox_instructions_string;
-			break;
-		default:
-			heading = "Internal mconf error!";
-		}
-		dialog_clear();
-		res = dialog_inputbox(prompt ? prompt : "Main Menu",
-				      heading, 10, 75,
-				      sym_get_string_value(menu->sym));
-		switch (res) {
-		case 0:
-			if (sym_set_string_value(menu->sym, dialog_input_result))
-				return;
-			show_textbox(NULL, "You have made an invalid entry.", 5, 43);
-			break;
-		case 1:
-			show_help(menu);
-			break;
-		case KEY_ESC:
-			return;
-		}
-	}
-}
-
-static void conf_load(void)
-{
-
-	while (1) {
-		int res;
-		dialog_clear();
-		res = dialog_inputbox(NULL, load_config_text,
-				      11, 55, filename);
-		switch(res) {
-		case 0:
-			if (!dialog_input_result[0])
-				return;
-			if (!conf_read(dialog_input_result)) {
-				set_config_filename(dialog_input_result);
-				conf_set_changed(true);
-				return;
-			}
-			show_textbox(NULL, "File does not exist!", 5, 38);
-			break;
-		case 1:
-			show_helptext("Load Alternate Configuration", load_config_help);
-			break;
-		case KEY_ESC:
-			return;
-		}
-	}
-}
-
-static void conf_save(void)
-{
-	while (1) {
-		int res;
-		dialog_clear();
-		res = dialog_inputbox(NULL, save_config_text,
-				      11, 55, filename);
-		switch(res) {
-		case 0:
-			if (!dialog_input_result[0])
-				return;
-			if (!conf_write(dialog_input_result)) {
-				set_config_filename(dialog_input_result);
-				return;
-			}
-			show_textbox(NULL, "Can't create file!", 5, 60);
-			break;
-		case 1:
-			show_helptext("Save Alternate Configuration", save_config_help);
-			break;
-		case KEY_ESC:
-			return;
-		}
-	}
-}
-
-static void conf(struct menu *menu, struct menu *active_menu)
-{
-	struct menu *submenu;
-	const char *prompt = menu_get_prompt(menu);
-	struct subtitle_part stpart;
-	struct symbol *sym;
-	int res;
-	int s_scroll = 0;
-
-	if (menu != &rootmenu)
-		stpart.text = menu_get_prompt(menu);
-	else
-		stpart.text = NULL;
-	list_add_tail(&stpart.entries, &trail);
-
-	while (1) {
-		item_reset();
-		current_menu = menu;
-		build_conf(menu);
-		if (!child_count)
-			break;
-		set_subtitle();
-		dialog_clear();
-		res = dialog_menu(prompt ? prompt : "Main Menu",
-				  menu_instructions,
-				  active_menu, &s_scroll);
-		if (res == 1 || res == KEY_ESC || res == -ERRDISPLAYTOOSMALL)
-			break;
-		if (item_count() != 0) {
-			if (!item_activate_selected())
-				continue;
-			if (!item_tag())
-				continue;
-		}
-		submenu = item_data();
-		active_menu = item_data();
-		if (submenu)
-			sym = submenu->sym;
-		else
-			sym = NULL;
-
-		switch (res) {
-		case 0:
-			switch (item_tag()) {
-			case 'm':
-				if (single_menu_mode)
-					submenu->data = (void *) (long) !submenu->data;
-				else
-					conf(submenu, NULL);
-				break;
-			case 't':
-				if (sym_is_choice(sym))
-					conf_choice(submenu);
-				else if (submenu->prompt->type == P_MENU)
-					conf(submenu, NULL);
-				break;
-			case 's':
-				conf_string(submenu);
-				break;
-			}
-			break;
-		case 2:
-			if (sym)
-				show_help(submenu);
-			else {
-				reset_subtitle();
-				show_helptext("README", mconf_readme);
-			}
-			break;
-		case 3:
-			reset_subtitle();
-			conf_save();
-			break;
-		case 4:
-			reset_subtitle();
-			conf_load();
-			break;
-		case 5:
-			if (item_is_tag('t')) {
-				if (sym_set_tristate_value(sym, yes))
-					break;
-				if (sym_set_tristate_value(sym, mod))
-					show_textbox(NULL, setmod_text, 6, 74);
-			}
-			break;
-		case 6:
-			if (item_is_tag('t'))
-				sym_set_tristate_value(sym, no);
-			break;
-		case 7:
-			if (item_is_tag('t'))
-				sym_set_tristate_value(sym, mod);
-			break;
-		case 8:
-			if (item_is_tag('t'))
-				sym_toggle_tristate_value(sym);
-			else if (item_is_tag('m'))
-				conf(submenu, NULL);
-			break;
-		case 9:
-			search_conf();
-			break;
-		case 10:
-			show_all_options = !show_all_options;
-			break;
-		}
-	}
-
-	list_del(trail.prev);
-}
-
-static void conf_message_callback(const char *s)
-{
-	if (save_and_exit) {
-		if (!silent)
-			printf("%s", s);
-	} else {
-		show_textbox(NULL, s, 6, 60);
-	}
-}
-
-static int handle_exit(void)
-{
-	int res;
-
-	save_and_exit = 1;
-	reset_subtitle();
-	dialog_clear();
-	if (conf_get_changed())
-		res = dialog_yesno(NULL,
-				   "Do you wish to save your new configuration?\n"
-				     "(Press <ESC><ESC> to continue kernel configuration.)",
-				   6, 60);
-	else
-		res = -1;
-
-	end_dialog(saved_x, saved_y);
-
-	switch (res) {
-	case 0:
-		if (conf_write(filename)) {
-			fprintf(stderr, "\n\n"
-					  "Error while writing of the configuration.\n"
-					  "Your configuration changes were NOT saved."
-					  "\n\n");
-			return 1;
-		}
-		conf_write_autoconf(0);
-		/* fall through */
-	case -1:
-		if (!silent)
-			printf("\n\n"
-				 "*** End of the configuration.\n"
-				 "*** Execute 'make' to start the build or try 'make help'."
-				 "\n\n");
-		res = 0;
-		break;
-	default:
-		if (!silent)
-			fprintf(stderr, "\n\n"
-					  "Your configuration changes were NOT saved."
-					  "\n\n");
-		if (res != KEY_ESC)
-			res = 0;
-	}
-
-	return res;
-}
-
-static void sig_handler(int signo)
-{
-	exit(handle_exit());
-}
-
-int main(int ac, char **av)
-{
-	char *mode;
-	int res;
-
-	signal(SIGINT, sig_handler);
-
-	if (ac > 1 && strcmp(av[1], "-s") == 0) {
-		silent = 1;
-		/* Silence conf_read() until the real callback is set up */
-		conf_set_message_callback(NULL);
-		av++;
-	}
-	conf_parse(av[1]);
-	conf_read(NULL);
-
-	mode = getenv("MENUCONFIG_MODE");
-	if (mode) {
-		if (!strcasecmp(mode, "single_menu"))
-			single_menu_mode = 1;
-	}
-
-	if (init_dialog(NULL)) {
-		fprintf(stderr, "Your display is too small to run Menuconfig!\n");
-		fprintf(stderr, "It must be at least 19 lines by 80 columns.\n");
-		return 1;
-	}
-
-	set_config_filename(conf_get_configname());
-	conf_set_message_callback(conf_message_callback);
-	do {
-		conf(&rootmenu, NULL);
-		res = handle_exit();
-	} while (res == KEY_ESC);
-
-	return res;
-}
diff -Nrup linux-6.16.7/scripts/kernel-doc linux-lenovo-x13s-linux-6.16.y/scripts/kernel-doc
--- linux-6.16.7/scripts/kernel-doc	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/scripts/kernel-doc	2025-09-11 09:47:42.000000000 -0600
@@ -1,315 +1 @@
-#!/usr/bin/env python3
-# SPDX-License-Identifier: GPL-2.0
-# Copyright(c) 2025: Mauro Carvalho Chehab <mchehab@kernel.org>.
-#
-# pylint: disable=C0103,R0915
-#
-# Converted from the kernel-doc script originally written in Perl
-# under GPLv2, copyrighted since 1998 by the following authors:
-#
-#    Aditya Srivastava <yashsri421@gmail.com>
-#    Akira Yokosawa <akiyks@gmail.com>
-#    Alexander A. Klimov <grandmaster@al2klimov.de>
-#    Alexander Lobakin <aleksander.lobakin@intel.com>
-#    Andr Almeida <andrealmeid@igalia.com>
-#    Andy Shevchenko <andriy.shevchenko@linux.intel.com>
-#    Anna-Maria Behnsen <anna-maria@linutronix.de>
-#    Armin Kuster <akuster@mvista.com>
-#    Bart Van Assche <bart.vanassche@sandisk.com>
-#    Ben Hutchings <ben@decadent.org.uk>
-#    Borislav Petkov <bbpetkov@yahoo.de>
-#    Chen-Yu Tsai <wenst@chromium.org>
-#    Coco Li <lixiaoyan@google.com>
-#    Conchr Navid <conchur@web.de>
-#    Daniel Santos <daniel.santos@pobox.com>
-#    Danilo Cesar Lemes de Paula <danilo.cesar@collabora.co.uk>
-#    Dan Luedtke <mail@danrl.de>
-#    Donald Hunter <donald.hunter@gmail.com>
-#    Gabriel Krisman Bertazi <krisman@collabora.co.uk>
-#    Greg Kroah-Hartman <gregkh@linuxfoundation.org>
-#    Harvey Harrison <harvey.harrison@gmail.com>
-#    Horia Geanta <horia.geanta@freescale.com>
-#    Ilya Dryomov <idryomov@gmail.com>
-#    Jakub Kicinski <kuba@kernel.org>
-#    Jani Nikula <jani.nikula@intel.com>
-#    Jason Baron <jbaron@redhat.com>
-#    Jason Gunthorpe <jgg@nvidia.com>
-#    Jrmy Bobbio <lunar@debian.org>
-#    Johannes Berg <johannes.berg@intel.com>
-#    Johannes Weiner <hannes@cmpxchg.org>
-#    Jonathan Cameron <Jonathan.Cameron@huawei.com>
-#    Jonathan Corbet <corbet@lwn.net>
-#    Jonathan Neuschfer <j.neuschaefer@gmx.net>
-#    Kamil Rytarowski <n54@gmx.com>
-#    Kees Cook <kees@kernel.org>
-#    Laurent Pinchart <laurent.pinchart@ideasonboard.com>
-#    Levin, Alexander (Sasha Levin) <alexander.levin@verizon.com>
-#    Linus Torvalds <torvalds@linux-foundation.org>
-#    Lucas De Marchi <lucas.demarchi@profusion.mobi>
-#    Mark Rutland <mark.rutland@arm.com>
-#    Markus Heiser <markus.heiser@darmarit.de>
-#    Martin Waitz <tali@admingilde.org>
-#    Masahiro Yamada <masahiroy@kernel.org>
-#    Matthew Wilcox <willy@infradead.org>
-#    Mauro Carvalho Chehab <mchehab+huawei@kernel.org>
-#    Michal Wajdeczko <michal.wajdeczko@intel.com>
-#    Michael Zucchi
-#    Mike Rapoport <rppt@linux.ibm.com>
-#    Niklas Sderlund <niklas.soderlund@corigine.com>
-#    Nishanth Menon <nm@ti.com>
-#    Paolo Bonzini <pbonzini@redhat.com>
-#    Pavan Kumar Linga <pavan.kumar.linga@intel.com>
-#    Pavel Pisa <pisa@cmp.felk.cvut.cz>
-#    Peter Maydell <peter.maydell@linaro.org>
-#    Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
-#    Randy Dunlap <rdunlap@infradead.org>
-#    Richard Kennedy <richard@rsk.demon.co.uk>
-#    Rich Walker <rw@shadow.org.uk>
-#    Rolf Eike Beer <eike-kernel@sf-tec.de>
-#    Sakari Ailus <sakari.ailus@linux.intel.com>
-#    Silvio Fricke <silvio.fricke@gmail.com>
-#    Simon Huggins
-#    Tim Waugh <twaugh@redhat.com>
-#    Tomasz Warnieo <tomasz.warniello@gmail.com>
-#    Utkarsh Tripathi <utripathi2002@gmail.com>
-#    valdis.kletnieks@vt.edu <valdis.kletnieks@vt.edu>
-#    Vegard Nossum <vegard.nossum@oracle.com>
-#    Will Deacon <will.deacon@arm.com>
-#    Yacine Belkadi <yacine.belkadi.1@gmail.com>
-#    Yujie Liu <yujie.liu@intel.com>
-
-"""
-kernel_doc
-==========
-
-Print formatted kernel documentation to stdout
-
-Read C language source or header FILEs, extract embedded
-documentation comments, and print formatted documentation
-to standard output.
-
-The documentation comments are identified by the "/**"
-opening comment mark.
-
-See Documentation/doc-guide/kernel-doc.rst for the
-documentation comment syntax.
-"""
-
-import argparse
-import logging
-import os
-import sys
-
-# Import Python modules
-
-LIB_DIR = "lib/kdoc"
-SRC_DIR = os.path.dirname(os.path.realpath(__file__))
-
-sys.path.insert(0, os.path.join(SRC_DIR, LIB_DIR))
-
-from kdoc_files import KernelFiles                      # pylint: disable=C0413
-from kdoc_output import RestFormat, ManFormat           # pylint: disable=C0413
-
-DESC = """
-Read C language source or header FILEs, extract embedded documentation comments,
-and print formatted documentation to standard output.
-
-The documentation comments are identified by the "/**" opening comment mark.
-
-See Documentation/doc-guide/kernel-doc.rst for the documentation comment syntax.
-"""
-
-EXPORT_FILE_DESC = """
-Specify an additional FILE in which to look for EXPORT_SYMBOL information.
-
-May be used multiple times.
-"""
-
-EXPORT_DESC = """
-Only output documentation for the symbols that have been
-exported using EXPORT_SYMBOL() and related macros in any input
-FILE or -export-file FILE.
-"""
-
-INTERNAL_DESC = """
-Only output documentation for the symbols that have NOT been
-exported using EXPORT_SYMBOL() and related macros in any input
-FILE or -export-file FILE.
-"""
-
-FUNCTION_DESC = """
-Only output documentation for the given function or DOC: section
-title. All other functions and DOC: sections are ignored.
-
-May be used multiple times.
-"""
-
-NOSYMBOL_DESC = """
-Exclude the specified symbol from the output documentation.
-
-May be used multiple times.
-"""
-
-FILES_DESC = """
-Header and C source files to be parsed.
-"""
-
-WARN_CONTENTS_BEFORE_SECTIONS_DESC = """
-Warns if there are contents before sections (deprecated).
-
-This option is kept just for backward-compatibility, but it does nothing,
-neither here nor at the original Perl script.
-"""
-
-
-class MsgFormatter(logging.Formatter):
-    """Helper class to format warnings on a similar way to kernel-doc.pl"""
-
-    def format(self, record):
-        record.levelname = record.levelname.capitalize()
-        return logging.Formatter.format(self, record)
-
-def main():
-    """Main program"""
-
-    parser = argparse.ArgumentParser(formatter_class=argparse.RawTextHelpFormatter,
-                                     description=DESC)
-
-    # Normal arguments
-
-    parser.add_argument("-v", "-verbose", "--verbose", action="store_true",
-                        help="Verbose output, more warnings and other information.")
-
-    parser.add_argument("-d", "-debug", "--debug", action="store_true",
-                        help="Enable debug messages")
-
-    parser.add_argument("-M", "-modulename", "--modulename",
-                        default="Kernel API",
-                        help="Allow setting a module name at the output.")
-
-    parser.add_argument("-l", "-enable-lineno", "--enable_lineno",
-                        action="store_true",
-                        help="Enable line number output (only in ReST mode)")
-
-    # Arguments to control the warning behavior
-
-    parser.add_argument("-Wreturn", "--wreturn", action="store_true",
-                        help="Warns about the lack of a return markup on functions.")
-
-    parser.add_argument("-Wshort-desc", "-Wshort-description", "--wshort-desc",
-                        action="store_true",
-                        help="Warns if initial short description is missing")
-
-    parser.add_argument("-Wcontents-before-sections",
-                        "--wcontents-before-sections", action="store_true",
-                        help=WARN_CONTENTS_BEFORE_SECTIONS_DESC)
-
-    parser.add_argument("-Wall", "--wall", action="store_true",
-                        help="Enable all types of warnings")
-
-    parser.add_argument("-Werror", "--werror", action="store_true",
-                        help="Treat warnings as errors.")
-
-    parser.add_argument("-export-file", "--export-file", action='append',
-                        help=EXPORT_FILE_DESC)
-
-    # Output format mutually-exclusive group
-
-    out_group = parser.add_argument_group("Output format selection (mutually exclusive)")
-
-    out_fmt = out_group.add_mutually_exclusive_group()
-
-    out_fmt.add_argument("-m", "-man", "--man", action="store_true",
-                         help="Output troff manual page format.")
-    out_fmt.add_argument("-r", "-rst", "--rst", action="store_true",
-                         help="Output reStructuredText format (default).")
-    out_fmt.add_argument("-N", "-none", "--none", action="store_true",
-                         help="Do not output documentation, only warnings.")
-
-    # Output selection mutually-exclusive group
-
-    sel_group = parser.add_argument_group("Output selection (mutually exclusive)")
-    sel_mut = sel_group.add_mutually_exclusive_group()
-
-    sel_mut.add_argument("-e", "-export", "--export", action='store_true',
-                         help=EXPORT_DESC)
-
-    sel_mut.add_argument("-i", "-internal", "--internal", action='store_true',
-                         help=INTERNAL_DESC)
-
-    sel_mut.add_argument("-s", "-function", "--symbol", action='append',
-                         help=FUNCTION_DESC)
-
-    # Those are valid for all 3 types of filter
-    parser.add_argument("-n", "-nosymbol", "--nosymbol", action='append',
-                        help=NOSYMBOL_DESC)
-
-    parser.add_argument("-D", "-no-doc-sections", "--no-doc-sections",
-                        action='store_true', help="Don't outputt DOC sections")
-
-    parser.add_argument("files", metavar="FILE",
-                        nargs="+", help=FILES_DESC)
-
-    args = parser.parse_args()
-
-    if args.wall:
-        args.wreturn = True
-        args.wshort_desc = True
-        args.wcontents_before_sections = True
-
-    logger = logging.getLogger()
-
-    if not args.debug:
-        logger.setLevel(logging.INFO)
-    else:
-        logger.setLevel(logging.DEBUG)
-
-    formatter = MsgFormatter('%(levelname)s: %(message)s')
-
-    handler = logging.StreamHandler()
-    handler.setFormatter(formatter)
-
-    logger.addHandler(handler)
-
-    if args.man:
-        out_style = ManFormat(modulename=args.modulename)
-    elif args.none:
-        out_style = None
-    else:
-        out_style = RestFormat()
-
-    kfiles = KernelFiles(verbose=args.verbose,
-                         out_style=out_style, werror=args.werror,
-                         wreturn=args.wreturn, wshort_desc=args.wshort_desc,
-                         wcontents_before_sections=args.wcontents_before_sections)
-
-    kfiles.parse(args.files, export_file=args.export_file)
-
-    for t in kfiles.msg(enable_lineno=args.enable_lineno, export=args.export,
-                        internal=args.internal, symbol=args.symbol,
-                        nosymbol=args.nosymbol, export_file=args.export_file,
-                        no_doc_sections=args.no_doc_sections):
-        msg = t[1]
-        if msg:
-            print(msg)
-
-    error_count = kfiles.errors
-    if not error_count:
-        sys.exit(0)
-
-    if args.werror:
-        print(f"{error_count} warnings as errors")
-        sys.exit(error_count)
-
-    if args.verbose:
-        print(f"{error_count} errors")
-
-    if args.none:
-        sys.exit(0)
-
-    sys.exit(error_count)
-
-
-# Call main method
-if __name__ == "__main__":
-    main()
+kernel-doc.py
\ No newline at end of file
diff -Nrup linux-6.16.7/scripts/sign-file.c linux-lenovo-x13s-linux-6.16.y/scripts/sign-file.c
--- linux-6.16.7/scripts/sign-file.c	2025-09-13 16:15:46.046904569 -0600
+++ linux-lenovo-x13s-linux-6.16.y/scripts/sign-file.c	2025-09-11 09:47:42.000000000 -0600
@@ -51,10 +51,9 @@
  * signing with anything other than SHA1 - so we're stuck with that if such is
  * the case.
  */
-#if defined(OPENSSL_NO_CMS) || \
-	( defined(LIBRESSL_VERSION_NUMBER) \
-	&& (LIBRESSL_VERSION_NUMBER < 0x3010000fL) ) || \
-	OPENSSL_VERSION_NUMBER < 0x10000000L
+#if defined(LIBRESSL_VERSION_NUMBER) || \
+	OPENSSL_VERSION_NUMBER < 0x10000000L || \
+	defined(OPENSSL_NO_CMS)
 #define USE_PKCS7
 #endif
 #ifndef USE_PKCS7
diff -Nrup linux-6.16.7/scripts/sign-file.c.orig linux-lenovo-x13s-linux-6.16.y/scripts/sign-file.c.orig
--- linux-6.16.7/scripts/sign-file.c.orig	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/scripts/sign-file.c.orig	1969-12-31 17:00:00.000000000 -0700
@@ -1,410 +0,0 @@
-/* Sign a module file using the given key.
- *
- * Copyright  2014-2016 Red Hat, Inc. All Rights Reserved.
- * Copyright  2015      Intel Corporation.
- * Copyright  2016      Hewlett Packard Enterprise Development LP
- *
- * Authors: David Howells <dhowells@redhat.com>
- *          David Woodhouse <dwmw2@infradead.org>
- *          Juerg Haefliger <juerg.haefliger@hpe.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public License
- * as published by the Free Software Foundation; either version 2.1
- * of the licence, or (at your option) any later version.
- */
-#define _GNU_SOURCE
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdint.h>
-#include <stdbool.h>
-#include <string.h>
-#include <getopt.h>
-#include <err.h>
-#include <arpa/inet.h>
-#include <openssl/opensslv.h>
-#include <openssl/bio.h>
-#include <openssl/evp.h>
-#include <openssl/pem.h>
-#include <openssl/err.h>
-#if OPENSSL_VERSION_MAJOR >= 3
-# define USE_PKCS11_PROVIDER
-# include <openssl/provider.h>
-# include <openssl/store.h>
-#else
-# if !defined(OPENSSL_NO_ENGINE) && !defined(OPENSSL_NO_DEPRECATED_3_0)
-#  define USE_PKCS11_ENGINE
-#  include <openssl/engine.h>
-# endif
-#endif
-#include "ssl-common.h"
-
-/*
- * Use CMS if we have openssl-1.0.0 or newer available - otherwise we have to
- * assume that it's not available and its header file is missing and that we
- * should use PKCS#7 instead.  Switching to the older PKCS#7 format restricts
- * the options we have on specifying the X.509 certificate we want.
- *
- * Further, older versions of OpenSSL don't support manually adding signers to
- * the PKCS#7 message so have to accept that we get a certificate included in
- * the signature message.  Nor do such older versions of OpenSSL support
- * signing with anything other than SHA1 - so we're stuck with that if such is
- * the case.
- */
-#if defined(LIBRESSL_VERSION_NUMBER) || \
-	OPENSSL_VERSION_NUMBER < 0x10000000L || \
-	defined(OPENSSL_NO_CMS)
-#define USE_PKCS7
-#endif
-#ifndef USE_PKCS7
-#include <openssl/cms.h>
-#else
-#include <openssl/pkcs7.h>
-#endif
-
-struct module_signature {
-	uint8_t		algo;		/* Public-key crypto algorithm [0] */
-	uint8_t		hash;		/* Digest algorithm [0] */
-	uint8_t		id_type;	/* Key identifier type [PKEY_ID_PKCS7] */
-	uint8_t		signer_len;	/* Length of signer's name [0] */
-	uint8_t		key_id_len;	/* Length of key identifier [0] */
-	uint8_t		__pad[3];
-	uint32_t	sig_len;	/* Length of signature data */
-};
-
-#define PKEY_ID_PKCS7 2
-
-static char magic_number[] = "~Module signature appended~\n";
-
-static __attribute__((noreturn))
-void format(void)
-{
-	fprintf(stderr,
-		"Usage: scripts/sign-file [-dp] <hash algo> <key> <x509> <module> [<dest>]\n");
-	fprintf(stderr,
-		"       scripts/sign-file -s <raw sig> <hash algo> <x509> <module> [<dest>]\n");
-	exit(2);
-}
-
-static const char *key_pass;
-
-static int pem_pw_cb(char *buf, int len, int w, void *v)
-{
-	int pwlen;
-
-	if (!key_pass)
-		return -1;
-
-	pwlen = strlen(key_pass);
-	if (pwlen >= len)
-		return -1;
-
-	strcpy(buf, key_pass);
-
-	/* If it's wrong, don't keep trying it. */
-	key_pass = NULL;
-
-	return pwlen;
-}
-
-static EVP_PKEY *read_private_key_pkcs11(const char *private_key_name)
-{
-	EVP_PKEY *private_key = NULL;
-#ifdef USE_PKCS11_PROVIDER
-	OSSL_STORE_CTX *store;
-
-	if (!OSSL_PROVIDER_try_load(NULL, "pkcs11", true))
-		ERR(1, "OSSL_PROVIDER_try_load(pkcs11)");
-	if (!OSSL_PROVIDER_try_load(NULL, "default", true))
-		ERR(1, "OSSL_PROVIDER_try_load(default)");
-
-	store = OSSL_STORE_open(private_key_name, NULL, NULL, NULL, NULL);
-	ERR(!store, "OSSL_STORE_open");
-
-	while (!OSSL_STORE_eof(store)) {
-		OSSL_STORE_INFO *info = OSSL_STORE_load(store);
-
-		if (!info) {
-			drain_openssl_errors(__LINE__, 0);
-			continue;
-		}
-		if (OSSL_STORE_INFO_get_type(info) == OSSL_STORE_INFO_PKEY) {
-			private_key = OSSL_STORE_INFO_get1_PKEY(info);
-			ERR(!private_key, "OSSL_STORE_INFO_get1_PKEY");
-		}
-		OSSL_STORE_INFO_free(info);
-		if (private_key)
-			break;
-	}
-	OSSL_STORE_close(store);
-#elif defined(USE_PKCS11_ENGINE)
-	ENGINE *e;
-
-	ENGINE_load_builtin_engines();
-	drain_openssl_errors(__LINE__, 1);
-	e = ENGINE_by_id("pkcs11");
-	ERR(!e, "Load PKCS#11 ENGINE");
-	if (ENGINE_init(e))
-		drain_openssl_errors(__LINE__, 1);
-	else
-		ERR(1, "ENGINE_init");
-	if (key_pass)
-		ERR(!ENGINE_ctrl_cmd_string(e, "PIN", key_pass, 0), "Set PKCS#11 PIN");
-	private_key = ENGINE_load_private_key(e, private_key_name, NULL, NULL);
-	ERR(!private_key, "%s", private_key_name);
-#else
-	fprintf(stderr, "no pkcs11 engine/provider available\n");
-	exit(1);
-#endif
-	return private_key;
-}
-
-static EVP_PKEY *read_private_key(const char *private_key_name)
-{
-	if (!strncmp(private_key_name, "pkcs11:", 7)) {
-		return read_private_key_pkcs11(private_key_name);
-	} else {
-		EVP_PKEY *private_key;
-		BIO *b;
-
-		b = BIO_new_file(private_key_name, "rb");
-		ERR(!b, "%s", private_key_name);
-		private_key = PEM_read_bio_PrivateKey(b, NULL, pem_pw_cb,
-						      NULL);
-		ERR(!private_key, "%s", private_key_name);
-		BIO_free(b);
-
-		return private_key;
-	}
-}
-
-static X509 *read_x509(const char *x509_name)
-{
-	unsigned char buf[2];
-	X509 *x509;
-	BIO *b;
-	int n;
-
-	b = BIO_new_file(x509_name, "rb");
-	ERR(!b, "%s", x509_name);
-
-	/* Look at the first two bytes of the file to determine the encoding */
-	n = BIO_read(b, buf, 2);
-	if (n != 2) {
-		if (BIO_should_retry(b)) {
-			fprintf(stderr, "%s: Read wanted retry\n", x509_name);
-			exit(1);
-		}
-		if (n >= 0) {
-			fprintf(stderr, "%s: Short read\n", x509_name);
-			exit(1);
-		}
-		ERR(1, "%s", x509_name);
-	}
-
-	ERR(BIO_reset(b) != 0, "%s", x509_name);
-
-	if (buf[0] == 0x30 && buf[1] >= 0x81 && buf[1] <= 0x84)
-		/* Assume raw DER encoded X.509 */
-		x509 = d2i_X509_bio(b, NULL);
-	else
-		/* Assume PEM encoded X.509 */
-		x509 = PEM_read_bio_X509(b, NULL, NULL, NULL);
-
-	BIO_free(b);
-	ERR(!x509, "%s", x509_name);
-
-	return x509;
-}
-
-int main(int argc, char **argv)
-{
-	struct module_signature sig_info = { .id_type = PKEY_ID_PKCS7 };
-	char *hash_algo = NULL;
-	char *private_key_name = NULL, *raw_sig_name = NULL;
-	char *x509_name, *module_name, *dest_name;
-	bool save_sig = false, replace_orig;
-	bool sign_only = false;
-	bool raw_sig = false;
-	unsigned char buf[4096];
-	unsigned long module_size, sig_size;
-	unsigned int use_signed_attrs;
-	const EVP_MD *digest_algo;
-	EVP_PKEY *private_key;
-#ifndef USE_PKCS7
-	CMS_ContentInfo *cms = NULL;
-	unsigned int use_keyid = 0;
-#else
-	PKCS7 *pkcs7 = NULL;
-#endif
-	X509 *x509;
-	BIO *bd, *bm;
-	int opt, n;
-	OpenSSL_add_all_algorithms();
-	ERR_load_crypto_strings();
-	ERR_clear_error();
-
-	key_pass = getenv("KBUILD_SIGN_PIN");
-
-#ifndef USE_PKCS7
-	use_signed_attrs = CMS_NOATTR;
-#else
-	use_signed_attrs = PKCS7_NOATTR;
-#endif
-
-	do {
-		opt = getopt(argc, argv, "sdpk");
-		switch (opt) {
-		case 's': raw_sig = true; break;
-		case 'p': save_sig = true; break;
-		case 'd': sign_only = true; save_sig = true; break;
-#ifndef USE_PKCS7
-		case 'k': use_keyid = CMS_USE_KEYID; break;
-#endif
-		case -1: break;
-		default: format();
-		}
-	} while (opt != -1);
-
-	argc -= optind;
-	argv += optind;
-	if (argc < 4 || argc > 5)
-		format();
-
-	if (raw_sig) {
-		raw_sig_name = argv[0];
-		hash_algo = argv[1];
-	} else {
-		hash_algo = argv[0];
-		private_key_name = argv[1];
-	}
-	x509_name = argv[2];
-	module_name = argv[3];
-	if (argc == 5 && strcmp(argv[3], argv[4]) != 0) {
-		dest_name = argv[4];
-		replace_orig = false;
-	} else {
-		ERR(asprintf(&dest_name, "%s.~signed~", module_name) < 0,
-		    "asprintf");
-		replace_orig = true;
-	}
-
-#ifdef USE_PKCS7
-	if (strcmp(hash_algo, "sha1") != 0) {
-		fprintf(stderr, "sign-file: %s only supports SHA1 signing\n",
-			OPENSSL_VERSION_TEXT);
-		exit(3);
-	}
-#endif
-
-	/* Open the module file */
-	bm = BIO_new_file(module_name, "rb");
-	ERR(!bm, "%s", module_name);
-
-	if (!raw_sig) {
-		/* Read the private key and the X.509 cert the PKCS#7 message
-		 * will point to.
-		 */
-		private_key = read_private_key(private_key_name);
-		x509 = read_x509(x509_name);
-
-		/* Digest the module data. */
-		OpenSSL_add_all_digests();
-		drain_openssl_errors(__LINE__, 0);
-		digest_algo = EVP_get_digestbyname(hash_algo);
-		ERR(!digest_algo, "EVP_get_digestbyname");
-
-#ifndef USE_PKCS7
-		/* Load the signature message from the digest buffer. */
-		cms = CMS_sign(NULL, NULL, NULL, NULL,
-			       CMS_NOCERTS | CMS_PARTIAL | CMS_BINARY |
-			       CMS_DETACHED | CMS_STREAM);
-		ERR(!cms, "CMS_sign");
-
-		ERR(!CMS_add1_signer(cms, x509, private_key, digest_algo,
-				     CMS_NOCERTS | CMS_BINARY |
-				     CMS_NOSMIMECAP | use_keyid |
-				     use_signed_attrs),
-		    "CMS_add1_signer");
-		ERR(CMS_final(cms, bm, NULL, CMS_NOCERTS | CMS_BINARY) != 1,
-		    "CMS_final");
-
-#else
-		pkcs7 = PKCS7_sign(x509, private_key, NULL, bm,
-				   PKCS7_NOCERTS | PKCS7_BINARY |
-				   PKCS7_DETACHED | use_signed_attrs);
-		ERR(!pkcs7, "PKCS7_sign");
-#endif
-
-		if (save_sig) {
-			char *sig_file_name;
-			BIO *b;
-
-			ERR(asprintf(&sig_file_name, "%s.p7s", module_name) < 0,
-			    "asprintf");
-			b = BIO_new_file(sig_file_name, "wb");
-			ERR(!b, "%s", sig_file_name);
-#ifndef USE_PKCS7
-			ERR(i2d_CMS_bio_stream(b, cms, NULL, 0) != 1,
-			    "%s", sig_file_name);
-#else
-			ERR(i2d_PKCS7_bio(b, pkcs7) != 1,
-			    "%s", sig_file_name);
-#endif
-			BIO_free(b);
-		}
-
-		if (sign_only) {
-			BIO_free(bm);
-			return 0;
-		}
-	}
-
-	/* Open the destination file now so that we can shovel the module data
-	 * across as we read it.
-	 */
-	bd = BIO_new_file(dest_name, "wb");
-	ERR(!bd, "%s", dest_name);
-
-	/* Append the marker and the PKCS#7 message to the destination file */
-	ERR(BIO_reset(bm) < 0, "%s", module_name);
-	while ((n = BIO_read(bm, buf, sizeof(buf))),
-	       n > 0) {
-		ERR(BIO_write(bd, buf, n) < 0, "%s", dest_name);
-	}
-	BIO_free(bm);
-	ERR(n < 0, "%s", module_name);
-	module_size = BIO_number_written(bd);
-
-	if (!raw_sig) {
-#ifndef USE_PKCS7
-		ERR(i2d_CMS_bio_stream(bd, cms, NULL, 0) != 1, "%s", dest_name);
-#else
-		ERR(i2d_PKCS7_bio(bd, pkcs7) != 1, "%s", dest_name);
-#endif
-	} else {
-		BIO *b;
-
-		/* Read the raw signature file and write the data to the
-		 * destination file
-		 */
-		b = BIO_new_file(raw_sig_name, "rb");
-		ERR(!b, "%s", raw_sig_name);
-		while ((n = BIO_read(b, buf, sizeof(buf))), n > 0)
-			ERR(BIO_write(bd, buf, n) < 0, "%s", dest_name);
-		BIO_free(b);
-	}
-
-	sig_size = BIO_number_written(bd) - module_size;
-	sig_info.sig_len = htonl(sig_size);
-	ERR(BIO_write(bd, &sig_info, sizeof(sig_info)) < 0, "%s", dest_name);
-	ERR(BIO_write(bd, magic_number, sizeof(magic_number) - 1) < 0, "%s", dest_name);
-
-	ERR(BIO_free(bd) != 1, "%s", dest_name);
-
-	/* Finally, if we're signing in place, replace the original. */
-	if (replace_orig)
-		ERR(rename(dest_name, module_name) < 0, "%s", dest_name);
-
-	return 0;
-}
diff -Nrup linux-6.16.7/sound/soc/codecs/Kconfig linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/Kconfig
--- linux-6.16.7/sound/soc/codecs/Kconfig	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/Kconfig	2025-09-11 09:47:42.000000000 -0600
@@ -2227,6 +2227,9 @@ config SND_SOC_UDA1380
 config SND_SOC_WCD_CLASSH
 	tristate
 
+config SND_SOC_WCD_COMMON
+	tristate
+
 config SND_SOC_WCD9335
 	tristate "WCD9335 Codec"
 	depends on SLIMBUS
@@ -2248,6 +2251,7 @@ config SND_SOC_WCD934X
 	select REGMAP_IRQ
 	select REGMAP_SLIMBUS
 	select SND_SOC_WCD_CLASSH
+	select SND_SOC_WCD_COMMON
 	select SND_SOC_WCD_MBHC
 	depends on MFD_WCD934X || COMPILE_TEST
 	help
@@ -2259,6 +2263,7 @@ config SND_SOC_WCD937X
 	tristate
 	depends on SOUNDWIRE || !SOUNDWIRE
 	select SND_SOC_WCD_CLASSH
+	select SND_SOC_WCD_COMMON
 
 config SND_SOC_WCD937X_SDW
 	tristate "WCD9370/WCD9375 Codec - SDW"
@@ -2278,6 +2283,7 @@ config SND_SOC_WCD938X
 	tristate
 	depends on SOUNDWIRE || !SOUNDWIRE
 	select SND_SOC_WCD_CLASSH
+	select SND_SOC_WCD_COMMON
 	select MULTIPLEXER
 
 config SND_SOC_WCD938X_SDW
@@ -2297,6 +2303,7 @@ config SND_SOC_WCD939X
 	depends on SOUNDWIRE || !SOUNDWIRE
 	depends on TYPEC || !TYPEC
 	select SND_SOC_WCD_CLASSH
+	select SND_SOC_WCD_COMMON
 
 config SND_SOC_WCD939X_SDW
 	tristate "WCD9390/WCD9395 Codec - SDW"
diff -Nrup linux-6.16.7/sound/soc/codecs/Makefile linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/Makefile
--- linux-6.16.7/sound/soc/codecs/Makefile	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/Makefile	2025-09-11 09:47:42.000000000 -0600
@@ -338,6 +338,7 @@ snd-soc-uda1334-y := uda1334.o
 snd-soc-uda1342-y := uda1342.o
 snd-soc-uda1380-y := uda1380.o
 snd-soc-wcd-classh-y := wcd-clsh-v2.o
+snd-soc-wcd-common-y := wcd-common.o
 snd-soc-wcd-mbhc-y := wcd-mbhc-v2.o
 snd-soc-wcd9335-y := wcd9335.o
 snd-soc-wcd934x-y := wcd934x.o
@@ -759,6 +760,7 @@ obj-$(CONFIG_SND_SOC_UDA1334)	+= snd-soc
 obj-$(CONFIG_SND_SOC_UDA1342)	+= snd-soc-uda1342.o
 obj-$(CONFIG_SND_SOC_UDA1380)	+= snd-soc-uda1380.o
 obj-$(CONFIG_SND_SOC_WCD_CLASSH)	+= snd-soc-wcd-classh.o
+obj-$(CONFIG_SND_SOC_WCD_COMMON)	+= snd-soc-wcd-common.o
 obj-$(CONFIG_SND_SOC_WCD_MBHC)	+= snd-soc-wcd-mbhc.o
 obj-$(CONFIG_SND_SOC_WCD9335)	+= snd-soc-wcd9335.o
 obj-$(CONFIG_SND_SOC_WCD934X)	+= snd-soc-wcd934x.o
diff -Nrup linux-6.16.7/sound/soc/codecs/wcd934x.c linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd934x.c
--- linux-6.16.7/sound/soc/codecs/wcd934x.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd934x.c	2025-09-11 09:47:42.000000000 -0600
@@ -21,6 +21,7 @@
 #include <sound/soc-dapm.h>
 #include <sound/tlv.h>
 #include "wcd-clsh-v2.h"
+#include "wcd-common.h"
 #include "wcd-mbhc-v2.h"
 
 #include <dt-bindings/sound/qcom,wcd934x.h>
@@ -116,9 +117,6 @@
 #define WCD934X_DEC_PWR_LVL_DF		0x00
 #define WCD934X_DEC_PWR_LVL_HYBRID WCD934X_DEC_PWR_LVL_DF
 
-#define WCD934X_DEF_MICBIAS_MV	1800
-#define WCD934X_MAX_MICBIAS_MV	2850
-
 #define WCD_IIR_FILTER_SIZE	(sizeof(u32) * BAND_MAX)
 
 #define WCD_IIR_FILTER_CTL(xname, iidx, bidx) \
@@ -530,6 +528,7 @@ struct wcd934x_codec {
 	struct slim_device *sdev;
 	struct slim_device *sidev;
 	struct wcd_clsh_ctrl *clsh_ctrl;
+	struct wcd_common common;
 	struct snd_soc_component *component;
 	struct wcd934x_slim_ch rx_chs[WCD934X_RX_MAX];
 	struct wcd934x_slim_ch tx_chs[WCD934X_TX_MAX];
@@ -557,7 +556,6 @@ struct wcd934x_codec {
 	struct mutex micb_lock;
 	u32 micb_ref[WCD934X_MAX_MICBIAS];
 	u32 pullup_ref[WCD934X_MAX_MICBIAS];
-	u32 micb2_mv;
 };
 
 #define to_wcd934x_codec(_hw) container_of(_hw, struct wcd934x_codec, hw)
@@ -2172,55 +2170,24 @@ static struct clk *wcd934x_register_mclk
 	return NULL;
 }
 
-static int wcd934x_get_micbias_val(struct device *dev, const char *micbias,
-				   u32 *micb_mv)
-{
-	int mv;
-
-	if (of_property_read_u32(dev->parent->of_node, micbias, &mv)) {
-		dev_err(dev, "%s value not found, using default\n", micbias);
-		mv = WCD934X_DEF_MICBIAS_MV;
-	} else {
-		/* convert it to milli volts */
-		mv = mv/1000;
-	}
-
-	if (mv < 1000 || mv > 2850) {
-		dev_err(dev, "%s value not in valid range, using default\n",
-			micbias);
-		mv = WCD934X_DEF_MICBIAS_MV;
-	}
-
-	if (micb_mv)
-		*micb_mv = mv;
-
-	return (mv - 1000) / 50;
-}
-
 static int wcd934x_init_dmic(struct snd_soc_component *comp)
 {
-	int vout_ctl_1, vout_ctl_2, vout_ctl_3, vout_ctl_4;
 	struct wcd934x_codec *wcd = dev_get_drvdata(comp->dev);
 	u32 def_dmic_rate, dmic_clk_drv;
+	int ret;
 
-	vout_ctl_1 = wcd934x_get_micbias_val(comp->dev,
-					     "qcom,micbias1-microvolt", NULL);
-	vout_ctl_2 = wcd934x_get_micbias_val(comp->dev,
-					     "qcom,micbias2-microvolt",
-					     &wcd->micb2_mv);
-	vout_ctl_3 = wcd934x_get_micbias_val(comp->dev,
-					     "qcom,micbias3-microvolt", NULL);
-	vout_ctl_4 = wcd934x_get_micbias_val(comp->dev,
-					     "qcom,micbias4-microvolt", NULL);
+	ret = wcd_dt_parse_mbhc_data(comp->dev, &wcd->mbhc_cfg);
+	if (ret)
+		return ret;
 
 	snd_soc_component_update_bits(comp, WCD934X_ANA_MICB1,
-				      WCD934X_MICB_VAL_MASK, vout_ctl_1);
+				      WCD934X_MICB_VAL_MASK, wcd->common.micb_vout[0]);
 	snd_soc_component_update_bits(comp, WCD934X_ANA_MICB2,
-				      WCD934X_MICB_VAL_MASK, vout_ctl_2);
+				      WCD934X_MICB_VAL_MASK, wcd->common.micb_vout[1]);
 	snd_soc_component_update_bits(comp, WCD934X_ANA_MICB3,
-				      WCD934X_MICB_VAL_MASK, vout_ctl_3);
+				      WCD934X_MICB_VAL_MASK, wcd->common.micb_vout[2]);
 	snd_soc_component_update_bits(comp, WCD934X_ANA_MICB4,
-				      WCD934X_MICB_VAL_MASK, vout_ctl_4);
+				      WCD934X_MICB_VAL_MASK, wcd->common.micb_vout[3]);
 
 	if (wcd->rate == WCD934X_MCLK_CLK_9P6MHZ)
 		def_dmic_rate = WCD9XXX_DMIC_SAMPLE_RATE_4P8MHZ;
@@ -2521,15 +2488,6 @@ static void wcd934x_mbhc_micb_ramp_contr
 	}
 }
 
-static int wcd934x_get_micb_vout_ctl_val(u32 micb_mv)
-{
-	/* min micbias voltage is 1V and maximum is 2.85V */
-	if (micb_mv < 1000 || micb_mv > 2850)
-		return -EINVAL;
-
-	return (micb_mv - 1000) / 50;
-}
-
 static int wcd934x_mbhc_micb_adjust_voltage(struct snd_soc_component *component,
 					    int req_volt, int micb_num)
 {
@@ -2566,7 +2524,7 @@ static int wcd934x_mbhc_micb_adjust_volt
 	cur_vout_ctl = snd_soc_component_read_field(component, micb_reg,
 						    WCD934X_MICB_VAL_MASK);
 
-	req_vout_ctl = wcd934x_get_micb_vout_ctl_val(req_volt);
+	req_vout_ctl = wcd_get_micb_vout_ctl_val(component->dev, req_volt);
 	if (req_vout_ctl < 0) {
 		ret = -EINVAL;
 		goto exit;
@@ -2614,10 +2572,10 @@ static int wcd934x_mbhc_micb_ctrl_thresh
 	 * voltage needed to detect threshold microphone, then do
 	 * not change the micbias, just return.
 	 */
-	if (wcd934x->micb2_mv >= WCD_MBHC_THR_HS_MICB_MV)
+	if (wcd934x->common.micb_mv[1] >= WCD_MBHC_THR_HS_MICB_MV)
 		return 0;
 
-	micb_mv = req_en ? WCD_MBHC_THR_HS_MICB_MV : wcd934x->micb2_mv;
+	micb_mv = req_en ? WCD_MBHC_THR_HS_MICB_MV : wcd934x->common.micb_mv[1];
 
 	rc = wcd934x_mbhc_micb_adjust_voltage(component, micb_mv, MIC_BIAS_2);
 
@@ -3040,7 +2998,7 @@ static void wcd934x_mbhc_deinit(struct s
 static int wcd934x_comp_probe(struct snd_soc_component *component)
 {
 	struct wcd934x_codec *wcd = dev_get_drvdata(component->dev);
-	int i;
+	int i, ret;
 
 	snd_soc_component_init_regmap(component, wcd->regmap);
 	wcd->component = component;
@@ -3058,7 +3016,12 @@ static int wcd934x_comp_probe(struct snd
 	for (i = 0; i < NUM_CODEC_DAIS; i++)
 		INIT_LIST_HEAD(&wcd->dai[i].slim_ch_list);
 
-	wcd934x_init_dmic(component);
+
+	ret = wcd934x_init_dmic(component);
+	if (ret) {
+		dev_err(component->dev, "Failed to Initialize micbias\n");
+		return ret;
+	}
 
 	if (wcd934x_mbhc_init(component))
 		dev_err(component->dev, "Failed to Initialize MBHC\n");
@@ -5864,14 +5827,13 @@ static int wcd934x_codec_parse_data(stru
 	cfg->anc_micbias = MIC_BIAS_2;
 	cfg->v_hs_max = WCD_MBHC_HS_V_MAX;
 	cfg->num_btn = WCD934X_MBHC_MAX_BUTTONS;
-	cfg->micb_mv = wcd->micb2_mv;
+	cfg->micb_mv = wcd->common.micb_mv[1];
 	cfg->linein_th = 5000;
 	cfg->hs_thr = 1700;
 	cfg->hph_thr = 50;
 
 	wcd_dt_parse_mbhc_data(dev, cfg);
 
-
 	return 0;
 }
 
@@ -5892,6 +5854,8 @@ static int wcd934x_codec_probe(struct pl
 	wcd->sdev = to_slim_device(data->dev);
 	mutex_init(&wcd->sysclk_mutex);
 	mutex_init(&wcd->micb_lock);
+	wcd->common.dev = dev->parent;
+	wcd->common.max_bias = 4;
 
 	ret = wcd934x_codec_parse_data(wcd);
 	if (ret)
diff -Nrup linux-6.16.7/sound/soc/codecs/wcd937x.c linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd937x.c
--- linux-6.16.7/sound/soc/codecs/wcd937x.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd937x.c	2025-09-11 09:47:42.000000000 -0600
@@ -21,6 +21,7 @@
 #include <sound/tlv.h>
 
 #include "wcd-clsh-v2.h"
+#include "wcd-common.h"
 #include "wcd-mbhc-v2.h"
 #include "wcd937x.h"
 
@@ -87,6 +88,7 @@ struct wcd937x_priv {
 	struct wcd_mbhc_config mbhc_cfg;
 	struct wcd_mbhc_intr intr_ids;
 	struct wcd_clsh_ctrl *clsh_info;
+	struct wcd_common common;
 	struct irq_domain *virq;
 	struct regmap_irq_chip *wcd_regmap_irq_chip;
 	struct regmap_irq_chip_data *irq_chip;
@@ -97,9 +99,6 @@ struct wcd937x_priv {
 	s32 pullup_ref[WCD937X_MAX_MICBIAS];
 	u32 hph_mode;
 	int ear_rx_path;
-	u32 micb1_mv;
-	u32 micb2_mv;
-	u32 micb3_mv;
 	int hphr_pdm_wd_int;
 	int hphl_pdm_wd_int;
 	int aux_pdm_wd_int;
@@ -872,15 +871,6 @@ static int wcd937x_enable_rx3(struct snd
 	return 0;
 }
 
-static int wcd937x_get_micb_vout_ctl_val(u32 micb_mv)
-{
-	if (micb_mv < 1000 || micb_mv > 2850) {
-		pr_err("Unsupported micbias voltage (%u mV)\n", micb_mv);
-		return -EINVAL;
-	}
-
-	return (micb_mv - 1000) / 50;
-}
 
 static int wcd937x_tx_swr_ctrl(struct snd_soc_dapm_widget *w,
 			       struct snd_kcontrol *kcontrol, int event)
@@ -1193,7 +1183,7 @@ static int wcd937x_codec_enable_micbias_
 static int wcd937x_connect_port(struct wcd937x_sdw_priv *wcd, u8 port_idx, u8 ch_id, bool enable)
 {
 	struct sdw_port_config *port_config = &wcd->port_config[port_idx - 1];
-	const struct wcd937x_sdw_ch_info *ch_info = &wcd->ch_info[ch_id];
+	const struct wcd_sdw_ch_info *ch_info = &wcd->ch_info[ch_id];
 	u8 port_num = ch_info->port_num;
 	u8 ch_mask = ch_info->ch_mask;
 	u8 mstr_port_num, mstr_ch_mask;
@@ -1481,7 +1471,7 @@ static int wcd937x_mbhc_micb_adjust_volt
 	cur_vout_ctl = snd_soc_component_read_field(component, micb_reg,
 						    WCD937X_MICB_VOUT_MASK);
 
-	req_vout_ctl = wcd937x_get_micb_vout_ctl_val(req_volt);
+	req_vout_ctl = wcd_get_micb_vout_ctl_val(component->dev, req_volt);
 	if (req_vout_ctl < 0) {
 		ret = -EINVAL;
 		goto exit;
@@ -1529,10 +1519,10 @@ static int wcd937x_mbhc_micb_ctrl_thresh
 	 * voltage needed to detect threshold microphone, then do
 	 * not change the micbias, just return.
 	 */
-	if (wcd937x->micb2_mv >= WCD_MBHC_THR_HS_MICB_MV)
+	if (wcd937x->common.micb_mv[2] >= WCD_MBHC_THR_HS_MICB_MV)
 		return 0;
 
-	micb_mv = req_en ? WCD_MBHC_THR_HS_MICB_MV : wcd937x->micb2_mv;
+	micb_mv = req_en ? WCD_MBHC_THR_HS_MICB_MV : wcd937x->common.micb_mv[2];
 
 	return wcd937x_mbhc_micb_adjust_voltage(component, micb_mv, MIC_BIAS_2);
 }
@@ -2046,9 +2036,9 @@ static const struct snd_kcontrol_new wcd
 	SOC_ENUM_EXT("RX HPH Mode", rx_hph_mode_mux_enum,
 		     wcd937x_rx_hph_mode_get, wcd937x_rx_hph_mode_put),
 
-	SOC_SINGLE_EXT("HPHL_COMP Switch", SND_SOC_NOPM, 0, 1, 0,
+	SOC_SINGLE_EXT("HPHL_COMP Switch", WCD937X_COMP_L, 0, 1, 0,
 		       wcd937x_get_compander, wcd937x_set_compander),
-	SOC_SINGLE_EXT("HPHR_COMP Switch", SND_SOC_NOPM, 1, 1, 0,
+	SOC_SINGLE_EXT("HPHR_COMP Switch", WCD937X_COMP_R, 1, 1, 0,
 		       wcd937x_get_compander, wcd937x_set_compander),
 
 	SOC_SINGLE_TLV("HPHL Volume", WCD937X_HPH_L_EN, 0, 20, 1, line_gain),
@@ -2436,22 +2426,14 @@ static const struct snd_soc_dapm_route w
 	{ "DMIC6_MIXER", "Switch", "DMIC6" },
 };
 
-static int wcd937x_set_micbias_data(struct wcd937x_priv *wcd937x)
+static void wcd937x_set_micbias_data(struct device *dev, struct wcd937x_priv *wcd937x)
 {
-	int vout_ctl[3];
-
-	/* Set micbias voltage */
-	vout_ctl[0] = wcd937x_get_micb_vout_ctl_val(wcd937x->micb1_mv);
-	vout_ctl[1] = wcd937x_get_micb_vout_ctl_val(wcd937x->micb2_mv);
-	vout_ctl[2] = wcd937x_get_micb_vout_ctl_val(wcd937x->micb3_mv);
-	if ((vout_ctl[0] | vout_ctl[1] | vout_ctl[2]) < 0)
-		return -EINVAL;
-
-	regmap_update_bits(wcd937x->regmap, WCD937X_ANA_MICB1, WCD937X_ANA_MICB_VOUT, vout_ctl[0]);
-	regmap_update_bits(wcd937x->regmap, WCD937X_ANA_MICB2, WCD937X_ANA_MICB_VOUT, vout_ctl[1]);
-	regmap_update_bits(wcd937x->regmap, WCD937X_ANA_MICB3, WCD937X_ANA_MICB_VOUT, vout_ctl[2]);
-
-	return 0;
+	regmap_update_bits(wcd937x->regmap, WCD937X_ANA_MICB1, WCD937X_ANA_MICB_VOUT,
+			wcd937x->common.micb_vout[0]);
+	regmap_update_bits(wcd937x->regmap, WCD937X_ANA_MICB2, WCD937X_ANA_MICB_VOUT,
+			wcd937x->common.micb_vout[1]);
+	regmap_update_bits(wcd937x->regmap, WCD937X_ANA_MICB3, WCD937X_ANA_MICB_VOUT,
+			wcd937x->common.micb_vout[2]);
 }
 
 static irqreturn_t wcd937x_wd_handle_irq(int irq, void *data)
@@ -2630,31 +2612,6 @@ static const struct snd_soc_component_dr
 	.endianness = 1,
 };
 
-static void wcd937x_dt_parse_micbias_info(struct device *dev, struct wcd937x_priv *wcd)
-{
-	struct device_node *np = dev->of_node;
-	u32 prop_val = 0;
-	int ret = 0;
-
-	ret = of_property_read_u32(np, "qcom,micbias1-microvolt", &prop_val);
-	if (!ret)
-		wcd->micb1_mv = prop_val / 1000;
-	else
-		dev_warn(dev, "Micbias1 DT property not found\n");
-
-	ret = of_property_read_u32(np, "qcom,micbias2-microvolt", &prop_val);
-	if (!ret)
-		wcd->micb2_mv = prop_val / 1000;
-	else
-		dev_warn(dev, "Micbias2 DT property not found\n");
-
-	ret = of_property_read_u32(np, "qcom,micbias3-microvolt", &prop_val);
-	if (!ret)
-		wcd->micb3_mv = prop_val / 1000;
-	else
-		dev_warn(dev, "Micbias3 DT property not found\n");
-}
-
 static bool wcd937x_swap_gnd_mic(struct snd_soc_component *component)
 {
 	int value;
@@ -2788,7 +2745,7 @@ static int wcd937x_bind(struct device *d
 		return ret;
 	}
 
-	wcd937x->rxdev = wcd937x_sdw_device_get(wcd937x->rxnode);
+	wcd937x->rxdev = of_sdw_find_device_by_node(wcd937x->rxnode);
 	if (!wcd937x->rxdev) {
 		dev_err(dev, "could not find slave with matching of node\n");
 		return -EINVAL;
@@ -2797,7 +2754,7 @@ static int wcd937x_bind(struct device *d
 	wcd937x->sdw_priv[AIF1_PB] = dev_get_drvdata(wcd937x->rxdev);
 	wcd937x->sdw_priv[AIF1_PB]->wcd937x = wcd937x;
 
-	wcd937x->txdev = wcd937x_sdw_device_get(wcd937x->txnode);
+	wcd937x->txdev = of_sdw_find_device_by_node(wcd937x->txnode);
 	if (!wcd937x->txdev) {
 		dev_err(dev, "could not find txslave with matching of node\n");
 		return -EINVAL;
@@ -2833,7 +2790,7 @@ static int wcd937x_bind(struct device *d
 		return -EINVAL;
 	}
 
-	wcd937x->regmap = dev_get_regmap(&wcd937x->tx_sdw_dev->dev, NULL);
+	wcd937x->regmap = wcd937x->sdw_priv[AIF1_CAP]->regmap;
 	if (!wcd937x->regmap) {
 		dev_err(dev, "could not get TX device regmap\n");
 		return -EINVAL;
@@ -2848,11 +2805,7 @@ static int wcd937x_bind(struct device *d
 	wcd937x->sdw_priv[AIF1_PB]->slave_irq = wcd937x->virq;
 	wcd937x->sdw_priv[AIF1_CAP]->slave_irq = wcd937x->virq;
 
-	ret = wcd937x_set_micbias_data(wcd937x);
-	if (ret < 0) {
-		dev_err(dev, "Bad micbias pdata\n");
-		return ret;
-	}
+	wcd937x_set_micbias_data(dev, wcd937x);
 
 	ret = snd_soc_register_component(dev, &soc_codec_dev_wcd937x,
 					 wcd937x_dais, ARRAY_SIZE(wcd937x_dais));
@@ -2920,6 +2873,8 @@ static int wcd937x_probe(struct platform
 
 	dev_set_drvdata(dev, wcd937x);
 	mutex_init(&wcd937x->micb_lock);
+	wcd937x->common.dev = dev;
+	wcd937x->common.max_bias = 3;
 
 	wcd937x->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_LOW);
 	if (IS_ERR(wcd937x->reset_gpio))
@@ -2947,13 +2902,15 @@ static int wcd937x_probe(struct platform
 	if (ret)
 		return dev_err_probe(dev, ret, "Failed to enable supplies\n");
 
-	wcd937x_dt_parse_micbias_info(dev, wcd937x);
+	ret = wcd_dt_parse_micbias_info(&wcd937x->common);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get micbias\n");
 
 	cfg->mbhc_micbias = MIC_BIAS_2;
 	cfg->anc_micbias = MIC_BIAS_2;
 	cfg->v_hs_max = WCD_MBHC_HS_V_MAX;
 	cfg->num_btn = WCD937X_MBHC_MAX_BUTTONS;
-	cfg->micb_mv = wcd937x->micb2_mv;
+	cfg->micb_mv = wcd937x->common.micb_mv[2];
 	cfg->linein_th = 5000;
 	cfg->hs_thr = 1700;
 	cfg->hph_thr = 50;
diff -Nrup linux-6.16.7/sound/soc/codecs/wcd937x.h linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd937x.h
--- linux-6.16.7/sound/soc/codecs/wcd937x.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd937x.h	2025-09-11 09:47:42.000000000 -0600
@@ -7,6 +7,7 @@
 
 #include <linux/soundwire/sdw.h>
 #include <linux/soundwire/sdw_type.h>
+#include "wcd-common.h"
 
 #define WCD937X_BASE_ADDRESS			0x3000
 #define WCD937X_ANA_BIAS			0x3001
@@ -508,26 +509,13 @@ enum wcd937x_rx_sdw_ports {
 	WCD937X_MAX_SWR_PORTS = WCD937X_DSD_PORT,
 };
 
-struct wcd937x_sdw_ch_info {
-	int port_num;
-	unsigned int ch_mask;
-	unsigned int master_ch_mask;
-};
-
-#define WCD_SDW_CH(id, pn, cmask)	\
-	[id] = {			\
-		.port_num = pn,		\
-		.ch_mask = cmask,	\
-		.master_ch_mask = cmask,	\
-	}
-
 struct wcd937x_priv;
 struct wcd937x_sdw_priv {
 	struct sdw_slave *sdev;
 	struct sdw_stream_config sconfig;
 	struct sdw_stream_runtime *sruntime;
 	struct sdw_port_config port_config[WCD937X_MAX_SWR_PORTS];
-	struct wcd937x_sdw_ch_info *ch_info;
+	struct wcd_sdw_ch_info *ch_info;
 	bool port_enable[WCD937X_MAX_SWR_CH_IDS];
 	unsigned int master_channel_map[SDW_MAX_PORTS];
 	int active_ports;
@@ -550,24 +538,22 @@ int wcd937x_sdw_hw_params(struct wcd937x
 			  struct snd_pcm_hw_params *params,
 			  struct snd_soc_dai *dai);
 
-struct device *wcd937x_sdw_device_get(struct device_node *np);
-
 #else
-int wcd937x_sdw_free(struct wcd937x_sdw_priv *wcd,
+static inline int wcd937x_sdw_free(struct wcd937x_sdw_priv *wcd,
 		     struct snd_pcm_substream *substream,
 		     struct snd_soc_dai *dai)
 {
 	return -EOPNOTSUPP;
 }
 
-int wcd937x_sdw_set_sdw_stream(struct wcd937x_sdw_priv *wcd,
+static inline int wcd937x_sdw_set_sdw_stream(struct wcd937x_sdw_priv *wcd,
 			       struct snd_soc_dai *dai,
 			       void *stream, int direction)
 {
 	return -EOPNOTSUPP;
 }
 
-int wcd937x_sdw_hw_params(struct wcd937x_sdw_priv *wcd,
+static inline int wcd937x_sdw_hw_params(struct wcd937x_sdw_priv *wcd,
 			  struct snd_pcm_substream *substream,
 			  struct snd_pcm_hw_params *params,
 			  struct snd_soc_dai *dai)
diff -Nrup linux-6.16.7/sound/soc/codecs/wcd937x-sdw.c linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd937x-sdw.c
--- linux-6.16.7/sound/soc/codecs/wcd937x-sdw.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd937x-sdw.c	2025-09-11 09:47:42.000000000 -0600
@@ -19,7 +19,7 @@
 #include <sound/soc.h>
 #include "wcd937x.h"
 
-static struct wcd937x_sdw_ch_info wcd937x_sdw_rx_ch_info[] = {
+static struct wcd_sdw_ch_info wcd937x_sdw_rx_ch_info[] = {
 	WCD_SDW_CH(WCD937X_HPH_L, WCD937X_HPH_PORT, BIT(0)),
 	WCD_SDW_CH(WCD937X_HPH_R, WCD937X_HPH_PORT, BIT(1)),
 	WCD_SDW_CH(WCD937X_CLSH, WCD937X_CLSH_PORT, BIT(0)),
@@ -30,7 +30,7 @@ static struct wcd937x_sdw_ch_info wcd937
 	WCD_SDW_CH(WCD937X_DSD_R, WCD937X_DSD_PORT, BIT(1)),
 };
 
-static struct wcd937x_sdw_ch_info wcd937x_sdw_tx_ch_info[] = {
+static struct wcd_sdw_ch_info wcd937x_sdw_tx_ch_info[] = {
 	WCD_SDW_CH(WCD937X_ADC1, WCD937X_ADC_1_PORT, BIT(0)),
 	WCD_SDW_CH(WCD937X_ADC2, WCD937X_ADC_2_3_PORT, BIT(0)),
 	WCD_SDW_CH(WCD937X_ADC3, WCD937X_ADC_2_3_PORT, BIT(0)),
@@ -78,12 +78,6 @@ static struct sdw_dpn_prop wcd937x_dpn_p
 	}
 };
 
-struct device *wcd937x_sdw_device_get(struct device_node *np)
-{
-	return bus_find_device_by_of_node(&sdw_bus_type, np);
-}
-EXPORT_SYMBOL_GPL(wcd937x_sdw_device_get);
-
 int wcd937x_sdw_hw_params(struct wcd937x_sdw_priv *wcd,
 			  struct snd_pcm_substream *substream,
 			  struct snd_pcm_hw_params *params,
@@ -118,19 +112,6 @@ int wcd937x_sdw_hw_params(struct wcd937x
 }
 EXPORT_SYMBOL_GPL(wcd937x_sdw_hw_params);
 
-static int wcd9370_update_status(struct sdw_slave *slave, enum sdw_slave_status status)
-{
-	struct wcd937x_sdw_priv *wcd = dev_get_drvdata(&slave->dev);
-
-	if (wcd->regmap && status == SDW_SLAVE_ATTACHED) {
-		/* Write out any cached changes that happened between probe and attach */
-		regcache_cache_only(wcd->regmap, false);
-		return regcache_sync(wcd->regmap);
-	}
-
-	return 0;
-}
-
 /*
  * Handle Soundwire out-of-band interrupt event by triggering
  * the first irq of the slave_irq irq domain, which then will
@@ -141,18 +122,9 @@ static int wcd9370_interrupt_callback(st
 				      struct sdw_slave_intr_status *status)
 {
 	struct wcd937x_sdw_priv *wcd = dev_get_drvdata(&slave->dev);
-	struct irq_domain *slave_irq = wcd->slave_irq;
-	u32 sts1, sts2, sts3;
-
-	do {
-		handle_nested_irq(irq_find_mapping(slave_irq, 0));
-		regmap_read(wcd->regmap, WCD937X_DIGITAL_INTR_STATUS_0, &sts1);
-		regmap_read(wcd->regmap, WCD937X_DIGITAL_INTR_STATUS_1, &sts2);
-		regmap_read(wcd->regmap, WCD937X_DIGITAL_INTR_STATUS_2, &sts3);
 
-	} while (sts1 || sts2 || sts3);
-
-	return IRQ_HANDLED;
+	return wcd_interrupt_callback(slave, wcd->slave_irq, WCD937X_DIGITAL_INTR_STATUS_0,
+				WCD937X_DIGITAL_INTR_STATUS_1, WCD937X_DIGITAL_INTR_STATUS_2);
 }
 
 static const struct reg_default wcd937x_defaults[] = {
@@ -985,35 +957,10 @@ static const struct regmap_config wcd937
 };
 
 static const struct sdw_slave_ops wcd9370_slave_ops = {
-	.update_status = wcd9370_update_status,
+	.update_status = wcd_update_status,
 	.interrupt_callback = wcd9370_interrupt_callback,
 };
 
-static int wcd937x_sdw_component_bind(struct device *dev,
-				      struct device *master, void *data)
-{
-	pm_runtime_set_autosuspend_delay(dev, 3000);
-	pm_runtime_use_autosuspend(dev);
-	pm_runtime_mark_last_busy(dev);
-	pm_runtime_set_active(dev);
-	pm_runtime_enable(dev);
-
-	return 0;
-}
-
-static void wcd937x_sdw_component_unbind(struct device *dev,
-					 struct device *master, void *data)
-{
-	pm_runtime_disable(dev);
-	pm_runtime_set_suspended(dev);
-	pm_runtime_dont_use_autosuspend(dev);
-}
-
-static const struct component_ops wcd937x_sdw_component_ops = {
-	.bind = wcd937x_sdw_component_bind,
-	.unbind = wcd937x_sdw_component_unbind,
-};
-
 static int wcd9370_probe(struct sdw_slave *pdev,
 			 const struct sdw_device_id *id)
 {
@@ -1099,7 +1046,7 @@ static int wcd9370_probe(struct sdw_slav
 	}
 
 
-	ret = component_add(dev, &wcd937x_sdw_component_ops);
+	ret = component_add(dev, &wcd_sdw_component_ops);
 	if (ret)
 		return ret;
 
@@ -1113,7 +1060,7 @@ static int wcd9370_remove(struct sdw_sla
 {
 	struct device *dev = &pdev->dev;
 
-	component_del(dev, &wcd937x_sdw_component_ops);
+	component_del(dev, &wcd_sdw_component_ops);
 
 	return 0;
 }
diff -Nrup linux-6.16.7/sound/soc/codecs/wcd938x.c linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd938x.c
--- linux-6.16.7/sound/soc/codecs/wcd938x.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd938x.c	2025-09-11 09:47:42.000000000 -0600
@@ -22,6 +22,7 @@
 #include <linux/regulator/consumer.h>
 
 #include "wcd-clsh-v2.h"
+#include "wcd-common.h"
 #include "wcd-mbhc-v2.h"
 #include "wcd938x.h"
 
@@ -158,6 +159,7 @@ struct wcd938x_priv {
 	struct wcd_mbhc_config mbhc_cfg;
 	struct wcd_mbhc_intr intr_ids;
 	struct wcd_clsh_ctrl *clsh_info;
+	struct wcd_common common;
 	struct irq_domain *virq;
 	struct regmap_irq_chip *wcd_regmap_irq_chip;
 	struct regmap_irq_chip_data *irq_chip;
@@ -175,10 +177,6 @@ struct wcd938x_priv {
 	struct gpio_desc *us_euro_gpio;
 	struct mux_control *us_euro_mux;
 	unsigned int mux_state;
-	u32 micb1_mv;
-	u32 micb2_mv;
-	u32 micb3_mv;
-	u32 micb4_mv;
 	int hphr_pdm_wd_int;
 	int hphl_pdm_wd_int;
 	int aux_pdm_wd_int;
@@ -398,7 +396,7 @@ static int wcd938x_io_init(struct wcd938
 
 }
 
-static int wcd938x_sdw_connect_port(const struct wcd938x_sdw_ch_info *ch_info,
+static int wcd938x_sdw_connect_port(const struct wcd_sdw_ch_info *ch_info,
 				    struct sdw_port_config *port_config,
 				    u8 enable)
 {
@@ -1096,8 +1094,7 @@ static int wcd938x_tx_swr_ctrl(struct sn
 	int bank;
 	int rate;
 
-	bank = (wcd938x_swr_get_current_bank(wcd938x->sdw_priv[AIF1_CAP]->sdev)) ? 0 : 1;
-	bank = bank ? 0 : 1;
+	bank = sdw_slave_get_current_bank(wcd938x->sdw_priv[AIF1_CAP]->sdev);
 
 	switch (event) {
 	case SND_SOC_DAPM_PRE_PMU:
@@ -1977,15 +1974,6 @@ static void wcd938x_mbhc_micb_ramp_contr
 	}
 }
 
-static int wcd938x_get_micb_vout_ctl_val(u32 micb_mv)
-{
-	/* min micbias voltage is 1V and maximum is 2.85V */
-	if (micb_mv < 1000 || micb_mv > 2850)
-		return -EINVAL;
-
-	return (micb_mv - 1000) / 50;
-}
-
 static int wcd938x_mbhc_micb_adjust_voltage(struct snd_soc_component *component,
 					    int req_volt, int micb_num)
 {
@@ -2022,7 +2010,7 @@ static int wcd938x_mbhc_micb_adjust_volt
 	cur_vout_ctl = snd_soc_component_read_field(component, micb_reg,
 						    WCD938X_MICB_VOUT_MASK);
 
-	req_vout_ctl = wcd938x_get_micb_vout_ctl_val(req_volt);
+	req_vout_ctl = wcd_get_micb_vout_ctl_val(component->dev, req_volt);
 	if (req_vout_ctl < 0) {
 		ret = -EINVAL;
 		goto exit;
@@ -2070,10 +2058,10 @@ static int wcd938x_mbhc_micb_ctrl_thresh
 	 * voltage needed to detect threshold microphone, then do
 	 * not change the micbias, just return.
 	 */
-	if (wcd938x->micb2_mv >= WCD_MBHC_THR_HS_MICB_MV)
+	if (wcd938x->common.micb_mv[2] >= WCD_MBHC_THR_HS_MICB_MV)
 		return 0;
 
-	micb_mv = req_en ? WCD_MBHC_THR_HS_MICB_MV : wcd938x->micb2_mv;
+	micb_mv = req_en ? WCD_MBHC_THR_HS_MICB_MV : wcd938x->common.micb_mv[2];
 
 	return wcd938x_mbhc_micb_adjust_voltage(component, micb_mv, MIC_BIAS_2);
 }
@@ -2978,28 +2966,16 @@ static const struct snd_soc_dapm_route w
 	{"EAR", NULL, "EAR PGA"},
 };
 
-static int wcd938x_set_micbias_data(struct wcd938x_priv *wcd938x)
+static void wcd938x_set_micbias_data(struct device *dev, struct wcd938x_priv *wcd938x)
 {
-	int vout_ctl_1, vout_ctl_2, vout_ctl_3, vout_ctl_4;
-
-	/* set micbias voltage */
-	vout_ctl_1 = wcd938x_get_micb_vout_ctl_val(wcd938x->micb1_mv);
-	vout_ctl_2 = wcd938x_get_micb_vout_ctl_val(wcd938x->micb2_mv);
-	vout_ctl_3 = wcd938x_get_micb_vout_ctl_val(wcd938x->micb3_mv);
-	vout_ctl_4 = wcd938x_get_micb_vout_ctl_val(wcd938x->micb4_mv);
-	if (vout_ctl_1 < 0 || vout_ctl_2 < 0 || vout_ctl_3 < 0 || vout_ctl_4 < 0)
-		return -EINVAL;
-
 	regmap_update_bits(wcd938x->regmap, WCD938X_ANA_MICB1,
-			   WCD938X_MICB_VOUT_MASK, vout_ctl_1);
+			   WCD938X_MICB_VOUT_MASK, wcd938x->common.micb_vout[0]);
 	regmap_update_bits(wcd938x->regmap, WCD938X_ANA_MICB2,
-			   WCD938X_MICB_VOUT_MASK, vout_ctl_2);
+			   WCD938X_MICB_VOUT_MASK, wcd938x->common.micb_vout[1]);
 	regmap_update_bits(wcd938x->regmap, WCD938X_ANA_MICB3,
-			   WCD938X_MICB_VOUT_MASK, vout_ctl_3);
+			   WCD938X_MICB_VOUT_MASK, wcd938x->common.micb_vout[2]);
 	regmap_update_bits(wcd938x->regmap, WCD938X_ANA_MICB4,
-			   WCD938X_MICB_VOUT_MASK, vout_ctl_4);
-
-	return 0;
+			   WCD938X_MICB_VOUT_MASK, wcd938x->common.micb_vout[3]);
 }
 
 static irqreturn_t wcd938x_wd_handle_irq(int irq, void *data)
@@ -3202,37 +3178,6 @@ static const struct snd_soc_component_dr
 	.endianness = 1,
 };
 
-static void wcd938x_dt_parse_micbias_info(struct device *dev, struct wcd938x_priv *wcd)
-{
-	struct device_node *np = dev->of_node;
-	u32 prop_val = 0;
-	int rc = 0;
-
-	rc = of_property_read_u32(np, "qcom,micbias1-microvolt",  &prop_val);
-	if (!rc)
-		wcd->micb1_mv = prop_val/1000;
-	else
-		dev_info(dev, "%s: Micbias1 DT property not found\n", __func__);
-
-	rc = of_property_read_u32(np, "qcom,micbias2-microvolt",  &prop_val);
-	if (!rc)
-		wcd->micb2_mv = prop_val/1000;
-	else
-		dev_info(dev, "%s: Micbias2 DT property not found\n", __func__);
-
-	rc = of_property_read_u32(np, "qcom,micbias3-microvolt", &prop_val);
-	if (!rc)
-		wcd->micb3_mv = prop_val/1000;
-	else
-		dev_info(dev, "%s: Micbias3 DT property not found\n", __func__);
-
-	rc = of_property_read_u32(np, "qcom,micbias4-microvolt",  &prop_val);
-	if (!rc)
-		wcd->micb4_mv = prop_val/1000;
-	else
-		dev_info(dev, "%s: Micbias4 DT property not found\n", __func__);
-}
-
 static bool wcd938x_swap_gnd_mic(struct snd_soc_component *component)
 {
 	struct wcd938x_priv *wcd938x = snd_soc_component_get_drvdata(component);
@@ -3307,13 +3252,15 @@ static int wcd938x_populate_dt_data(stru
 		return dev_err_probe(dev, ret, "Failed to enable supplies\n");
 	}
 
-	wcd938x_dt_parse_micbias_info(dev, wcd938x);
+	ret = wcd_dt_parse_micbias_info(&wcd938x->common);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get and enable supplies\n");
 
 	cfg->mbhc_micbias = MIC_BIAS_2;
 	cfg->anc_micbias = MIC_BIAS_2;
 	cfg->v_hs_max = WCD_MBHC_HS_V_MAX;
 	cfg->num_btn = WCD938X_MBHC_MAX_BUTTONS;
-	cfg->micb_mv = wcd938x->micb2_mv;
+	cfg->micb_mv = wcd938x->common.micb_mv[2];
 	cfg->linein_th = 5000;
 	cfg->hs_thr = 1700;
 	cfg->hph_thr = 50;
@@ -3411,7 +3358,7 @@ static int wcd938x_bind(struct device *d
 		return ret;
 	}
 
-	wcd938x->rxdev = wcd938x_sdw_device_get(wcd938x->rxnode);
+	wcd938x->rxdev = of_sdw_find_device_by_node(wcd938x->rxnode);
 	if (!wcd938x->rxdev) {
 		dev_err(dev, "could not find slave with matching of node\n");
 		ret = -EINVAL;
@@ -3420,7 +3367,7 @@ static int wcd938x_bind(struct device *d
 	wcd938x->sdw_priv[AIF1_PB] = dev_get_drvdata(wcd938x->rxdev);
 	wcd938x->sdw_priv[AIF1_PB]->wcd938x = wcd938x;
 
-	wcd938x->txdev = wcd938x_sdw_device_get(wcd938x->txnode);
+	wcd938x->txdev = of_sdw_find_device_by_node(wcd938x->txnode);
 	if (!wcd938x->txdev) {
 		dev_err(dev, "could not find txslave with matching of node\n");
 		ret = -EINVAL;
@@ -3453,7 +3400,7 @@ static int wcd938x_bind(struct device *d
 		goto err_remove_tx_link;
 	}
 
-	wcd938x->regmap = dev_get_regmap(&wcd938x->tx_sdw_dev->dev, NULL);
+	wcd938x->regmap = wcd938x->sdw_priv[AIF1_CAP]->regmap;
 	if (!wcd938x->regmap) {
 		dev_err(dev, "could not get TX device regmap\n");
 		ret = -EINVAL;
@@ -3469,11 +3416,7 @@ static int wcd938x_bind(struct device *d
 	wcd938x->sdw_priv[AIF1_PB]->slave_irq = wcd938x->virq;
 	wcd938x->sdw_priv[AIF1_CAP]->slave_irq = wcd938x->virq;
 
-	ret = wcd938x_set_micbias_data(wcd938x);
-	if (ret < 0) {
-		dev_err(dev, "%s: bad micbias pdata\n", __func__);
-		goto err_remove_rx_link;
-	}
+	wcd938x_set_micbias_data(dev, wcd938x);
 
 	ret = snd_soc_register_component(dev, &soc_codec_dev_wcd938x,
 					 wcd938x_dais, ARRAY_SIZE(wcd938x_dais));
@@ -3562,6 +3505,8 @@ static int wcd938x_probe(struct platform
 
 	dev_set_drvdata(dev, wcd938x);
 	mutex_init(&wcd938x->micb_lock);
+	wcd938x->common.dev = dev;
+	wcd938x->common.max_bias = 4;
 
 	ret = wcd938x_populate_dt_data(wcd938x, dev);
 	if (ret)
diff -Nrup linux-6.16.7/sound/soc/codecs/wcd938x.h linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd938x.h
--- linux-6.16.7/sound/soc/codecs/wcd938x.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd938x.h	2025-09-11 09:47:42.000000000 -0600
@@ -587,17 +587,6 @@
 
 #define WCD938X_MAX_SWR_CH_IDS	15
 
-struct wcd938x_sdw_ch_info {
-	int port_num;
-	unsigned int ch_mask;
-};
-
-#define WCD_SDW_CH(id, pn, cmask)	\
-	[id] = {			\
-		.port_num = pn,		\
-		.ch_mask = cmask,	\
-	}
-
 enum wcd938x_tx_sdw_ports {
 	WCD938X_ADC_1_2_PORT = 1,
 	WCD938X_ADC_3_4_PORT,
@@ -649,7 +638,7 @@ struct wcd938x_sdw_priv {
 	struct sdw_stream_config sconfig;
 	struct sdw_stream_runtime *sruntime;
 	struct sdw_port_config port_config[WCD938X_MAX_SWR_PORTS];
-	const struct wcd938x_sdw_ch_info *ch_info;
+	const struct wcd_sdw_ch_info *ch_info;
 	bool port_enable[WCD938X_MAX_SWR_CH_IDS];
 	int active_ports;
 	bool is_tx;
@@ -669,10 +658,6 @@ int wcd938x_sdw_hw_params(struct wcd938x
 			  struct snd_pcm_substream *substream,
 			  struct snd_pcm_hw_params *params,
 			  struct snd_soc_dai *dai);
-
-struct device *wcd938x_sdw_device_get(struct device_node *np);
-int wcd938x_swr_get_current_bank(struct sdw_slave *sdev);
-
 #else
 
 static inline int wcd938x_sdw_free(struct wcd938x_sdw_priv *wcd,
@@ -697,14 +682,5 @@ static inline int wcd938x_sdw_hw_params(
 	return -EOPNOTSUPP;
 }
 
-static inline struct device *wcd938x_sdw_device_get(struct device_node *np)
-{
-	return NULL;
-}
-
-static inline int wcd938x_swr_get_current_bank(struct sdw_slave *sdev)
-{
-	return 0;
-}
 #endif /* CONFIG_SND_SOC_WCD938X_SDW */
 #endif /* __WCD938X_H__ */
diff -Nrup linux-6.16.7/sound/soc/codecs/wcd938x-sdw.c linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd938x-sdw.c
--- linux-6.16.7/sound/soc/codecs/wcd938x-sdw.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd938x-sdw.c	2025-09-11 09:47:42.000000000 -0600
@@ -18,10 +18,9 @@
 #include <sound/soc.h>
 #include <sound/soc-dapm.h>
 #include "wcd938x.h"
+#include "wcd-common.h"
 
-#define SWRS_SCP_HOST_CLK_DIV2_CTL_BANK(m) (0xE0 + 0x10 * (m))
-
-static const struct wcd938x_sdw_ch_info wcd938x_sdw_rx_ch_info[] = {
+static const struct wcd_sdw_ch_info wcd938x_sdw_rx_ch_info[] = {
 	WCD_SDW_CH(WCD938X_HPH_L, WCD938X_HPH_PORT, BIT(0)),
 	WCD_SDW_CH(WCD938X_HPH_R, WCD938X_HPH_PORT, BIT(1)),
 	WCD_SDW_CH(WCD938X_CLSH, WCD938X_CLSH_PORT, BIT(0)),
@@ -32,7 +31,7 @@ static const struct wcd938x_sdw_ch_info
 	WCD_SDW_CH(WCD938X_DSD_R, WCD938X_DSD_PORT, BIT(1)),
 };
 
-static const struct wcd938x_sdw_ch_info wcd938x_sdw_tx_ch_info[] = {
+static const struct wcd_sdw_ch_info wcd938x_sdw_tx_ch_info[] = {
 	WCD_SDW_CH(WCD938X_ADC1, WCD938X_ADC_1_2_PORT, BIT(0)),
 	WCD_SDW_CH(WCD938X_ADC2, WCD938X_ADC_1_2_PORT, BIT(1)),
 	WCD_SDW_CH(WCD938X_ADC3, WCD938X_ADC_3_4_PORT, BIT(0)),
@@ -82,23 +81,6 @@ static struct sdw_dpn_prop wcd938x_dpn_p
 	}
 };
 
-struct device *wcd938x_sdw_device_get(struct device_node *np)
-{
-	return bus_find_device_by_of_node(&sdw_bus_type, np);
-
-}
-EXPORT_SYMBOL_GPL(wcd938x_sdw_device_get);
-
-int wcd938x_swr_get_current_bank(struct sdw_slave *sdev)
-{
-	int bank;
-
-	bank  = sdw_read(sdev, SDW_SCP_CTRL);
-
-	return ((bank & 0x40) ? 1 : 0);
-}
-EXPORT_SYMBOL_GPL(wcd938x_swr_get_current_bank);
-
 int wcd938x_sdw_hw_params(struct wcd938x_sdw_priv *wcd,
 			  struct snd_pcm_substream *substream,
 			  struct snd_pcm_hw_params *params,
@@ -158,44 +140,13 @@ int wcd938x_sdw_set_sdw_stream(struct wc
 }
 EXPORT_SYMBOL_GPL(wcd938x_sdw_set_sdw_stream);
 
-static int wcd9380_update_status(struct sdw_slave *slave,
-				 enum sdw_slave_status status)
-{
-	struct wcd938x_sdw_priv *wcd = dev_get_drvdata(&slave->dev);
-
-	if (wcd->regmap && (status == SDW_SLAVE_ATTACHED)) {
-		/* Write out any cached changes that happened between probe and attach */
-		regcache_cache_only(wcd->regmap, false);
-		return regcache_sync(wcd->regmap);
-	}
-
-	return 0;
-}
-
-static int wcd9380_bus_config(struct sdw_slave *slave,
-			      struct sdw_bus_params *params)
-{
-	sdw_write(slave, SWRS_SCP_HOST_CLK_DIV2_CTL_BANK(params->next_bank),  0x01);
-
-	return 0;
-}
-
 static int wcd9380_interrupt_callback(struct sdw_slave *slave,
 				      struct sdw_slave_intr_status *status)
 {
 	struct wcd938x_sdw_priv *wcd = dev_get_drvdata(&slave->dev);
-	struct irq_domain *slave_irq = wcd->slave_irq;
-	u32 sts1, sts2, sts3;
-
-	do {
-		handle_nested_irq(irq_find_mapping(slave_irq, 0));
-		regmap_read(wcd->regmap, WCD938X_DIGITAL_INTR_STATUS_0, &sts1);
-		regmap_read(wcd->regmap, WCD938X_DIGITAL_INTR_STATUS_1, &sts2);
-		regmap_read(wcd->regmap, WCD938X_DIGITAL_INTR_STATUS_2, &sts3);
 
-	} while (sts1 || sts2 || sts3);
-
-	return IRQ_HANDLED;
+	return wcd_interrupt_callback(slave, wcd->slave_irq, WCD938X_DIGITAL_INTR_STATUS_0,
+				WCD938X_DIGITAL_INTR_STATUS_1, WCD938X_DIGITAL_INTR_STATUS_2);
 }
 
 static const struct reg_default wcd938x_defaults[] = {
@@ -1193,25 +1144,9 @@ static const struct regmap_config wcd938
 };
 
 static const struct sdw_slave_ops wcd9380_slave_ops = {
-	.update_status = wcd9380_update_status,
+	.update_status = wcd_update_status,
 	.interrupt_callback = wcd9380_interrupt_callback,
-	.bus_config = wcd9380_bus_config,
-};
-
-static int wcd938x_sdw_component_bind(struct device *dev,
-				      struct device *master, void *data)
-{
-	return 0;
-}
-
-static void wcd938x_sdw_component_unbind(struct device *dev,
-					 struct device *master, void *data)
-{
-}
-
-static const struct component_ops wcd938x_sdw_component_ops = {
-	.bind   = wcd938x_sdw_component_bind,
-	.unbind = wcd938x_sdw_component_unbind,
+	.bus_config = wcd_bus_config,
 };
 
 static int wcd9380_probe(struct sdw_slave *pdev,
@@ -1278,7 +1213,7 @@ static int wcd9380_probe(struct sdw_slav
 	pm_runtime_set_active(dev);
 	pm_runtime_enable(dev);
 
-	ret = component_add(dev, &wcd938x_sdw_component_ops);
+	ret = component_add(dev, &wcd_sdw_component_ops);
 	if (ret)
 		goto err_disable_rpm;
 
@@ -1296,7 +1231,7 @@ static int wcd9380_remove(struct sdw_sla
 {
 	struct device *dev = &pdev->dev;
 
-	component_del(dev, &wcd938x_sdw_component_ops);
+	component_del(dev, &wcd_sdw_component_ops);
 
 	pm_runtime_disable(dev);
 	pm_runtime_set_suspended(dev);
diff -Nrup linux-6.16.7/sound/soc/codecs/wcd939x.c linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd939x.c
--- linux-6.16.7/sound/soc/codecs/wcd939x.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd939x.c	2025-09-11 09:47:42.000000000 -0600
@@ -28,6 +28,7 @@
 #include <linux/usb/typec_altmode.h>
 
 #include "wcd-clsh-v2.h"
+#include "wcd-common.h"
 #include "wcd-mbhc-v2.h"
 #include "wcd939x.h"
 
@@ -189,6 +190,7 @@ struct wcd939x_priv {
 	struct wcd_mbhc_config mbhc_cfg;
 	struct wcd_mbhc_intr intr_ids;
 	struct wcd_clsh_ctrl *clsh_info;
+	struct wcd_common common;
 	struct irq_domain *virq;
 	struct regmap_irq_chip *wcd_regmap_irq_chip;
 	struct regmap_irq_chip_data *irq_chip;
@@ -201,10 +203,6 @@ struct wcd939x_priv {
 	u32 tx_mode[TX_ADC_MAX];
 	int variant;
 	struct gpio_desc *reset_gpio;
-	u32 micb1_mv;
-	u32 micb2_mv;
-	u32 micb3_mv;
-	u32 micb4_mv;
 	int hphr_pdm_wd_int;
 	int hphl_pdm_wd_int;
 	int ear_pdm_wd_int;
@@ -411,7 +409,7 @@ static int wcd939x_io_init(struct snd_so
 	return 0;
 }
 
-static int wcd939x_sdw_connect_port(const struct wcd939x_sdw_ch_info *ch_info,
+static int wcd939x_sdw_connect_port(const struct wcd_sdw_ch_info *ch_info,
 				    struct sdw_port_config *port_config,
 				    u8 enable)
 {
@@ -1013,7 +1011,7 @@ static int wcd939x_tx_swr_ctrl(struct sn
 	int bank;
 	int rate;
 
-	bank = wcd939x_swr_get_current_bank(wcd939x->sdw_priv[AIF1_CAP]->sdev);
+	bank = sdw_slave_get_current_bank(wcd939x->sdw_priv[AIF1_CAP]->sdev);
 
 	switch (event) {
 	case SND_SOC_DAPM_PRE_PMU:
@@ -1915,17 +1913,6 @@ static void wcd939x_mbhc_micb_ramp_contr
 	}
 }
 
-static int wcd939x_get_micb_vout_ctl_val(u32 micb_mv)
-{
-	/* min micbias voltage is 1V and maximum is 2.85V */
-	if (micb_mv < 1000 || micb_mv > 2850) {
-		pr_err("%s: unsupported micbias voltage\n", __func__);
-		return -EINVAL;
-	}
-
-	return (micb_mv - 1000) / 50;
-}
-
 static int wcd939x_mbhc_micb_adjust_voltage(struct snd_soc_component *component,
 					    int req_volt, int micb_num)
 {
@@ -1965,7 +1952,7 @@ static int wcd939x_mbhc_micb_adjust_volt
 	cur_vout_ctl = snd_soc_component_read_field(component, micb_reg,
 						    WCD939X_MICB_VOUT_CTL);
 
-	req_vout_ctl = wcd939x_get_micb_vout_ctl_val(req_volt);
+	req_vout_ctl = wcd_get_micb_vout_ctl_val(component->dev, req_volt);
 	if (req_vout_ctl < 0) {
 		ret = req_vout_ctl;
 		goto exit;
@@ -2017,10 +2004,10 @@ static int wcd939x_mbhc_micb_ctrl_thresh
 	 * voltage needed to detect threshold microphone, then do
 	 * not change the micbias, just return.
 	 */
-	if (wcd939x->micb2_mv >= WCD_MBHC_THR_HS_MICB_MV)
+	if (wcd939x->common.micb_mv[1] >= WCD_MBHC_THR_HS_MICB_MV)
 		return 0;
 
-	micb_mv = req_en ? WCD_MBHC_THR_HS_MICB_MV : wcd939x->micb2_mv;
+	micb_mv = req_en ? WCD_MBHC_THR_HS_MICB_MV : wcd939x->common.micb_mv[1];
 
 	return wcd939x_mbhc_micb_adjust_voltage(component, micb_mv, MIC_BIAS_2);
 }
@@ -2891,28 +2878,16 @@ static const struct snd_soc_dapm_route w
 	{"EAR", NULL, "EAR PGA"},
 };
 
-static int wcd939x_set_micbias_data(struct wcd939x_priv *wcd939x)
+static void wcd939x_set_micbias_data(struct device *dev, struct wcd939x_priv *wcd939x)
 {
-	int vout_ctl_1, vout_ctl_2, vout_ctl_3, vout_ctl_4;
-
-	/* set micbias voltage */
-	vout_ctl_1 = wcd939x_get_micb_vout_ctl_val(wcd939x->micb1_mv);
-	vout_ctl_2 = wcd939x_get_micb_vout_ctl_val(wcd939x->micb2_mv);
-	vout_ctl_3 = wcd939x_get_micb_vout_ctl_val(wcd939x->micb3_mv);
-	vout_ctl_4 = wcd939x_get_micb_vout_ctl_val(wcd939x->micb4_mv);
-	if (vout_ctl_1 < 0 || vout_ctl_2 < 0 || vout_ctl_3 < 0 || vout_ctl_4 < 0)
-		return -EINVAL;
-
 	regmap_update_bits(wcd939x->regmap, WCD939X_ANA_MICB1,
-			   WCD939X_MICB_VOUT_CTL, vout_ctl_1);
+			   WCD939X_MICB_VOUT_CTL, wcd939x->common.micb_vout[0]);
 	regmap_update_bits(wcd939x->regmap, WCD939X_ANA_MICB2,
-			   WCD939X_MICB_VOUT_CTL, vout_ctl_2);
+			   WCD939X_MICB_VOUT_CTL, wcd939x->common.micb_vout[1]);
 	regmap_update_bits(wcd939x->regmap, WCD939X_ANA_MICB3,
-			   WCD939X_MICB_VOUT_CTL, vout_ctl_3);
+			   WCD939X_MICB_VOUT_CTL, wcd939x->common.micb_vout[2]);
 	regmap_update_bits(wcd939x->regmap, WCD939X_ANA_MICB4,
-			   WCD939X_MICB_VOUT_CTL, vout_ctl_4);
-
-	return 0;
+			   WCD939X_MICB_VOUT_CTL, wcd939x->common.micb_vout[3]);
 }
 
 static irqreturn_t wcd939x_wd_handle_irq(int irq, void *data)
@@ -3182,37 +3157,6 @@ static int wcd939x_typec_mux_set(struct
 }
 #endif /* CONFIG_TYPEC */
 
-static void wcd939x_dt_parse_micbias_info(struct device *dev, struct wcd939x_priv *wcd)
-{
-	struct device_node *np = dev->of_node;
-	u32 prop_val = 0;
-	int rc = 0;
-
-	rc = of_property_read_u32(np, "qcom,micbias1-microvolt",  &prop_val);
-	if (!rc)
-		wcd->micb1_mv = prop_val / 1000;
-	else
-		dev_info(dev, "%s: Micbias1 DT property not found\n", __func__);
-
-	rc = of_property_read_u32(np, "qcom,micbias2-microvolt",  &prop_val);
-	if (!rc)
-		wcd->micb2_mv = prop_val / 1000;
-	else
-		dev_info(dev, "%s: Micbias2 DT property not found\n", __func__);
-
-	rc = of_property_read_u32(np, "qcom,micbias3-microvolt", &prop_val);
-	if (!rc)
-		wcd->micb3_mv = prop_val / 1000;
-	else
-		dev_info(dev, "%s: Micbias3 DT property not found\n", __func__);
-
-	rc = of_property_read_u32(np, "qcom,micbias4-microvolt",  &prop_val);
-	if (!rc)
-		wcd->micb4_mv = prop_val / 1000;
-	else
-		dev_info(dev, "%s: Micbias4 DT property not found\n", __func__);
-}
-
 #if IS_ENABLED(CONFIG_TYPEC)
 static bool wcd939x_swap_gnd_mic(struct snd_soc_component *component)
 {
@@ -3259,13 +3203,15 @@ static int wcd939x_populate_dt_data(stru
 		return dev_err_probe(dev, ret, "Failed to enable supplies\n");
 	}
 
-	wcd939x_dt_parse_micbias_info(dev, wcd939x);
+	ret = wcd_dt_parse_micbias_info(&wcd939x->common);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get micbias\n");
 
 	cfg->mbhc_micbias = MIC_BIAS_2;
 	cfg->anc_micbias = MIC_BIAS_2;
 	cfg->v_hs_max = WCD_MBHC_HS_V_MAX;
 	cfg->num_btn = WCD939X_MBHC_MAX_BUTTONS;
-	cfg->micb_mv = wcd939x->micb2_mv;
+	cfg->micb_mv = wcd939x->common.micb_mv[1];
 	cfg->linein_th = 5000;
 	cfg->hs_thr = 1700;
 	cfg->hph_thr = 50;
@@ -3390,7 +3336,7 @@ static int wcd939x_bind(struct device *d
 		goto err_put_typec_switch;
 	}
 
-	wcd939x->rxdev = wcd939x_sdw_device_get(wcd939x->rxnode);
+	wcd939x->rxdev = of_sdw_find_device_by_node(wcd939x->rxnode);
 	if (!wcd939x->rxdev) {
 		dev_err(dev, "could not find slave with matching of node\n");
 		ret = -EINVAL;
@@ -3399,7 +3345,7 @@ static int wcd939x_bind(struct device *d
 	wcd939x->sdw_priv[AIF1_PB] = dev_get_drvdata(wcd939x->rxdev);
 	wcd939x->sdw_priv[AIF1_PB]->wcd939x = wcd939x;
 
-	wcd939x->txdev = wcd939x_sdw_device_get(wcd939x->txnode);
+	wcd939x->txdev = of_sdw_find_device_by_node(wcd939x->txnode);
 	if (!wcd939x->txdev) {
 		dev_err(dev, "could not find txslave with matching of node\n");
 		ret = -EINVAL;
@@ -3435,10 +3381,10 @@ static int wcd939x_bind(struct device *d
 	}
 
 	/* Get regmap from TX SoundWire device */
-	wcd939x->regmap = wcd939x_swr_get_regmap(wcd939x->sdw_priv[AIF1_CAP]);
-	if (IS_ERR(wcd939x->regmap)) {
+	wcd939x->regmap = wcd939x->sdw_priv[AIF1_CAP]->regmap;
+	if (!wcd939x->regmap) {
 		dev_err(dev, "could not get TX device regmap\n");
-		ret = PTR_ERR(wcd939x->regmap);
+		ret = -ENODEV;
 		goto err_remove_rx_link;
 	}
 
@@ -3451,11 +3397,7 @@ static int wcd939x_bind(struct device *d
 	wcd939x->sdw_priv[AIF1_PB]->slave_irq = wcd939x->virq;
 	wcd939x->sdw_priv[AIF1_CAP]->slave_irq = wcd939x->virq;
 
-	ret = wcd939x_set_micbias_data(wcd939x);
-	if (ret < 0) {
-		dev_err(dev, "%s: bad micbias pdata\n", __func__);
-		goto err_remove_rx_link;
-	}
+	wcd939x_set_micbias_data(dev, wcd939x);
 
 	/* Check WCD9395 version */
 	regmap_read(wcd939x->regmap, WCD939X_DIGITAL_CHIP_ID1, &id1);
@@ -3620,6 +3562,8 @@ static int wcd939x_probe(struct platform
 
 	dev_set_drvdata(dev, wcd939x);
 	mutex_init(&wcd939x->micb_lock);
+	wcd939x->common.dev = dev;
+	wcd939x->common.max_bias = 4;
 
 	ret = wcd939x_populate_dt_data(wcd939x, dev);
 	if (ret) {
diff -Nrup linux-6.16.7/sound/soc/codecs/wcd939x.h linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd939x.h
--- linux-6.16.7/sound/soc/codecs/wcd939x.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd939x.h	2025-09-11 09:47:42.000000000 -0600
@@ -844,17 +844,6 @@
 
 #define WCD939X_MAX_SWR_CH_IDS		(15)
 
-struct wcd939x_sdw_ch_info {
-	int port_num;
-	unsigned int ch_mask;
-};
-
-#define WCD_SDW_CH(id, pn, cmask)	\
-	[id] = {			\
-		.port_num = pn,		\
-		.ch_mask = cmask,	\
-	}
-
 enum wcd939x_tx_sdw_ports {
 	WCD939X_ADC_1_4_PORT = 1,
 	WCD939X_ADC_DMIC_1_2_PORT,
@@ -909,7 +898,7 @@ struct wcd939x_sdw_priv {
 	struct sdw_stream_config sconfig;
 	struct sdw_stream_runtime *sruntime;
 	struct sdw_port_config port_config[WCD939X_MAX_SWR_PORTS];
-	const struct wcd939x_sdw_ch_info *ch_info;
+	const struct wcd_sdw_ch_info *ch_info;
 	bool port_enable[WCD939X_MAX_SWR_CH_IDS];
 	int active_ports;
 	bool is_tx;
@@ -929,11 +918,6 @@ int wcd939x_sdw_hw_params(struct wcd939x
 			  struct snd_pcm_substream *substream,
 			  struct snd_pcm_hw_params *params,
 			  struct snd_soc_dai *dai);
-
-struct device *wcd939x_sdw_device_get(struct device_node *np);
-unsigned int wcd939x_swr_get_current_bank(struct sdw_slave *sdev);
-
-struct regmap *wcd939x_swr_get_regmap(struct wcd939x_sdw_priv *wcd);
 #else
 
 static inline int wcd939x_sdw_free(struct wcd939x_sdw_priv *wcd,
@@ -958,20 +942,6 @@ static inline int wcd939x_sdw_hw_params(
 	return -EOPNOTSUPP;
 }
 
-static inline struct device *wcd939x_sdw_device_get(struct device_node *np)
-{
-	return NULL;
-}
-
-static inline unsigned int wcd939x_swr_get_current_bank(struct sdw_slave *sdev)
-{
-	return 0;
-}
-
-struct regmap *wcd939x_swr_get_regmap(struct wcd939x_sdw_priv *wcd)
-{
-	return PTR_ERR(-EINVAL);
-}
 #endif /* CONFIG_SND_SOC_WCD939X_SDW */
 
 #endif /* __WCD939X_H__ */
diff -Nrup linux-6.16.7/sound/soc/codecs/wcd939x-sdw.c linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd939x-sdw.c
--- linux-6.16.7/sound/soc/codecs/wcd939x-sdw.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd939x-sdw.c	2025-09-11 09:47:42.000000000 -0600
@@ -20,10 +20,9 @@
 #include <sound/soc.h>
 #include <sound/soc-dapm.h>
 #include "wcd939x.h"
+#include "wcd-common.h"
 
-#define SWRS_SCP_HOST_CLK_DIV2_CTL_BANK(m) (0xE0 + 0x10 * (m))
-
-static const struct wcd939x_sdw_ch_info wcd939x_sdw_rx_ch_info[] = {
+static const struct wcd_sdw_ch_info wcd939x_sdw_rx_ch_info[] = {
 	WCD_SDW_CH(WCD939X_HPH_L, WCD939X_HPH_PORT, BIT(0)),
 	WCD_SDW_CH(WCD939X_HPH_R, WCD939X_HPH_PORT, BIT(1)),
 	WCD_SDW_CH(WCD939X_CLSH, WCD939X_CLSH_PORT, BIT(0)),
@@ -36,7 +35,7 @@ static const struct wcd939x_sdw_ch_info
 	WCD_SDW_CH(WCD939X_HIFI_PCM_R, WCD939X_HIFI_PCM_PORT, BIT(1)),
 };
 
-static const struct wcd939x_sdw_ch_info wcd939x_sdw_tx_ch_info[] = {
+static const struct wcd_sdw_ch_info wcd939x_sdw_tx_ch_info[] = {
 	WCD_SDW_CH(WCD939X_ADC1, WCD939X_ADC_1_4_PORT, BIT(0)),
 	WCD_SDW_CH(WCD939X_ADC2, WCD939X_ADC_1_4_PORT, BIT(1)),
 	WCD_SDW_CH(WCD939X_ADC3, WCD939X_ADC_1_4_PORT, BIT(2)),
@@ -128,19 +127,6 @@ static struct sdw_dpn_prop wcd939x_tx_dp
 	}
 };
 
-struct device *wcd939x_sdw_device_get(struct device_node *np)
-{
-	return bus_find_device_by_of_node(&sdw_bus_type, np);
-}
-EXPORT_SYMBOL_GPL(wcd939x_sdw_device_get);
-
-unsigned int wcd939x_swr_get_current_bank(struct sdw_slave *sdev)
-{
-	return FIELD_GET(SDW_SCP_STAT_CURR_BANK,
-			 sdw_read(sdev, SDW_SCP_CTRL));
-}
-EXPORT_SYMBOL_GPL(wcd939x_swr_get_current_bank);
-
 int wcd939x_sdw_hw_params(struct wcd939x_sdw_priv *wcd,
 			  struct snd_pcm_substream *substream,
 			  struct snd_pcm_hw_params *params,
@@ -199,38 +185,6 @@ int wcd939x_sdw_set_sdw_stream(struct wc
 }
 EXPORT_SYMBOL_GPL(wcd939x_sdw_set_sdw_stream);
 
-struct regmap *wcd939x_swr_get_regmap(struct wcd939x_sdw_priv *wcd)
-{
-	if (wcd->regmap)
-		return wcd->regmap;
-
-	return ERR_PTR(-EINVAL);
-}
-EXPORT_SYMBOL_GPL(wcd939x_swr_get_regmap);
-
-static int wcd9390_update_status(struct sdw_slave *slave,
-				 enum sdw_slave_status status)
-{
-	struct wcd939x_sdw_priv *wcd = dev_get_drvdata(&slave->dev);
-
-	if (wcd->regmap && status == SDW_SLAVE_ATTACHED) {
-		/* Write out any cached changes that happened between probe and attach */
-		regcache_cache_only(wcd->regmap, false);
-		return regcache_sync(wcd->regmap);
-	}
-
-	return 0;
-}
-
-static int wcd9390_bus_config(struct sdw_slave *slave,
-			      struct sdw_bus_params *params)
-{
-	sdw_write(slave, SWRS_SCP_HOST_CLK_DIV2_CTL_BANK(params->next_bank),
-		  0x01);
-
-	return 0;
-}
-
 /*
  * Handle Soundwire out-of-band interrupt event by triggering
  * the first irq of the slave_irq irq domain, which then will
@@ -241,18 +195,9 @@ static int wcd9390_interrupt_callback(st
 				      struct sdw_slave_intr_status *status)
 {
 	struct wcd939x_sdw_priv *wcd = dev_get_drvdata(&slave->dev);
-	struct irq_domain *slave_irq = wcd->slave_irq;
-	u32 sts1, sts2, sts3;
-
-	do {
-		handle_nested_irq(irq_find_mapping(slave_irq, 0));
-		regmap_read(wcd->regmap, WCD939X_DIGITAL_INTR_STATUS_0, &sts1);
-		regmap_read(wcd->regmap, WCD939X_DIGITAL_INTR_STATUS_1, &sts2);
-		regmap_read(wcd->regmap, WCD939X_DIGITAL_INTR_STATUS_2, &sts3);
-
-	} while (sts1 || sts2 || sts3);
 
-	return IRQ_HANDLED;
+	return wcd_interrupt_callback(slave, wcd->slave_irq, WCD939X_DIGITAL_INTR_STATUS_0,
+			WCD939X_DIGITAL_INTR_STATUS_1, WCD939X_DIGITAL_INTR_STATUS_2);
 }
 
 static const struct reg_default wcd939x_defaults[] = {
@@ -1385,34 +1330,9 @@ static const struct regmap_config wcd939
 };
 
 static const struct sdw_slave_ops wcd9390_slave_ops = {
-	.update_status = wcd9390_update_status,
+	.update_status = wcd_update_status,
 	.interrupt_callback = wcd9390_interrupt_callback,
-	.bus_config = wcd9390_bus_config,
-};
-
-static int wcd939x_sdw_component_bind(struct device *dev, struct device *master,
-				      void *data)
-{
-	pm_runtime_set_autosuspend_delay(dev, 3000);
-	pm_runtime_use_autosuspend(dev);
-	pm_runtime_mark_last_busy(dev);
-	pm_runtime_set_active(dev);
-	pm_runtime_enable(dev);
-
-	return 0;
-}
-
-static void wcd939x_sdw_component_unbind(struct device *dev,
-					 struct device *master, void *data)
-{
-	pm_runtime_disable(dev);
-	pm_runtime_set_suspended(dev);
-	pm_runtime_dont_use_autosuspend(dev);
-}
-
-static const struct component_ops wcd939x_sdw_component_ops = {
-	.bind = wcd939x_sdw_component_bind,
-	.unbind = wcd939x_sdw_component_unbind,
+	.bus_config = wcd_bus_config,
 };
 
 static int wcd9390_probe(struct sdw_slave *pdev, const struct sdw_device_id *id)
@@ -1478,7 +1398,7 @@ static int wcd9390_probe(struct sdw_slav
 		regcache_cache_only(wcd->regmap, true);
 	}
 
-	ret = component_add(dev, &wcd939x_sdw_component_ops);
+	ret = component_add(dev, &wcd_sdw_component_ops);
 	if (ret)
 		return ret;
 
@@ -1493,7 +1413,7 @@ static int wcd9390_remove(struct sdw_sla
 	struct device *dev = &pdev->dev;
 	struct wcd939x_sdw_priv *wcd = dev_get_drvdata(dev);
 
-	component_del(dev, &wcd939x_sdw_component_ops);
+	component_del(dev, &wcd_sdw_component_ops);
 
 	if (wcd->regmap)
 		regmap_exit(wcd->regmap);
diff -Nrup linux-6.16.7/sound/soc/codecs/wcd-common.c linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd-common.c
--- linux-6.16.7/sound/soc/codecs/wcd-common.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd-common.c	2025-09-11 09:47:42.000000000 -0600
@@ -0,0 +1,143 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2025, Qualcomm Technologies, Inc. and/or its subsidiaries.
+
+#include <linux/export.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/of.h>
+#include <linux/printk.h>
+#include <linux/component.h>
+#include <linux/pm_runtime.h>
+#include <linux/soundwire/sdw.h>
+#include <linux/soundwire/sdw_type.h>
+#include <linux/regmap.h>
+
+#include "wcd-common.h"
+
+#define WCD_MIN_MICBIAS_MV	1000
+#define WCD_DEF_MICBIAS_MV	1800
+#define WCD_MAX_MICBIAS_MV	2850
+
+#define SWRS_SCP_HOST_CLK_DIV2_CTL_BANK(m) (0xE0 + 0x10 * (m))
+
+int wcd_get_micb_vout_ctl_val(struct device *dev, u32 micb_mv)
+{
+	/* min micbias voltage is 1V and maximum is 2.85V */
+	if (micb_mv < WCD_MIN_MICBIAS_MV || micb_mv > WCD_MAX_MICBIAS_MV) {
+		dev_err(dev, "Unsupported micbias voltage (%u mV)\n", micb_mv);
+		return -EINVAL;
+	}
+
+	return (micb_mv - WCD_MIN_MICBIAS_MV) / 50;
+}
+EXPORT_SYMBOL_GPL(wcd_get_micb_vout_ctl_val);
+
+static int wcd_get_micbias_val(struct device *dev, int micb_num, u32 *micb_mv)
+{
+	char micbias[64];
+	int mv;
+
+	sprintf(micbias, "qcom,micbias%d-microvolt", micb_num);
+
+	if (of_property_read_u32(dev->of_node, micbias, &mv)) {
+		dev_err(dev, "%s value not found, using default\n", micbias);
+		mv = WCD_DEF_MICBIAS_MV;
+	} else {
+		/* convert it to milli volts */
+		mv = mv/1000;
+	}
+	if (micb_mv)
+		*micb_mv = mv;
+
+	mv = wcd_get_micb_vout_ctl_val(dev, mv);
+	if (mv < 0) {
+		dev_err(dev, "Unsupported %s voltage (%d mV), falling back to default (%d mV)\n",
+				micbias, mv, WCD_DEF_MICBIAS_MV);
+		return wcd_get_micb_vout_ctl_val(dev, WCD_DEF_MICBIAS_MV);
+	}
+
+	return mv;
+}
+
+int wcd_dt_parse_micbias_info(struct wcd_common *common)
+{
+	int i;
+
+	for (i = 0; i < common->max_bias; i++) {
+		common->micb_vout[i] = wcd_get_micbias_val(common->dev, i + 1, &common->micb_mv[i]);
+		if (common->micb_vout[i] < 0)
+			return -EINVAL;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(wcd_dt_parse_micbias_info);
+
+static int wcd_sdw_component_bind(struct device *dev, struct device *master, void *data)
+{
+	pm_runtime_set_autosuspend_delay(dev, 3000);
+	pm_runtime_use_autosuspend(dev);
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+
+	return 0;
+}
+
+static void wcd_sdw_component_unbind(struct device *dev, struct device *master, void *data)
+{
+	pm_runtime_disable(dev);
+	pm_runtime_set_suspended(dev);
+	pm_runtime_dont_use_autosuspend(dev);
+}
+
+const struct component_ops wcd_sdw_component_ops = {
+	.bind = wcd_sdw_component_bind,
+	.unbind = wcd_sdw_component_unbind,
+};
+EXPORT_SYMBOL_GPL(wcd_sdw_component_ops);
+
+int wcd_update_status(struct sdw_slave *slave, enum sdw_slave_status status)
+{
+	struct regmap *regmap = dev_get_regmap(&slave->dev, NULL);
+
+	if (regmap && status == SDW_SLAVE_ATTACHED) {
+		/* Write out any cached changes that happened between probe and attach */
+		regcache_cache_only(regmap, false);
+		return regcache_sync(regmap);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(wcd_update_status);
+
+int wcd_bus_config(struct sdw_slave *slave, struct sdw_bus_params *params)
+{
+	sdw_write(slave, SWRS_SCP_HOST_CLK_DIV2_CTL_BANK(params->next_bank), 0x01);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(wcd_bus_config);
+
+int wcd_interrupt_callback(struct sdw_slave *slave, struct irq_domain *slave_irq,
+		unsigned int wcd_intr_status0, unsigned int wcd_intr_status1,
+		unsigned int wcd_intr_status2)
+{
+	struct regmap *regmap = dev_get_regmap(&slave->dev, NULL);
+	u32 sts1, sts2, sts3;
+
+	do {
+		handle_nested_irq(irq_find_mapping(slave_irq, 0));
+		regmap_read(regmap, wcd_intr_status0, &sts1);
+		regmap_read(regmap, wcd_intr_status1, &sts2);
+		regmap_read(regmap, wcd_intr_status2, &sts3);
+
+	} while (sts1 || sts2 || sts3);
+
+	return IRQ_HANDLED;
+}
+EXPORT_SYMBOL_GPL(wcd_interrupt_callback);
+
+MODULE_DESCRIPTION("Common Qualcomm WCD Codec helpers driver");
+MODULE_LICENSE("GPL");
diff -Nrup linux-6.16.7/sound/soc/codecs/wcd-common.h linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd-common.h
--- linux-6.16.7/sound/soc/codecs/wcd-common.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd-common.h	2025-09-11 09:47:42.000000000 -0600
@@ -0,0 +1,46 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2025, Qualcomm Technologies, Inc. and/or its subsidiaries.
+ */
+
+#ifndef __WCD_COMMON_H__
+#define __WCD_COMMON_H__
+
+struct device;
+struct sdw_slave;
+struct sdw_bus_params;
+struct irq_domain;
+enum sdw_slave_status;
+
+#define WCD_MAX_MICBIAS		4
+
+struct wcd_sdw_ch_info {
+	int port_num;
+	unsigned int ch_mask;
+	unsigned int master_ch_mask;
+};
+
+#define WCD_SDW_CH(id, pn, cmask)	\
+	[id] = {			\
+		.port_num = pn,		\
+		.ch_mask = cmask,	\
+		.master_ch_mask = cmask,	\
+	}
+
+struct wcd_common {
+	struct device *dev;
+	int max_bias;
+	u32 micb_mv[WCD_MAX_MICBIAS];
+	u32 micb_vout[WCD_MAX_MICBIAS];
+};
+
+extern const struct component_ops wcd_sdw_component_ops;
+int wcd_get_micb_vout_ctl_val(struct device *dev, u32 micb_mv);
+int wcd_dt_parse_micbias_info(struct wcd_common *common);
+int wcd_update_status(struct sdw_slave *slave, enum sdw_slave_status status);
+int wcd_bus_config(struct sdw_slave *slave, struct sdw_bus_params *params);
+int wcd_interrupt_callback(struct sdw_slave *slave, struct irq_domain *slave_irq,
+		unsigned int wcd_intr_status0, unsigned int wcd_intr_status1,
+		unsigned int wcd_intr_status2);
+
+#endif /* __WCD_COMMON_H__  */
diff -Nrup linux-6.16.7/sound/soc/qcom/qdsp6/audioreach.c linux-lenovo-x13s-linux-6.16.y/sound/soc/qcom/qdsp6/audioreach.c
--- linux-6.16.7/sound/soc/qcom/qdsp6/audioreach.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/qcom/qdsp6/audioreach.c	2025-09-11 09:47:42.000000000 -0600
@@ -202,6 +202,31 @@ struct apm_display_port_module_intf_cfg
 } __packed;
 #define APM_DP_INTF_CFG_PSIZE ALIGN(sizeof(struct apm_display_port_module_intf_cfg), 8)
 
+struct apm_module_sp_vi_op_mode_cfg {
+	struct apm_module_param_data param_data;
+	struct param_id_sp_vi_op_mode_cfg cfg;
+} __packed;
+
+#define APM_SP_VI_OP_MODE_CFG_PSIZE(ch) ALIGN( \
+				sizeof(struct apm_module_sp_vi_op_mode_cfg) + \
+				(ch) * sizeof(uint32_t), 8)
+
+struct apm_module_sp_vi_ex_mode_cfg {
+	struct apm_module_param_data param_data;
+	struct param_id_sp_vi_ex_mode_cfg cfg;
+} __packed;
+
+#define APM_SP_VI_EX_MODE_CFG_PSIZE ALIGN(sizeof(struct apm_module_sp_vi_ex_mode_cfg), 8)
+
+struct apm_module_sp_vi_channel_map_cfg {
+	struct apm_module_param_data param_data;
+	struct param_id_sp_vi_channel_map_cfg cfg;
+} __packed;
+
+#define APM_SP_VI_CH_MAP_CFG_PSIZE(ch) ALIGN( \
+				sizeof(struct apm_module_sp_vi_channel_map_cfg) + \
+				(ch) * sizeof(uint32_t), 8)
+
 static void *__audioreach_alloc_pkt(int payload_size, uint32_t opcode, uint32_t token,
 				    uint32_t src_port, uint32_t dest_port, bool has_cmd_hdr)
 {
@@ -811,6 +836,30 @@ static int audioreach_gapless_set_media_
 					 EARLY_EOS_DELAY_MS);
 }
 
+static int audioreach_set_module_config(struct q6apm_graph *graph,
+					struct audioreach_module *module,
+					struct audioreach_module_config *cfg)
+{
+	int payload_size = le32_to_cpu(module->data->size);
+	struct gpr_pkt *pkt;
+	int rc;
+	void *p;
+
+	pkt = audioreach_alloc_apm_cmd_pkt(payload_size, APM_CMD_SET_CFG, 0);
+	if (IS_ERR(pkt))
+		return PTR_ERR(pkt);
+
+	p = (void *)pkt + GPR_HDR_SIZE + APM_CMD_HDR_SIZE;
+
+	memcpy(p, module->data->data, payload_size);
+
+	rc = q6apm_send_cmd_sync(graph->apm, pkt, 0);
+
+	kfree(pkt);
+
+	return rc;
+}
+
 static int audioreach_mfc_set_media_format(struct q6apm_graph *graph,
 					   struct audioreach_module *module,
 					   struct audioreach_module_config *cfg)
@@ -1226,6 +1275,98 @@ static int audioreach_gain_set(struct q6
 	return rc;
 }
 
+static int audioreach_speaker_protection(struct q6apm_graph *graph,
+					 struct audioreach_module *module,
+					 uint32_t operation_mode)
+{
+	return audioreach_send_u32_param(graph, module, PARAM_ID_SP_OP_MODE,
+					 operation_mode);
+}
+
+static int audioreach_speaker_protection_vi(struct q6apm_graph *graph,
+					    struct audioreach_module *module,
+					    struct audioreach_module_config *mcfg)
+{
+	u32 num_channels = mcfg->num_channels;
+	struct apm_module_sp_vi_op_mode_cfg *op_cfg;
+	struct apm_module_sp_vi_channel_map_cfg *cm_cfg;
+	struct apm_module_sp_vi_ex_mode_cfg *ex_cfg;
+	int op_sz, cm_sz, ex_sz;
+	struct apm_module_param_data *param_data;
+	int rc, i, payload_size;
+	struct gpr_pkt *pkt;
+	void *p;
+
+	if (num_channels > 2) {
+		dev_err(graph->dev, "Error: Invalid channels (%d)!\n", num_channels);
+		return -EINVAL;
+	}
+
+	op_sz = APM_SP_VI_OP_MODE_CFG_PSIZE(num_channels);
+	/* Channel mapping for Isense and Vsense, thus twice number of speakers. */
+	cm_sz = APM_SP_VI_CH_MAP_CFG_PSIZE(num_channels * 2);
+	ex_sz = APM_SP_VI_EX_MODE_CFG_PSIZE;
+
+	payload_size = op_sz + cm_sz + ex_sz;
+
+	pkt = audioreach_alloc_apm_cmd_pkt(payload_size, APM_CMD_SET_CFG, 0);
+	if (IS_ERR(pkt))
+		return PTR_ERR(pkt);
+
+	p = (void *)pkt + GPR_HDR_SIZE + APM_CMD_HDR_SIZE;
+
+	op_cfg = p;
+	param_data = &op_cfg->param_data;
+	param_data->module_instance_id = module->instance_id;
+	param_data->error_code = 0;
+	param_data->param_id = PARAM_ID_SP_VI_OP_MODE_CFG;
+	param_data->param_size = op_sz - APM_MODULE_PARAM_DATA_SIZE;
+
+	op_cfg->cfg.num_channels = num_channels;
+	op_cfg->cfg.operation_mode = PARAM_ID_SP_VI_OP_MODE_NORMAL;
+	op_cfg->cfg.quick_calibration = 1;
+	/*
+	 * op_cfg->cfg.r0_t0_selection should be set only for normal mode, keep
+	 * as 0 for calibration
+	 */
+	p += op_sz;
+
+	cm_cfg = p;
+	param_data = &cm_cfg->param_data;
+	param_data->module_instance_id = module->instance_id;
+	param_data->error_code = 0;
+	param_data->param_id = PARAM_ID_SP_VI_CHANNEL_MAP_CFG;
+	param_data->param_size = cm_sz - APM_MODULE_PARAM_DATA_SIZE;
+
+	cm_cfg->cfg.num_channels = num_channels * 2;
+	for (i = 0; i < num_channels; i++) {
+		/*
+		 * Map speakers into Vsense and then Isense of each channel.
+		 * E.g. for PCM_CHANNEL_FL and PCM_CHANNEL_FR to:
+		 * [ 1, 2, 3, 4]
+		 */
+		cm_cfg->cfg.channel_mapping[2 * i] = (mcfg->channel_map[i] - 1) * 2 + 1;
+		cm_cfg->cfg.channel_mapping[2 * i + 1] = (mcfg->channel_map[i] - 1) * 2 + 2;
+	}
+
+	p += cm_sz;
+
+	ex_cfg = p;
+	param_data = &ex_cfg->param_data;
+	param_data->module_instance_id = module->instance_id;
+	param_data->error_code = 0;
+	param_data->param_id = PARAM_ID_SP_VI_EX_MODE_CFG;
+	param_data->param_size = ex_sz - APM_MODULE_PARAM_DATA_SIZE;
+
+	ex_cfg->cfg.factory_mode = 0;
+
+	rc = q6apm_send_cmd_sync(graph->apm, pkt, 0);
+
+	kfree(pkt);
+
+	return rc;
+}
+
 int audioreach_set_media_format(struct q6apm_graph *graph, struct audioreach_module *module,
 				struct audioreach_module_config *cfg)
 {
@@ -1247,6 +1388,9 @@ int audioreach_set_media_format(struct q
 	case MODULE_ID_DISPLAY_PORT_SINK:
 		rc = audioreach_display_port_set_media_format(graph, module, cfg);
 		break;
+	case  MODULE_ID_SMECNS_V2:
+		rc = audioreach_set_module_config(graph, module, cfg);
+		break;
 	case MODULE_ID_I2S_SOURCE:
 	case MODULE_ID_I2S_SINK:
 		rc = audioreach_i2s_set_media_format(graph, module, cfg);
@@ -1272,6 +1416,14 @@ int audioreach_set_media_format(struct q
 	case MODULE_ID_GAPLESS:
 		rc = audioreach_gapless_set_media_format(graph, module, cfg);
 		break;
+	case MODULE_ID_SPEAKER_PROTECTION:
+		rc = audioreach_speaker_protection(graph, module,
+						   PARAM_ID_SP_OP_MODE_NORMAL);
+		break;
+	case MODULE_ID_SPEAKER_PROTECTION_VI:
+		rc = audioreach_speaker_protection_vi(graph, module, cfg);
+		break;
+
 	default:
 		rc = 0;
 	}
diff -Nrup linux-6.16.7/sound/soc/qcom/qdsp6/audioreach.h linux-lenovo-x13s-linux-6.16.y/sound/soc/qcom/qdsp6/audioreach.h
--- linux-6.16.7/sound/soc/qcom/qdsp6/audioreach.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/qcom/qdsp6/audioreach.h	2025-09-11 09:47:42.000000000 -0600
@@ -4,6 +4,7 @@
 #define __AUDIOREACH_H__
 #include <linux/types.h>
 #include <linux/soc/qcom/apr.h>
+#include <uapi/sound/snd_ar_tokens.h>
 #include <sound/soc.h>
 struct q6apm;
 struct q6apm_graph;
@@ -17,18 +18,21 @@ struct q6apm_graph;
 #define MODULE_ID_PCM_DEC		0x07001005
 #define MODULE_ID_PLACEHOLDER_ENCODER	0x07001008
 #define MODULE_ID_PLACEHOLDER_DECODER	0x07001009
-#define MODULE_ID_SAL			0x07001010
-#define MODULE_ID_MFC			0x07001015
-#define MODULE_ID_CODEC_DMA_SINK	0x07001023
-#define MODULE_ID_CODEC_DMA_SOURCE	0x07001024
 #define MODULE_ID_I2S_SINK		0x0700100A
 #define MODULE_ID_I2S_SOURCE		0x0700100B
+#define MODULE_ID_SAL			0x07001010
+#define MODULE_ID_MFC			0x07001015
 #define MODULE_ID_DATA_LOGGING		0x0700101A
 #define MODULE_ID_AAC_DEC		0x0700101F
+#define MODULE_ID_CODEC_DMA_SINK	0x07001023
+#define MODULE_ID_CODEC_DMA_SOURCE	0x07001024
 #define MODULE_ID_FLAC_DEC		0x0700102F
+#define MODULE_ID_SMECNS_V2		0x07001031
 #define MODULE_ID_MP3_DECODE		0x0700103B
 #define MODULE_ID_GAPLESS		0x0700104D
 #define MODULE_ID_DISPLAY_PORT_SINK	0x07001069
+#define MODULE_ID_SPEAKER_PROTECTION	0x070010E2
+#define MODULE_ID_SPEAKER_PROTECTION_VI	0x070010E3
 
 #define APM_CMD_GET_SPF_STATE		0x01001021
 #define APM_CMD_RSP_GET_SPF_STATE	0x02001007
@@ -461,8 +465,8 @@ struct param_id_i2s_intf_cfg {
 } __packed;
 
 #define I2S_INTF_TYPE_PRIMARY		0
-#define I2S_INTF_TYPE_SECOINDARY	1
-#define I2S_INTF_TYPE_TERTINARY		2
+#define I2S_INTF_TYPE_SECONDARY		1
+#define I2S_INTF_TYPE_TERTIARY		2
 #define I2S_INTF_TYPE_QUATERNARY	3
 #define I2S_INTF_TYPE_QUINARY		4
 #define I2S_SD0				1
@@ -540,6 +544,43 @@ struct data_logging_config {
 	uint32_t mode;
 } __packed;
 
+/* Speaker Protection */
+#define PARAM_ID_SP_OP_MODE			0x080011e9
+#define PARAM_ID_SP_OP_MODE_NORMAL		0
+#define PARAM_ID_SP_OP_MODE_CALIBRATION		1
+#define PARAM_ID_SP_OP_MODE_FACTORY_TEST	2
+#define PARAM_ID_SP_OP_MODE_VALIDATION		3
+
+struct param_id_sp_op_mode {
+	uint32_t operation_mode;
+} __packed;
+
+/* Speaker Protection VI */
+
+#define PARAM_ID_SP_VI_OP_MODE_CFG		0x080011f4
+#define PARAM_ID_SP_VI_OP_MODE_NORMAL		0
+#define PARAM_ID_SP_VI_OP_MODE_CALIBRATION	1
+#define PARAM_ID_SP_VI_OP_MODE_FACTORY_TEST	2
+#define PARAM_ID_SP_VI_OP_MODE_VALIDATION	3
+struct param_id_sp_vi_op_mode_cfg {
+	uint32_t num_channels;
+	uint32_t operation_mode;
+	uint32_t quick_calibration;
+	uint32_t r0_t0_selection[];
+} __packed;
+
+#define PARAM_ID_SP_VI_EX_MODE_CFG		0x080011ff
+struct param_id_sp_vi_ex_mode_cfg {
+	uint32_t factory_mode;
+} __packed;
+
+#define PARAM_ID_SP_VI_CHANNEL_MAP_CFG		0x08001203
+struct param_id_sp_vi_channel_map_cfg {
+	uint32_t num_channels;
+	/* [ Vsense of ch 1, Isense of ch 1, Vsense of ch 2, Isense of ch 2, ... ] */
+	uint32_t channel_mapping[];
+} __packed;
+
 #define PARAM_ID_SAL_OUTPUT_CFG			0x08001016
 struct param_id_sal_output_config {
 	uint32_t bits_per_sample;
@@ -707,9 +748,6 @@ struct audioreach_module {
 	uint32_t max_ip_port;
 	uint32_t max_op_port;
 
-	uint32_t in_port;
-	uint32_t out_port;
-
 	uint32_t num_connections;
 	/* Connections */
 	uint32_t src_mod_inst_id;
@@ -745,6 +783,7 @@ struct audioreach_module {
 	struct list_head node;
 	struct audioreach_container *container;
 	struct snd_soc_dapm_widget *widget;
+	struct audioreach_module_priv_data *data;
 };
 
 struct audioreach_module_config {
diff -Nrup linux-6.16.7/sound/soc/qcom/qdsp6/q6apm-lpass-dais.c linux-lenovo-x13s-linux-6.16.y/sound/soc/qcom/qdsp6/q6apm-lpass-dais.c
--- linux-6.16.7/sound/soc/qcom/qdsp6/q6apm-lpass-dais.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/qcom/qdsp6/q6apm-lpass-dais.c	2025-09-11 09:47:42.000000000 -0600
@@ -213,8 +213,10 @@ static int q6apm_lpass_dai_prepare(struc
 
 	return 0;
 err:
-	q6apm_graph_close(dai_data->graph[dai->id]);
-	dai_data->graph[dai->id] = NULL;
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		q6apm_graph_close(dai_data->graph[dai->id]);
+		dai_data->graph[dai->id] = NULL;
+	}
 	return rc;
 }
 
diff -Nrup linux-6.16.7/sound/soc/qcom/qdsp6/topology.c linux-lenovo-x13s-linux-6.16.y/sound/soc/qcom/qdsp6/topology.c
--- linux-6.16.7/sound/soc/qcom/qdsp6/topology.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/qcom/qdsp6/topology.c	2025-09-11 09:47:42.000000000 -0600
@@ -305,6 +305,34 @@ static struct snd_soc_tplg_vendor_array
 	return NULL;
 }
 
+static struct audioreach_module_priv_data *audioreach_get_module_priv_data(
+		struct snd_soc_tplg_private *private)
+{
+	int sz;
+
+	for (sz = 0; sz < le32_to_cpu(private->size); ) {
+		struct snd_soc_tplg_vendor_array *mod_array;
+
+		mod_array = (struct snd_soc_tplg_vendor_array *)((u8 *)private->array + sz);
+		if (le32_to_cpu(mod_array->type) == SND_SOC_AR_TPLG_MODULE_CFG_TYPE) {
+			struct audioreach_module_priv_data *pdata;
+
+			pdata = kzalloc(struct_size(pdata, data, le32_to_cpu(mod_array->size)),
+				       GFP_KERNEL);
+			if (!pdata)
+				return ERR_PTR(-ENOMEM);
+
+			memcpy(pdata, ((u8 *)private->data + sz), struct_size(pdata, data,
+						le32_to_cpu(mod_array->size)));
+			return pdata;
+		}
+
+		sz = sz + le32_to_cpu(mod_array->size);
+	}
+
+	return NULL;
+}
+
 static struct audioreach_sub_graph *audioreach_parse_sg_tokens(struct q6apm *apm,
 						       struct snd_soc_tplg_private *private)
 {
@@ -412,7 +440,7 @@ static struct audioreach_module *audiore
 							struct snd_soc_tplg_private *private,
 							struct snd_soc_dapm_widget *w)
 {
-	uint32_t max_ip_port = 0, max_op_port = 0, in_port = 0, out_port = 0;
+	uint32_t max_ip_port = 0, max_op_port = 0;
 	uint32_t src_mod_op_port_id[AR_MAX_MOD_LINKS] = { 0, };
 	uint32_t dst_mod_inst_id[AR_MAX_MOD_LINKS] = { 0, };
 	uint32_t dst_mod_ip_port_id[AR_MAX_MOD_LINKS] = { 0, };
@@ -455,12 +483,6 @@ static struct audioreach_module *audiore
 		case AR_TKN_U32_MODULE_MAX_OP_PORTS:
 			max_op_port = le32_to_cpu(mod_elem->value);
 			break;
-		case AR_TKN_U32_MODULE_IN_PORTS:
-			in_port = le32_to_cpu(mod_elem->value);
-			break;
-		case AR_TKN_U32_MODULE_OUT_PORTS:
-			out_port = le32_to_cpu(mod_elem->value);
-			break;
 		case AR_TKN_U32_MODULE_SRC_INSTANCE_ID:
 			src_mod_inst_id = le32_to_cpu(mod_elem->value);
 			break;
@@ -550,8 +572,6 @@ static struct audioreach_module *audiore
 		mod->module_id = module_id;
 		mod->max_ip_port = max_ip_port;
 		mod->max_op_port = max_op_port;
-		mod->in_port = in_port;
-		mod->out_port = out_port;
 		mod->src_mod_inst_id = src_mod_inst_id;
 		for (pn = 0; pn < mod->max_op_port; pn++) {
 			if (src_mod_op_port_id[pn] && dst_mod_inst_id[pn] &&
@@ -587,8 +607,10 @@ static int audioreach_widget_load_module
 		return PTR_ERR(cont);
 
 	mod = audioreach_parse_common_tokens(apm, cont, &tplg_w->priv, w);
-	if (IS_ERR(mod))
-		return PTR_ERR(mod);
+	if (IS_ERR_OR_NULL(mod))
+		return mod ? PTR_ERR(mod) : -ENODEV;
+
+	mod->data = audioreach_get_module_priv_data(&tplg_w->priv);
 
 	dobj = &w->dobj;
 	dobj->private = mod;
@@ -947,6 +969,7 @@ static int audioreach_widget_unload(stru
 	cont->num_modules--;
 
 	list_del(&mod->node);
+	kfree(mod->data);
 	kfree(mod);
 	/* Graph Info has N sub-graphs, sub-graph has N containers, Container has N Modules */
 	if (list_empty(&cont->modules_list)) { /* if no modules in the container then remove it */
diff -Nrup linux-6.16.7/sound/soc/qcom/sc8280xp.c linux-lenovo-x13s-linux-6.16.y/sound/soc/qcom/sc8280xp.c
--- linux-6.16.7/sound/soc/qcom/sc8280xp.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/qcom/sc8280xp.c	2025-09-11 09:47:42.000000000 -0600
@@ -7,6 +7,7 @@
 #include <sound/soc.h>
 #include <sound/soc-dapm.h>
 #include <sound/pcm.h>
+#include <sound/pcm_params.h>
 #include <linux/soundwire/sdw.h>
 #include <sound/jack.h>
 #include <linux/input-event-codes.h>
@@ -82,8 +83,10 @@ static int sc8280xp_be_hw_params_fixup(s
 					SNDRV_PCM_HW_PARAM_RATE);
 	struct snd_interval *channels = hw_param_interval(params,
 					SNDRV_PCM_HW_PARAM_CHANNELS);
+	struct snd_mask *fmt = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);
 
 	rate->min = rate->max = 48000;
+	snd_mask_set_format(fmt, SNDRV_PCM_FORMAT_S16_LE);
 	channels->min = 2;
 	channels->max = 2;
 	switch (cpu_dai->id) {
diff -Nrup linux-6.16.7/tools/lib/bpf/elf.c linux-lenovo-x13s-linux-6.16.y/tools/lib/bpf/elf.c
--- linux-6.16.7/tools/lib/bpf/elf.c	2025-09-13 16:15:46.049768241 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/lib/bpf/elf.c	2025-09-11 09:47:42.000000000 -0600
@@ -370,11 +370,6 @@ out:
 	return ret;
 }
 
-#if !defined(__clang__)
-#pragma GCC diagnostic push
-/* https://gcc.gnu.org/PR114952 */
-#pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
-#endif
 /* Find offset of function name in ELF object specified by path. "name" matches
  * symbol name or name@@LIB for library functions.
  */
@@ -390,9 +385,6 @@ long elf_find_func_offset_from_file(cons
 	elf_close(&elf_fd);
 	return ret;
 }
-#if !defined(__clang__)
-#pragma GCC diagnostic pop
-#endif
 
 struct symbol {
 	const char *name;
diff -Nrup linux-6.16.7/tools/lib/bpf/elf.c.orig linux-lenovo-x13s-linux-6.16.y/tools/lib/bpf/elf.c.orig
--- linux-6.16.7/tools/lib/bpf/elf.c.orig	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/lib/bpf/elf.c.orig	1969-12-31 17:00:00.000000000 -0700
@@ -1,559 +0,0 @@
-// SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)
-
-#ifndef _GNU_SOURCE
-#define _GNU_SOURCE
-#endif
-#include <libelf.h>
-#include <gelf.h>
-#include <fcntl.h>
-#include <linux/kernel.h>
-
-#include "libbpf_internal.h"
-#include "str_error.h"
-
-/* A SHT_GNU_versym section holds 16-bit words. This bit is set if
- * the symbol is hidden and can only be seen when referenced using an
- * explicit version number. This is a GNU extension.
- */
-#define VERSYM_HIDDEN	0x8000
-
-/* This is the mask for the rest of the data in a word read from a
- * SHT_GNU_versym section.
- */
-#define VERSYM_VERSION	0x7fff
-
-int elf_open(const char *binary_path, struct elf_fd *elf_fd)
-{
-	int fd, ret;
-	Elf *elf;
-
-	elf_fd->elf = NULL;
-	elf_fd->fd = -1;
-
-	if (elf_version(EV_CURRENT) == EV_NONE) {
-		pr_warn("elf: failed to init libelf for %s\n", binary_path);
-		return -LIBBPF_ERRNO__LIBELF;
-	}
-	fd = open(binary_path, O_RDONLY | O_CLOEXEC);
-	if (fd < 0) {
-		ret = -errno;
-		pr_warn("elf: failed to open %s: %s\n", binary_path, errstr(ret));
-		return ret;
-	}
-	elf = elf_begin(fd, ELF_C_READ_MMAP, NULL);
-	if (!elf) {
-		pr_warn("elf: could not read elf from %s: %s\n", binary_path, elf_errmsg(-1));
-		close(fd);
-		return -LIBBPF_ERRNO__FORMAT;
-	}
-	elf_fd->fd = fd;
-	elf_fd->elf = elf;
-	return 0;
-}
-
-void elf_close(struct elf_fd *elf_fd)
-{
-	if (!elf_fd)
-		return;
-	elf_end(elf_fd->elf);
-	close(elf_fd->fd);
-}
-
-/* Return next ELF section of sh_type after scn, or first of that type if scn is NULL. */
-static Elf_Scn *elf_find_next_scn_by_type(Elf *elf, int sh_type, Elf_Scn *scn)
-{
-	while ((scn = elf_nextscn(elf, scn)) != NULL) {
-		GElf_Shdr sh;
-
-		if (!gelf_getshdr(scn, &sh))
-			continue;
-		if (sh.sh_type == sh_type)
-			return scn;
-	}
-	return NULL;
-}
-
-struct elf_sym {
-	const char *name;
-	GElf_Sym sym;
-	GElf_Shdr sh;
-	int ver;
-	bool hidden;
-};
-
-struct elf_sym_iter {
-	Elf *elf;
-	Elf_Data *syms;
-	Elf_Data *versyms;
-	Elf_Data *verdefs;
-	size_t nr_syms;
-	size_t strtabidx;
-	size_t verdef_strtabidx;
-	size_t next_sym_idx;
-	struct elf_sym sym;
-	int st_type;
-};
-
-static int elf_sym_iter_new(struct elf_sym_iter *iter,
-			    Elf *elf, const char *binary_path,
-			    int sh_type, int st_type)
-{
-	Elf_Scn *scn = NULL;
-	GElf_Ehdr ehdr;
-	GElf_Shdr sh;
-
-	memset(iter, 0, sizeof(*iter));
-
-	if (!gelf_getehdr(elf, &ehdr)) {
-		pr_warn("elf: failed to get ehdr from %s: %s\n", binary_path, elf_errmsg(-1));
-		return -EINVAL;
-	}
-
-	scn = elf_find_next_scn_by_type(elf, sh_type, NULL);
-	if (!scn) {
-		pr_debug("elf: failed to find symbol table ELF sections in '%s'\n",
-			 binary_path);
-		return -ENOENT;
-	}
-
-	if (!gelf_getshdr(scn, &sh))
-		return -EINVAL;
-
-	iter->strtabidx = sh.sh_link;
-	iter->syms = elf_getdata(scn, 0);
-	if (!iter->syms) {
-		pr_warn("elf: failed to get symbols for symtab section in '%s': %s\n",
-			binary_path, elf_errmsg(-1));
-		return -EINVAL;
-	}
-	iter->nr_syms = iter->syms->d_size / sh.sh_entsize;
-	iter->elf = elf;
-	iter->st_type = st_type;
-
-	/* Version symbol table is meaningful to dynsym only */
-	if (sh_type != SHT_DYNSYM)
-		return 0;
-
-	scn = elf_find_next_scn_by_type(elf, SHT_GNU_versym, NULL);
-	if (!scn)
-		return 0;
-	iter->versyms = elf_getdata(scn, 0);
-
-	scn = elf_find_next_scn_by_type(elf, SHT_GNU_verdef, NULL);
-	if (!scn)
-		return 0;
-
-	iter->verdefs = elf_getdata(scn, 0);
-	if (!iter->verdefs || !gelf_getshdr(scn, &sh)) {
-		pr_warn("elf: failed to get verdef ELF section in '%s'\n", binary_path);
-		return -EINVAL;
-	}
-	iter->verdef_strtabidx = sh.sh_link;
-
-	return 0;
-}
-
-static struct elf_sym *elf_sym_iter_next(struct elf_sym_iter *iter)
-{
-	struct elf_sym *ret = &iter->sym;
-	GElf_Sym *sym = &ret->sym;
-	const char *name = NULL;
-	GElf_Versym versym;
-	Elf_Scn *sym_scn;
-	size_t idx;
-
-	for (idx = iter->next_sym_idx; idx < iter->nr_syms; idx++) {
-		if (!gelf_getsym(iter->syms, idx, sym))
-			continue;
-		if (GELF_ST_TYPE(sym->st_info) != iter->st_type)
-			continue;
-		name = elf_strptr(iter->elf, iter->strtabidx, sym->st_name);
-		if (!name)
-			continue;
-		sym_scn = elf_getscn(iter->elf, sym->st_shndx);
-		if (!sym_scn)
-			continue;
-		if (!gelf_getshdr(sym_scn, &ret->sh))
-			continue;
-
-		iter->next_sym_idx = idx + 1;
-		ret->name = name;
-		ret->ver = 0;
-		ret->hidden = false;
-
-		if (iter->versyms) {
-			if (!gelf_getversym(iter->versyms, idx, &versym))
-				continue;
-			ret->ver = versym & VERSYM_VERSION;
-			ret->hidden = versym & VERSYM_HIDDEN;
-		}
-		return ret;
-	}
-
-	return NULL;
-}
-
-static const char *elf_get_vername(struct elf_sym_iter *iter, int ver)
-{
-	GElf_Verdaux verdaux;
-	GElf_Verdef verdef;
-	int offset;
-
-	if (!iter->verdefs)
-		return NULL;
-
-	offset = 0;
-	while (gelf_getverdef(iter->verdefs, offset, &verdef)) {
-		if (verdef.vd_ndx != ver) {
-			if (!verdef.vd_next)
-				break;
-
-			offset += verdef.vd_next;
-			continue;
-		}
-
-		if (!gelf_getverdaux(iter->verdefs, offset + verdef.vd_aux, &verdaux))
-			break;
-
-		return elf_strptr(iter->elf, iter->verdef_strtabidx, verdaux.vda_name);
-
-	}
-	return NULL;
-}
-
-static bool symbol_match(struct elf_sym_iter *iter, int sh_type, struct elf_sym *sym,
-			 const char *name, size_t name_len, const char *lib_ver)
-{
-	const char *ver_name;
-
-	/* Symbols are in forms of func, func@LIB_VER or func@@LIB_VER
-	 * make sure the func part matches the user specified name
-	 */
-	if (strncmp(sym->name, name, name_len) != 0)
-		return false;
-
-	/* ...but we don't want a search for "foo" to match 'foo2" also, so any
-	 * additional characters in sname should be of the form "@@LIB".
-	 */
-	if (sym->name[name_len] != '\0' && sym->name[name_len] != '@')
-		return false;
-
-	/* If user does not specify symbol version, then we got a match */
-	if (!lib_ver)
-		return true;
-
-	/* If user specifies symbol version, for dynamic symbols,
-	 * get version name from ELF verdef section for comparison.
-	 */
-	if (sh_type == SHT_DYNSYM) {
-		ver_name = elf_get_vername(iter, sym->ver);
-		if (!ver_name)
-			return false;
-		return strcmp(ver_name, lib_ver) == 0;
-	}
-
-	/* For normal symbols, it is already in form of func@LIB_VER */
-	return strcmp(sym->name, name) == 0;
-}
-
-/* Transform symbol's virtual address (absolute for binaries and relative
- * for shared libs) into file offset, which is what kernel is expecting
- * for uprobe/uretprobe attachment.
- * See Documentation/trace/uprobetracer.rst for more details. This is done
- * by looking up symbol's containing section's header and using iter's virtual
- * address (sh_addr) and corresponding file offset (sh_offset) to transform
- * sym.st_value (virtual address) into desired final file offset.
- */
-static unsigned long elf_sym_offset(struct elf_sym *sym)
-{
-	return sym->sym.st_value - sym->sh.sh_addr + sym->sh.sh_offset;
-}
-
-/* Find offset of function name in the provided ELF object. "binary_path" is
- * the path to the ELF binary represented by "elf", and only used for error
- * reporting matters. "name" matches symbol name or name@@LIB for library
- * functions.
- */
-long elf_find_func_offset(Elf *elf, const char *binary_path, const char *name)
-{
-	int i, sh_types[2] = { SHT_DYNSYM, SHT_SYMTAB };
-	const char *at_symbol, *lib_ver;
-	bool is_shared_lib;
-	long ret = -ENOENT;
-	size_t name_len;
-	GElf_Ehdr ehdr;
-
-	if (!gelf_getehdr(elf, &ehdr)) {
-		pr_warn("elf: failed to get ehdr from %s: %s\n", binary_path, elf_errmsg(-1));
-		ret = -LIBBPF_ERRNO__FORMAT;
-		goto out;
-	}
-	/* for shared lib case, we do not need to calculate relative offset */
-	is_shared_lib = ehdr.e_type == ET_DYN;
-
-	/* Does name specify "@@LIB_VER" or "@LIB_VER" ? */
-	at_symbol = strchr(name, '@');
-	if (at_symbol) {
-		name_len = at_symbol - name;
-		/* skip second @ if it's @@LIB_VER case */
-		if (at_symbol[1] == '@')
-			at_symbol++;
-		lib_ver = at_symbol + 1;
-	} else {
-		name_len = strlen(name);
-		lib_ver = NULL;
-	}
-
-	/* Search SHT_DYNSYM, SHT_SYMTAB for symbol. This search order is used because if
-	 * a binary is stripped, it may only have SHT_DYNSYM, and a fully-statically
-	 * linked binary may not have SHT_DYMSYM, so absence of a section should not be
-	 * reported as a warning/error.
-	 */
-	for (i = 0; i < ARRAY_SIZE(sh_types); i++) {
-		struct elf_sym_iter iter;
-		struct elf_sym *sym;
-		int last_bind = -1;
-		int cur_bind;
-
-		ret = elf_sym_iter_new(&iter, elf, binary_path, sh_types[i], STT_FUNC);
-		if (ret == -ENOENT)
-			continue;
-		if (ret)
-			goto out;
-
-		while ((sym = elf_sym_iter_next(&iter))) {
-			if (!symbol_match(&iter, sh_types[i], sym, name, name_len, lib_ver))
-				continue;
-
-			cur_bind = GELF_ST_BIND(sym->sym.st_info);
-
-			if (ret > 0) {
-				/* handle multiple matches */
-				if (elf_sym_offset(sym) == ret) {
-					/* same offset, no problem */
-					continue;
-				} else if (last_bind != STB_WEAK && cur_bind != STB_WEAK) {
-					/* Only accept one non-weak bind. */
-					pr_warn("elf: ambiguous match for '%s', '%s' in '%s'\n",
-						sym->name, name, binary_path);
-					ret = -LIBBPF_ERRNO__FORMAT;
-					goto out;
-				} else if (cur_bind == STB_WEAK) {
-					/* already have a non-weak bind, and
-					 * this is a weak bind, so ignore.
-					 */
-					continue;
-				}
-			}
-
-			ret = elf_sym_offset(sym);
-			last_bind = cur_bind;
-		}
-		if (ret > 0)
-			break;
-	}
-
-	if (ret > 0) {
-		pr_debug("elf: symbol address match for '%s' in '%s': 0x%lx\n", name, binary_path,
-			 ret);
-	} else {
-		if (ret == 0) {
-			pr_warn("elf: '%s' is 0 in symtab for '%s': %s\n", name, binary_path,
-				is_shared_lib ? "should not be 0 in a shared library" :
-						"try using shared library path instead");
-			ret = -ENOENT;
-		} else {
-			pr_warn("elf: failed to find symbol '%s' in '%s'\n", name, binary_path);
-		}
-	}
-out:
-	return ret;
-}
-
-/* Find offset of function name in ELF object specified by path. "name" matches
- * symbol name or name@@LIB for library functions.
- */
-long elf_find_func_offset_from_file(const char *binary_path, const char *name)
-{
-	struct elf_fd elf_fd;
-	long ret = -ENOENT;
-
-	ret = elf_open(binary_path, &elf_fd);
-	if (ret)
-		return ret;
-	ret = elf_find_func_offset(elf_fd.elf, binary_path, name);
-	elf_close(&elf_fd);
-	return ret;
-}
-
-struct symbol {
-	const char *name;
-	int bind;
-	int idx;
-};
-
-static int symbol_cmp(const void *a, const void *b)
-{
-	const struct symbol *sym_a = a;
-	const struct symbol *sym_b = b;
-
-	return strcmp(sym_a->name, sym_b->name);
-}
-
-/*
- * Return offsets in @poffsets for symbols specified in @syms array argument.
- * On success returns 0 and offsets are returned in allocated array with @cnt
- * size, that needs to be released by the caller.
- */
-int elf_resolve_syms_offsets(const char *binary_path, int cnt,
-			     const char **syms, unsigned long **poffsets,
-			     int st_type)
-{
-	int sh_types[2] = { SHT_DYNSYM, SHT_SYMTAB };
-	int err = 0, i, cnt_done = 0;
-	unsigned long *offsets;
-	struct symbol *symbols;
-	struct elf_fd elf_fd;
-
-	err = elf_open(binary_path, &elf_fd);
-	if (err)
-		return err;
-
-	offsets = calloc(cnt, sizeof(*offsets));
-	symbols = calloc(cnt, sizeof(*symbols));
-
-	if (!offsets || !symbols) {
-		err = -ENOMEM;
-		goto out;
-	}
-
-	for (i = 0; i < cnt; i++) {
-		symbols[i].name = syms[i];
-		symbols[i].idx = i;
-	}
-
-	qsort(symbols, cnt, sizeof(*symbols), symbol_cmp);
-
-	for (i = 0; i < ARRAY_SIZE(sh_types); i++) {
-		struct elf_sym_iter iter;
-		struct elf_sym *sym;
-
-		err = elf_sym_iter_new(&iter, elf_fd.elf, binary_path, sh_types[i], st_type);
-		if (err == -ENOENT)
-			continue;
-		if (err)
-			goto out;
-
-		while ((sym = elf_sym_iter_next(&iter))) {
-			unsigned long sym_offset = elf_sym_offset(sym);
-			int bind = GELF_ST_BIND(sym->sym.st_info);
-			struct symbol *found, tmp = {
-				.name = sym->name,
-			};
-			unsigned long *offset;
-
-			found = bsearch(&tmp, symbols, cnt, sizeof(*symbols), symbol_cmp);
-			if (!found)
-				continue;
-
-			offset = &offsets[found->idx];
-			if (*offset > 0) {
-				/* same offset, no problem */
-				if (*offset == sym_offset)
-					continue;
-				/* handle multiple matches */
-				if (found->bind != STB_WEAK && bind != STB_WEAK) {
-					/* Only accept one non-weak bind. */
-					pr_warn("elf: ambiguous match found '%s@%lu' in '%s' previous offset %lu\n",
-						sym->name, sym_offset, binary_path, *offset);
-					err = -ESRCH;
-					goto out;
-				} else if (bind == STB_WEAK) {
-					/* already have a non-weak bind, and
-					 * this is a weak bind, so ignore.
-					 */
-					continue;
-				}
-			} else {
-				cnt_done++;
-			}
-			*offset = sym_offset;
-			found->bind = bind;
-		}
-	}
-
-	if (cnt != cnt_done) {
-		err = -ENOENT;
-		goto out;
-	}
-
-	*poffsets = offsets;
-
-out:
-	free(symbols);
-	if (err)
-		free(offsets);
-	elf_close(&elf_fd);
-	return err;
-}
-
-/*
- * Return offsets in @poffsets for symbols specified by @pattern argument.
- * On success returns 0 and offsets are returned in allocated @poffsets
- * array with the @pctn size, that needs to be released by the caller.
- */
-int elf_resolve_pattern_offsets(const char *binary_path, const char *pattern,
-				unsigned long **poffsets, size_t *pcnt)
-{
-	int sh_types[2] = { SHT_SYMTAB, SHT_DYNSYM };
-	unsigned long *offsets = NULL;
-	size_t cap = 0, cnt = 0;
-	struct elf_fd elf_fd;
-	int err = 0, i;
-
-	err = elf_open(binary_path, &elf_fd);
-	if (err)
-		return err;
-
-	for (i = 0; i < ARRAY_SIZE(sh_types); i++) {
-		struct elf_sym_iter iter;
-		struct elf_sym *sym;
-
-		err = elf_sym_iter_new(&iter, elf_fd.elf, binary_path, sh_types[i], STT_FUNC);
-		if (err == -ENOENT)
-			continue;
-		if (err)
-			goto out;
-
-		while ((sym = elf_sym_iter_next(&iter))) {
-			if (!glob_match(sym->name, pattern))
-				continue;
-
-			err = libbpf_ensure_mem((void **) &offsets, &cap, sizeof(*offsets),
-						cnt + 1);
-			if (err)
-				goto out;
-
-			offsets[cnt++] = elf_sym_offset(sym);
-		}
-
-		/* If we found anything in the first symbol section,
-		 * do not search others to avoid duplicates.
-		 */
-		if (cnt)
-			break;
-	}
-
-	if (cnt) {
-		*poffsets = offsets;
-		*pcnt = cnt;
-	} else {
-		err = -ENOENT;
-	}
-
-out:
-	if (err)
-		free(offsets);
-	elf_close(&elf_fd);
-	return err;
-}
diff -Nrup linux-6.16.7/tools/lib/bpf/Makefile linux-lenovo-x13s-linux-6.16.y/tools/lib/bpf/Makefile
--- linux-6.16.7/tools/lib/bpf/Makefile	2025-09-13 16:15:46.052018566 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/lib/bpf/Makefile	2025-09-11 09:47:42.000000000 -0600
@@ -77,15 +77,10 @@ else
   CFLAGS := -g -O2
 endif
 
-# Treat warnings as errors unless directed not to
-ifneq ($(WERROR),0)
-  CFLAGS += -Werror
-endif
-
 # Append required CFLAGS
 override CFLAGS += -std=gnu89
 override CFLAGS += $(EXTRA_WARNINGS) -Wno-switch-enum
-override CFLAGS += -Wall
+override CFLAGS += -Werror -Wall
 override CFLAGS += $(INCLUDES)
 override CFLAGS += -fvisibility=hidden
 override CFLAGS += -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64
diff -Nrup linux-6.16.7/tools/perf/arch/arm64/entry/syscalls/syscall_64.tbl linux-lenovo-x13s-linux-6.16.y/tools/perf/arch/arm64/entry/syscalls/syscall_64.tbl
--- linux-6.16.7/tools/perf/arch/arm64/entry/syscalls/syscall_64.tbl	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/arch/arm64/entry/syscalls/syscall_64.tbl	2025-09-11 09:47:42.000000000 -0600
@@ -1,410 +1 @@
-# SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note
-#
-# This file contains the system call numbers for all of the
-# more recently added architectures.
-#
-# As a basic principle, no duplication of functionality
-# should be added, e.g. we don't use lseek when llseek
-# is present. New architectures should use this file
-# and implement the less feature-full calls in user space.
-#
-0	common	io_setup			sys_io_setup			compat_sys_io_setup
-1	common	io_destroy			sys_io_destroy
-2	common	io_submit			sys_io_submit			compat_sys_io_submit
-3	common	io_cancel			sys_io_cancel
-4	time32	io_getevents			sys_io_getevents_time32
-4	64	io_getevents			sys_io_getevents
-5	common	setxattr			sys_setxattr
-6	common	lsetxattr			sys_lsetxattr
-7	common	fsetxattr			sys_fsetxattr
-8	common	getxattr			sys_getxattr
-9	common	lgetxattr			sys_lgetxattr
-10	common	fgetxattr			sys_fgetxattr
-11	common	listxattr			sys_listxattr
-12	common	llistxattr			sys_llistxattr
-13	common	flistxattr			sys_flistxattr
-14	common	removexattr			sys_removexattr
-15	common	lremovexattr			sys_lremovexattr
-16	common	fremovexattr			sys_fremovexattr
-17	common	getcwd				sys_getcwd
-18	common	lookup_dcookie			sys_ni_syscall
-19	common	eventfd2			sys_eventfd2
-20	common	epoll_create1			sys_epoll_create1
-21	common	epoll_ctl			sys_epoll_ctl
-22	common	epoll_pwait			sys_epoll_pwait			compat_sys_epoll_pwait
-23	common	dup				sys_dup
-24	common	dup3				sys_dup3
-25	32	fcntl64				sys_fcntl64			compat_sys_fcntl64
-25	64	fcntl				sys_fcntl
-26	common	inotify_init1			sys_inotify_init1
-27	common	inotify_add_watch		sys_inotify_add_watch
-28	common	inotify_rm_watch		sys_inotify_rm_watch
-29	common	ioctl				sys_ioctl			compat_sys_ioctl
-30	common	ioprio_set			sys_ioprio_set
-31	common	ioprio_get			sys_ioprio_get
-32	common	flock				sys_flock
-33	common	mknodat				sys_mknodat
-34	common	mkdirat				sys_mkdirat
-35	common	unlinkat			sys_unlinkat
-36	common	symlinkat			sys_symlinkat
-37	common	linkat				sys_linkat
-# renameat is superseded with flags by renameat2
-38	renameat renameat			sys_renameat
-39	common	umount2				sys_umount
-40	common	mount				sys_mount
-41	common	pivot_root			sys_pivot_root
-42	common	nfsservctl			sys_ni_syscall
-43	32	statfs64			sys_statfs64			compat_sys_statfs64
-43	64	statfs				sys_statfs
-44	32	fstatfs64			sys_fstatfs64			compat_sys_fstatfs64
-44	64	fstatfs				sys_fstatfs
-45	32	truncate64			sys_truncate64			compat_sys_truncate64
-45	64	truncate			sys_truncate
-46	32	ftruncate64			sys_ftruncate64			compat_sys_ftruncate64
-46	64	ftruncate			sys_ftruncate
-47	common	fallocate			sys_fallocate			compat_sys_fallocate
-48	common	faccessat			sys_faccessat
-49	common	chdir				sys_chdir
-50	common	fchdir				sys_fchdir
-51	common	chroot				sys_chroot
-52	common	fchmod				sys_fchmod
-53	common	fchmodat			sys_fchmodat
-54	common	fchownat			sys_fchownat
-55	common	fchown				sys_fchown
-56	common	openat				sys_openat
-57	common	close				sys_close
-58	common	vhangup				sys_vhangup
-59	common	pipe2				sys_pipe2
-60	common	quotactl			sys_quotactl
-61	common	getdents64			sys_getdents64
-62	32	llseek				sys_llseek
-62	64	lseek				sys_lseek
-63	common	read				sys_read
-64	common	write				sys_write
-65	common	readv				sys_readv			sys_readv
-66	common	writev				sys_writev			sys_writev
-67	common	pread64				sys_pread64			compat_sys_pread64
-68	common	pwrite64			sys_pwrite64			compat_sys_pwrite64
-69	common	preadv				sys_preadv			compat_sys_preadv
-70	common	pwritev				sys_pwritev			compat_sys_pwritev
-71	32	sendfile64			sys_sendfile64
-71	64	sendfile			sys_sendfile64
-72	time32	pselect6			sys_pselect6_time32		compat_sys_pselect6_time32
-72	64	pselect6			sys_pselect6
-73	time32	ppoll				sys_ppoll_time32		compat_sys_ppoll_time32
-73	64	ppoll				sys_ppoll
-74	common	signalfd4			sys_signalfd4			compat_sys_signalfd4
-75	common	vmsplice			sys_vmsplice
-76	common	splice				sys_splice
-77	common	tee				sys_tee
-78	common	readlinkat			sys_readlinkat
-79	stat64	fstatat64			sys_fstatat64
-79	64	newfstatat			sys_newfstatat
-80	stat64	fstat64				sys_fstat64
-80	64	fstat				sys_newfstat
-81	common	sync				sys_sync
-82	common	fsync				sys_fsync
-83	common	fdatasync			sys_fdatasync
-84	common	sync_file_range			sys_sync_file_range		compat_sys_sync_file_range
-85	common	timerfd_create			sys_timerfd_create
-86	time32	timerfd_settime			sys_timerfd_settime32
-86	64	timerfd_settime			sys_timerfd_settime
-87	time32	timerfd_gettime			sys_timerfd_gettime32
-87	64	timerfd_gettime			sys_timerfd_gettime
-88	time32	utimensat			sys_utimensat_time32
-88	64	utimensat			sys_utimensat
-89	common	acct				sys_acct
-90	common	capget				sys_capget
-91	common	capset				sys_capset
-92	common	personality			sys_personality
-93	common	exit				sys_exit
-94	common	exit_group			sys_exit_group
-95	common	waitid				sys_waitid			compat_sys_waitid
-96	common	set_tid_address			sys_set_tid_address
-97	common	unshare				sys_unshare
-98	time32	futex				sys_futex_time32
-98	64	futex				sys_futex
-99	common	set_robust_list			sys_set_robust_list		compat_sys_set_robust_list
-100	common	get_robust_list			sys_get_robust_list		compat_sys_get_robust_list
-101	time32	nanosleep			sys_nanosleep_time32
-101	64	nanosleep			sys_nanosleep
-102	common	getitimer			sys_getitimer			compat_sys_getitimer
-103	common	setitimer			sys_setitimer			compat_sys_setitimer
-104	common	kexec_load			sys_kexec_load			compat_sys_kexec_load
-105	common	init_module			sys_init_module
-106	common	delete_module			sys_delete_module
-107	common	timer_create			sys_timer_create		compat_sys_timer_create
-108	time32	timer_gettime			sys_timer_gettime32
-108	64	timer_gettime			sys_timer_gettime
-109	common	timer_getoverrun		sys_timer_getoverrun
-110	time32	timer_settime			sys_timer_settime32
-110	64	timer_settime			sys_timer_settime
-111	common	timer_delete			sys_timer_delete
-112	time32	clock_settime			sys_clock_settime32
-112	64	clock_settime			sys_clock_settime
-113	time32	clock_gettime			sys_clock_gettime32
-113	64	clock_gettime			sys_clock_gettime
-114	time32	clock_getres			sys_clock_getres_time32
-114	64	clock_getres			sys_clock_getres
-115	time32	clock_nanosleep			sys_clock_nanosleep_time32
-115	64	clock_nanosleep			sys_clock_nanosleep
-116	common	syslog				sys_syslog
-117	common	ptrace				sys_ptrace			compat_sys_ptrace
-118	common	sched_setparam			sys_sched_setparam
-119	common	sched_setscheduler		sys_sched_setscheduler
-120	common	sched_getscheduler		sys_sched_getscheduler
-121	common	sched_getparam			sys_sched_getparam
-122	common	sched_setaffinity		sys_sched_setaffinity		compat_sys_sched_setaffinity
-123	common	sched_getaffinity		sys_sched_getaffinity		compat_sys_sched_getaffinity
-124	common	sched_yield			sys_sched_yield
-125	common	sched_get_priority_max		sys_sched_get_priority_max
-126	common	sched_get_priority_min		sys_sched_get_priority_min
-127	time32	sched_rr_get_interval		sys_sched_rr_get_interval_time32
-127	64	sched_rr_get_interval		sys_sched_rr_get_interval
-128	common	restart_syscall			sys_restart_syscall
-129	common	kill				sys_kill
-130	common	tkill				sys_tkill
-131	common	tgkill				sys_tgkill
-132	common	sigaltstack			sys_sigaltstack			compat_sys_sigaltstack
-133	common	rt_sigsuspend			sys_rt_sigsuspend		compat_sys_rt_sigsuspend
-134	common	rt_sigaction			sys_rt_sigaction		compat_sys_rt_sigaction
-135	common	rt_sigprocmask			sys_rt_sigprocmask		compat_sys_rt_sigprocmask
-136	common	rt_sigpending			sys_rt_sigpending		compat_sys_rt_sigpending
-137	time32	rt_sigtimedwait			sys_rt_sigtimedwait_time32	compat_sys_rt_sigtimedwait_time32
-137	64	rt_sigtimedwait			sys_rt_sigtimedwait
-138	common	rt_sigqueueinfo			sys_rt_sigqueueinfo		compat_sys_rt_sigqueueinfo
-139	common	rt_sigreturn			sys_rt_sigreturn		compat_sys_rt_sigreturn
-140	common	setpriority			sys_setpriority
-141	common	getpriority			sys_getpriority
-142	common	reboot				sys_reboot
-143	common	setregid			sys_setregid
-144	common	setgid				sys_setgid
-145	common	setreuid			sys_setreuid
-146	common	setuid				sys_setuid
-147	common	setresuid			sys_setresuid
-148	common	getresuid			sys_getresuid
-149	common	setresgid			sys_setresgid
-150	common	getresgid			sys_getresgid
-151	common	setfsuid			sys_setfsuid
-152	common	setfsgid			sys_setfsgid
-153	common	times				sys_times			compat_sys_times
-154	common	setpgid				sys_setpgid
-155	common	getpgid				sys_getpgid
-156	common	getsid				sys_getsid
-157	common	setsid				sys_setsid
-158	common	getgroups			sys_getgroups
-159	common	setgroups			sys_setgroups
-160	common	uname				sys_newuname
-161	common	sethostname			sys_sethostname
-162	common	setdomainname			sys_setdomainname
-# getrlimit and setrlimit are superseded with prlimit64
-163	rlimit	getrlimit			sys_getrlimit			compat_sys_getrlimit
-164	rlimit	setrlimit			sys_setrlimit			compat_sys_setrlimit
-165	common	getrusage			sys_getrusage			compat_sys_getrusage
-166	common	umask				sys_umask
-167	common	prctl				sys_prctl
-168	common	getcpu				sys_getcpu
-169	time32	gettimeofday			sys_gettimeofday		compat_sys_gettimeofday
-169	64	gettimeofday			sys_gettimeofday
-170	time32	settimeofday			sys_settimeofday		compat_sys_settimeofday
-170	64	settimeofday			sys_settimeofday
-171	time32	adjtimex			sys_adjtimex_time32
-171	64	adjtimex			sys_adjtimex
-172	common	getpid				sys_getpid
-173	common	getppid				sys_getppid
-174	common	getuid				sys_getuid
-175	common	geteuid				sys_geteuid
-176	common	getgid				sys_getgid
-177	common	getegid				sys_getegid
-178	common	gettid				sys_gettid
-179	common	sysinfo				sys_sysinfo			compat_sys_sysinfo
-180	common	mq_open				sys_mq_open			compat_sys_mq_open
-181	common	mq_unlink			sys_mq_unlink
-182	time32	mq_timedsend			sys_mq_timedsend_time32
-182	64	mq_timedsend			sys_mq_timedsend
-183	time32	mq_timedreceive			sys_mq_timedreceive_time32
-183	64	mq_timedreceive			sys_mq_timedreceive
-184	common	mq_notify			sys_mq_notify			compat_sys_mq_notify
-185	common	mq_getsetattr			sys_mq_getsetattr		compat_sys_mq_getsetattr
-186	common	msgget				sys_msgget
-187	common	msgctl				sys_msgctl			compat_sys_msgctl
-188	common	msgrcv				sys_msgrcv			compat_sys_msgrcv
-189	common	msgsnd				sys_msgsnd			compat_sys_msgsnd
-190	common	semget				sys_semget
-191	common	semctl				sys_semctl			compat_sys_semctl
-192	time32	semtimedop			sys_semtimedop_time32
-192	64	semtimedop			sys_semtimedop
-193	common	semop				sys_semop
-194	common	shmget				sys_shmget
-195	common	shmctl				sys_shmctl			compat_sys_shmctl
-196	common	shmat				sys_shmat			compat_sys_shmat
-197	common	shmdt				sys_shmdt
-198	common	socket				sys_socket
-199	common	socketpair			sys_socketpair
-200	common	bind				sys_bind
-201	common	listen				sys_listen
-202	common	accept				sys_accept
-203	common	connect				sys_connect
-204	common	getsockname			sys_getsockname
-205	common	getpeername			sys_getpeername
-206	common	sendto				sys_sendto
-207	common	recvfrom			sys_recvfrom			compat_sys_recvfrom
-208	common	setsockopt			sys_setsockopt			sys_setsockopt
-209	common	getsockopt			sys_getsockopt			sys_getsockopt
-210	common	shutdown			sys_shutdown
-211	common	sendmsg				sys_sendmsg			compat_sys_sendmsg
-212	common	recvmsg				sys_recvmsg			compat_sys_recvmsg
-213	common	readahead			sys_readahead			compat_sys_readahead
-214	common	brk				sys_brk
-215	common	munmap				sys_munmap
-216	common	mremap				sys_mremap
-217	common	add_key				sys_add_key
-218	common	request_key			sys_request_key
-219	common	keyctl				sys_keyctl			compat_sys_keyctl
-220	common	clone				sys_clone
-221	common	execve				sys_execve			compat_sys_execve
-222	32	mmap2				sys_mmap2
-222	64	mmap				sys_mmap
-223	32	fadvise64_64			sys_fadvise64_64		compat_sys_fadvise64_64
-223	64	fadvise64			sys_fadvise64_64
-224	common	swapon				sys_swapon
-225	common	swapoff				sys_swapoff
-226	common	mprotect			sys_mprotect
-227	common	msync				sys_msync
-228	common	mlock				sys_mlock
-229	common	munlock				sys_munlock
-230	common	mlockall			sys_mlockall
-231	common	munlockall			sys_munlockall
-232	common	mincore				sys_mincore
-233	common	madvise				sys_madvise
-234	common	remap_file_pages		sys_remap_file_pages
-235	common	mbind				sys_mbind
-236	common	get_mempolicy			sys_get_mempolicy
-237	common	set_mempolicy			sys_set_mempolicy
-238	common	migrate_pages			sys_migrate_pages
-239	common	move_pages			sys_move_pages
-240	common	rt_tgsigqueueinfo		sys_rt_tgsigqueueinfo		compat_sys_rt_tgsigqueueinfo
-241	common	perf_event_open			sys_perf_event_open
-242	common	accept4				sys_accept4
-243	time32	recvmmsg			sys_recvmmsg_time32		compat_sys_recvmmsg_time32
-243	64	recvmmsg			sys_recvmmsg
-# Architectures may provide up to 16 syscalls of their own between 244 and 259
-244	arc	cacheflush			sys_cacheflush
-245	arc	arc_settls			sys_arc_settls
-246	arc	arc_gettls			sys_arc_gettls
-247	arc	sysfs				sys_sysfs
-248	arc	arc_usr_cmpxchg			sys_arc_usr_cmpxchg
-
-244	csky	set_thread_area			sys_set_thread_area
-245	csky	cacheflush			sys_cacheflush
-
-244	nios2	cacheflush			sys_cacheflush
-
-244	or1k	or1k_atomic			sys_or1k_atomic
-
-258	riscv	riscv_hwprobe			sys_riscv_hwprobe
-259	riscv	riscv_flush_icache		sys_riscv_flush_icache
-
-260	time32	wait4				sys_wait4			compat_sys_wait4
-260	64	wait4				sys_wait4
-261	common	prlimit64			sys_prlimit64
-262	common	fanotify_init			sys_fanotify_init
-263	common	fanotify_mark			sys_fanotify_mark
-264	common	name_to_handle_at		sys_name_to_handle_at
-265	common	open_by_handle_at		sys_open_by_handle_at
-266	time32	clock_adjtime			sys_clock_adjtime32
-266	64	clock_adjtime			sys_clock_adjtime
-267	common	syncfs				sys_syncfs
-268	common	setns				sys_setns
-269	common	sendmmsg			sys_sendmmsg			compat_sys_sendmmsg
-270	common	process_vm_readv		sys_process_vm_readv
-271	common	process_vm_writev		sys_process_vm_writev
-272	common	kcmp				sys_kcmp
-273	common	finit_module			sys_finit_module
-274	common	sched_setattr			sys_sched_setattr
-275	common	sched_getattr			sys_sched_getattr
-276	common	renameat2			sys_renameat2
-277	common	seccomp				sys_seccomp
-278	common	getrandom			sys_getrandom
-279	common	memfd_create			sys_memfd_create
-280	common	bpf				sys_bpf
-281	common	execveat			sys_execveat			compat_sys_execveat
-282	common	userfaultfd			sys_userfaultfd
-283	common	membarrier			sys_membarrier
-284	common	mlock2				sys_mlock2
-285	common	copy_file_range			sys_copy_file_range
-286	common	preadv2				sys_preadv2			compat_sys_preadv2
-287	common	pwritev2			sys_pwritev2			compat_sys_pwritev2
-288	common	pkey_mprotect			sys_pkey_mprotect
-289	common	pkey_alloc			sys_pkey_alloc
-290	common	pkey_free			sys_pkey_free
-291	common	statx				sys_statx
-292	time32	io_pgetevents			sys_io_pgetevents_time32	compat_sys_io_pgetevents
-292	64	io_pgetevents			sys_io_pgetevents
-293	common	rseq				sys_rseq
-294	common	kexec_file_load			sys_kexec_file_load
-# 295 through 402 are unassigned to sync up with generic numbers don't use
-403	32	clock_gettime64			sys_clock_gettime
-404	32	clock_settime64			sys_clock_settime
-405	32	clock_adjtime64			sys_clock_adjtime
-406	32	clock_getres_time64		sys_clock_getres
-407	32	clock_nanosleep_time64		sys_clock_nanosleep
-408	32	timer_gettime64			sys_timer_gettime
-409	32	timer_settime64			sys_timer_settime
-410	32	timerfd_gettime64		sys_timerfd_gettime
-411	32	timerfd_settime64		sys_timerfd_settime
-412	32	utimensat_time64		sys_utimensat
-413	32	pselect6_time64			sys_pselect6			compat_sys_pselect6_time64
-414	32	ppoll_time64			sys_ppoll			compat_sys_ppoll_time64
-416	32	io_pgetevents_time64		sys_io_pgetevents		compat_sys_io_pgetevents_time64
-417	32	recvmmsg_time64			sys_recvmmsg			compat_sys_recvmmsg_time64
-418	32	mq_timedsend_time64		sys_mq_timedsend
-419	32	mq_timedreceive_time64		sys_mq_timedreceive
-420	32	semtimedop_time64		sys_semtimedop
-421	32	rt_sigtimedwait_time64		sys_rt_sigtimedwait		compat_sys_rt_sigtimedwait_time64
-422	32	futex_time64			sys_futex
-423	32	sched_rr_get_interval_time64	sys_sched_rr_get_interval
-424	common	pidfd_send_signal		sys_pidfd_send_signal
-425	common	io_uring_setup			sys_io_uring_setup
-426	common	io_uring_enter			sys_io_uring_enter
-427	common	io_uring_register		sys_io_uring_register
-428	common	open_tree			sys_open_tree
-429	common	move_mount			sys_move_mount
-430	common	fsopen				sys_fsopen
-431	common	fsconfig			sys_fsconfig
-432	common	fsmount				sys_fsmount
-433	common	fspick				sys_fspick
-434	common	pidfd_open			sys_pidfd_open
-435	common	clone3				sys_clone3
-436	common	close_range			sys_close_range
-437	common	openat2				sys_openat2
-438	common	pidfd_getfd			sys_pidfd_getfd
-439	common	faccessat2			sys_faccessat2
-440	common	process_madvise			sys_process_madvise
-441	common	epoll_pwait2			sys_epoll_pwait2		compat_sys_epoll_pwait2
-442	common	mount_setattr			sys_mount_setattr
-443	common	quotactl_fd			sys_quotactl_fd
-444	common	landlock_create_ruleset		sys_landlock_create_ruleset
-445	common	landlock_add_rule		sys_landlock_add_rule
-446	common	landlock_restrict_self		sys_landlock_restrict_self
-447	memfd_secret	memfd_secret		sys_memfd_secret
-448	common	process_mrelease		sys_process_mrelease
-449	common	futex_waitv			sys_futex_waitv
-450	common	set_mempolicy_home_node		sys_set_mempolicy_home_node
-451	common	cachestat			sys_cachestat
-452	common	fchmodat2			sys_fchmodat2
-453	common	map_shadow_stack		sys_map_shadow_stack
-454	common	futex_wake			sys_futex_wake
-455	common	futex_wait			sys_futex_wait
-456	common	futex_requeue			sys_futex_requeue
-457	common	statmount			sys_statmount
-458	common	listmount			sys_listmount
-459	common	lsm_get_self_attr		sys_lsm_get_self_attr
-460	common	lsm_set_self_attr		sys_lsm_set_self_attr
-461	common	lsm_list_modules		sys_lsm_list_modules
-462	common	mseal				sys_mseal
-463	common	setxattrat			sys_setxattrat
-464	common	getxattrat			sys_getxattrat
-465	common	listxattrat			sys_listxattrat
-466	common	removexattrat			sys_removexattrat
-467	common	open_tree_attr			sys_open_tree_attr
+../../../../../scripts/syscall.tbl
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/bullet-07/firmware.json linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-07/firmware.json
--- linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/bullet-07/firmware.json	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-07/firmware.json	2025-09-11 09:47:42.000000000 -0600
@@ -1,68 +1 @@
-[
-  {
-    "ArchStdEvent": "FW_MISALIGNED_LOAD"
-  },
-  {
-    "ArchStdEvent": "FW_MISALIGNED_STORE"
-  },
-  {
-    "ArchStdEvent": "FW_ACCESS_LOAD"
-  },
-  {
-    "ArchStdEvent": "FW_ACCESS_STORE"
-  },
-  {
-    "ArchStdEvent": "FW_ILLEGAL_INSN"
-  },
-  {
-    "ArchStdEvent": "FW_SET_TIMER"
-  },
-  {
-    "ArchStdEvent": "FW_IPI_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_IPI_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_FENCE_I_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_FENCE_I_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_ASID_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_ASID_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_VMID_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_VMID_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_ASID_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_ASID_RECEIVED"
-  }
-]
+../bullet/firmware.json
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/bullet-07/instruction.json linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-07/instruction.json
--- linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/bullet-07/instruction.json	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-07/instruction.json	2025-09-11 09:47:42.000000000 -0600
@@ -1,92 +1 @@
-[
-  {
-    "EventName": "EXCEPTION_TAKEN",
-    "EventCode": "0x100",
-    "BriefDescription": "Counts exceptions taken"
-  },
-  {
-    "EventName": "INTEGER_LOAD_RETIRED",
-    "EventCode": "0x200",
-    "BriefDescription": "Counts integer load instructions retired"
-  },
-  {
-    "EventName": "INTEGER_STORE_RETIRED",
-    "EventCode": "0x400",
-    "BriefDescription": "Counts integer store instructions retired"
-  },
-  {
-    "EventName": "ATOMIC_MEMORY_RETIRED",
-    "EventCode": "0x800",
-    "BriefDescription": "Counts atomic memory instructions retired"
-  },
-  {
-    "EventName": "SYSTEM_INSTRUCTION_RETIRED",
-    "EventCode": "0x1000",
-    "BriefDescription": "Counts system instructions retired (CSR, WFI, MRET, etc.)"
-  },
-  {
-    "EventName": "INTEGER_ARITHMETIC_RETIRED",
-    "EventCode": "0x2000",
-    "BriefDescription": "Counts integer arithmetic instructions retired"
-  },
-  {
-    "EventName": "CONDITIONAL_BRANCH_RETIRED",
-    "EventCode": "0x4000",
-    "BriefDescription": "Counts conditional branch instructions retired"
-  },
-  {
-    "EventName": "JAL_INSTRUCTION_RETIRED",
-    "EventCode": "0x8000",
-    "BriefDescription": "Counts jump-and-link instructions retired"
-  },
-  {
-    "EventName": "JALR_INSTRUCTION_RETIRED",
-    "EventCode": "0x10000",
-    "BriefDescription": "Counts indirect jump instructions (JALR) retired"
-  },
-  {
-    "EventName": "INTEGER_MULTIPLICATION_RETIRED",
-    "EventCode": "0x20000",
-    "BriefDescription": "Counts integer multiplication instructions retired"
-  },
-  {
-    "EventName": "INTEGER_DIVISION_RETIRED",
-    "EventCode": "0x40000",
-    "BriefDescription": "Counts integer division instructions retired"
-  },
-  {
-    "EventName": "FP_LOAD_RETIRED",
-    "EventCode": "0x80000",
-    "BriefDescription": "Counts floating-point load instructions retired"
-  },
-  {
-    "EventName": "FP_STORE_RETIRED",
-    "EventCode": "0x100000",
-    "BriefDescription": "Counts floating-point store instructions retired"
-  },
-  {
-    "EventName": "FP_ADD_RETIRED",
-    "EventCode": "0x200000",
-    "BriefDescription": "Counts floating-point add instructions retired"
-  },
-  {
-    "EventName": "FP_MUL_RETIRED",
-    "EventCode": "0x400000",
-    "BriefDescription": "Counts floating-point multiply instructions retired"
-  },
-  {
-    "EventName": "FP_MULADD_RETIRED",
-    "EventCode": "0x800000",
-    "BriefDescription": "Counts floating-point fused multiply-add instructions retired"
-  },
-  {
-    "EventName": "FP_DIV_SQRT_RETIRED",
-    "EventCode": "0x1000000",
-    "BriefDescription": "Counts floating point divide or square root instructions retired"
-  },
-  {
-    "EventName": "OTHER_FP_RETIRED",
-    "EventCode": "0x2000000",
-    "BriefDescription": "Counts other floating-point instructions retired"
-  }
-]
+../bullet/instruction.json
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/bullet-07/memory.json linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-07/memory.json
--- linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/bullet-07/memory.json	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-07/memory.json	2025-09-11 09:47:42.000000000 -0600
@@ -1,32 +1 @@
-[
-  {
-    "EventName": "ICACHE_MISS",
-    "EventCode": "0x102",
-    "BriefDescription": "Counts instruction cache misses"
-  },
-  {
-    "EventName": "DCACHE_MISS",
-    "EventCode": "0x202",
-    "BriefDescription": "Counts data cache misses"
-  },
-  {
-    "EventName": "DCACHE_RELEASE",
-    "EventCode": "0x402",
-    "BriefDescription": "Counts writeback requests from the data cache"
-  },
-  {
-    "EventName": "ITLB_MISS",
-    "EventCode": "0x802",
-    "BriefDescription": "Counts Instruction TLB misses caused by instruction address translation requests"
-  },
-  {
-    "EventName": "DTLB_MISS",
-    "EventCode": "0x1002",
-    "BriefDescription": "Counts Data TLB misses caused by data address translation requests"
-  },
-  {
-    "EventName": "UTLB_MISS",
-    "EventCode": "0x2002",
-    "BriefDescription": "Counts Unified TLB misses caused by address translation requests"
-  }
-]
+../bullet/memory.json
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/cycle-and-instruction-count.json linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/cycle-and-instruction-count.json
--- linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/cycle-and-instruction-count.json	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/cycle-and-instruction-count.json	2025-09-11 09:47:42.000000000 -0600
@@ -1,12 +1 @@
-[
-  {
-    "EventName": "CORE_CLOCK_CYCLES",
-    "EventCode": "0x165",
-    "BriefDescription": "Counts core clock cycles"
-  },
-  {
-    "EventName": "INSTRUCTIONS_RETIRED",
-    "EventCode": "0x265",
-    "BriefDescription": "Counts instructions retired"
-  }
-]
+../bullet-07/cycle-and-instruction-count.json
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/firmware.json linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/firmware.json
--- linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/firmware.json	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/firmware.json	2025-09-11 09:47:42.000000000 -0600
@@ -1,68 +1 @@
-[
-  {
-    "ArchStdEvent": "FW_MISALIGNED_LOAD"
-  },
-  {
-    "ArchStdEvent": "FW_MISALIGNED_STORE"
-  },
-  {
-    "ArchStdEvent": "FW_ACCESS_LOAD"
-  },
-  {
-    "ArchStdEvent": "FW_ACCESS_STORE"
-  },
-  {
-    "ArchStdEvent": "FW_ILLEGAL_INSN"
-  },
-  {
-    "ArchStdEvent": "FW_SET_TIMER"
-  },
-  {
-    "ArchStdEvent": "FW_IPI_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_IPI_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_FENCE_I_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_FENCE_I_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_ASID_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_ASID_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_VMID_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_VMID_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_ASID_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_ASID_RECEIVED"
-  }
-]
+../bullet/firmware.json
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/instruction.json linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/instruction.json
--- linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/instruction.json	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/instruction.json	2025-09-11 09:47:42.000000000 -0600
@@ -1,92 +1 @@
-[
-  {
-    "EventName": "EXCEPTION_TAKEN",
-    "EventCode": "0x100",
-    "BriefDescription": "Counts exceptions taken"
-  },
-  {
-    "EventName": "INTEGER_LOAD_RETIRED",
-    "EventCode": "0x200",
-    "BriefDescription": "Counts integer load instructions retired"
-  },
-  {
-    "EventName": "INTEGER_STORE_RETIRED",
-    "EventCode": "0x400",
-    "BriefDescription": "Counts integer store instructions retired"
-  },
-  {
-    "EventName": "ATOMIC_MEMORY_RETIRED",
-    "EventCode": "0x800",
-    "BriefDescription": "Counts atomic memory instructions retired"
-  },
-  {
-    "EventName": "SYSTEM_INSTRUCTION_RETIRED",
-    "EventCode": "0x1000",
-    "BriefDescription": "Counts system instructions retired (CSR, WFI, MRET, etc.)"
-  },
-  {
-    "EventName": "INTEGER_ARITHMETIC_RETIRED",
-    "EventCode": "0x2000",
-    "BriefDescription": "Counts integer arithmetic instructions retired"
-  },
-  {
-    "EventName": "CONDITIONAL_BRANCH_RETIRED",
-    "EventCode": "0x4000",
-    "BriefDescription": "Counts conditional branch instructions retired"
-  },
-  {
-    "EventName": "JAL_INSTRUCTION_RETIRED",
-    "EventCode": "0x8000",
-    "BriefDescription": "Counts jump-and-link instructions retired"
-  },
-  {
-    "EventName": "JALR_INSTRUCTION_RETIRED",
-    "EventCode": "0x10000",
-    "BriefDescription": "Counts indirect jump instructions (JALR) retired"
-  },
-  {
-    "EventName": "INTEGER_MULTIPLICATION_RETIRED",
-    "EventCode": "0x20000",
-    "BriefDescription": "Counts integer multiplication instructions retired"
-  },
-  {
-    "EventName": "INTEGER_DIVISION_RETIRED",
-    "EventCode": "0x40000",
-    "BriefDescription": "Counts integer division instructions retired"
-  },
-  {
-    "EventName": "FP_LOAD_RETIRED",
-    "EventCode": "0x80000",
-    "BriefDescription": "Counts floating-point load instructions retired"
-  },
-  {
-    "EventName": "FP_STORE_RETIRED",
-    "EventCode": "0x100000",
-    "BriefDescription": "Counts floating-point store instructions retired"
-  },
-  {
-    "EventName": "FP_ADD_RETIRED",
-    "EventCode": "0x200000",
-    "BriefDescription": "Counts floating-point add instructions retired"
-  },
-  {
-    "EventName": "FP_MUL_RETIRED",
-    "EventCode": "0x400000",
-    "BriefDescription": "Counts floating-point multiply instructions retired"
-  },
-  {
-    "EventName": "FP_MULADD_RETIRED",
-    "EventCode": "0x800000",
-    "BriefDescription": "Counts floating-point fused multiply-add instructions retired"
-  },
-  {
-    "EventName": "FP_DIV_SQRT_RETIRED",
-    "EventCode": "0x1000000",
-    "BriefDescription": "Counts floating point divide or square root instructions retired"
-  },
-  {
-    "EventName": "OTHER_FP_RETIRED",
-    "EventCode": "0x2000000",
-    "BriefDescription": "Counts other floating-point instructions retired"
-  }
-]
+../bullet/instruction.json
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/memory.json linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/memory.json
--- linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/memory.json	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/memory.json	2025-09-11 09:47:42.000000000 -0600
@@ -1,32 +1 @@
-[
-  {
-    "EventName": "ICACHE_MISS",
-    "EventCode": "0x102",
-    "BriefDescription": "Counts instruction cache misses"
-  },
-  {
-    "EventName": "DCACHE_MISS",
-    "EventCode": "0x202",
-    "BriefDescription": "Counts data cache misses"
-  },
-  {
-    "EventName": "DCACHE_RELEASE",
-    "EventCode": "0x402",
-    "BriefDescription": "Counts writeback requests from the data cache"
-  },
-  {
-    "EventName": "ITLB_MISS",
-    "EventCode": "0x802",
-    "BriefDescription": "Counts Instruction TLB misses caused by instruction address translation requests"
-  },
-  {
-    "EventName": "DTLB_MISS",
-    "EventCode": "0x1002",
-    "BriefDescription": "Counts Data TLB misses caused by data address translation requests"
-  },
-  {
-    "EventName": "UTLB_MISS",
-    "EventCode": "0x2002",
-    "BriefDescription": "Counts Unified TLB misses caused by address translation requests"
-  }
-]
+../bullet/memory.json
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/watchpoint.json linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/watchpoint.json
--- linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/watchpoint.json	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/watchpoint.json	2025-09-11 09:47:42.000000000 -0600
@@ -1,42 +1 @@
-[
-  {
-    "EventName": "WATCHPOINT_0",
-    "EventCode": "0x164",
-    "BriefDescription": "Counts occurrences of watchpoint 0 with action=8"
-  },
-  {
-    "EventName": "WATCHPOINT_1",
-    "EventCode": "0x264",
-    "BriefDescription": "Counts occurrences of watchpoint 1 with action=8"
-  },
-  {
-    "EventName": "WATCHPOINT_2",
-    "EventCode": "0x464",
-    "BriefDescription": "Counts occurrences of watchpoint 2 with action=8"
-  },
-  {
-    "EventName": "WATCHPOINT_3",
-    "EventCode": "0x864",
-    "BriefDescription": "Counts occurrences of watchpoint 3 with action=8"
-  },
-  {
-    "EventName": "WATCHPOINT_4",
-    "EventCode": "0x1064",
-    "BriefDescription": "Counts occurrences of watchpoint 4 with action=8"
-  },
-  {
-    "EventName": "WATCHPOINT_5",
-    "EventCode": "0x2064",
-    "BriefDescription": "Counts occurrences of watchpoint 5 with action=8"
-  },
-  {
-    "EventName": "WATCHPOINT_6",
-    "EventCode": "0x4064",
-    "BriefDescription": "Counts occurrences of watchpoint 6 with action=8"
-  },
-  {
-    "EventName": "WATCHPOINT_7",
-    "EventCode": "0x8064",
-    "BriefDescription": "Counts occurrences of watchpoint 7 with action=8"
-  }
-]
+../bullet-07/watchpoint.json
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/p550/firmware.json linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/p550/firmware.json
--- linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/p550/firmware.json	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/p550/firmware.json	2025-09-11 09:47:42.000000000 -0600
@@ -1,68 +1 @@
-[
-  {
-    "ArchStdEvent": "FW_MISALIGNED_LOAD"
-  },
-  {
-    "ArchStdEvent": "FW_MISALIGNED_STORE"
-  },
-  {
-    "ArchStdEvent": "FW_ACCESS_LOAD"
-  },
-  {
-    "ArchStdEvent": "FW_ACCESS_STORE"
-  },
-  {
-    "ArchStdEvent": "FW_ILLEGAL_INSN"
-  },
-  {
-    "ArchStdEvent": "FW_SET_TIMER"
-  },
-  {
-    "ArchStdEvent": "FW_IPI_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_IPI_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_FENCE_I_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_FENCE_I_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_ASID_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_ASID_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_VMID_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_VMID_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_ASID_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_ASID_RECEIVED"
-  }
-]
+../bullet/firmware.json
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/p550/instruction.json linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/p550/instruction.json
--- linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/p550/instruction.json	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/p550/instruction.json	2025-09-11 09:47:42.000000000 -0600
@@ -1,92 +1 @@
-[
-  {
-    "EventName": "EXCEPTION_TAKEN",
-    "EventCode": "0x100",
-    "BriefDescription": "Counts exceptions taken"
-  },
-  {
-    "EventName": "INTEGER_LOAD_RETIRED",
-    "EventCode": "0x200",
-    "BriefDescription": "Counts integer load instructions retired"
-  },
-  {
-    "EventName": "INTEGER_STORE_RETIRED",
-    "EventCode": "0x400",
-    "BriefDescription": "Counts integer store instructions retired"
-  },
-  {
-    "EventName": "ATOMIC_MEMORY_RETIRED",
-    "EventCode": "0x800",
-    "BriefDescription": "Counts atomic memory instructions retired"
-  },
-  {
-    "EventName": "SYSTEM_INSTRUCTION_RETIRED",
-    "EventCode": "0x1000",
-    "BriefDescription": "Counts system instructions retired (CSR, WFI, MRET, etc.)"
-  },
-  {
-    "EventName": "INTEGER_ARITHMETIC_RETIRED",
-    "EventCode": "0x2000",
-    "BriefDescription": "Counts integer arithmetic instructions retired"
-  },
-  {
-    "EventName": "CONDITIONAL_BRANCH_RETIRED",
-    "EventCode": "0x4000",
-    "BriefDescription": "Counts conditional branch instructions retired"
-  },
-  {
-    "EventName": "JAL_INSTRUCTION_RETIRED",
-    "EventCode": "0x8000",
-    "BriefDescription": "Counts jump-and-link instructions retired"
-  },
-  {
-    "EventName": "JALR_INSTRUCTION_RETIRED",
-    "EventCode": "0x10000",
-    "BriefDescription": "Counts indirect jump instructions (JALR) retired"
-  },
-  {
-    "EventName": "INTEGER_MULTIPLICATION_RETIRED",
-    "EventCode": "0x20000",
-    "BriefDescription": "Counts integer multiplication instructions retired"
-  },
-  {
-    "EventName": "INTEGER_DIVISION_RETIRED",
-    "EventCode": "0x40000",
-    "BriefDescription": "Counts integer division instructions retired"
-  },
-  {
-    "EventName": "FP_LOAD_RETIRED",
-    "EventCode": "0x80000",
-    "BriefDescription": "Counts floating-point load instructions retired"
-  },
-  {
-    "EventName": "FP_STORE_RETIRED",
-    "EventCode": "0x100000",
-    "BriefDescription": "Counts floating-point store instructions retired"
-  },
-  {
-    "EventName": "FP_ADD_RETIRED",
-    "EventCode": "0x200000",
-    "BriefDescription": "Counts floating-point add instructions retired"
-  },
-  {
-    "EventName": "FP_MUL_RETIRED",
-    "EventCode": "0x400000",
-    "BriefDescription": "Counts floating-point multiply instructions retired"
-  },
-  {
-    "EventName": "FP_MULADD_RETIRED",
-    "EventCode": "0x800000",
-    "BriefDescription": "Counts floating-point fused multiply-add instructions retired"
-  },
-  {
-    "EventName": "FP_DIV_SQRT_RETIRED",
-    "EventCode": "0x1000000",
-    "BriefDescription": "Counts floating point divide or square root instructions retired"
-  },
-  {
-    "EventName": "OTHER_FP_RETIRED",
-    "EventCode": "0x2000000",
-    "BriefDescription": "Counts other floating-point instructions retired"
-  }
-]
+../bullet/instruction.json
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/p550/microarch.json linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/p550/microarch.json
--- linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/p550/microarch.json	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/p550/microarch.json	2025-09-11 09:47:42.000000000 -0600
@@ -1,57 +1 @@
-[
-  {
-    "EventName": "ADDRESSGEN_INTERLOCK",
-    "EventCode": "0x101",
-    "BriefDescription": "Counts cycles with an address-generation interlock"
-  },
-  {
-    "EventName": "LONGLATENCY_INTERLOCK",
-    "EventCode": "0x201",
-    "BriefDescription": "Counts cycles with a long-latency interlock"
-  },
-  {
-    "EventName": "CSR_INTERLOCK",
-    "EventCode": "0x401",
-    "BriefDescription": "Counts cycles with a CSR interlock"
-  },
-  {
-    "EventName": "ICACHE_BLOCKED",
-    "EventCode": "0x801",
-    "BriefDescription": "Counts cycles in which the instruction cache was not able to provide an instruction"
-  },
-  {
-    "EventName": "DCACHE_BLOCKED",
-    "EventCode": "0x1001",
-    "BriefDescription": "Counts cycles in which the data cache blocked an instruction"
-  },
-  {
-    "EventName": "BRANCH_DIRECTION_MISPREDICTION",
-    "EventCode": "0x2001",
-    "BriefDescription": "Counts mispredictions of conditional branch direction (taken/not taken)"
-  },
-  {
-    "EventName": "BRANCH_TARGET_MISPREDICTION",
-    "EventCode": "0x4001",
-    "BriefDescription": "Counts mispredictions of the target PC of control-flow instructions"
-  },
-  {
-    "EventName": "PIPELINE_FLUSH",
-    "EventCode": "0x8001",
-    "BriefDescription": "Counts flushes of the core pipeline. Common causes include fence.i and CSR accesses"
-  },
-  {
-    "EventName": "REPLAY",
-    "EventCode": "0x10001",
-    "BriefDescription": "Counts instruction replays"
-  },
-  {
-    "EventName": "INTEGER_MUL_DIV_INTERLOCK",
-    "EventCode": "0x20001",
-    "BriefDescription": "Counts cycles with a multiply or divide interlock"
-  },
-  {
-    "EventName": "FP_INTERLOCK",
-    "EventCode": "0x40001",
-    "BriefDescription": "Counts cycles with a floating-point interlock"
-  }
-]
+../bullet/microarch.json
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/p650/cycle-and-instruction-count.json linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/p650/cycle-and-instruction-count.json
--- linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/p650/cycle-and-instruction-count.json	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/p650/cycle-and-instruction-count.json	2025-09-11 09:47:42.000000000 -0600
@@ -1,12 +1 @@
-[
-  {
-    "EventName": "CORE_CLOCK_CYCLES",
-    "EventCode": "0x165",
-    "BriefDescription": "Counts core clock cycles"
-  },
-  {
-    "EventName": "INSTRUCTIONS_RETIRED",
-    "EventCode": "0x265",
-    "BriefDescription": "Counts instructions retired"
-  }
-]
+../bullet-07/cycle-and-instruction-count.json
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/p650/firmware.json linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/p650/firmware.json
--- linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/p650/firmware.json	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/p650/firmware.json	2025-09-11 09:47:42.000000000 -0600
@@ -1,68 +1 @@
-[
-  {
-    "ArchStdEvent": "FW_MISALIGNED_LOAD"
-  },
-  {
-    "ArchStdEvent": "FW_MISALIGNED_STORE"
-  },
-  {
-    "ArchStdEvent": "FW_ACCESS_LOAD"
-  },
-  {
-    "ArchStdEvent": "FW_ACCESS_STORE"
-  },
-  {
-    "ArchStdEvent": "FW_ILLEGAL_INSN"
-  },
-  {
-    "ArchStdEvent": "FW_SET_TIMER"
-  },
-  {
-    "ArchStdEvent": "FW_IPI_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_IPI_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_FENCE_I_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_FENCE_I_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_ASID_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_ASID_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_VMID_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_VMID_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_ASID_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_ASID_RECEIVED"
-  }
-]
+../bullet/firmware.json
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/p650/instruction.json linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/p650/instruction.json
--- linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/p650/instruction.json	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/p650/instruction.json	2025-09-11 09:47:42.000000000 -0600
@@ -1,92 +1 @@
-[
-  {
-    "EventName": "EXCEPTION_TAKEN",
-    "EventCode": "0x100",
-    "BriefDescription": "Counts exceptions taken"
-  },
-  {
-    "EventName": "INTEGER_LOAD_RETIRED",
-    "EventCode": "0x200",
-    "BriefDescription": "Counts integer load instructions retired"
-  },
-  {
-    "EventName": "INTEGER_STORE_RETIRED",
-    "EventCode": "0x400",
-    "BriefDescription": "Counts integer store instructions retired"
-  },
-  {
-    "EventName": "ATOMIC_MEMORY_RETIRED",
-    "EventCode": "0x800",
-    "BriefDescription": "Counts atomic memory instructions retired"
-  },
-  {
-    "EventName": "SYSTEM_INSTRUCTION_RETIRED",
-    "EventCode": "0x1000",
-    "BriefDescription": "Counts system instructions retired (CSR, WFI, MRET, etc.)"
-  },
-  {
-    "EventName": "INTEGER_ARITHMETIC_RETIRED",
-    "EventCode": "0x2000",
-    "BriefDescription": "Counts integer arithmetic instructions retired"
-  },
-  {
-    "EventName": "CONDITIONAL_BRANCH_RETIRED",
-    "EventCode": "0x4000",
-    "BriefDescription": "Counts conditional branch instructions retired"
-  },
-  {
-    "EventName": "JAL_INSTRUCTION_RETIRED",
-    "EventCode": "0x8000",
-    "BriefDescription": "Counts jump-and-link instructions retired"
-  },
-  {
-    "EventName": "JALR_INSTRUCTION_RETIRED",
-    "EventCode": "0x10000",
-    "BriefDescription": "Counts indirect jump instructions (JALR) retired"
-  },
-  {
-    "EventName": "INTEGER_MULTIPLICATION_RETIRED",
-    "EventCode": "0x20000",
-    "BriefDescription": "Counts integer multiplication instructions retired"
-  },
-  {
-    "EventName": "INTEGER_DIVISION_RETIRED",
-    "EventCode": "0x40000",
-    "BriefDescription": "Counts integer division instructions retired"
-  },
-  {
-    "EventName": "FP_LOAD_RETIRED",
-    "EventCode": "0x80000",
-    "BriefDescription": "Counts floating-point load instructions retired"
-  },
-  {
-    "EventName": "FP_STORE_RETIRED",
-    "EventCode": "0x100000",
-    "BriefDescription": "Counts floating-point store instructions retired"
-  },
-  {
-    "EventName": "FP_ADD_RETIRED",
-    "EventCode": "0x200000",
-    "BriefDescription": "Counts floating-point add instructions retired"
-  },
-  {
-    "EventName": "FP_MUL_RETIRED",
-    "EventCode": "0x400000",
-    "BriefDescription": "Counts floating-point multiply instructions retired"
-  },
-  {
-    "EventName": "FP_MULADD_RETIRED",
-    "EventCode": "0x800000",
-    "BriefDescription": "Counts floating-point fused multiply-add instructions retired"
-  },
-  {
-    "EventName": "FP_DIV_SQRT_RETIRED",
-    "EventCode": "0x1000000",
-    "BriefDescription": "Counts floating point divide or square root instructions retired"
-  },
-  {
-    "EventName": "OTHER_FP_RETIRED",
-    "EventCode": "0x2000000",
-    "BriefDescription": "Counts other floating-point instructions retired"
-  }
-]
+../bullet/instruction.json
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/p650/watchpoint.json linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/p650/watchpoint.json
--- linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/p650/watchpoint.json	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/p650/watchpoint.json	2025-09-11 09:47:42.000000000 -0600
@@ -1,42 +1 @@
-[
-  {
-    "EventName": "WATCHPOINT_0",
-    "EventCode": "0x164",
-    "BriefDescription": "Counts occurrences of watchpoint 0 with action=8"
-  },
-  {
-    "EventName": "WATCHPOINT_1",
-    "EventCode": "0x264",
-    "BriefDescription": "Counts occurrences of watchpoint 1 with action=8"
-  },
-  {
-    "EventName": "WATCHPOINT_2",
-    "EventCode": "0x464",
-    "BriefDescription": "Counts occurrences of watchpoint 2 with action=8"
-  },
-  {
-    "EventName": "WATCHPOINT_3",
-    "EventCode": "0x864",
-    "BriefDescription": "Counts occurrences of watchpoint 3 with action=8"
-  },
-  {
-    "EventName": "WATCHPOINT_4",
-    "EventCode": "0x1064",
-    "BriefDescription": "Counts occurrences of watchpoint 4 with action=8"
-  },
-  {
-    "EventName": "WATCHPOINT_5",
-    "EventCode": "0x2064",
-    "BriefDescription": "Counts occurrences of watchpoint 5 with action=8"
-  },
-  {
-    "EventName": "WATCHPOINT_6",
-    "EventCode": "0x4064",
-    "BriefDescription": "Counts occurrences of watchpoint 6 with action=8"
-  },
-  {
-    "EventName": "WATCHPOINT_7",
-    "EventCode": "0x8064",
-    "BriefDescription": "Counts occurrences of watchpoint 7 with action=8"
-  }
-]
+../bullet-07/watchpoint.json
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/bpf/disasm.c linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/bpf/disasm.c
--- linux-6.16.7/tools/testing/selftests/bpf/disasm.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/bpf/disasm.c	2025-09-11 09:47:42.000000000 -0600
@@ -1,390 +1 @@
-// SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
-/* Copyright (c) 2011-2014 PLUMgrid, http://plumgrid.com
- * Copyright (c) 2016 Facebook
- */
-
-#include <linux/bpf.h>
-
-#include "disasm.h"
-
-#define __BPF_FUNC_STR_FN(x) [BPF_FUNC_ ## x] = __stringify(bpf_ ## x)
-static const char * const func_id_str[] = {
-	__BPF_FUNC_MAPPER(__BPF_FUNC_STR_FN)
-};
-#undef __BPF_FUNC_STR_FN
-
-static const char *__func_get_name(const struct bpf_insn_cbs *cbs,
-				   const struct bpf_insn *insn,
-				   char *buff, size_t len)
-{
-	BUILD_BUG_ON(ARRAY_SIZE(func_id_str) != __BPF_FUNC_MAX_ID);
-
-	if (!insn->src_reg &&
-	    insn->imm >= 0 && insn->imm < __BPF_FUNC_MAX_ID &&
-	    func_id_str[insn->imm])
-		return func_id_str[insn->imm];
-
-	if (cbs && cbs->cb_call) {
-		const char *res;
-
-		res = cbs->cb_call(cbs->private_data, insn);
-		if (res)
-			return res;
-	}
-
-	if (insn->src_reg == BPF_PSEUDO_CALL)
-		snprintf(buff, len, "%+d", insn->imm);
-	else if (insn->src_reg == BPF_PSEUDO_KFUNC_CALL)
-		snprintf(buff, len, "kernel-function");
-
-	return buff;
-}
-
-static const char *__func_imm_name(const struct bpf_insn_cbs *cbs,
-				   const struct bpf_insn *insn,
-				   u64 full_imm, char *buff, size_t len)
-{
-	if (cbs && cbs->cb_imm)
-		return cbs->cb_imm(cbs->private_data, insn, full_imm);
-
-	snprintf(buff, len, "0x%llx", (unsigned long long)full_imm);
-	return buff;
-}
-
-const char *func_id_name(int id)
-{
-	if (id >= 0 && id < __BPF_FUNC_MAX_ID && func_id_str[id])
-		return func_id_str[id];
-	else
-		return "unknown";
-}
-
-const char *const bpf_class_string[8] = {
-	[BPF_LD]    = "ld",
-	[BPF_LDX]   = "ldx",
-	[BPF_ST]    = "st",
-	[BPF_STX]   = "stx",
-	[BPF_ALU]   = "alu",
-	[BPF_JMP]   = "jmp",
-	[BPF_JMP32] = "jmp32",
-	[BPF_ALU64] = "alu64",
-};
-
-const char *const bpf_alu_string[16] = {
-	[BPF_ADD >> 4]  = "+=",
-	[BPF_SUB >> 4]  = "-=",
-	[BPF_MUL >> 4]  = "*=",
-	[BPF_DIV >> 4]  = "/=",
-	[BPF_OR  >> 4]  = "|=",
-	[BPF_AND >> 4]  = "&=",
-	[BPF_LSH >> 4]  = "<<=",
-	[BPF_RSH >> 4]  = ">>=",
-	[BPF_NEG >> 4]  = "neg",
-	[BPF_MOD >> 4]  = "%=",
-	[BPF_XOR >> 4]  = "^=",
-	[BPF_MOV >> 4]  = "=",
-	[BPF_ARSH >> 4] = "s>>=",
-	[BPF_END >> 4]  = "endian",
-};
-
-static const char *const bpf_alu_sign_string[16] = {
-	[BPF_DIV >> 4]  = "s/=",
-	[BPF_MOD >> 4]  = "s%=",
-};
-
-static const char *const bpf_movsx_string[4] = {
-	[0] = "(s8)",
-	[1] = "(s16)",
-	[3] = "(s32)",
-};
-
-static const char *const bpf_atomic_alu_string[16] = {
-	[BPF_ADD >> 4]  = "add",
-	[BPF_AND >> 4]  = "and",
-	[BPF_OR >> 4]  = "or",
-	[BPF_XOR >> 4]  = "xor",
-};
-
-static const char *const bpf_ldst_string[] = {
-	[BPF_W >> 3]  = "u32",
-	[BPF_H >> 3]  = "u16",
-	[BPF_B >> 3]  = "u8",
-	[BPF_DW >> 3] = "u64",
-};
-
-static const char *const bpf_ldsx_string[] = {
-	[BPF_W >> 3]  = "s32",
-	[BPF_H >> 3]  = "s16",
-	[BPF_B >> 3]  = "s8",
-};
-
-static const char *const bpf_jmp_string[16] = {
-	[BPF_JA >> 4]   = "jmp",
-	[BPF_JEQ >> 4]  = "==",
-	[BPF_JGT >> 4]  = ">",
-	[BPF_JLT >> 4]  = "<",
-	[BPF_JGE >> 4]  = ">=",
-	[BPF_JLE >> 4]  = "<=",
-	[BPF_JSET >> 4] = "&",
-	[BPF_JNE >> 4]  = "!=",
-	[BPF_JSGT >> 4] = "s>",
-	[BPF_JSLT >> 4] = "s<",
-	[BPF_JSGE >> 4] = "s>=",
-	[BPF_JSLE >> 4] = "s<=",
-	[BPF_CALL >> 4] = "call",
-	[BPF_EXIT >> 4] = "exit",
-};
-
-static void print_bpf_end_insn(bpf_insn_print_t verbose,
-			       void *private_data,
-			       const struct bpf_insn *insn)
-{
-	verbose(private_data, "(%02x) r%d = %s%d r%d\n",
-		insn->code, insn->dst_reg,
-		BPF_SRC(insn->code) == BPF_TO_BE ? "be" : "le",
-		insn->imm, insn->dst_reg);
-}
-
-static void print_bpf_bswap_insn(bpf_insn_print_t verbose,
-			       void *private_data,
-			       const struct bpf_insn *insn)
-{
-	verbose(private_data, "(%02x) r%d = bswap%d r%d\n",
-		insn->code, insn->dst_reg,
-		insn->imm, insn->dst_reg);
-}
-
-static bool is_sdiv_smod(const struct bpf_insn *insn)
-{
-	return (BPF_OP(insn->code)  == BPF_DIV || BPF_OP(insn->code) == BPF_MOD) &&
-	       insn->off == 1;
-}
-
-static bool is_movsx(const struct bpf_insn *insn)
-{
-	return BPF_OP(insn->code) == BPF_MOV &&
-	       (insn->off == 8 || insn->off == 16 || insn->off == 32);
-}
-
-static bool is_addr_space_cast(const struct bpf_insn *insn)
-{
-	return insn->code == (BPF_ALU64 | BPF_MOV | BPF_X) &&
-		insn->off == BPF_ADDR_SPACE_CAST;
-}
-
-/* Special (internal-only) form of mov, used to resolve per-CPU addrs:
- * dst_reg = src_reg + <percpu_base_off>
- * BPF_ADDR_PERCPU is used as a special insn->off value.
- */
-#define BPF_ADDR_PERCPU	(-1)
-
-static inline bool is_mov_percpu_addr(const struct bpf_insn *insn)
-{
-	return insn->code == (BPF_ALU64 | BPF_MOV | BPF_X) && insn->off == BPF_ADDR_PERCPU;
-}
-
-void print_bpf_insn(const struct bpf_insn_cbs *cbs,
-		    const struct bpf_insn *insn,
-		    bool allow_ptr_leaks)
-{
-	const bpf_insn_print_t verbose = cbs->cb_print;
-	u8 class = BPF_CLASS(insn->code);
-
-	if (class == BPF_ALU || class == BPF_ALU64) {
-		if (BPF_OP(insn->code) == BPF_END) {
-			if (class == BPF_ALU64)
-				print_bpf_bswap_insn(verbose, cbs->private_data, insn);
-			else
-				print_bpf_end_insn(verbose, cbs->private_data, insn);
-		} else if (BPF_OP(insn->code) == BPF_NEG) {
-			verbose(cbs->private_data, "(%02x) %c%d = -%c%d\n",
-				insn->code, class == BPF_ALU ? 'w' : 'r',
-				insn->dst_reg, class == BPF_ALU ? 'w' : 'r',
-				insn->dst_reg);
-		} else if (is_addr_space_cast(insn)) {
-			verbose(cbs->private_data, "(%02x) r%d = addr_space_cast(r%d, %u, %u)\n",
-				insn->code, insn->dst_reg,
-				insn->src_reg, ((u32)insn->imm) >> 16, (u16)insn->imm);
-		} else if (is_mov_percpu_addr(insn)) {
-			verbose(cbs->private_data, "(%02x) r%d = &(void __percpu *)(r%d)\n",
-				insn->code, insn->dst_reg, insn->src_reg);
-		} else if (BPF_SRC(insn->code) == BPF_X) {
-			verbose(cbs->private_data, "(%02x) %c%d %s %s%c%d\n",
-				insn->code, class == BPF_ALU ? 'w' : 'r',
-				insn->dst_reg,
-				is_sdiv_smod(insn) ? bpf_alu_sign_string[BPF_OP(insn->code) >> 4]
-						   : bpf_alu_string[BPF_OP(insn->code) >> 4],
-				is_movsx(insn) ? bpf_movsx_string[(insn->off >> 3) - 1] : "",
-				class == BPF_ALU ? 'w' : 'r',
-				insn->src_reg);
-		} else {
-			verbose(cbs->private_data, "(%02x) %c%d %s %d\n",
-				insn->code, class == BPF_ALU ? 'w' : 'r',
-				insn->dst_reg,
-				is_sdiv_smod(insn) ? bpf_alu_sign_string[BPF_OP(insn->code) >> 4]
-						   : bpf_alu_string[BPF_OP(insn->code) >> 4],
-				insn->imm);
-		}
-	} else if (class == BPF_STX) {
-		if (BPF_MODE(insn->code) == BPF_MEM)
-			verbose(cbs->private_data, "(%02x) *(%s *)(r%d %+d) = r%d\n",
-				insn->code,
-				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
-				insn->dst_reg,
-				insn->off, insn->src_reg);
-		else if (BPF_MODE(insn->code) == BPF_ATOMIC &&
-			 (insn->imm == BPF_ADD || insn->imm == BPF_AND ||
-			  insn->imm == BPF_OR || insn->imm == BPF_XOR)) {
-			verbose(cbs->private_data, "(%02x) lock *(%s *)(r%d %+d) %s r%d\n",
-				insn->code,
-				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
-				insn->dst_reg, insn->off,
-				bpf_alu_string[BPF_OP(insn->imm) >> 4],
-				insn->src_reg);
-		} else if (BPF_MODE(insn->code) == BPF_ATOMIC &&
-			   (insn->imm == (BPF_ADD | BPF_FETCH) ||
-			    insn->imm == (BPF_AND | BPF_FETCH) ||
-			    insn->imm == (BPF_OR | BPF_FETCH) ||
-			    insn->imm == (BPF_XOR | BPF_FETCH))) {
-			verbose(cbs->private_data, "(%02x) r%d = atomic%s_fetch_%s((%s *)(r%d %+d), r%d)\n",
-				insn->code, insn->src_reg,
-				BPF_SIZE(insn->code) == BPF_DW ? "64" : "",
-				bpf_atomic_alu_string[BPF_OP(insn->imm) >> 4],
-				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
-				insn->dst_reg, insn->off, insn->src_reg);
-		} else if (BPF_MODE(insn->code) == BPF_ATOMIC &&
-			   insn->imm == BPF_CMPXCHG) {
-			verbose(cbs->private_data, "(%02x) r0 = atomic%s_cmpxchg((%s *)(r%d %+d), r0, r%d)\n",
-				insn->code,
-				BPF_SIZE(insn->code) == BPF_DW ? "64" : "",
-				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
-				insn->dst_reg, insn->off,
-				insn->src_reg);
-		} else if (BPF_MODE(insn->code) == BPF_ATOMIC &&
-			   insn->imm == BPF_XCHG) {
-			verbose(cbs->private_data, "(%02x) r%d = atomic%s_xchg((%s *)(r%d %+d), r%d)\n",
-				insn->code, insn->src_reg,
-				BPF_SIZE(insn->code) == BPF_DW ? "64" : "",
-				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
-				insn->dst_reg, insn->off, insn->src_reg);
-		} else if (BPF_MODE(insn->code) == BPF_ATOMIC &&
-			   insn->imm == BPF_LOAD_ACQ) {
-			verbose(cbs->private_data, "(%02x) r%d = load_acquire((%s *)(r%d %+d))\n",
-				insn->code, insn->dst_reg,
-				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
-				insn->src_reg, insn->off);
-		} else if (BPF_MODE(insn->code) == BPF_ATOMIC &&
-			   insn->imm == BPF_STORE_REL) {
-			verbose(cbs->private_data, "(%02x) store_release((%s *)(r%d %+d), r%d)\n",
-				insn->code,
-				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
-				insn->dst_reg, insn->off, insn->src_reg);
-		} else {
-			verbose(cbs->private_data, "BUG_%02x\n", insn->code);
-		}
-	} else if (class == BPF_ST) {
-		if (BPF_MODE(insn->code) == BPF_MEM) {
-			verbose(cbs->private_data, "(%02x) *(%s *)(r%d %+d) = %d\n",
-				insn->code,
-				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
-				insn->dst_reg,
-				insn->off, insn->imm);
-		} else if (BPF_MODE(insn->code) == 0xc0 /* BPF_NOSPEC, no UAPI */) {
-			verbose(cbs->private_data, "(%02x) nospec\n", insn->code);
-		} else {
-			verbose(cbs->private_data, "BUG_st_%02x\n", insn->code);
-		}
-	} else if (class == BPF_LDX) {
-		if (BPF_MODE(insn->code) != BPF_MEM && BPF_MODE(insn->code) != BPF_MEMSX) {
-			verbose(cbs->private_data, "BUG_ldx_%02x\n", insn->code);
-			return;
-		}
-		verbose(cbs->private_data, "(%02x) r%d = *(%s *)(r%d %+d)\n",
-			insn->code, insn->dst_reg,
-			BPF_MODE(insn->code) == BPF_MEM ?
-				 bpf_ldst_string[BPF_SIZE(insn->code) >> 3] :
-				 bpf_ldsx_string[BPF_SIZE(insn->code) >> 3],
-			insn->src_reg, insn->off);
-	} else if (class == BPF_LD) {
-		if (BPF_MODE(insn->code) == BPF_ABS) {
-			verbose(cbs->private_data, "(%02x) r0 = *(%s *)skb[%d]\n",
-				insn->code,
-				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
-				insn->imm);
-		} else if (BPF_MODE(insn->code) == BPF_IND) {
-			verbose(cbs->private_data, "(%02x) r0 = *(%s *)skb[r%d + %d]\n",
-				insn->code,
-				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
-				insn->src_reg, insn->imm);
-		} else if (BPF_MODE(insn->code) == BPF_IMM &&
-			   BPF_SIZE(insn->code) == BPF_DW) {
-			/* At this point, we already made sure that the second
-			 * part of the ldimm64 insn is accessible.
-			 */
-			u64 imm = ((u64)(insn + 1)->imm << 32) | (u32)insn->imm;
-			bool is_ptr = insn->src_reg == BPF_PSEUDO_MAP_FD ||
-				      insn->src_reg == BPF_PSEUDO_MAP_VALUE;
-			char tmp[64];
-
-			if (is_ptr && !allow_ptr_leaks)
-				imm = 0;
-
-			verbose(cbs->private_data, "(%02x) r%d = %s\n",
-				insn->code, insn->dst_reg,
-				__func_imm_name(cbs, insn, imm,
-						tmp, sizeof(tmp)));
-		} else {
-			verbose(cbs->private_data, "BUG_ld_%02x\n", insn->code);
-			return;
-		}
-	} else if (class == BPF_JMP32 || class == BPF_JMP) {
-		u8 opcode = BPF_OP(insn->code);
-
-		if (opcode == BPF_CALL) {
-			char tmp[64];
-
-			if (insn->src_reg == BPF_PSEUDO_CALL) {
-				verbose(cbs->private_data, "(%02x) call pc%s\n",
-					insn->code,
-					__func_get_name(cbs, insn,
-							tmp, sizeof(tmp)));
-			} else {
-				strcpy(tmp, "unknown");
-				verbose(cbs->private_data, "(%02x) call %s#%d\n", insn->code,
-					__func_get_name(cbs, insn,
-							tmp, sizeof(tmp)),
-					insn->imm);
-			}
-		} else if (insn->code == (BPF_JMP | BPF_JA)) {
-			verbose(cbs->private_data, "(%02x) goto pc%+d\n",
-				insn->code, insn->off);
-		} else if (insn->code == (BPF_JMP | BPF_JCOND) &&
-			   insn->src_reg == BPF_MAY_GOTO) {
-			verbose(cbs->private_data, "(%02x) may_goto pc%+d\n",
-				insn->code, insn->off);
-		} else if (insn->code == (BPF_JMP32 | BPF_JA)) {
-			verbose(cbs->private_data, "(%02x) gotol pc%+d\n",
-				insn->code, insn->imm);
-		} else if (insn->code == (BPF_JMP | BPF_EXIT)) {
-			verbose(cbs->private_data, "(%02x) exit\n", insn->code);
-		} else if (BPF_SRC(insn->code) == BPF_X) {
-			verbose(cbs->private_data,
-				"(%02x) if %c%d %s %c%d goto pc%+d\n",
-				insn->code, class == BPF_JMP32 ? 'w' : 'r',
-				insn->dst_reg,
-				bpf_jmp_string[BPF_OP(insn->code) >> 4],
-				class == BPF_JMP32 ? 'w' : 'r',
-				insn->src_reg, insn->off);
-		} else {
-			verbose(cbs->private_data,
-				"(%02x) if %c%d %s 0x%x goto pc%+d\n",
-				insn->code, class == BPF_JMP32 ? 'w' : 'r',
-				insn->dst_reg,
-				bpf_jmp_string[BPF_OP(insn->code) >> 4],
-				(u32)insn->imm, insn->off);
-		}
-	} else {
-		verbose(cbs->private_data, "(%02x) %s\n",
-			insn->code, bpf_class_string[class]);
-	}
-}
+../../../../kernel/bpf/disasm.c
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/bpf/disasm.h linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/bpf/disasm.h
--- linux-6.16.7/tools/testing/selftests/bpf/disasm.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/bpf/disasm.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,40 +1 @@
-/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */
-/* Copyright (c) 2011-2014 PLUMgrid, http://plumgrid.com
- * Copyright (c) 2016 Facebook
- */
-
-#ifndef __BPF_DISASM_H__
-#define __BPF_DISASM_H__
-
-#include <linux/bpf.h>
-#include <linux/kernel.h>
-#include <linux/stringify.h>
-#ifndef __KERNEL__
-#include <stdio.h>
-#include <string.h>
-#endif
-
-extern const char *const bpf_alu_string[16];
-extern const char *const bpf_class_string[8];
-
-const char *func_id_name(int id);
-
-typedef __printf(2, 3) void (*bpf_insn_print_t)(void *private_data,
-						const char *, ...);
-typedef const char *(*bpf_insn_revmap_call_t)(void *private_data,
-					      const struct bpf_insn *insn);
-typedef const char *(*bpf_insn_print_imm_t)(void *private_data,
-					    const struct bpf_insn *insn,
-					    __u64 full_imm);
-
-struct bpf_insn_cbs {
-	bpf_insn_print_t	cb_print;
-	bpf_insn_revmap_call_t	cb_call;
-	bpf_insn_print_imm_t	cb_imm;
-	void			*private_data;
-};
-
-void print_bpf_insn(const struct bpf_insn_cbs *cbs,
-		    const struct bpf_insn *insn,
-		    bool allow_ptr_leaks);
-#endif
+../../../../kernel/bpf/disasm.h
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/bpf/json_writer.c linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/bpf/json_writer.c
--- linux-6.16.7/tools/testing/selftests/bpf/json_writer.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/bpf/json_writer.c	2025-09-11 09:47:42.000000000 -0600
@@ -1,355 +1 @@
-// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-2-Clause)
-/*
- * Simple streaming JSON writer
- *
- * This takes care of the annoying bits of JSON syntax like the commas
- * after elements
- *
- * Authors:	Stephen Hemminger <stephen@networkplumber.org>
- */
-
-#include <stdio.h>
-#include <stdbool.h>
-#include <stdarg.h>
-#include <assert.h>
-#include <malloc.h>
-#include <inttypes.h>
-#include <stdint.h>
-
-#include "json_writer.h"
-
-struct json_writer {
-	FILE		*out;	/* output file */
-	unsigned	depth;  /* nesting */
-	bool		pretty; /* optional whitepace */
-	char		sep;	/* either nul or comma */
-};
-
-/* indentation for pretty print */
-static void jsonw_indent(json_writer_t *self)
-{
-	unsigned i;
-	for (i = 0; i < self->depth; ++i)
-		fputs("    ", self->out);
-}
-
-/* end current line and indent if pretty printing */
-static void jsonw_eol(json_writer_t *self)
-{
-	if (!self->pretty)
-		return;
-
-	putc('\n', self->out);
-	jsonw_indent(self);
-}
-
-/* If current object is not empty print a comma */
-static void jsonw_eor(json_writer_t *self)
-{
-	if (self->sep != '\0')
-		putc(self->sep, self->out);
-	self->sep = ',';
-}
-
-
-/* Output JSON encoded string */
-/* Handles C escapes, does not do Unicode */
-static void jsonw_puts(json_writer_t *self, const char *str)
-{
-	putc('"', self->out);
-	for (; *str; ++str)
-		switch (*str) {
-		case '\t':
-			fputs("\\t", self->out);
-			break;
-		case '\n':
-			fputs("\\n", self->out);
-			break;
-		case '\r':
-			fputs("\\r", self->out);
-			break;
-		case '\f':
-			fputs("\\f", self->out);
-			break;
-		case '\b':
-			fputs("\\b", self->out);
-			break;
-		case '\\':
-			fputs("\\\\", self->out);
-			break;
-		case '"':
-			fputs("\\\"", self->out);
-			break;
-		default:
-			putc(*str, self->out);
-		}
-	putc('"', self->out);
-}
-
-/* Create a new JSON stream */
-json_writer_t *jsonw_new(FILE *f)
-{
-	json_writer_t *self = malloc(sizeof(*self));
-	if (self) {
-		self->out = f;
-		self->depth = 0;
-		self->pretty = false;
-		self->sep = '\0';
-	}
-	return self;
-}
-
-/* End output to JSON stream */
-void jsonw_destroy(json_writer_t **self_p)
-{
-	json_writer_t *self = *self_p;
-
-	assert(self->depth == 0);
-	fputs("\n", self->out);
-	fflush(self->out);
-	free(self);
-	*self_p = NULL;
-}
-
-void jsonw_pretty(json_writer_t *self, bool on)
-{
-	self->pretty = on;
-}
-
-void jsonw_reset(json_writer_t *self)
-{
-	assert(self->depth == 0);
-	self->sep = '\0';
-}
-
-/* Basic blocks */
-static void jsonw_begin(json_writer_t *self, int c)
-{
-	jsonw_eor(self);
-	putc(c, self->out);
-	++self->depth;
-	self->sep = '\0';
-}
-
-static void jsonw_end(json_writer_t *self, int c)
-{
-	assert(self->depth > 0);
-
-	--self->depth;
-	if (self->sep != '\0')
-		jsonw_eol(self);
-	putc(c, self->out);
-	self->sep = ',';
-}
-
-
-/* Add a JSON property name */
-void jsonw_name(json_writer_t *self, const char *name)
-{
-	jsonw_eor(self);
-	jsonw_eol(self);
-	self->sep = '\0';
-	jsonw_puts(self, name);
-	putc(':', self->out);
-	if (self->pretty)
-		putc(' ', self->out);
-}
-
-void jsonw_vprintf_enquote(json_writer_t *self, const char *fmt, va_list ap)
-{
-	jsonw_eor(self);
-	putc('"', self->out);
-	vfprintf(self->out, fmt, ap);
-	putc('"', self->out);
-}
-
-void jsonw_printf(json_writer_t *self, const char *fmt, ...)
-{
-	va_list ap;
-
-	va_start(ap, fmt);
-	jsonw_eor(self);
-	vfprintf(self->out, fmt, ap);
-	va_end(ap);
-}
-
-/* Collections */
-void jsonw_start_object(json_writer_t *self)
-{
-	jsonw_begin(self, '{');
-}
-
-void jsonw_end_object(json_writer_t *self)
-{
-	jsonw_end(self, '}');
-}
-
-void jsonw_start_array(json_writer_t *self)
-{
-	jsonw_begin(self, '[');
-}
-
-void jsonw_end_array(json_writer_t *self)
-{
-	jsonw_end(self, ']');
-}
-
-/* JSON value types */
-void jsonw_string(json_writer_t *self, const char *value)
-{
-	jsonw_eor(self);
-	jsonw_puts(self, value);
-}
-
-void jsonw_bool(json_writer_t *self, bool val)
-{
-	jsonw_printf(self, "%s", val ? "true" : "false");
-}
-
-void jsonw_null(json_writer_t *self)
-{
-	jsonw_printf(self, "null");
-}
-
-void jsonw_float_fmt(json_writer_t *self, const char *fmt, double num)
-{
-	jsonw_printf(self, fmt, num);
-}
-
-#ifdef notused
-void jsonw_float(json_writer_t *self, double num)
-{
-	jsonw_printf(self, "%g", num);
-}
-#endif
-
-void jsonw_hu(json_writer_t *self, unsigned short num)
-{
-	jsonw_printf(self, "%hu", num);
-}
-
-void jsonw_uint(json_writer_t *self, uint64_t num)
-{
-	jsonw_printf(self, "%"PRIu64, num);
-}
-
-void jsonw_lluint(json_writer_t *self, unsigned long long int num)
-{
-	jsonw_printf(self, "%llu", num);
-}
-
-void jsonw_int(json_writer_t *self, int64_t num)
-{
-	jsonw_printf(self, "%"PRId64, num);
-}
-
-/* Basic name/value objects */
-void jsonw_string_field(json_writer_t *self, const char *prop, const char *val)
-{
-	jsonw_name(self, prop);
-	jsonw_string(self, val);
-}
-
-void jsonw_bool_field(json_writer_t *self, const char *prop, bool val)
-{
-	jsonw_name(self, prop);
-	jsonw_bool(self, val);
-}
-
-#ifdef notused
-void jsonw_float_field(json_writer_t *self, const char *prop, double val)
-{
-	jsonw_name(self, prop);
-	jsonw_float(self, val);
-}
-#endif
-
-void jsonw_float_field_fmt(json_writer_t *self,
-			   const char *prop,
-			   const char *fmt,
-			   double val)
-{
-	jsonw_name(self, prop);
-	jsonw_float_fmt(self, fmt, val);
-}
-
-void jsonw_uint_field(json_writer_t *self, const char *prop, uint64_t num)
-{
-	jsonw_name(self, prop);
-	jsonw_uint(self, num);
-}
-
-void jsonw_hu_field(json_writer_t *self, const char *prop, unsigned short num)
-{
-	jsonw_name(self, prop);
-	jsonw_hu(self, num);
-}
-
-void jsonw_lluint_field(json_writer_t *self,
-			const char *prop,
-			unsigned long long int num)
-{
-	jsonw_name(self, prop);
-	jsonw_lluint(self, num);
-}
-
-void jsonw_int_field(json_writer_t *self, const char *prop, int64_t num)
-{
-	jsonw_name(self, prop);
-	jsonw_int(self, num);
-}
-
-void jsonw_null_field(json_writer_t *self, const char *prop)
-{
-	jsonw_name(self, prop);
-	jsonw_null(self);
-}
-
-#ifdef TEST
-int main(int argc, char **argv)
-{
-	json_writer_t *wr = jsonw_new(stdout);
-
-	jsonw_start_object(wr);
-	jsonw_pretty(wr, true);
-	jsonw_name(wr, "Vyatta");
-	jsonw_start_object(wr);
-	jsonw_string_field(wr, "url", "http://vyatta.com");
-	jsonw_uint_field(wr, "downloads", 2000000ul);
-	jsonw_float_field(wr, "stock", 8.16);
-
-	jsonw_name(wr, "ARGV");
-	jsonw_start_array(wr);
-	while (--argc)
-		jsonw_string(wr, *++argv);
-	jsonw_end_array(wr);
-
-	jsonw_name(wr, "empty");
-	jsonw_start_array(wr);
-	jsonw_end_array(wr);
-
-	jsonw_name(wr, "NIL");
-	jsonw_start_object(wr);
-	jsonw_end_object(wr);
-
-	jsonw_null_field(wr, "my_null");
-
-	jsonw_name(wr, "special chars");
-	jsonw_start_array(wr);
-	jsonw_string_field(wr, "slash", "/");
-	jsonw_string_field(wr, "newline", "\n");
-	jsonw_string_field(wr, "tab", "\t");
-	jsonw_string_field(wr, "ff", "\f");
-	jsonw_string_field(wr, "quote", "\"");
-	jsonw_string_field(wr, "tick", "\'");
-	jsonw_string_field(wr, "backslash", "\\");
-	jsonw_end_array(wr);
-
-	jsonw_end_object(wr);
-
-	jsonw_end_object(wr);
-	jsonw_destroy(&wr);
-	return 0;
-}
-
-#endif
+../../../bpf/bpftool/json_writer.c
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/bpf/json_writer.h linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/bpf/json_writer.h
--- linux-6.16.7/tools/testing/selftests/bpf/json_writer.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/bpf/json_writer.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,74 +1 @@
-/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */
-/*
- * Simple streaming JSON writer
- *
- * This takes care of the annoying bits of JSON syntax like the commas
- * after elements
- *
- * Authors:	Stephen Hemminger <stephen@networkplumber.org>
- */
-
-#ifndef _JSON_WRITER_H_
-#define _JSON_WRITER_H_
-
-#include <stdbool.h>
-#include <stdint.h>
-#include <stdarg.h>
-#include <stdio.h>
-#include <linux/compiler.h>
-
-/* Opaque class structure */
-typedef struct json_writer json_writer_t;
-
-/* Create a new JSON stream */
-json_writer_t *jsonw_new(FILE *f);
-/* End output to JSON stream */
-void jsonw_destroy(json_writer_t **self_p);
-
-/* Cause output to have pretty whitespace */
-void jsonw_pretty(json_writer_t *self, bool on);
-
-/* Reset separator to create new JSON */
-void jsonw_reset(json_writer_t *self);
-
-/* Add property name */
-void jsonw_name(json_writer_t *self, const char *name);
-
-/* Add value  */
-void __printf(2, 0) jsonw_vprintf_enquote(json_writer_t *self, const char *fmt,
-					  va_list ap);
-void __printf(2, 3) jsonw_printf(json_writer_t *self, const char *fmt, ...);
-void jsonw_string(json_writer_t *self, const char *value);
-void jsonw_bool(json_writer_t *self, bool value);
-void jsonw_float(json_writer_t *self, double number);
-void jsonw_float_fmt(json_writer_t *self, const char *fmt, double num);
-void jsonw_uint(json_writer_t *self, uint64_t number);
-void jsonw_hu(json_writer_t *self, unsigned short number);
-void jsonw_int(json_writer_t *self, int64_t number);
-void jsonw_null(json_writer_t *self);
-void jsonw_lluint(json_writer_t *self, unsigned long long int num);
-
-/* Useful Combinations of name and value */
-void jsonw_string_field(json_writer_t *self, const char *prop, const char *val);
-void jsonw_bool_field(json_writer_t *self, const char *prop, bool value);
-void jsonw_float_field(json_writer_t *self, const char *prop, double num);
-void jsonw_uint_field(json_writer_t *self, const char *prop, uint64_t num);
-void jsonw_hu_field(json_writer_t *self, const char *prop, unsigned short num);
-void jsonw_int_field(json_writer_t *self, const char *prop, int64_t num);
-void jsonw_null_field(json_writer_t *self, const char *prop);
-void jsonw_lluint_field(json_writer_t *self, const char *prop,
-			unsigned long long int num);
-void jsonw_float_field_fmt(json_writer_t *self, const char *prop,
-			   const char *fmt, double val);
-
-/* Collections */
-void jsonw_start_object(json_writer_t *self);
-void jsonw_end_object(json_writer_t *self);
-
-void jsonw_start_array(json_writer_t *self);
-void jsonw_end_array(json_writer_t *self);
-
-/* Override default exception handling */
-typedef void (jsonw_err_handler_fn)(const char *);
-
-#endif /* _JSON_WRITER_H_ */
+../../../bpf/bpftool/json_writer.h
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/drivers/net/dsa/bridge_locked_port.sh linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/bridge_locked_port.sh
--- linux-6.16.7/tools/testing/selftests/drivers/net/dsa/bridge_locked_port.sh	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/bridge_locked_port.sh	2025-09-11 09:47:42.000000000 -0600
@@ -1,9 +1 @@
-#!/bin/bash
-# SPDX-License-Identifier: GPL-2.0
-
-libdir=$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")
-testname=$(basename "${BASH_SOURCE[0]}")
-
-source "$libdir"/forwarding.config
-cd "$libdir"/../../../net/forwarding/ || exit 1
-source "./$testname" "$@"
+run_net_forwarding_test.sh
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/drivers/net/dsa/bridge_mdb.sh linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/bridge_mdb.sh
--- linux-6.16.7/tools/testing/selftests/drivers/net/dsa/bridge_mdb.sh	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/bridge_mdb.sh	2025-09-11 09:47:42.000000000 -0600
@@ -1,9 +1 @@
-#!/bin/bash
-# SPDX-License-Identifier: GPL-2.0
-
-libdir=$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")
-testname=$(basename "${BASH_SOURCE[0]}")
-
-source "$libdir"/forwarding.config
-cd "$libdir"/../../../net/forwarding/ || exit 1
-source "./$testname" "$@"
+run_net_forwarding_test.sh
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/drivers/net/dsa/bridge_mld.sh linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/bridge_mld.sh
--- linux-6.16.7/tools/testing/selftests/drivers/net/dsa/bridge_mld.sh	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/bridge_mld.sh	2025-09-11 09:47:42.000000000 -0600
@@ -1,9 +1 @@
-#!/bin/bash
-# SPDX-License-Identifier: GPL-2.0
-
-libdir=$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")
-testname=$(basename "${BASH_SOURCE[0]}")
-
-source "$libdir"/forwarding.config
-cd "$libdir"/../../../net/forwarding/ || exit 1
-source "./$testname" "$@"
+run_net_forwarding_test.sh
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/drivers/net/dsa/bridge_vlan_aware.sh linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/bridge_vlan_aware.sh
--- linux-6.16.7/tools/testing/selftests/drivers/net/dsa/bridge_vlan_aware.sh	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/bridge_vlan_aware.sh	2025-09-11 09:47:42.000000000 -0600
@@ -1,9 +1 @@
-#!/bin/bash
-# SPDX-License-Identifier: GPL-2.0
-
-libdir=$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")
-testname=$(basename "${BASH_SOURCE[0]}")
-
-source "$libdir"/forwarding.config
-cd "$libdir"/../../../net/forwarding/ || exit 1
-source "./$testname" "$@"
+run_net_forwarding_test.sh
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/drivers/net/dsa/bridge_vlan_mcast.sh linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/bridge_vlan_mcast.sh
--- linux-6.16.7/tools/testing/selftests/drivers/net/dsa/bridge_vlan_mcast.sh	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/bridge_vlan_mcast.sh	2025-09-11 09:47:42.000000000 -0600
@@ -1,9 +1 @@
-#!/bin/bash
-# SPDX-License-Identifier: GPL-2.0
-
-libdir=$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")
-testname=$(basename "${BASH_SOURCE[0]}")
-
-source "$libdir"/forwarding.config
-cd "$libdir"/../../../net/forwarding/ || exit 1
-source "./$testname" "$@"
+run_net_forwarding_test.sh
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/drivers/net/dsa/bridge_vlan_unaware.sh linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/bridge_vlan_unaware.sh
--- linux-6.16.7/tools/testing/selftests/drivers/net/dsa/bridge_vlan_unaware.sh	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/bridge_vlan_unaware.sh	2025-09-11 09:47:42.000000000 -0600
@@ -1,9 +1 @@
-#!/bin/bash
-# SPDX-License-Identifier: GPL-2.0
-
-libdir=$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")
-testname=$(basename "${BASH_SOURCE[0]}")
-
-source "$libdir"/forwarding.config
-cd "$libdir"/../../../net/forwarding/ || exit 1
-source "./$testname" "$@"
+run_net_forwarding_test.sh
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/drivers/net/dsa/local_termination.sh linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/local_termination.sh
--- linux-6.16.7/tools/testing/selftests/drivers/net/dsa/local_termination.sh	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/local_termination.sh	2025-09-11 09:47:42.000000000 -0600
@@ -1,9 +1 @@
-#!/bin/bash
-# SPDX-License-Identifier: GPL-2.0
-
-libdir=$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")
-testname=$(basename "${BASH_SOURCE[0]}")
-
-source "$libdir"/forwarding.config
-cd "$libdir"/../../../net/forwarding/ || exit 1
-source "./$testname" "$@"
+run_net_forwarding_test.sh
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/drivers/net/dsa/no_forwarding.sh linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/no_forwarding.sh
--- linux-6.16.7/tools/testing/selftests/drivers/net/dsa/no_forwarding.sh	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/no_forwarding.sh	2025-09-11 09:47:42.000000000 -0600
@@ -1,9 +1 @@
-#!/bin/bash
-# SPDX-License-Identifier: GPL-2.0
-
-libdir=$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")
-testname=$(basename "${BASH_SOURCE[0]}")
-
-source "$libdir"/forwarding.config
-cd "$libdir"/../../../net/forwarding/ || exit 1
-source "./$testname" "$@"
+run_net_forwarding_test.sh
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/drivers/net/dsa/tc_actions.sh linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/tc_actions.sh
--- linux-6.16.7/tools/testing/selftests/drivers/net/dsa/tc_actions.sh	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/tc_actions.sh	2025-09-11 09:47:42.000000000 -0600
@@ -1,9 +1 @@
-#!/bin/bash
-# SPDX-License-Identifier: GPL-2.0
-
-libdir=$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")
-testname=$(basename "${BASH_SOURCE[0]}")
-
-source "$libdir"/forwarding.config
-cd "$libdir"/../../../net/forwarding/ || exit 1
-source "./$testname" "$@"
+run_net_forwarding_test.sh
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/drivers/net/dsa/tc_taprio.sh linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/tc_taprio.sh
--- linux-6.16.7/tools/testing/selftests/drivers/net/dsa/tc_taprio.sh	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/tc_taprio.sh	2025-09-11 09:47:42.000000000 -0600
@@ -1,9 +1 @@
-#!/bin/bash
-# SPDX-License-Identifier: GPL-2.0
-
-libdir=$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")
-testname=$(basename "${BASH_SOURCE[0]}")
-
-source "$libdir"/forwarding.config
-cd "$libdir"/../../../net/forwarding/ || exit 1
-source "./$testname" "$@"
+run_net_forwarding_test.sh
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/drivers/net/mlxsw/spectrum-2/port_range_scale.sh linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/mlxsw/spectrum-2/port_range_scale.sh
--- linux-6.16.7/tools/testing/selftests/drivers/net/mlxsw/spectrum-2/port_range_scale.sh	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/mlxsw/spectrum-2/port_range_scale.sh	2025-09-11 09:47:42.000000000 -0600
@@ -1,16 +1 @@
-# SPDX-License-Identifier: GPL-2.0
-source ../port_range_scale.sh
-
-port_range_get_target()
-{
-	local should_fail=$1; shift
-	local target
-
-	target=$(devlink_resource_size_get port_range_registers)
-
-	if ((! should_fail)); then
-		echo $target
-	else
-		echo $((target + 1))
-	fi
-}
+../spectrum/port_range_scale.sh
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/drivers/net/mlxsw/spectrum-2/rif_counter_scale.sh linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/mlxsw/spectrum-2/rif_counter_scale.sh
--- linux-6.16.7/tools/testing/selftests/drivers/net/mlxsw/spectrum-2/rif_counter_scale.sh	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/mlxsw/spectrum-2/rif_counter_scale.sh	2025-09-11 09:47:42.000000000 -0600
@@ -1,34 +1 @@
-# SPDX-License-Identifier: GPL-2.0
-source ../rif_counter_scale.sh
-
-rif_counter_get_target()
-{
-	local should_fail=$1; shift
-	local max_cnts
-	local max_rifs
-	local target
-
-	max_rifs=$(devlink_resource_size_get rifs)
-	max_cnts=$(devlink_resource_size_get counters rif)
-
-	# Remove already allocated RIFs.
-	((max_rifs -= $(devlink_resource_occ_get rifs)))
-
-	# 10 KVD slots per counter, ingress+egress counters per RIF
-	((max_cnts /= 20))
-
-	# Pointless to run the overflow test if we don't have enough RIFs to
-	# host all the counters.
-	if ((max_cnts > max_rifs && should_fail)); then
-		echo 0
-		return
-	fi
-
-	target=$((max_rifs < max_cnts ? max_rifs : max_cnts))
-
-	if ((! should_fail)); then
-		echo $target
-	else
-		echo $((target + 1))
-	fi
-}
+../spectrum/rif_counter_scale.sh
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/net/tcp_ao/icmps-accept.c linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/net/tcp_ao/icmps-accept.c
--- linux-6.16.7/tools/testing/selftests/net/tcp_ao/icmps-accept.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/net/tcp_ao/icmps-accept.c	2025-09-11 09:47:42.000000000 -0600
@@ -1,448 +1 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Selftest that verifies that incomping ICMPs are ignored,
- * the TCP connection stays alive, no hard or soft errors get reported
- * to the usespace and the counter for ignored ICMPs is updated.
- *
- * RFC5925, 7.8:
- * >> A TCP-AO implementation MUST default to ignore incoming ICMPv4
- * messages of Type 3 (destination unreachable), Codes 2-4 (protocol
- * unreachable, port unreachable, and fragmentation needed -- hard
- * errors), and ICMPv6 Type 1 (destination unreachable), Code 1
- * (administratively prohibited) and Code 4 (port unreachable) intended
- * for connections in synchronized states (ESTABLISHED, FIN-WAIT-1, FIN-
- * WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT) that match MKTs.
- *
- * Author: Dmitry Safonov <dima@arista.com>
- */
-#include <inttypes.h>
-#include <linux/icmp.h>
-#include <linux/icmpv6.h>
-#include <linux/ipv6.h>
-#include <netinet/in.h>
-#include <netinet/ip.h>
-#include <sys/socket.h>
-#include "aolib.h"
-#include "../../../../include/linux/compiler.h"
-
-const size_t packets_nr = 20;
-const size_t packet_size = 100;
-const char *tcpao_icmps	= "TCPAODroppedIcmps";
-
-#ifdef IPV6_TEST
-const char *dst_unreach	= "Icmp6InDestUnreachs";
-const int sk_ip_level	= SOL_IPV6;
-const int sk_recverr	= IPV6_RECVERR;
-#else
-const char *dst_unreach	= "InDestUnreachs";
-const int sk_ip_level	= SOL_IP;
-const int sk_recverr	= IP_RECVERR;
-#endif
-
-/* Server is expected to fail with hard error if ::accept_icmp is set */
-#ifdef TEST_ICMPS_ACCEPT
-# define test_icmps_fail test_ok
-# define test_icmps_ok test_fail
-#else
-# define test_icmps_fail test_fail
-# define test_icmps_ok test_ok
-#endif
-
-static void serve_interfered(int sk)
-{
-	ssize_t test_quota = packet_size * packets_nr * 10;
-	uint64_t dest_unreach_a, dest_unreach_b;
-	uint64_t icmp_ignored_a, icmp_ignored_b;
-	struct tcp_counters cnt1, cnt2;
-	bool counter_not_found;
-	struct netstat *ns_after, *ns_before;
-	ssize_t bytes;
-
-	ns_before = netstat_read();
-	dest_unreach_a = netstat_get(ns_before, dst_unreach, NULL);
-	icmp_ignored_a = netstat_get(ns_before, tcpao_icmps, NULL);
-	if (test_get_tcp_counters(sk, &cnt1))
-		test_error("test_get_tcp_counters()");
-	bytes = test_server_run(sk, test_quota, 0);
-	ns_after = netstat_read();
-	netstat_print_diff(ns_before, ns_after);
-	dest_unreach_b = netstat_get(ns_after, dst_unreach, NULL);
-	icmp_ignored_b = netstat_get(ns_after, tcpao_icmps,
-					&counter_not_found);
-	if (test_get_tcp_counters(sk, &cnt2))
-		test_error("test_get_tcp_counters()");
-
-	netstat_free(ns_before);
-	netstat_free(ns_after);
-
-	if (dest_unreach_a >= dest_unreach_b) {
-		test_fail("%s counter didn't change: %" PRIu64 " >= %" PRIu64,
-				dst_unreach, dest_unreach_a, dest_unreach_b);
-		return;
-	}
-	test_ok("%s delivered %" PRIu64,
-		dst_unreach, dest_unreach_b - dest_unreach_a);
-	if (bytes < 0)
-		test_icmps_fail("Server failed with %zd: %s", bytes, strerrordesc_np(-bytes));
-	else
-		test_icmps_ok("Server survived %zd bytes of traffic", test_quota);
-	if (counter_not_found) {
-		test_fail("Not found %s counter", tcpao_icmps);
-		return;
-	}
-#ifdef TEST_ICMPS_ACCEPT
-	test_assert_counters(NULL, &cnt1, &cnt2, TEST_CNT_GOOD);
-#else
-	test_assert_counters(NULL, &cnt1, &cnt2, TEST_CNT_GOOD | TEST_CNT_AO_DROPPED_ICMP);
-#endif
-	if (icmp_ignored_a >= icmp_ignored_b) {
-		test_icmps_fail("%s counter didn't change: %" PRIu64 " >= %" PRIu64,
-				tcpao_icmps, icmp_ignored_a, icmp_ignored_b);
-		return;
-	}
-	test_icmps_ok("ICMPs ignored %" PRIu64, icmp_ignored_b - icmp_ignored_a);
-}
-
-static void *server_fn(void *arg)
-{
-	int val, sk, lsk;
-	bool accept_icmps = false;
-
-	lsk = test_listen_socket(this_ip_addr, test_server_port, 1);
-
-#ifdef TEST_ICMPS_ACCEPT
-	accept_icmps = true;
-#endif
-
-	if (test_set_ao_flags(lsk, false, accept_icmps))
-		test_error("setsockopt(TCP_AO_INFO)");
-
-	if (test_add_key(lsk, DEFAULT_TEST_PASSWORD, this_ip_dest, -1, 100, 100))
-		test_error("setsockopt(TCP_AO_ADD_KEY)");
-	synchronize_threads();
-
-	if (test_wait_fd(lsk, TEST_TIMEOUT_SEC, 0))
-		test_error("test_wait_fd()");
-
-	sk = accept(lsk, NULL, NULL);
-	if (sk < 0)
-		test_error("accept()");
-
-	/* Fail on hard ip errors, such as dest unreachable (RFC1122) */
-	val = 1;
-	if (setsockopt(sk, sk_ip_level, sk_recverr, &val, sizeof(val)))
-		test_error("setsockopt()");
-
-	synchronize_threads();
-
-	serve_interfered(sk);
-	return NULL;
-}
-
-static size_t packets_sent;
-static size_t icmps_sent;
-
-static uint32_t checksum4_nofold(void *data, size_t len, uint32_t sum)
-{
-	uint16_t *words = data;
-	size_t i;
-
-	for (i = 0; i < len / sizeof(uint16_t); i++)
-		sum += words[i];
-	if (len & 1)
-		sum += ((char *)data)[len - 1];
-	return sum;
-}
-
-static uint16_t checksum4_fold(void *data, size_t len, uint32_t sum)
-{
-	sum = checksum4_nofold(data, len, sum);
-	while (sum > 0xFFFF)
-		sum = (sum & 0xFFFF) + (sum >> 16);
-	return ~sum;
-}
-
-static void set_ip4hdr(struct iphdr *iph, size_t packet_len, int proto,
-		struct sockaddr_in *src, struct sockaddr_in *dst)
-{
-	iph->version	= 4;
-	iph->ihl	= 5;
-	iph->tos	= 0;
-	iph->tot_len	= htons(packet_len);
-	iph->ttl	= 2;
-	iph->protocol	= proto;
-	iph->saddr	= src->sin_addr.s_addr;
-	iph->daddr	= dst->sin_addr.s_addr;
-	iph->check	= checksum4_fold((void *)iph, iph->ihl << 1, 0);
-}
-
-static void icmp_interfere4(uint8_t type, uint8_t code, uint32_t rcv_nxt,
-		struct sockaddr_in *src, struct sockaddr_in *dst)
-{
-	int sk = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
-	struct {
-		struct iphdr iph;
-		struct icmphdr icmph;
-		struct iphdr iphe;
-		struct {
-			uint16_t sport;
-			uint16_t dport;
-			uint32_t seq;
-		} tcph;
-	} packet = {};
-	size_t packet_len;
-	ssize_t bytes;
-
-	if (sk < 0)
-		test_error("socket(AF_INET, SOCK_RAW, IPPROTO_RAW)");
-
-	packet_len = sizeof(packet);
-	set_ip4hdr(&packet.iph, packet_len, IPPROTO_ICMP, src, dst);
-
-	packet.icmph.type = type;
-	packet.icmph.code = code;
-	if (code == ICMP_FRAG_NEEDED) {
-		randomize_buffer(&packet.icmph.un.frag.mtu,
-				sizeof(packet.icmph.un.frag.mtu));
-	}
-
-	packet_len = sizeof(packet.iphe) + sizeof(packet.tcph);
-	set_ip4hdr(&packet.iphe, packet_len, IPPROTO_TCP, dst, src);
-
-	packet.tcph.sport = dst->sin_port;
-	packet.tcph.dport = src->sin_port;
-	packet.tcph.seq = htonl(rcv_nxt);
-
-	packet_len = sizeof(packet) - sizeof(packet.iph);
-	packet.icmph.checksum = checksum4_fold((void *)&packet.icmph,
-						packet_len, 0);
-
-	bytes = sendto(sk, &packet, sizeof(packet), 0,
-		       (struct sockaddr *)dst, sizeof(*dst));
-	if (bytes != sizeof(packet))
-		test_error("send(): %zd", bytes);
-	icmps_sent++;
-
-	close(sk);
-}
-
-static void set_ip6hdr(struct ipv6hdr *iph, size_t packet_len, int proto,
-		struct sockaddr_in6 *src, struct sockaddr_in6 *dst)
-{
-	iph->version		= 6;
-	iph->payload_len	= htons(packet_len);
-	iph->nexthdr		= proto;
-	iph->hop_limit		= 2;
-	iph->saddr		= src->sin6_addr;
-	iph->daddr		= dst->sin6_addr;
-}
-
-static inline uint16_t csum_fold(uint32_t csum)
-{
-	uint32_t sum = csum;
-
-	sum = (sum & 0xffff) + (sum >> 16);
-	sum = (sum & 0xffff) + (sum >> 16);
-	return (uint16_t)~sum;
-}
-
-static inline uint32_t csum_add(uint32_t csum, uint32_t addend)
-{
-	uint32_t res = csum;
-
-	res += addend;
-	return res + (res < addend);
-}
-
-noinline uint32_t checksum6_nofold(void *data, size_t len, uint32_t sum)
-{
-	uint16_t *words = data;
-	size_t i;
-
-	for (i = 0; i < len / sizeof(uint16_t); i++)
-		sum = csum_add(sum, words[i]);
-	if (len & 1)
-		sum = csum_add(sum, ((char *)data)[len - 1]);
-	return sum;
-}
-
-noinline uint16_t icmp6_checksum(struct sockaddr_in6 *src,
-				 struct sockaddr_in6 *dst,
-				 void *ptr, size_t len, uint8_t proto)
-{
-	struct {
-		struct in6_addr saddr;
-		struct in6_addr daddr;
-		uint32_t payload_len;
-		uint8_t zero[3];
-		uint8_t nexthdr;
-	} pseudo_header = {};
-	uint32_t sum;
-
-	pseudo_header.saddr		= src->sin6_addr;
-	pseudo_header.daddr		= dst->sin6_addr;
-	pseudo_header.payload_len	= htonl(len);
-	pseudo_header.nexthdr		= proto;
-
-	sum = checksum6_nofold(&pseudo_header, sizeof(pseudo_header), 0);
-	sum = checksum6_nofold(ptr, len, sum);
-
-	return csum_fold(sum);
-}
-
-static void icmp6_interfere(int type, int code, uint32_t rcv_nxt,
-		struct sockaddr_in6 *src, struct sockaddr_in6 *dst)
-{
-	int sk = socket(AF_INET6, SOCK_RAW, IPPROTO_RAW);
-	struct sockaddr_in6 dst_raw = *dst;
-	struct {
-		struct ipv6hdr iph;
-		struct icmp6hdr icmph;
-		struct ipv6hdr iphe;
-		struct {
-			uint16_t sport;
-			uint16_t dport;
-			uint32_t seq;
-		} tcph;
-	} packet = {};
-	size_t packet_len;
-	ssize_t bytes;
-
-
-	if (sk < 0)
-		test_error("socket(AF_INET6, SOCK_RAW, IPPROTO_RAW)");
-
-	packet_len = sizeof(packet) - sizeof(packet.iph);
-	set_ip6hdr(&packet.iph, packet_len, IPPROTO_ICMPV6, src, dst);
-
-	packet.icmph.icmp6_type = type;
-	packet.icmph.icmp6_code = code;
-
-	packet_len = sizeof(packet.iphe) + sizeof(packet.tcph);
-	set_ip6hdr(&packet.iphe, packet_len, IPPROTO_TCP, dst, src);
-
-	packet.tcph.sport = dst->sin6_port;
-	packet.tcph.dport = src->sin6_port;
-	packet.tcph.seq = htonl(rcv_nxt);
-
-	packet_len = sizeof(packet) - sizeof(packet.iph);
-
-	packet.icmph.icmp6_cksum = icmp6_checksum(src, dst,
-			(void *)&packet.icmph, packet_len, IPPROTO_ICMPV6);
-
-	dst_raw.sin6_port = htons(IPPROTO_RAW);
-	bytes = sendto(sk, &packet, sizeof(packet), 0,
-		       (struct sockaddr *)&dst_raw, sizeof(dst_raw));
-	if (bytes != sizeof(packet))
-		test_error("send(): %zd", bytes);
-	icmps_sent++;
-
-	close(sk);
-}
-
-static uint32_t get_rcv_nxt(int sk)
-{
-	int val = TCP_REPAIR_ON;
-	uint32_t ret;
-	socklen_t sz = sizeof(ret);
-
-	if (setsockopt(sk, SOL_TCP, TCP_REPAIR, &val, sizeof(val)))
-		test_error("setsockopt(TCP_REPAIR)");
-	val = TCP_RECV_QUEUE;
-	if (setsockopt(sk, SOL_TCP, TCP_REPAIR_QUEUE, &val, sizeof(val)))
-		test_error("setsockopt(TCP_REPAIR_QUEUE)");
-	if (getsockopt(sk, SOL_TCP, TCP_QUEUE_SEQ, &ret, &sz))
-		test_error("getsockopt(TCP_QUEUE_SEQ)");
-	val = TCP_REPAIR_OFF_NO_WP;
-	if (setsockopt(sk, SOL_TCP, TCP_REPAIR, &val, sizeof(val)))
-		test_error("setsockopt(TCP_REPAIR)");
-	return ret;
-}
-
-static void icmp_interfere(const size_t nr, uint32_t rcv_nxt, void *src, void *dst)
-{
-	struct sockaddr_in *saddr4 = src;
-	struct sockaddr_in *daddr4 = dst;
-	struct sockaddr_in6 *saddr6 = src;
-	struct sockaddr_in6 *daddr6 = dst;
-	size_t i;
-
-	if (saddr4->sin_family != daddr4->sin_family)
-		test_error("Different address families");
-
-	for (i = 0; i < nr; i++) {
-		if (saddr4->sin_family == AF_INET) {
-			icmp_interfere4(ICMP_DEST_UNREACH, ICMP_PROT_UNREACH,
-					rcv_nxt, saddr4, daddr4);
-			icmp_interfere4(ICMP_DEST_UNREACH, ICMP_PORT_UNREACH,
-					rcv_nxt, saddr4, daddr4);
-			icmp_interfere4(ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED,
-					rcv_nxt, saddr4, daddr4);
-			icmps_sent += 3;
-		} else if (saddr4->sin_family == AF_INET6) {
-			icmp6_interfere(ICMPV6_DEST_UNREACH,
-					ICMPV6_ADM_PROHIBITED,
-					rcv_nxt, saddr6, daddr6);
-			icmp6_interfere(ICMPV6_DEST_UNREACH,
-					ICMPV6_PORT_UNREACH,
-					rcv_nxt, saddr6, daddr6);
-			icmps_sent += 2;
-		} else {
-			test_error("Not ip address family");
-		}
-	}
-}
-
-static void send_interfered(int sk)
-{
-	struct sockaddr_in6 src, dst;
-	socklen_t addr_sz;
-
-	addr_sz = sizeof(src);
-	if (getsockname(sk, &src, &addr_sz))
-		test_error("getsockname()");
-	addr_sz = sizeof(dst);
-	if (getpeername(sk, &dst, &addr_sz))
-		test_error("getpeername()");
-
-	while (1) {
-		uint32_t rcv_nxt;
-
-		if (test_client_verify(sk, packet_size, packets_nr)) {
-			test_fail("client: connection is broken");
-			return;
-		}
-		packets_sent += packets_nr;
-		rcv_nxt = get_rcv_nxt(sk);
-		icmp_interfere(packets_nr, rcv_nxt, (void *)&src, (void *)&dst);
-	}
-}
-
-static void *client_fn(void *arg)
-{
-	int sk = socket(test_family, SOCK_STREAM, IPPROTO_TCP);
-
-	if (sk < 0)
-		test_error("socket()");
-
-	if (test_add_key(sk, DEFAULT_TEST_PASSWORD, this_ip_dest, -1, 100, 100))
-		test_error("setsockopt(TCP_AO_ADD_KEY)");
-
-	synchronize_threads();
-	if (test_connect_socket(sk, this_ip_dest, test_server_port) <= 0)
-		test_error("failed to connect()");
-	synchronize_threads();
-
-	send_interfered(sk);
-
-	/* Not expecting client to quit */
-	test_fail("client disconnected");
-
-	return NULL;
-}
-
-int main(int argc, char *argv[])
-{
-	test_init(4, server_fn, client_fn);
-	return 0;
-}
+icmps-discard.c
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/powerpc/copyloops/copy_mc_64.S linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/copyloops/copy_mc_64.S
--- linux-6.16.7/tools/testing/selftests/powerpc/copyloops/copy_mc_64.S	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/copyloops/copy_mc_64.S	2025-09-11 09:47:42.000000000 -0600
@@ -1,242 +1 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Copyright (C) IBM Corporation, 2011
- * Derived from copyuser_power7.s by Anton Blanchard <anton@au.ibm.com>
- * Author - Balbir Singh <bsingharora@gmail.com>
- */
-#include <linux/export.h>
-#include <asm/ppc_asm.h>
-#include <asm/errno.h>
-
-	.macro err1
-100:
-	EX_TABLE(100b,.Ldo_err1)
-	.endm
-
-	.macro err2
-200:
-	EX_TABLE(200b,.Ldo_err2)
-	.endm
-
-	.macro err3
-300:	EX_TABLE(300b,.Ldone)
-	.endm
-
-.Ldo_err2:
-	ld	r22,STK_REG(R22)(r1)
-	ld	r21,STK_REG(R21)(r1)
-	ld	r20,STK_REG(R20)(r1)
-	ld	r19,STK_REG(R19)(r1)
-	ld	r18,STK_REG(R18)(r1)
-	ld	r17,STK_REG(R17)(r1)
-	ld	r16,STK_REG(R16)(r1)
-	ld	r15,STK_REG(R15)(r1)
-	ld	r14,STK_REG(R14)(r1)
-	addi	r1,r1,STACKFRAMESIZE
-.Ldo_err1:
-	/* Do a byte by byte copy to get the exact remaining size */
-	mtctr	r7
-46:
-err3;	lbz	r0,0(r4)
-	addi	r4,r4,1
-err3;	stb	r0,0(r3)
-	addi	r3,r3,1
-	bdnz	46b
-	li	r3,0
-	blr
-
-.Ldone:
-	mfctr	r3
-	blr
-
-
-_GLOBAL(copy_mc_generic)
-	mr	r7,r5
-	cmpldi	r5,16
-	blt	.Lshort_copy
-
-.Lcopy:
-	/* Get the source 8B aligned */
-	neg	r6,r4
-	mtocrf	0x01,r6
-	clrldi	r6,r6,(64-3)
-
-	bf	cr7*4+3,1f
-err1;	lbz	r0,0(r4)
-	addi	r4,r4,1
-err1;	stb	r0,0(r3)
-	addi	r3,r3,1
-	subi	r7,r7,1
-
-1:	bf	cr7*4+2,2f
-err1;	lhz	r0,0(r4)
-	addi	r4,r4,2
-err1;	sth	r0,0(r3)
-	addi	r3,r3,2
-	subi	r7,r7,2
-
-2:	bf	cr7*4+1,3f
-err1;	lwz	r0,0(r4)
-	addi	r4,r4,4
-err1;	stw	r0,0(r3)
-	addi	r3,r3,4
-	subi	r7,r7,4
-
-3:	sub	r5,r5,r6
-	cmpldi	r5,128
-
-	mflr	r0
-	stdu	r1,-STACKFRAMESIZE(r1)
-	std	r14,STK_REG(R14)(r1)
-	std	r15,STK_REG(R15)(r1)
-	std	r16,STK_REG(R16)(r1)
-	std	r17,STK_REG(R17)(r1)
-	std	r18,STK_REG(R18)(r1)
-	std	r19,STK_REG(R19)(r1)
-	std	r20,STK_REG(R20)(r1)
-	std	r21,STK_REG(R21)(r1)
-	std	r22,STK_REG(R22)(r1)
-	std	r0,STACKFRAMESIZE+16(r1)
-
-	blt	5f
-	srdi	r6,r5,7
-	mtctr	r6
-
-	/* Now do cacheline (128B) sized loads and stores. */
-	.align	5
-4:
-err2;	ld	r0,0(r4)
-err2;	ld	r6,8(r4)
-err2;	ld	r8,16(r4)
-err2;	ld	r9,24(r4)
-err2;	ld	r10,32(r4)
-err2;	ld	r11,40(r4)
-err2;	ld	r12,48(r4)
-err2;	ld	r14,56(r4)
-err2;	ld	r15,64(r4)
-err2;	ld	r16,72(r4)
-err2;	ld	r17,80(r4)
-err2;	ld	r18,88(r4)
-err2;	ld	r19,96(r4)
-err2;	ld	r20,104(r4)
-err2;	ld	r21,112(r4)
-err2;	ld	r22,120(r4)
-	addi	r4,r4,128
-err2;	std	r0,0(r3)
-err2;	std	r6,8(r3)
-err2;	std	r8,16(r3)
-err2;	std	r9,24(r3)
-err2;	std	r10,32(r3)
-err2;	std	r11,40(r3)
-err2;	std	r12,48(r3)
-err2;	std	r14,56(r3)
-err2;	std	r15,64(r3)
-err2;	std	r16,72(r3)
-err2;	std	r17,80(r3)
-err2;	std	r18,88(r3)
-err2;	std	r19,96(r3)
-err2;	std	r20,104(r3)
-err2;	std	r21,112(r3)
-err2;	std	r22,120(r3)
-	addi	r3,r3,128
-	subi	r7,r7,128
-	bdnz	4b
-
-	clrldi	r5,r5,(64-7)
-
-	/* Up to 127B to go */
-5:	srdi	r6,r5,4
-	mtocrf	0x01,r6
-
-6:	bf	cr7*4+1,7f
-err2;	ld	r0,0(r4)
-err2;	ld	r6,8(r4)
-err2;	ld	r8,16(r4)
-err2;	ld	r9,24(r4)
-err2;	ld	r10,32(r4)
-err2;	ld	r11,40(r4)
-err2;	ld	r12,48(r4)
-err2;	ld	r14,56(r4)
-	addi	r4,r4,64
-err2;	std	r0,0(r3)
-err2;	std	r6,8(r3)
-err2;	std	r8,16(r3)
-err2;	std	r9,24(r3)
-err2;	std	r10,32(r3)
-err2;	std	r11,40(r3)
-err2;	std	r12,48(r3)
-err2;	std	r14,56(r3)
-	addi	r3,r3,64
-	subi	r7,r7,64
-
-7:	ld	r14,STK_REG(R14)(r1)
-	ld	r15,STK_REG(R15)(r1)
-	ld	r16,STK_REG(R16)(r1)
-	ld	r17,STK_REG(R17)(r1)
-	ld	r18,STK_REG(R18)(r1)
-	ld	r19,STK_REG(R19)(r1)
-	ld	r20,STK_REG(R20)(r1)
-	ld	r21,STK_REG(R21)(r1)
-	ld	r22,STK_REG(R22)(r1)
-	addi	r1,r1,STACKFRAMESIZE
-
-	/* Up to 63B to go */
-	bf	cr7*4+2,8f
-err1;	ld	r0,0(r4)
-err1;	ld	r6,8(r4)
-err1;	ld	r8,16(r4)
-err1;	ld	r9,24(r4)
-	addi	r4,r4,32
-err1;	std	r0,0(r3)
-err1;	std	r6,8(r3)
-err1;	std	r8,16(r3)
-err1;	std	r9,24(r3)
-	addi	r3,r3,32
-	subi	r7,r7,32
-
-	/* Up to 31B to go */
-8:	bf	cr7*4+3,9f
-err1;	ld	r0,0(r4)
-err1;	ld	r6,8(r4)
-	addi	r4,r4,16
-err1;	std	r0,0(r3)
-err1;	std	r6,8(r3)
-	addi	r3,r3,16
-	subi	r7,r7,16
-
-9:	clrldi	r5,r5,(64-4)
-
-	/* Up to 15B to go */
-.Lshort_copy:
-	mtocrf	0x01,r5
-	bf	cr7*4+0,12f
-err1;	lwz	r0,0(r4)	/* Less chance of a reject with word ops */
-err1;	lwz	r6,4(r4)
-	addi	r4,r4,8
-err1;	stw	r0,0(r3)
-err1;	stw	r6,4(r3)
-	addi	r3,r3,8
-	subi	r7,r7,8
-
-12:	bf	cr7*4+1,13f
-err1;	lwz	r0,0(r4)
-	addi	r4,r4,4
-err1;	stw	r0,0(r3)
-	addi	r3,r3,4
-	subi	r7,r7,4
-
-13:	bf	cr7*4+2,14f
-err1;	lhz	r0,0(r4)
-	addi	r4,r4,2
-err1;	sth	r0,0(r3)
-	addi	r3,r3,2
-	subi	r7,r7,2
-
-14:	bf	cr7*4+3,15f
-err1;	lbz	r0,0(r4)
-err1;	stb	r0,0(r3)
-
-15:	li	r3,0
-	blr
-
-EXPORT_SYMBOL_GPL(copy_mc_generic);
+../../../../../arch/powerpc/lib/copy_mc_64.S
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/powerpc/copyloops/copyuser_64.S linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/copyloops/copyuser_64.S
--- linux-6.16.7/tools/testing/selftests/powerpc/copyloops/copyuser_64.S	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/copyloops/copyuser_64.S	2025-09-11 09:47:42.000000000 -0600
@@ -1,564 +1 @@
-/* SPDX-License-Identifier: GPL-2.0-or-later */
-/*
- * Copyright (C) 2002 Paul Mackerras, IBM Corp.
- */
-#include <linux/export.h>
-#include <asm/processor.h>
-#include <asm/ppc_asm.h>
-#include <asm/asm-compat.h>
-#include <asm/feature-fixups.h>
-
-#ifndef SELFTEST_CASE
-/* 0 == most CPUs, 1 == POWER6, 2 == Cell */
-#define SELFTEST_CASE	0
-#endif
-
-#ifdef __BIG_ENDIAN__
-#define sLd sld		/* Shift towards low-numbered address. */
-#define sHd srd		/* Shift towards high-numbered address. */
-#else
-#define sLd srd		/* Shift towards low-numbered address. */
-#define sHd sld		/* Shift towards high-numbered address. */
-#endif
-
-/*
- * These macros are used to generate exception table entries.
- * The exception handlers below use the original arguments
- * (stored on the stack) and the point where we're up to in
- * the destination buffer, i.e. the address of the first
- * unmodified byte.  Generally r3 points into the destination
- * buffer, but the first unmodified byte is at a variable
- * offset from r3.  In the code below, the symbol r3_offset
- * is set to indicate the current offset at each point in
- * the code.  This offset is then used as a negative offset
- * from the exception handler code, and those instructions
- * before the exception handlers are addi instructions that
- * adjust r3 to point to the correct place.
- */
-	.macro	lex		/* exception handler for load */
-100:	EX_TABLE(100b, .Lld_exc - r3_offset)
-	.endm
-
-	.macro	stex		/* exception handler for store */
-100:	EX_TABLE(100b, .Lst_exc - r3_offset)
-	.endm
-
-	.align	7
-_GLOBAL_TOC(__copy_tofrom_user)
-#ifdef CONFIG_PPC_BOOK3S_64
-BEGIN_FTR_SECTION
-	nop
-FTR_SECTION_ELSE
-	b	__copy_tofrom_user_power7
-ALT_FTR_SECTION_END_IFCLR(CPU_FTR_VMX_COPY)
-#endif
-_GLOBAL(__copy_tofrom_user_base)
-	/* first check for a 4kB copy on a 4kB boundary */
-	cmpldi	cr1,r5,16
-	cmpdi	cr6,r5,4096
-	or	r0,r3,r4
-	neg	r6,r3		/* LS 3 bits = # bytes to 8-byte dest bdry */
-	andi.	r0,r0,4095
-	std	r3,-24(r1)
-	crand	cr0*4+2,cr0*4+2,cr6*4+2
-	std	r4,-16(r1)
-	std	r5,-8(r1)
-	dcbt	0,r4
-	beq	.Lcopy_page_4K
-	andi.	r6,r6,7
-	PPC_MTOCRF(0x01,r5)
-	blt	cr1,.Lshort_copy
-/* Below we want to nop out the bne if we're on a CPU that has the
- * CPU_FTR_UNALIGNED_LD_STD bit set and the CPU_FTR_CP_USE_DCBTZ bit
- * cleared.
- * At the time of writing the only CPU that has this combination of bits
- * set is Power6.
- */
-test_feature = (SELFTEST_CASE == 1)
-BEGIN_FTR_SECTION
-	nop
-FTR_SECTION_ELSE
-	bne	.Ldst_unaligned
-ALT_FTR_SECTION_END(CPU_FTR_UNALIGNED_LD_STD | CPU_FTR_CP_USE_DCBTZ, \
-		    CPU_FTR_UNALIGNED_LD_STD)
-.Ldst_aligned:
-	addi	r3,r3,-16
-r3_offset = 16
-test_feature = (SELFTEST_CASE == 0)
-BEGIN_FTR_SECTION
-	andi.	r0,r4,7
-	bne	.Lsrc_unaligned
-END_FTR_SECTION_IFCLR(CPU_FTR_UNALIGNED_LD_STD)
-	blt	cr1,.Ldo_tail		/* if < 16 bytes to copy */
-	srdi	r0,r5,5
-	cmpdi	cr1,r0,0
-lex;	ld	r7,0(r4)
-lex;	ld	r6,8(r4)
-	addi	r4,r4,16
-	mtctr	r0
-	andi.	r0,r5,0x10
-	beq	22f
-	addi	r3,r3,16
-r3_offset = 0
-	addi	r4,r4,-16
-	mr	r9,r7
-	mr	r8,r6
-	beq	cr1,72f
-21:
-lex;	ld	r7,16(r4)
-lex;	ld	r6,24(r4)
-	addi	r4,r4,32
-stex;	std	r9,0(r3)
-r3_offset = 8
-stex;	std	r8,8(r3)
-r3_offset = 16
-22:
-lex;	ld	r9,0(r4)
-lex;	ld	r8,8(r4)
-stex;	std	r7,16(r3)
-r3_offset = 24
-stex;	std	r6,24(r3)
-	addi	r3,r3,32
-r3_offset = 0
-	bdnz	21b
-72:
-stex;	std	r9,0(r3)
-r3_offset = 8
-stex;	std	r8,8(r3)
-r3_offset = 16
-	andi.	r5,r5,0xf
-	beq+	3f
-	addi	r4,r4,16
-.Ldo_tail:
-	addi	r3,r3,16
-r3_offset = 0
-	bf	cr7*4+0,246f
-lex;	ld	r9,0(r4)
-	addi	r4,r4,8
-stex;	std	r9,0(r3)
-	addi	r3,r3,8
-246:	bf	cr7*4+1,1f
-lex;	lwz	r9,0(r4)
-	addi	r4,r4,4
-stex;	stw	r9,0(r3)
-	addi	r3,r3,4
-1:	bf	cr7*4+2,2f
-lex;	lhz	r9,0(r4)
-	addi	r4,r4,2
-stex;	sth	r9,0(r3)
-	addi	r3,r3,2
-2:	bf	cr7*4+3,3f
-lex;	lbz	r9,0(r4)
-stex;	stb	r9,0(r3)
-3:	li	r3,0
-	blr
-
-.Lsrc_unaligned:
-r3_offset = 16
-	srdi	r6,r5,3
-	addi	r5,r5,-16
-	subf	r4,r0,r4
-	srdi	r7,r5,4
-	sldi	r10,r0,3
-	cmpldi	cr6,r6,3
-	andi.	r5,r5,7
-	mtctr	r7
-	subfic	r11,r10,64
-	add	r5,r5,r0
-	bt	cr7*4+0,28f
-
-lex;	ld	r9,0(r4)	/* 3+2n loads, 2+2n stores */
-lex;	ld	r0,8(r4)
-	sLd	r6,r9,r10
-lex;	ldu	r9,16(r4)
-	sHd	r7,r0,r11
-	sLd	r8,r0,r10
-	or	r7,r7,r6
-	blt	cr6,79f
-lex;	ld	r0,8(r4)
-	b	2f
-
-28:
-lex;	ld	r0,0(r4)	/* 4+2n loads, 3+2n stores */
-lex;	ldu	r9,8(r4)
-	sLd	r8,r0,r10
-	addi	r3,r3,-8
-r3_offset = 24
-	blt	cr6,5f
-lex;	ld	r0,8(r4)
-	sHd	r12,r9,r11
-	sLd	r6,r9,r10
-lex;	ldu	r9,16(r4)
-	or	r12,r8,r12
-	sHd	r7,r0,r11
-	sLd	r8,r0,r10
-	addi	r3,r3,16
-r3_offset = 8
-	beq	cr6,78f
-
-1:	or	r7,r7,r6
-lex;	ld	r0,8(r4)
-stex;	std	r12,8(r3)
-r3_offset = 16
-2:	sHd	r12,r9,r11
-	sLd	r6,r9,r10
-lex;	ldu	r9,16(r4)
-	or	r12,r8,r12
-stex;	stdu	r7,16(r3)
-r3_offset = 8
-	sHd	r7,r0,r11
-	sLd	r8,r0,r10
-	bdnz	1b
-
-78:
-stex;	std	r12,8(r3)
-r3_offset = 16
-	or	r7,r7,r6
-79:
-stex;	std	r7,16(r3)
-r3_offset = 24
-5:	sHd	r12,r9,r11
-	or	r12,r8,r12
-stex;	std	r12,24(r3)
-r3_offset = 32
-	bne	6f
-	li	r3,0
-	blr
-6:	cmpwi	cr1,r5,8
-	addi	r3,r3,32
-r3_offset = 0
-	sLd	r9,r9,r10
-	ble	cr1,7f
-lex;	ld	r0,8(r4)
-	sHd	r7,r0,r11
-	or	r9,r7,r9
-7:
-	bf	cr7*4+1,1f
-#ifdef __BIG_ENDIAN__
-	rotldi	r9,r9,32
-#endif
-stex;	stw	r9,0(r3)
-#ifdef __LITTLE_ENDIAN__
-	rotrdi	r9,r9,32
-#endif
-	addi	r3,r3,4
-1:	bf	cr7*4+2,2f
-#ifdef __BIG_ENDIAN__
-	rotldi	r9,r9,16
-#endif
-stex;	sth	r9,0(r3)
-#ifdef __LITTLE_ENDIAN__
-	rotrdi	r9,r9,16
-#endif
-	addi	r3,r3,2
-2:	bf	cr7*4+3,3f
-#ifdef __BIG_ENDIAN__
-	rotldi	r9,r9,8
-#endif
-stex;	stb	r9,0(r3)
-#ifdef __LITTLE_ENDIAN__
-	rotrdi	r9,r9,8
-#endif
-3:	li	r3,0
-	blr
-
-.Ldst_unaligned:
-r3_offset = 0
-	PPC_MTOCRF(0x01,r6)		/* put #bytes to 8B bdry into cr7 */
-	subf	r5,r6,r5
-	li	r7,0
-	cmpldi	cr1,r5,16
-	bf	cr7*4+3,1f
-100:	EX_TABLE(100b, .Lld_exc_r7)
-	lbz	r0,0(r4)
-100:	EX_TABLE(100b, .Lst_exc_r7)
-	stb	r0,0(r3)
-	addi	r7,r7,1
-1:	bf	cr7*4+2,2f
-100:	EX_TABLE(100b, .Lld_exc_r7)
-	lhzx	r0,r7,r4
-100:	EX_TABLE(100b, .Lst_exc_r7)
-	sthx	r0,r7,r3
-	addi	r7,r7,2
-2:	bf	cr7*4+1,3f
-100:	EX_TABLE(100b, .Lld_exc_r7)
-	lwzx	r0,r7,r4
-100:	EX_TABLE(100b, .Lst_exc_r7)
-	stwx	r0,r7,r3
-3:	PPC_MTOCRF(0x01,r5)
-	add	r4,r6,r4
-	add	r3,r6,r3
-	b	.Ldst_aligned
-
-.Lshort_copy:
-r3_offset = 0
-	bf	cr7*4+0,1f
-lex;	lwz	r0,0(r4)
-lex;	lwz	r9,4(r4)
-	addi	r4,r4,8
-stex;	stw	r0,0(r3)
-stex;	stw	r9,4(r3)
-	addi	r3,r3,8
-1:	bf	cr7*4+1,2f
-lex;	lwz	r0,0(r4)
-	addi	r4,r4,4
-stex;	stw	r0,0(r3)
-	addi	r3,r3,4
-2:	bf	cr7*4+2,3f
-lex;	lhz	r0,0(r4)
-	addi	r4,r4,2
-stex;	sth	r0,0(r3)
-	addi	r3,r3,2
-3:	bf	cr7*4+3,4f
-lex;	lbz	r0,0(r4)
-stex;	stb	r0,0(r3)
-4:	li	r3,0
-	blr
-
-/*
- * exception handlers follow
- * we have to return the number of bytes not copied
- * for an exception on a load, we set the rest of the destination to 0
- * Note that the number of bytes of instructions for adjusting r3 needs
- * to equal the amount of the adjustment, due to the trick of using
- * .Lld_exc - r3_offset as the handler address.
- */
-
-.Lld_exc_r7:
-	add	r3,r3,r7
-	b	.Lld_exc
-
-	/* adjust by 24 */
-	addi	r3,r3,8
-	nop
-	/* adjust by 16 */
-	addi	r3,r3,8
-	nop
-	/* adjust by 8 */
-	addi	r3,r3,8
-	nop
-
-/*
- * Here we have had a fault on a load and r3 points to the first
- * unmodified byte of the destination.  We use the original arguments
- * and r3 to work out how much wasn't copied.  Since we load some
- * distance ahead of the stores, we continue copying byte-by-byte until
- * we hit the load fault again in order to copy as much as possible.
- */
-.Lld_exc:
-	ld	r6,-24(r1)
-	ld	r4,-16(r1)
-	ld	r5,-8(r1)
-	subf	r6,r6,r3
-	add	r4,r4,r6
-	subf	r5,r6,r5	/* #bytes left to go */
-
-/*
- * first see if we can copy any more bytes before hitting another exception
- */
-	mtctr	r5
-r3_offset = 0
-100:	EX_TABLE(100b, .Ldone)
-43:	lbz	r0,0(r4)
-	addi	r4,r4,1
-stex;	stb	r0,0(r3)
-	addi	r3,r3,1
-	bdnz	43b
-	li	r3,0		/* huh? all copied successfully this time? */
-	blr
-
-/*
- * here we have trapped again, amount remaining is in ctr.
- */
-.Ldone:
-	mfctr	r3
-	blr
-
-/*
- * exception handlers for stores: we need to work out how many bytes
- * weren't copied, and we may need to copy some more.
- * Note that the number of bytes of instructions for adjusting r3 needs
- * to equal the amount of the adjustment, due to the trick of using
- * .Lst_exc - r3_offset as the handler address.
- */
-.Lst_exc_r7:
-	add	r3,r3,r7
-	b	.Lst_exc
-
-	/* adjust by 24 */
-	addi	r3,r3,8
-	nop
-	/* adjust by 16 */
-	addi	r3,r3,8
-	nop
-	/* adjust by 8 */
-	addi	r3,r3,4
-	/* adjust by 4 */
-	addi	r3,r3,4
-.Lst_exc:
-	ld	r6,-24(r1)	/* original destination pointer */
-	ld	r4,-16(r1)	/* original source pointer */
-	ld	r5,-8(r1)	/* original number of bytes */
-	add	r7,r6,r5
-	/*
-	 * If the destination pointer isn't 8-byte aligned,
-	 * we may have got the exception as a result of a
-	 * store that overlapped a page boundary, so we may be
-	 * able to copy a few more bytes.
-	 */
-17:	andi.	r0,r3,7
-	beq	19f
-	subf	r8,r6,r3	/* #bytes copied */
-100:	EX_TABLE(100b,19f)
-	lbzx	r0,r8,r4
-100:	EX_TABLE(100b,19f)
-	stb	r0,0(r3)
-	addi	r3,r3,1
-	cmpld	r3,r7
-	blt	17b
-19:	subf	r3,r3,r7	/* #bytes not copied in r3 */
-	blr
-
-/*
- * Routine to copy a whole page of data, optimized for POWER4.
- * On POWER4 it is more than 50% faster than the simple loop
- * above (following the .Ldst_aligned label).
- */
-	.macro	exc
-100:	EX_TABLE(100b, .Labort)
-	.endm
-.Lcopy_page_4K:
-	std	r31,-32(1)
-	std	r30,-40(1)
-	std	r29,-48(1)
-	std	r28,-56(1)
-	std	r27,-64(1)
-	std	r26,-72(1)
-	std	r25,-80(1)
-	std	r24,-88(1)
-	std	r23,-96(1)
-	std	r22,-104(1)
-	std	r21,-112(1)
-	std	r20,-120(1)
-	li	r5,4096/32 - 1
-	addi	r3,r3,-8
-	li	r0,5
-0:	addi	r5,r5,-24
-	mtctr	r0
-exc;	ld	r22,640(4)
-exc;	ld	r21,512(4)
-exc;	ld	r20,384(4)
-exc;	ld	r11,256(4)
-exc;	ld	r9,128(4)
-exc;	ld	r7,0(4)
-exc;	ld	r25,648(4)
-exc;	ld	r24,520(4)
-exc;	ld	r23,392(4)
-exc;	ld	r10,264(4)
-exc;	ld	r8,136(4)
-exc;	ldu	r6,8(4)
-	cmpwi	r5,24
-1:
-exc;	std	r22,648(3)
-exc;	std	r21,520(3)
-exc;	std	r20,392(3)
-exc;	std	r11,264(3)
-exc;	std	r9,136(3)
-exc;	std	r7,8(3)
-exc;	ld	r28,648(4)
-exc;	ld	r27,520(4)
-exc;	ld	r26,392(4)
-exc;	ld	r31,264(4)
-exc;	ld	r30,136(4)
-exc;	ld	r29,8(4)
-exc;	std	r25,656(3)
-exc;	std	r24,528(3)
-exc;	std	r23,400(3)
-exc;	std	r10,272(3)
-exc;	std	r8,144(3)
-exc;	std	r6,16(3)
-exc;	ld	r22,656(4)
-exc;	ld	r21,528(4)
-exc;	ld	r20,400(4)
-exc;	ld	r11,272(4)
-exc;	ld	r9,144(4)
-exc;	ld	r7,16(4)
-exc;	std	r28,664(3)
-exc;	std	r27,536(3)
-exc;	std	r26,408(3)
-exc;	std	r31,280(3)
-exc;	std	r30,152(3)
-exc;	stdu	r29,24(3)
-exc;	ld	r25,664(4)
-exc;	ld	r24,536(4)
-exc;	ld	r23,408(4)
-exc;	ld	r10,280(4)
-exc;	ld	r8,152(4)
-exc;	ldu	r6,24(4)
-	bdnz	1b
-exc;	std	r22,648(3)
-exc;	std	r21,520(3)
-exc;	std	r20,392(3)
-exc;	std	r11,264(3)
-exc;	std	r9,136(3)
-exc;	std	r7,8(3)
-	addi	r4,r4,640
-	addi	r3,r3,648
-	bge	0b
-	mtctr	r5
-exc;	ld	r7,0(4)
-exc;	ld	r8,8(4)
-exc;	ldu	r9,16(4)
-3:
-exc;	ld	r10,8(4)
-exc;	std	r7,8(3)
-exc;	ld	r7,16(4)
-exc;	std	r8,16(3)
-exc;	ld	r8,24(4)
-exc;	std	r9,24(3)
-exc;	ldu	r9,32(4)
-exc;	stdu	r10,32(3)
-	bdnz	3b
-4:
-exc;	ld	r10,8(4)
-exc;	std	r7,8(3)
-exc;	std	r8,16(3)
-exc;	std	r9,24(3)
-exc;	std	r10,32(3)
-9:	ld	r20,-120(1)
-	ld	r21,-112(1)
-	ld	r22,-104(1)
-	ld	r23,-96(1)
-	ld	r24,-88(1)
-	ld	r25,-80(1)
-	ld	r26,-72(1)
-	ld	r27,-64(1)
-	ld	r28,-56(1)
-	ld	r29,-48(1)
-	ld	r30,-40(1)
-	ld	r31,-32(1)
-	li	r3,0
-	blr
-
-/*
- * on an exception, reset to the beginning and jump back into the
- * standard __copy_tofrom_user
- */
-.Labort:
-	ld	r20,-120(1)
-	ld	r21,-112(1)
-	ld	r22,-104(1)
-	ld	r23,-96(1)
-	ld	r24,-88(1)
-	ld	r25,-80(1)
-	ld	r26,-72(1)
-	ld	r27,-64(1)
-	ld	r28,-56(1)
-	ld	r29,-48(1)
-	ld	r30,-40(1)
-	ld	r31,-32(1)
-	ld	r3,-24(r1)
-	ld	r4,-16(r1)
-	li	r5,4096
-	b	.Ldst_aligned
-EXPORT_SYMBOL(__copy_tofrom_user)
+../../../../../arch/powerpc/lib/copyuser_64.S
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/powerpc/copyloops/copyuser_power7.S linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/copyloops/copyuser_power7.S
--- linux-6.16.7/tools/testing/selftests/powerpc/copyloops/copyuser_power7.S	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/copyloops/copyuser_power7.S	2025-09-11 09:47:42.000000000 -0600
@@ -1,685 +1 @@
-/* SPDX-License-Identifier: GPL-2.0-or-later */
-/*
- *
- * Copyright (C) IBM Corporation, 2011
- *
- * Author: Anton Blanchard <anton@au.ibm.com>
- */
-#include <asm/ppc_asm.h>
-
-#ifndef SELFTEST_CASE
-/* 0 == don't use VMX, 1 == use VMX */
-#define SELFTEST_CASE	0
-#endif
-
-#ifdef __BIG_ENDIAN__
-#define LVS(VRT,RA,RB)		lvsl	VRT,RA,RB
-#define VPERM(VRT,VRA,VRB,VRC)	vperm	VRT,VRA,VRB,VRC
-#else
-#define LVS(VRT,RA,RB)		lvsr	VRT,RA,RB
-#define VPERM(VRT,VRA,VRB,VRC)	vperm	VRT,VRB,VRA,VRC
-#endif
-
-	.macro err1
-100:
-	EX_TABLE(100b,.Ldo_err1)
-	.endm
-
-	.macro err2
-200:
-	EX_TABLE(200b,.Ldo_err2)
-	.endm
-
-#ifdef CONFIG_ALTIVEC
-	.macro err3
-300:
-	EX_TABLE(300b,.Ldo_err3)
-	.endm
-
-	.macro err4
-400:
-	EX_TABLE(400b,.Ldo_err4)
-	.endm
-
-
-.Ldo_err4:
-	ld	r16,STK_REG(R16)(r1)
-	ld	r15,STK_REG(R15)(r1)
-	ld	r14,STK_REG(R14)(r1)
-.Ldo_err3:
-	bl	CFUNC(exit_vmx_usercopy)
-	ld	r0,STACKFRAMESIZE+16(r1)
-	mtlr	r0
-	b	.Lexit
-#endif /* CONFIG_ALTIVEC */
-
-.Ldo_err2:
-	ld	r22,STK_REG(R22)(r1)
-	ld	r21,STK_REG(R21)(r1)
-	ld	r20,STK_REG(R20)(r1)
-	ld	r19,STK_REG(R19)(r1)
-	ld	r18,STK_REG(R18)(r1)
-	ld	r17,STK_REG(R17)(r1)
-	ld	r16,STK_REG(R16)(r1)
-	ld	r15,STK_REG(R15)(r1)
-	ld	r14,STK_REG(R14)(r1)
-.Lexit:
-	addi	r1,r1,STACKFRAMESIZE
-.Ldo_err1:
-	ld	r3,-STACKFRAMESIZE+STK_REG(R31)(r1)
-	ld	r4,-STACKFRAMESIZE+STK_REG(R30)(r1)
-	ld	r5,-STACKFRAMESIZE+STK_REG(R29)(r1)
-	b	__copy_tofrom_user_base
-
-
-_GLOBAL(__copy_tofrom_user_power7)
-	cmpldi	r5,16
-	cmpldi	cr1,r5,3328
-
-	std	r3,-STACKFRAMESIZE+STK_REG(R31)(r1)
-	std	r4,-STACKFRAMESIZE+STK_REG(R30)(r1)
-	std	r5,-STACKFRAMESIZE+STK_REG(R29)(r1)
-
-	blt	.Lshort_copy
-
-#ifdef CONFIG_ALTIVEC
-test_feature = SELFTEST_CASE
-BEGIN_FTR_SECTION
-	bgt	cr1,.Lvmx_copy
-END_FTR_SECTION_IFSET(CPU_FTR_ALTIVEC)
-#endif
-
-.Lnonvmx_copy:
-	/* Get the source 8B aligned */
-	neg	r6,r4
-	mtocrf	0x01,r6
-	clrldi	r6,r6,(64-3)
-
-	bf	cr7*4+3,1f
-err1;	lbz	r0,0(r4)
-	addi	r4,r4,1
-err1;	stb	r0,0(r3)
-	addi	r3,r3,1
-
-1:	bf	cr7*4+2,2f
-err1;	lhz	r0,0(r4)
-	addi	r4,r4,2
-err1;	sth	r0,0(r3)
-	addi	r3,r3,2
-
-2:	bf	cr7*4+1,3f
-err1;	lwz	r0,0(r4)
-	addi	r4,r4,4
-err1;	stw	r0,0(r3)
-	addi	r3,r3,4
-
-3:	sub	r5,r5,r6
-	cmpldi	r5,128
-	blt	5f
-
-	mflr	r0
-	stdu	r1,-STACKFRAMESIZE(r1)
-	std	r14,STK_REG(R14)(r1)
-	std	r15,STK_REG(R15)(r1)
-	std	r16,STK_REG(R16)(r1)
-	std	r17,STK_REG(R17)(r1)
-	std	r18,STK_REG(R18)(r1)
-	std	r19,STK_REG(R19)(r1)
-	std	r20,STK_REG(R20)(r1)
-	std	r21,STK_REG(R21)(r1)
-	std	r22,STK_REG(R22)(r1)
-	std	r0,STACKFRAMESIZE+16(r1)
-
-	srdi	r6,r5,7
-	mtctr	r6
-
-	/* Now do cacheline (128B) sized loads and stores. */
-	.align	5
-4:
-err2;	ld	r0,0(r4)
-err2;	ld	r6,8(r4)
-err2;	ld	r7,16(r4)
-err2;	ld	r8,24(r4)
-err2;	ld	r9,32(r4)
-err2;	ld	r10,40(r4)
-err2;	ld	r11,48(r4)
-err2;	ld	r12,56(r4)
-err2;	ld	r14,64(r4)
-err2;	ld	r15,72(r4)
-err2;	ld	r16,80(r4)
-err2;	ld	r17,88(r4)
-err2;	ld	r18,96(r4)
-err2;	ld	r19,104(r4)
-err2;	ld	r20,112(r4)
-err2;	ld	r21,120(r4)
-	addi	r4,r4,128
-err2;	std	r0,0(r3)
-err2;	std	r6,8(r3)
-err2;	std	r7,16(r3)
-err2;	std	r8,24(r3)
-err2;	std	r9,32(r3)
-err2;	std	r10,40(r3)
-err2;	std	r11,48(r3)
-err2;	std	r12,56(r3)
-err2;	std	r14,64(r3)
-err2;	std	r15,72(r3)
-err2;	std	r16,80(r3)
-err2;	std	r17,88(r3)
-err2;	std	r18,96(r3)
-err2;	std	r19,104(r3)
-err2;	std	r20,112(r3)
-err2;	std	r21,120(r3)
-	addi	r3,r3,128
-	bdnz	4b
-
-	clrldi	r5,r5,(64-7)
-
-	ld	r14,STK_REG(R14)(r1)
-	ld	r15,STK_REG(R15)(r1)
-	ld	r16,STK_REG(R16)(r1)
-	ld	r17,STK_REG(R17)(r1)
-	ld	r18,STK_REG(R18)(r1)
-	ld	r19,STK_REG(R19)(r1)
-	ld	r20,STK_REG(R20)(r1)
-	ld	r21,STK_REG(R21)(r1)
-	ld	r22,STK_REG(R22)(r1)
-	addi	r1,r1,STACKFRAMESIZE
-
-	/* Up to 127B to go */
-5:	srdi	r6,r5,4
-	mtocrf	0x01,r6
-
-6:	bf	cr7*4+1,7f
-err1;	ld	r0,0(r4)
-err1;	ld	r6,8(r4)
-err1;	ld	r7,16(r4)
-err1;	ld	r8,24(r4)
-err1;	ld	r9,32(r4)
-err1;	ld	r10,40(r4)
-err1;	ld	r11,48(r4)
-err1;	ld	r12,56(r4)
-	addi	r4,r4,64
-err1;	std	r0,0(r3)
-err1;	std	r6,8(r3)
-err1;	std	r7,16(r3)
-err1;	std	r8,24(r3)
-err1;	std	r9,32(r3)
-err1;	std	r10,40(r3)
-err1;	std	r11,48(r3)
-err1;	std	r12,56(r3)
-	addi	r3,r3,64
-
-	/* Up to 63B to go */
-7:	bf	cr7*4+2,8f
-err1;	ld	r0,0(r4)
-err1;	ld	r6,8(r4)
-err1;	ld	r7,16(r4)
-err1;	ld	r8,24(r4)
-	addi	r4,r4,32
-err1;	std	r0,0(r3)
-err1;	std	r6,8(r3)
-err1;	std	r7,16(r3)
-err1;	std	r8,24(r3)
-	addi	r3,r3,32
-
-	/* Up to 31B to go */
-8:	bf	cr7*4+3,9f
-err1;	ld	r0,0(r4)
-err1;	ld	r6,8(r4)
-	addi	r4,r4,16
-err1;	std	r0,0(r3)
-err1;	std	r6,8(r3)
-	addi	r3,r3,16
-
-9:	clrldi	r5,r5,(64-4)
-
-	/* Up to 15B to go */
-.Lshort_copy:
-	mtocrf	0x01,r5
-	bf	cr7*4+0,12f
-err1;	lwz	r0,0(r4)	/* Less chance of a reject with word ops */
-err1;	lwz	r6,4(r4)
-	addi	r4,r4,8
-err1;	stw	r0,0(r3)
-err1;	stw	r6,4(r3)
-	addi	r3,r3,8
-
-12:	bf	cr7*4+1,13f
-err1;	lwz	r0,0(r4)
-	addi	r4,r4,4
-err1;	stw	r0,0(r3)
-	addi	r3,r3,4
-
-13:	bf	cr7*4+2,14f
-err1;	lhz	r0,0(r4)
-	addi	r4,r4,2
-err1;	sth	r0,0(r3)
-	addi	r3,r3,2
-
-14:	bf	cr7*4+3,15f
-err1;	lbz	r0,0(r4)
-err1;	stb	r0,0(r3)
-
-15:	li	r3,0
-	blr
-
-.Lunwind_stack_nonvmx_copy:
-	addi	r1,r1,STACKFRAMESIZE
-	b	.Lnonvmx_copy
-
-.Lvmx_copy:
-#ifdef CONFIG_ALTIVEC
-	mflr	r0
-	std	r0,16(r1)
-	stdu	r1,-STACKFRAMESIZE(r1)
-	bl	CFUNC(enter_vmx_usercopy)
-	cmpwi	cr1,r3,0
-	ld	r0,STACKFRAMESIZE+16(r1)
-	ld	r3,STK_REG(R31)(r1)
-	ld	r4,STK_REG(R30)(r1)
-	ld	r5,STK_REG(R29)(r1)
-	mtlr	r0
-
-	/*
-	 * We prefetch both the source and destination using enhanced touch
-	 * instructions. We use a stream ID of 0 for the load side and
-	 * 1 for the store side.
-	 */
-	clrrdi	r6,r4,7
-	clrrdi	r9,r3,7
-	ori	r9,r9,1		/* stream=1 */
-
-	srdi	r7,r5,7		/* length in cachelines, capped at 0x3FF */
-	cmpldi	r7,0x3FF
-	ble	1f
-	li	r7,0x3FF
-1:	lis	r0,0x0E00	/* depth=7 */
-	sldi	r7,r7,7
-	or	r7,r7,r0
-	ori	r10,r7,1	/* stream=1 */
-
-	DCBT_SETUP_STREAMS(r6, r7, r9, r10, r8)
-
-	beq	cr1,.Lunwind_stack_nonvmx_copy
-
-	/*
-	 * If source and destination are not relatively aligned we use a
-	 * slower permute loop.
-	 */
-	xor	r6,r4,r3
-	rldicl.	r6,r6,0,(64-4)
-	bne	.Lvmx_unaligned_copy
-
-	/* Get the destination 16B aligned */
-	neg	r6,r3
-	mtocrf	0x01,r6
-	clrldi	r6,r6,(64-4)
-
-	bf	cr7*4+3,1f
-err3;	lbz	r0,0(r4)
-	addi	r4,r4,1
-err3;	stb	r0,0(r3)
-	addi	r3,r3,1
-
-1:	bf	cr7*4+2,2f
-err3;	lhz	r0,0(r4)
-	addi	r4,r4,2
-err3;	sth	r0,0(r3)
-	addi	r3,r3,2
-
-2:	bf	cr7*4+1,3f
-err3;	lwz	r0,0(r4)
-	addi	r4,r4,4
-err3;	stw	r0,0(r3)
-	addi	r3,r3,4
-
-3:	bf	cr7*4+0,4f
-err3;	ld	r0,0(r4)
-	addi	r4,r4,8
-err3;	std	r0,0(r3)
-	addi	r3,r3,8
-
-4:	sub	r5,r5,r6
-
-	/* Get the desination 128B aligned */
-	neg	r6,r3
-	srdi	r7,r6,4
-	mtocrf	0x01,r7
-	clrldi	r6,r6,(64-7)
-
-	li	r9,16
-	li	r10,32
-	li	r11,48
-
-	bf	cr7*4+3,5f
-err3;	lvx	v1,0,r4
-	addi	r4,r4,16
-err3;	stvx	v1,0,r3
-	addi	r3,r3,16
-
-5:	bf	cr7*4+2,6f
-err3;	lvx	v1,0,r4
-err3;	lvx	v0,r4,r9
-	addi	r4,r4,32
-err3;	stvx	v1,0,r3
-err3;	stvx	v0,r3,r9
-	addi	r3,r3,32
-
-6:	bf	cr7*4+1,7f
-err3;	lvx	v3,0,r4
-err3;	lvx	v2,r4,r9
-err3;	lvx	v1,r4,r10
-err3;	lvx	v0,r4,r11
-	addi	r4,r4,64
-err3;	stvx	v3,0,r3
-err3;	stvx	v2,r3,r9
-err3;	stvx	v1,r3,r10
-err3;	stvx	v0,r3,r11
-	addi	r3,r3,64
-
-7:	sub	r5,r5,r6
-	srdi	r6,r5,7
-
-	std	r14,STK_REG(R14)(r1)
-	std	r15,STK_REG(R15)(r1)
-	std	r16,STK_REG(R16)(r1)
-
-	li	r12,64
-	li	r14,80
-	li	r15,96
-	li	r16,112
-
-	mtctr	r6
-
-	/*
-	 * Now do cacheline sized loads and stores. By this stage the
-	 * cacheline stores are also cacheline aligned.
-	 */
-	.align	5
-8:
-err4;	lvx	v7,0,r4
-err4;	lvx	v6,r4,r9
-err4;	lvx	v5,r4,r10
-err4;	lvx	v4,r4,r11
-err4;	lvx	v3,r4,r12
-err4;	lvx	v2,r4,r14
-err4;	lvx	v1,r4,r15
-err4;	lvx	v0,r4,r16
-	addi	r4,r4,128
-err4;	stvx	v7,0,r3
-err4;	stvx	v6,r3,r9
-err4;	stvx	v5,r3,r10
-err4;	stvx	v4,r3,r11
-err4;	stvx	v3,r3,r12
-err4;	stvx	v2,r3,r14
-err4;	stvx	v1,r3,r15
-err4;	stvx	v0,r3,r16
-	addi	r3,r3,128
-	bdnz	8b
-
-	ld	r14,STK_REG(R14)(r1)
-	ld	r15,STK_REG(R15)(r1)
-	ld	r16,STK_REG(R16)(r1)
-
-	/* Up to 127B to go */
-	clrldi	r5,r5,(64-7)
-	srdi	r6,r5,4
-	mtocrf	0x01,r6
-
-	bf	cr7*4+1,9f
-err3;	lvx	v3,0,r4
-err3;	lvx	v2,r4,r9
-err3;	lvx	v1,r4,r10
-err3;	lvx	v0,r4,r11
-	addi	r4,r4,64
-err3;	stvx	v3,0,r3
-err3;	stvx	v2,r3,r9
-err3;	stvx	v1,r3,r10
-err3;	stvx	v0,r3,r11
-	addi	r3,r3,64
-
-9:	bf	cr7*4+2,10f
-err3;	lvx	v1,0,r4
-err3;	lvx	v0,r4,r9
-	addi	r4,r4,32
-err3;	stvx	v1,0,r3
-err3;	stvx	v0,r3,r9
-	addi	r3,r3,32
-
-10:	bf	cr7*4+3,11f
-err3;	lvx	v1,0,r4
-	addi	r4,r4,16
-err3;	stvx	v1,0,r3
-	addi	r3,r3,16
-
-	/* Up to 15B to go */
-11:	clrldi	r5,r5,(64-4)
-	mtocrf	0x01,r5
-	bf	cr7*4+0,12f
-err3;	ld	r0,0(r4)
-	addi	r4,r4,8
-err3;	std	r0,0(r3)
-	addi	r3,r3,8
-
-12:	bf	cr7*4+1,13f
-err3;	lwz	r0,0(r4)
-	addi	r4,r4,4
-err3;	stw	r0,0(r3)
-	addi	r3,r3,4
-
-13:	bf	cr7*4+2,14f
-err3;	lhz	r0,0(r4)
-	addi	r4,r4,2
-err3;	sth	r0,0(r3)
-	addi	r3,r3,2
-
-14:	bf	cr7*4+3,15f
-err3;	lbz	r0,0(r4)
-err3;	stb	r0,0(r3)
-
-15:	addi	r1,r1,STACKFRAMESIZE
-	b	CFUNC(exit_vmx_usercopy)	/* tail call optimise */
-
-.Lvmx_unaligned_copy:
-	/* Get the destination 16B aligned */
-	neg	r6,r3
-	mtocrf	0x01,r6
-	clrldi	r6,r6,(64-4)
-
-	bf	cr7*4+3,1f
-err3;	lbz	r0,0(r4)
-	addi	r4,r4,1
-err3;	stb	r0,0(r3)
-	addi	r3,r3,1
-
-1:	bf	cr7*4+2,2f
-err3;	lhz	r0,0(r4)
-	addi	r4,r4,2
-err3;	sth	r0,0(r3)
-	addi	r3,r3,2
-
-2:	bf	cr7*4+1,3f
-err3;	lwz	r0,0(r4)
-	addi	r4,r4,4
-err3;	stw	r0,0(r3)
-	addi	r3,r3,4
-
-3:	bf	cr7*4+0,4f
-err3;	lwz	r0,0(r4)	/* Less chance of a reject with word ops */
-err3;	lwz	r7,4(r4)
-	addi	r4,r4,8
-err3;	stw	r0,0(r3)
-err3;	stw	r7,4(r3)
-	addi	r3,r3,8
-
-4:	sub	r5,r5,r6
-
-	/* Get the desination 128B aligned */
-	neg	r6,r3
-	srdi	r7,r6,4
-	mtocrf	0x01,r7
-	clrldi	r6,r6,(64-7)
-
-	li	r9,16
-	li	r10,32
-	li	r11,48
-
-	LVS(v16,0,r4)		/* Setup permute control vector */
-err3;	lvx	v0,0,r4
-	addi	r4,r4,16
-
-	bf	cr7*4+3,5f
-err3;	lvx	v1,0,r4
-	VPERM(v8,v0,v1,v16)
-	addi	r4,r4,16
-err3;	stvx	v8,0,r3
-	addi	r3,r3,16
-	vor	v0,v1,v1
-
-5:	bf	cr7*4+2,6f
-err3;	lvx	v1,0,r4
-	VPERM(v8,v0,v1,v16)
-err3;	lvx	v0,r4,r9
-	VPERM(v9,v1,v0,v16)
-	addi	r4,r4,32
-err3;	stvx	v8,0,r3
-err3;	stvx	v9,r3,r9
-	addi	r3,r3,32
-
-6:	bf	cr7*4+1,7f
-err3;	lvx	v3,0,r4
-	VPERM(v8,v0,v3,v16)
-err3;	lvx	v2,r4,r9
-	VPERM(v9,v3,v2,v16)
-err3;	lvx	v1,r4,r10
-	VPERM(v10,v2,v1,v16)
-err3;	lvx	v0,r4,r11
-	VPERM(v11,v1,v0,v16)
-	addi	r4,r4,64
-err3;	stvx	v8,0,r3
-err3;	stvx	v9,r3,r9
-err3;	stvx	v10,r3,r10
-err3;	stvx	v11,r3,r11
-	addi	r3,r3,64
-
-7:	sub	r5,r5,r6
-	srdi	r6,r5,7
-
-	std	r14,STK_REG(R14)(r1)
-	std	r15,STK_REG(R15)(r1)
-	std	r16,STK_REG(R16)(r1)
-
-	li	r12,64
-	li	r14,80
-	li	r15,96
-	li	r16,112
-
-	mtctr	r6
-
-	/*
-	 * Now do cacheline sized loads and stores. By this stage the
-	 * cacheline stores are also cacheline aligned.
-	 */
-	.align	5
-8:
-err4;	lvx	v7,0,r4
-	VPERM(v8,v0,v7,v16)
-err4;	lvx	v6,r4,r9
-	VPERM(v9,v7,v6,v16)
-err4;	lvx	v5,r4,r10
-	VPERM(v10,v6,v5,v16)
-err4;	lvx	v4,r4,r11
-	VPERM(v11,v5,v4,v16)
-err4;	lvx	v3,r4,r12
-	VPERM(v12,v4,v3,v16)
-err4;	lvx	v2,r4,r14
-	VPERM(v13,v3,v2,v16)
-err4;	lvx	v1,r4,r15
-	VPERM(v14,v2,v1,v16)
-err4;	lvx	v0,r4,r16
-	VPERM(v15,v1,v0,v16)
-	addi	r4,r4,128
-err4;	stvx	v8,0,r3
-err4;	stvx	v9,r3,r9
-err4;	stvx	v10,r3,r10
-err4;	stvx	v11,r3,r11
-err4;	stvx	v12,r3,r12
-err4;	stvx	v13,r3,r14
-err4;	stvx	v14,r3,r15
-err4;	stvx	v15,r3,r16
-	addi	r3,r3,128
-	bdnz	8b
-
-	ld	r14,STK_REG(R14)(r1)
-	ld	r15,STK_REG(R15)(r1)
-	ld	r16,STK_REG(R16)(r1)
-
-	/* Up to 127B to go */
-	clrldi	r5,r5,(64-7)
-	srdi	r6,r5,4
-	mtocrf	0x01,r6
-
-	bf	cr7*4+1,9f
-err3;	lvx	v3,0,r4
-	VPERM(v8,v0,v3,v16)
-err3;	lvx	v2,r4,r9
-	VPERM(v9,v3,v2,v16)
-err3;	lvx	v1,r4,r10
-	VPERM(v10,v2,v1,v16)
-err3;	lvx	v0,r4,r11
-	VPERM(v11,v1,v0,v16)
-	addi	r4,r4,64
-err3;	stvx	v8,0,r3
-err3;	stvx	v9,r3,r9
-err3;	stvx	v10,r3,r10
-err3;	stvx	v11,r3,r11
-	addi	r3,r3,64
-
-9:	bf	cr7*4+2,10f
-err3;	lvx	v1,0,r4
-	VPERM(v8,v0,v1,v16)
-err3;	lvx	v0,r4,r9
-	VPERM(v9,v1,v0,v16)
-	addi	r4,r4,32
-err3;	stvx	v8,0,r3
-err3;	stvx	v9,r3,r9
-	addi	r3,r3,32
-
-10:	bf	cr7*4+3,11f
-err3;	lvx	v1,0,r4
-	VPERM(v8,v0,v1,v16)
-	addi	r4,r4,16
-err3;	stvx	v8,0,r3
-	addi	r3,r3,16
-
-	/* Up to 15B to go */
-11:	clrldi	r5,r5,(64-4)
-	addi	r4,r4,-16	/* Unwind the +16 load offset */
-	mtocrf	0x01,r5
-	bf	cr7*4+0,12f
-err3;	lwz	r0,0(r4)	/* Less chance of a reject with word ops */
-err3;	lwz	r6,4(r4)
-	addi	r4,r4,8
-err3;	stw	r0,0(r3)
-err3;	stw	r6,4(r3)
-	addi	r3,r3,8
-
-12:	bf	cr7*4+1,13f
-err3;	lwz	r0,0(r4)
-	addi	r4,r4,4
-err3;	stw	r0,0(r3)
-	addi	r3,r3,4
-
-13:	bf	cr7*4+2,14f
-err3;	lhz	r0,0(r4)
-	addi	r4,r4,2
-err3;	sth	r0,0(r3)
-	addi	r3,r3,2
-
-14:	bf	cr7*4+3,15f
-err3;	lbz	r0,0(r4)
-err3;	stb	r0,0(r3)
-
-15:	addi	r1,r1,STACKFRAMESIZE
-	b	CFUNC(exit_vmx_usercopy)	/* tail call optimise */
-#endif /* CONFIG_ALTIVEC */
+../../../../../arch/powerpc/lib/copyuser_power7.S
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/powerpc/copyloops/mem_64.S linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/copyloops/mem_64.S
--- linux-6.16.7/tools/testing/selftests/powerpc/copyloops/mem_64.S	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/copyloops/mem_64.S	2025-09-11 09:47:42.000000000 -0600
@@ -1,142 +1 @@
-/* SPDX-License-Identifier: GPL-2.0-or-later */
-/*
- * String handling functions for PowerPC.
- *
- * Copyright (C) 1996 Paul Mackerras.
- */
-#include <linux/export.h>
-#include <asm/processor.h>
-#include <asm/errno.h>
-#include <asm/ppc_asm.h>
-#include <asm/kasan.h>
-
-#ifndef CONFIG_KASAN
-_GLOBAL(__memset16)
-	rlwimi	r4,r4,16,0,15
-	/* fall through */
-
-_GLOBAL(__memset32)
-	rldimi	r4,r4,32,0
-	/* fall through */
-
-_GLOBAL(__memset64)
-	neg	r0,r3
-	andi.	r0,r0,7
-	cmplw	cr1,r5,r0
-	b	.Lms
-EXPORT_SYMBOL(__memset16)
-EXPORT_SYMBOL(__memset32)
-EXPORT_SYMBOL(__memset64)
-#endif
-
-_GLOBAL_KASAN(memset)
-	neg	r0,r3
-	rlwimi	r4,r4,8,16,23
-	andi.	r0,r0,7			/* # bytes to be 8-byte aligned */
-	rlwimi	r4,r4,16,0,15
-	cmplw	cr1,r5,r0		/* do we get that far? */
-	rldimi	r4,r4,32,0
-.Lms:	PPC_MTOCRF(1,r0)
-	mr	r6,r3
-	blt	cr1,8f
-	beq	3f			/* if already 8-byte aligned */
-	subf	r5,r0,r5
-	bf	31,1f
-	stb	r4,0(r6)
-	addi	r6,r6,1
-1:	bf	30,2f
-	sth	r4,0(r6)
-	addi	r6,r6,2
-2:	bf	29,3f
-	stw	r4,0(r6)
-	addi	r6,r6,4
-3:	srdi.	r0,r5,6
-	clrldi	r5,r5,58
-	mtctr	r0
-	beq	5f
-	.balign 16
-4:	std	r4,0(r6)
-	std	r4,8(r6)
-	std	r4,16(r6)
-	std	r4,24(r6)
-	std	r4,32(r6)
-	std	r4,40(r6)
-	std	r4,48(r6)
-	std	r4,56(r6)
-	addi	r6,r6,64
-	bdnz	4b
-5:	srwi.	r0,r5,3
-	clrlwi	r5,r5,29
-	PPC_MTOCRF(1,r0)
-	beq	8f
-	bf	29,6f
-	std	r4,0(r6)
-	std	r4,8(r6)
-	std	r4,16(r6)
-	std	r4,24(r6)
-	addi	r6,r6,32
-6:	bf	30,7f
-	std	r4,0(r6)
-	std	r4,8(r6)
-	addi	r6,r6,16
-7:	bf	31,8f
-	std	r4,0(r6)
-	addi	r6,r6,8
-8:	cmpwi	r5,0
-	PPC_MTOCRF(1,r5)
-	beqlr
-	bf	29,9f
-	stw	r4,0(r6)
-	addi	r6,r6,4
-9:	bf	30,10f
-	sth	r4,0(r6)
-	addi	r6,r6,2
-10:	bflr	31
-	stb	r4,0(r6)
-	blr
-EXPORT_SYMBOL(memset)
-EXPORT_SYMBOL_KASAN(memset)
-
-_GLOBAL_TOC_KASAN(memmove)
-	cmplw	0,r3,r4
-	bgt	backwards_memcpy
-	b	memcpy
-
-_GLOBAL(backwards_memcpy)
-	rlwinm.	r7,r5,32-3,3,31		/* r0 = r5 >> 3 */
-	add	r6,r3,r5
-	add	r4,r4,r5
-	beq	2f
-	andi.	r0,r6,3
-	mtctr	r7
-	bne	5f
-	.balign 16
-1:	lwz	r7,-4(r4)
-	lwzu	r8,-8(r4)
-	stw	r7,-4(r6)
-	stwu	r8,-8(r6)
-	bdnz	1b
-	andi.	r5,r5,7
-2:	cmplwi	0,r5,4
-	blt	3f
-	lwzu	r0,-4(r4)
-	subi	r5,r5,4
-	stwu	r0,-4(r6)
-3:	cmpwi	0,r5,0
-	beqlr
-	mtctr	r5
-4:	lbzu	r0,-1(r4)
-	stbu	r0,-1(r6)
-	bdnz	4b
-	blr
-5:	mtctr	r0
-6:	lbzu	r7,-1(r4)
-	stbu	r7,-1(r6)
-	bdnz	6b
-	subf	r5,r0,r5
-	rlwinm.	r7,r5,32-3,3,31
-	beq	2b
-	mtctr	r7
-	b	1b
-EXPORT_SYMBOL(memmove)
-EXPORT_SYMBOL_KASAN(memmove)
+../../../../../arch/powerpc/lib/mem_64.S
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/powerpc/copyloops/memcpy_64.S linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/copyloops/memcpy_64.S
--- linux-6.16.7/tools/testing/selftests/powerpc/copyloops/memcpy_64.S	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/copyloops/memcpy_64.S	2025-09-11 09:47:42.000000000 -0600
@@ -1,230 +1 @@
-/* SPDX-License-Identifier: GPL-2.0-or-later */
-/*
- * Copyright (C) 2002 Paul Mackerras, IBM Corp.
- */
-#include <linux/export.h>
-#include <asm/processor.h>
-#include <asm/ppc_asm.h>
-#include <asm/asm-compat.h>
-#include <asm/feature-fixups.h>
-#include <asm/kasan.h>
-
-#ifndef SELFTEST_CASE
-/* For big-endian, 0 == most CPUs, 1 == POWER6, 2 == Cell */
-#define SELFTEST_CASE	0
-#endif
-
-	.align	7
-_GLOBAL_TOC_KASAN(memcpy)
-BEGIN_FTR_SECTION
-#ifdef __LITTLE_ENDIAN__
-	cmpdi	cr7,r5,0
-#else
-	std	r3,-STACKFRAMESIZE+STK_REG(R31)(r1)	/* save destination pointer for return value */
-#endif
-FTR_SECTION_ELSE
-#ifdef CONFIG_PPC_BOOK3S_64
-	b	memcpy_power7
-#endif
-ALT_FTR_SECTION_END_IFCLR(CPU_FTR_VMX_COPY)
-#ifdef __LITTLE_ENDIAN__
-	/* dumb little-endian memcpy that will get replaced at runtime */
-	addi r9,r3,-1
-	addi r4,r4,-1
-	beqlr cr7
-	mtctr r5
-1:	lbzu r10,1(r4)
-	stbu r10,1(r9)
-	bdnz 1b
-	blr
-#else
-	PPC_MTOCRF(0x01,r5)
-	cmpldi	cr1,r5,16
-	neg	r6,r3		# LS 3 bits = # bytes to 8-byte dest bdry
-	andi.	r6,r6,7
-	dcbt	0,r4
-	blt	cr1,.Lshort_copy
-/* Below we want to nop out the bne if we're on a CPU that has the
-   CPU_FTR_UNALIGNED_LD_STD bit set and the CPU_FTR_CP_USE_DCBTZ bit
-   cleared.
-   At the time of writing the only CPU that has this combination of bits
-   set is Power6. */
-test_feature = (SELFTEST_CASE == 1)
-BEGIN_FTR_SECTION
-	nop
-FTR_SECTION_ELSE
-	bne	.Ldst_unaligned
-ALT_FTR_SECTION_END(CPU_FTR_UNALIGNED_LD_STD | CPU_FTR_CP_USE_DCBTZ, \
-                    CPU_FTR_UNALIGNED_LD_STD)
-.Ldst_aligned:
-	addi	r3,r3,-16
-test_feature = (SELFTEST_CASE == 0)
-BEGIN_FTR_SECTION
-	andi.	r0,r4,7
-	bne	.Lsrc_unaligned
-END_FTR_SECTION_IFCLR(CPU_FTR_UNALIGNED_LD_STD)
-	srdi	r7,r5,4
-	ld	r9,0(r4)
-	addi	r4,r4,-8
-	mtctr	r7
-	andi.	r5,r5,7
-	bf	cr7*4+0,2f
-	addi	r3,r3,8
-	addi	r4,r4,8
-	mr	r8,r9
-	blt	cr1,3f
-1:	ld	r9,8(r4)
-	std	r8,8(r3)
-2:	ldu	r8,16(r4)
-	stdu	r9,16(r3)
-	bdnz	1b
-3:	std	r8,8(r3)
-	beq	3f
-	addi	r3,r3,16
-.Ldo_tail:
-	bf	cr7*4+1,1f
-	lwz	r9,8(r4)
-	addi	r4,r4,4
-	stw	r9,0(r3)
-	addi	r3,r3,4
-1:	bf	cr7*4+2,2f
-	lhz	r9,8(r4)
-	addi	r4,r4,2
-	sth	r9,0(r3)
-	addi	r3,r3,2
-2:	bf	cr7*4+3,3f
-	lbz	r9,8(r4)
-	stb	r9,0(r3)
-3:	ld	r3,-STACKFRAMESIZE+STK_REG(R31)(r1)	/* return dest pointer */
-	blr
-
-.Lsrc_unaligned:
-	srdi	r6,r5,3
-	addi	r5,r5,-16
-	subf	r4,r0,r4
-	srdi	r7,r5,4
-	sldi	r10,r0,3
-	cmpdi	cr6,r6,3
-	andi.	r5,r5,7
-	mtctr	r7
-	subfic	r11,r10,64
-	add	r5,r5,r0
-
-	bt	cr7*4+0,0f
-
-	ld	r9,0(r4)	# 3+2n loads, 2+2n stores
-	ld	r0,8(r4)
-	sld	r6,r9,r10
-	ldu	r9,16(r4)
-	srd	r7,r0,r11
-	sld	r8,r0,r10
-	or	r7,r7,r6
-	blt	cr6,4f
-	ld	r0,8(r4)
-	# s1<< in r8, d0=(s0<<|s1>>) in r7, s3 in r0, s2 in r9, nix in r6 & r12
-	b	2f
-
-0:	ld	r0,0(r4)	# 4+2n loads, 3+2n stores
-	ldu	r9,8(r4)
-	sld	r8,r0,r10
-	addi	r3,r3,-8
-	blt	cr6,5f
-	ld	r0,8(r4)
-	srd	r12,r9,r11
-	sld	r6,r9,r10
-	ldu	r9,16(r4)
-	or	r12,r8,r12
-	srd	r7,r0,r11
-	sld	r8,r0,r10
-	addi	r3,r3,16
-	beq	cr6,3f
-
-	# d0=(s0<<|s1>>) in r12, s1<< in r6, s2>> in r7, s2<< in r8, s3 in r9
-1:	or	r7,r7,r6
-	ld	r0,8(r4)
-	std	r12,8(r3)
-2:	srd	r12,r9,r11
-	sld	r6,r9,r10
-	ldu	r9,16(r4)
-	or	r12,r8,r12
-	stdu	r7,16(r3)
-	srd	r7,r0,r11
-	sld	r8,r0,r10
-	bdnz	1b
-
-3:	std	r12,8(r3)
-	or	r7,r7,r6
-4:	std	r7,16(r3)
-5:	srd	r12,r9,r11
-	or	r12,r8,r12
-	std	r12,24(r3)
-	beq	4f
-	cmpwi	cr1,r5,8
-	addi	r3,r3,32
-	sld	r9,r9,r10
-	ble	cr1,6f
-	ld	r0,8(r4)
-	srd	r7,r0,r11
-	or	r9,r7,r9
-6:
-	bf	cr7*4+1,1f
-	rotldi	r9,r9,32
-	stw	r9,0(r3)
-	addi	r3,r3,4
-1:	bf	cr7*4+2,2f
-	rotldi	r9,r9,16
-	sth	r9,0(r3)
-	addi	r3,r3,2
-2:	bf	cr7*4+3,3f
-	rotldi	r9,r9,8
-	stb	r9,0(r3)
-3:	ld	r3,-STACKFRAMESIZE+STK_REG(R31)(r1)	/* return dest pointer */
-	blr
-
-.Ldst_unaligned:
-	PPC_MTOCRF(0x01,r6)		# put #bytes to 8B bdry into cr7
-	subf	r5,r6,r5
-	li	r7,0
-	cmpldi	cr1,r5,16
-	bf	cr7*4+3,1f
-	lbz	r0,0(r4)
-	stb	r0,0(r3)
-	addi	r7,r7,1
-1:	bf	cr7*4+2,2f
-	lhzx	r0,r7,r4
-	sthx	r0,r7,r3
-	addi	r7,r7,2
-2:	bf	cr7*4+1,3f
-	lwzx	r0,r7,r4
-	stwx	r0,r7,r3
-3:	PPC_MTOCRF(0x01,r5)
-	add	r4,r6,r4
-	add	r3,r6,r3
-	b	.Ldst_aligned
-
-.Lshort_copy:
-	bf	cr7*4+0,1f
-	lwz	r0,0(r4)
-	lwz	r9,4(r4)
-	addi	r4,r4,8
-	stw	r0,0(r3)
-	stw	r9,4(r3)
-	addi	r3,r3,8
-1:	bf	cr7*4+1,2f
-	lwz	r0,0(r4)
-	addi	r4,r4,4
-	stw	r0,0(r3)
-	addi	r3,r3,4
-2:	bf	cr7*4+2,3f
-	lhz	r0,0(r4)
-	addi	r4,r4,2
-	sth	r0,0(r3)
-	addi	r3,r3,2
-3:	bf	cr7*4+3,4f
-	lbz	r0,0(r4)
-	stb	r0,0(r3)
-4:	ld	r3,-STACKFRAMESIZE+STK_REG(R31)(r1)	/* return dest pointer */
-	blr
-#endif
-EXPORT_SYMBOL(memcpy)
-EXPORT_SYMBOL_KASAN(memcpy)
+../../../../../arch/powerpc/lib/memcpy_64.S
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/powerpc/copyloops/memcpy_power7.S linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/copyloops/memcpy_power7.S
--- linux-6.16.7/tools/testing/selftests/powerpc/copyloops/memcpy_power7.S	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/copyloops/memcpy_power7.S	2025-09-11 09:47:42.000000000 -0600
@@ -1,633 +1 @@
-/* SPDX-License-Identifier: GPL-2.0-or-later */
-/*
- *
- * Copyright (C) IBM Corporation, 2012
- *
- * Author: Anton Blanchard <anton@au.ibm.com>
- */
-#include <asm/ppc_asm.h>
-
-#ifndef SELFTEST_CASE
-/* 0 == don't use VMX, 1 == use VMX */
-#define SELFTEST_CASE	0
-#endif
-
-#ifdef __BIG_ENDIAN__
-#define LVS(VRT,RA,RB)		lvsl	VRT,RA,RB
-#define VPERM(VRT,VRA,VRB,VRC)	vperm	VRT,VRA,VRB,VRC
-#else
-#define LVS(VRT,RA,RB)		lvsr	VRT,RA,RB
-#define VPERM(VRT,VRA,VRB,VRC)	vperm	VRT,VRB,VRA,VRC
-#endif
-
-_GLOBAL(memcpy_power7)
-	cmpldi	r5,16
-	cmpldi	cr1,r5,4096
-	std	r3,-STACKFRAMESIZE+STK_REG(R31)(r1)
-	blt	.Lshort_copy
-
-#ifdef CONFIG_ALTIVEC
-test_feature = SELFTEST_CASE
-BEGIN_FTR_SECTION
-	bgt	cr1, .Lvmx_copy
-END_FTR_SECTION_IFSET(CPU_FTR_ALTIVEC)
-#endif
-
-.Lnonvmx_copy:
-	/* Get the source 8B aligned */
-	neg	r6,r4
-	mtocrf	0x01,r6
-	clrldi	r6,r6,(64-3)
-
-	bf	cr7*4+3,1f
-	lbz	r0,0(r4)
-	addi	r4,r4,1
-	stb	r0,0(r3)
-	addi	r3,r3,1
-
-1:	bf	cr7*4+2,2f
-	lhz	r0,0(r4)
-	addi	r4,r4,2
-	sth	r0,0(r3)
-	addi	r3,r3,2
-
-2:	bf	cr7*4+1,3f
-	lwz	r0,0(r4)
-	addi	r4,r4,4
-	stw	r0,0(r3)
-	addi	r3,r3,4
-
-3:	sub	r5,r5,r6
-	cmpldi	r5,128
-	blt	5f
-
-	mflr	r0
-	stdu	r1,-STACKFRAMESIZE(r1)
-	std	r14,STK_REG(R14)(r1)
-	std	r15,STK_REG(R15)(r1)
-	std	r16,STK_REG(R16)(r1)
-	std	r17,STK_REG(R17)(r1)
-	std	r18,STK_REG(R18)(r1)
-	std	r19,STK_REG(R19)(r1)
-	std	r20,STK_REG(R20)(r1)
-	std	r21,STK_REG(R21)(r1)
-	std	r22,STK_REG(R22)(r1)
-	std	r0,STACKFRAMESIZE+16(r1)
-
-	srdi	r6,r5,7
-	mtctr	r6
-
-	/* Now do cacheline (128B) sized loads and stores. */
-	.align	5
-4:
-	ld	r0,0(r4)
-	ld	r6,8(r4)
-	ld	r7,16(r4)
-	ld	r8,24(r4)
-	ld	r9,32(r4)
-	ld	r10,40(r4)
-	ld	r11,48(r4)
-	ld	r12,56(r4)
-	ld	r14,64(r4)
-	ld	r15,72(r4)
-	ld	r16,80(r4)
-	ld	r17,88(r4)
-	ld	r18,96(r4)
-	ld	r19,104(r4)
-	ld	r20,112(r4)
-	ld	r21,120(r4)
-	addi	r4,r4,128
-	std	r0,0(r3)
-	std	r6,8(r3)
-	std	r7,16(r3)
-	std	r8,24(r3)
-	std	r9,32(r3)
-	std	r10,40(r3)
-	std	r11,48(r3)
-	std	r12,56(r3)
-	std	r14,64(r3)
-	std	r15,72(r3)
-	std	r16,80(r3)
-	std	r17,88(r3)
-	std	r18,96(r3)
-	std	r19,104(r3)
-	std	r20,112(r3)
-	std	r21,120(r3)
-	addi	r3,r3,128
-	bdnz	4b
-
-	clrldi	r5,r5,(64-7)
-
-	ld	r14,STK_REG(R14)(r1)
-	ld	r15,STK_REG(R15)(r1)
-	ld	r16,STK_REG(R16)(r1)
-	ld	r17,STK_REG(R17)(r1)
-	ld	r18,STK_REG(R18)(r1)
-	ld	r19,STK_REG(R19)(r1)
-	ld	r20,STK_REG(R20)(r1)
-	ld	r21,STK_REG(R21)(r1)
-	ld	r22,STK_REG(R22)(r1)
-	addi	r1,r1,STACKFRAMESIZE
-
-	/* Up to 127B to go */
-5:	srdi	r6,r5,4
-	mtocrf	0x01,r6
-
-6:	bf	cr7*4+1,7f
-	ld	r0,0(r4)
-	ld	r6,8(r4)
-	ld	r7,16(r4)
-	ld	r8,24(r4)
-	ld	r9,32(r4)
-	ld	r10,40(r4)
-	ld	r11,48(r4)
-	ld	r12,56(r4)
-	addi	r4,r4,64
-	std	r0,0(r3)
-	std	r6,8(r3)
-	std	r7,16(r3)
-	std	r8,24(r3)
-	std	r9,32(r3)
-	std	r10,40(r3)
-	std	r11,48(r3)
-	std	r12,56(r3)
-	addi	r3,r3,64
-
-	/* Up to 63B to go */
-7:	bf	cr7*4+2,8f
-	ld	r0,0(r4)
-	ld	r6,8(r4)
-	ld	r7,16(r4)
-	ld	r8,24(r4)
-	addi	r4,r4,32
-	std	r0,0(r3)
-	std	r6,8(r3)
-	std	r7,16(r3)
-	std	r8,24(r3)
-	addi	r3,r3,32
-
-	/* Up to 31B to go */
-8:	bf	cr7*4+3,9f
-	ld	r0,0(r4)
-	ld	r6,8(r4)
-	addi	r4,r4,16
-	std	r0,0(r3)
-	std	r6,8(r3)
-	addi	r3,r3,16
-
-9:	clrldi	r5,r5,(64-4)
-
-	/* Up to 15B to go */
-.Lshort_copy:
-	mtocrf	0x01,r5
-	bf	cr7*4+0,12f
-	lwz	r0,0(r4)	/* Less chance of a reject with word ops */
-	lwz	r6,4(r4)
-	addi	r4,r4,8
-	stw	r0,0(r3)
-	stw	r6,4(r3)
-	addi	r3,r3,8
-
-12:	bf	cr7*4+1,13f
-	lwz	r0,0(r4)
-	addi	r4,r4,4
-	stw	r0,0(r3)
-	addi	r3,r3,4
-
-13:	bf	cr7*4+2,14f
-	lhz	r0,0(r4)
-	addi	r4,r4,2
-	sth	r0,0(r3)
-	addi	r3,r3,2
-
-14:	bf	cr7*4+3,15f
-	lbz	r0,0(r4)
-	stb	r0,0(r3)
-
-15:	ld	r3,-STACKFRAMESIZE+STK_REG(R31)(r1)
-	blr
-
-.Lunwind_stack_nonvmx_copy:
-	addi	r1,r1,STACKFRAMESIZE
-	b	.Lnonvmx_copy
-
-.Lvmx_copy:
-#ifdef CONFIG_ALTIVEC
-	mflr	r0
-	std	r4,-STACKFRAMESIZE+STK_REG(R30)(r1)
-	std	r5,-STACKFRAMESIZE+STK_REG(R29)(r1)
-	std	r0,16(r1)
-	stdu	r1,-STACKFRAMESIZE(r1)
-	bl	CFUNC(enter_vmx_ops)
-	cmpwi	cr1,r3,0
-	ld	r0,STACKFRAMESIZE+16(r1)
-	ld	r3,STK_REG(R31)(r1)
-	ld	r4,STK_REG(R30)(r1)
-	ld	r5,STK_REG(R29)(r1)
-	mtlr	r0
-
-	/*
-	 * We prefetch both the source and destination using enhanced touch
-	 * instructions. We use a stream ID of 0 for the load side and
-	 * 1 for the store side.
-	 */
-	clrrdi	r6,r4,7
-	clrrdi	r9,r3,7
-	ori	r9,r9,1		/* stream=1 */
-
-	srdi	r7,r5,7		/* length in cachelines, capped at 0x3FF */
-	cmpldi	r7,0x3FF
-	ble	1f
-	li	r7,0x3FF
-1:	lis	r0,0x0E00	/* depth=7 */
-	sldi	r7,r7,7
-	or	r7,r7,r0
-	ori	r10,r7,1	/* stream=1 */
-
-	DCBT_SETUP_STREAMS(r6, r7, r9, r10, r8)
-
-	beq	cr1,.Lunwind_stack_nonvmx_copy
-
-	/*
-	 * If source and destination are not relatively aligned we use a
-	 * slower permute loop.
-	 */
-	xor	r6,r4,r3
-	rldicl.	r6,r6,0,(64-4)
-	bne	.Lvmx_unaligned_copy
-
-	/* Get the destination 16B aligned */
-	neg	r6,r3
-	mtocrf	0x01,r6
-	clrldi	r6,r6,(64-4)
-
-	bf	cr7*4+3,1f
-	lbz	r0,0(r4)
-	addi	r4,r4,1
-	stb	r0,0(r3)
-	addi	r3,r3,1
-
-1:	bf	cr7*4+2,2f
-	lhz	r0,0(r4)
-	addi	r4,r4,2
-	sth	r0,0(r3)
-	addi	r3,r3,2
-
-2:	bf	cr7*4+1,3f
-	lwz	r0,0(r4)
-	addi	r4,r4,4
-	stw	r0,0(r3)
-	addi	r3,r3,4
-
-3:	bf	cr7*4+0,4f
-	ld	r0,0(r4)
-	addi	r4,r4,8
-	std	r0,0(r3)
-	addi	r3,r3,8
-
-4:	sub	r5,r5,r6
-
-	/* Get the desination 128B aligned */
-	neg	r6,r3
-	srdi	r7,r6,4
-	mtocrf	0x01,r7
-	clrldi	r6,r6,(64-7)
-
-	li	r9,16
-	li	r10,32
-	li	r11,48
-
-	bf	cr7*4+3,5f
-	lvx	v1,0,r4
-	addi	r4,r4,16
-	stvx	v1,0,r3
-	addi	r3,r3,16
-
-5:	bf	cr7*4+2,6f
-	lvx	v1,0,r4
-	lvx	v0,r4,r9
-	addi	r4,r4,32
-	stvx	v1,0,r3
-	stvx	v0,r3,r9
-	addi	r3,r3,32
-
-6:	bf	cr7*4+1,7f
-	lvx	v3,0,r4
-	lvx	v2,r4,r9
-	lvx	v1,r4,r10
-	lvx	v0,r4,r11
-	addi	r4,r4,64
-	stvx	v3,0,r3
-	stvx	v2,r3,r9
-	stvx	v1,r3,r10
-	stvx	v0,r3,r11
-	addi	r3,r3,64
-
-7:	sub	r5,r5,r6
-	srdi	r6,r5,7
-
-	std	r14,STK_REG(R14)(r1)
-	std	r15,STK_REG(R15)(r1)
-	std	r16,STK_REG(R16)(r1)
-
-	li	r12,64
-	li	r14,80
-	li	r15,96
-	li	r16,112
-
-	mtctr	r6
-
-	/*
-	 * Now do cacheline sized loads and stores. By this stage the
-	 * cacheline stores are also cacheline aligned.
-	 */
-	.align	5
-8:
-	lvx	v7,0,r4
-	lvx	v6,r4,r9
-	lvx	v5,r4,r10
-	lvx	v4,r4,r11
-	lvx	v3,r4,r12
-	lvx	v2,r4,r14
-	lvx	v1,r4,r15
-	lvx	v0,r4,r16
-	addi	r4,r4,128
-	stvx	v7,0,r3
-	stvx	v6,r3,r9
-	stvx	v5,r3,r10
-	stvx	v4,r3,r11
-	stvx	v3,r3,r12
-	stvx	v2,r3,r14
-	stvx	v1,r3,r15
-	stvx	v0,r3,r16
-	addi	r3,r3,128
-	bdnz	8b
-
-	ld	r14,STK_REG(R14)(r1)
-	ld	r15,STK_REG(R15)(r1)
-	ld	r16,STK_REG(R16)(r1)
-
-	/* Up to 127B to go */
-	clrldi	r5,r5,(64-7)
-	srdi	r6,r5,4
-	mtocrf	0x01,r6
-
-	bf	cr7*4+1,9f
-	lvx	v3,0,r4
-	lvx	v2,r4,r9
-	lvx	v1,r4,r10
-	lvx	v0,r4,r11
-	addi	r4,r4,64
-	stvx	v3,0,r3
-	stvx	v2,r3,r9
-	stvx	v1,r3,r10
-	stvx	v0,r3,r11
-	addi	r3,r3,64
-
-9:	bf	cr7*4+2,10f
-	lvx	v1,0,r4
-	lvx	v0,r4,r9
-	addi	r4,r4,32
-	stvx	v1,0,r3
-	stvx	v0,r3,r9
-	addi	r3,r3,32
-
-10:	bf	cr7*4+3,11f
-	lvx	v1,0,r4
-	addi	r4,r4,16
-	stvx	v1,0,r3
-	addi	r3,r3,16
-
-	/* Up to 15B to go */
-11:	clrldi	r5,r5,(64-4)
-	mtocrf	0x01,r5
-	bf	cr7*4+0,12f
-	ld	r0,0(r4)
-	addi	r4,r4,8
-	std	r0,0(r3)
-	addi	r3,r3,8
-
-12:	bf	cr7*4+1,13f
-	lwz	r0,0(r4)
-	addi	r4,r4,4
-	stw	r0,0(r3)
-	addi	r3,r3,4
-
-13:	bf	cr7*4+2,14f
-	lhz	r0,0(r4)
-	addi	r4,r4,2
-	sth	r0,0(r3)
-	addi	r3,r3,2
-
-14:	bf	cr7*4+3,15f
-	lbz	r0,0(r4)
-	stb	r0,0(r3)
-
-15:	addi	r1,r1,STACKFRAMESIZE
-	ld	r3,-STACKFRAMESIZE+STK_REG(R31)(r1)
-	b	CFUNC(exit_vmx_ops)		/* tail call optimise */
-
-.Lvmx_unaligned_copy:
-	/* Get the destination 16B aligned */
-	neg	r6,r3
-	mtocrf	0x01,r6
-	clrldi	r6,r6,(64-4)
-
-	bf	cr7*4+3,1f
-	lbz	r0,0(r4)
-	addi	r4,r4,1
-	stb	r0,0(r3)
-	addi	r3,r3,1
-
-1:	bf	cr7*4+2,2f
-	lhz	r0,0(r4)
-	addi	r4,r4,2
-	sth	r0,0(r3)
-	addi	r3,r3,2
-
-2:	bf	cr7*4+1,3f
-	lwz	r0,0(r4)
-	addi	r4,r4,4
-	stw	r0,0(r3)
-	addi	r3,r3,4
-
-3:	bf	cr7*4+0,4f
-	lwz	r0,0(r4)	/* Less chance of a reject with word ops */
-	lwz	r7,4(r4)
-	addi	r4,r4,8
-	stw	r0,0(r3)
-	stw	r7,4(r3)
-	addi	r3,r3,8
-
-4:	sub	r5,r5,r6
-
-	/* Get the desination 128B aligned */
-	neg	r6,r3
-	srdi	r7,r6,4
-	mtocrf	0x01,r7
-	clrldi	r6,r6,(64-7)
-
-	li	r9,16
-	li	r10,32
-	li	r11,48
-
-	LVS(v16,0,r4)		/* Setup permute control vector */
-	lvx	v0,0,r4
-	addi	r4,r4,16
-
-	bf	cr7*4+3,5f
-	lvx	v1,0,r4
-	VPERM(v8,v0,v1,v16)
-	addi	r4,r4,16
-	stvx	v8,0,r3
-	addi	r3,r3,16
-	vor	v0,v1,v1
-
-5:	bf	cr7*4+2,6f
-	lvx	v1,0,r4
-	VPERM(v8,v0,v1,v16)
-	lvx	v0,r4,r9
-	VPERM(v9,v1,v0,v16)
-	addi	r4,r4,32
-	stvx	v8,0,r3
-	stvx	v9,r3,r9
-	addi	r3,r3,32
-
-6:	bf	cr7*4+1,7f
-	lvx	v3,0,r4
-	VPERM(v8,v0,v3,v16)
-	lvx	v2,r4,r9
-	VPERM(v9,v3,v2,v16)
-	lvx	v1,r4,r10
-	VPERM(v10,v2,v1,v16)
-	lvx	v0,r4,r11
-	VPERM(v11,v1,v0,v16)
-	addi	r4,r4,64
-	stvx	v8,0,r3
-	stvx	v9,r3,r9
-	stvx	v10,r3,r10
-	stvx	v11,r3,r11
-	addi	r3,r3,64
-
-7:	sub	r5,r5,r6
-	srdi	r6,r5,7
-
-	std	r14,STK_REG(R14)(r1)
-	std	r15,STK_REG(R15)(r1)
-	std	r16,STK_REG(R16)(r1)
-
-	li	r12,64
-	li	r14,80
-	li	r15,96
-	li	r16,112
-
-	mtctr	r6
-
-	/*
-	 * Now do cacheline sized loads and stores. By this stage the
-	 * cacheline stores are also cacheline aligned.
-	 */
-	.align	5
-8:
-	lvx	v7,0,r4
-	VPERM(v8,v0,v7,v16)
-	lvx	v6,r4,r9
-	VPERM(v9,v7,v6,v16)
-	lvx	v5,r4,r10
-	VPERM(v10,v6,v5,v16)
-	lvx	v4,r4,r11
-	VPERM(v11,v5,v4,v16)
-	lvx	v3,r4,r12
-	VPERM(v12,v4,v3,v16)
-	lvx	v2,r4,r14
-	VPERM(v13,v3,v2,v16)
-	lvx	v1,r4,r15
-	VPERM(v14,v2,v1,v16)
-	lvx	v0,r4,r16
-	VPERM(v15,v1,v0,v16)
-	addi	r4,r4,128
-	stvx	v8,0,r3
-	stvx	v9,r3,r9
-	stvx	v10,r3,r10
-	stvx	v11,r3,r11
-	stvx	v12,r3,r12
-	stvx	v13,r3,r14
-	stvx	v14,r3,r15
-	stvx	v15,r3,r16
-	addi	r3,r3,128
-	bdnz	8b
-
-	ld	r14,STK_REG(R14)(r1)
-	ld	r15,STK_REG(R15)(r1)
-	ld	r16,STK_REG(R16)(r1)
-
-	/* Up to 127B to go */
-	clrldi	r5,r5,(64-7)
-	srdi	r6,r5,4
-	mtocrf	0x01,r6
-
-	bf	cr7*4+1,9f
-	lvx	v3,0,r4
-	VPERM(v8,v0,v3,v16)
-	lvx	v2,r4,r9
-	VPERM(v9,v3,v2,v16)
-	lvx	v1,r4,r10
-	VPERM(v10,v2,v1,v16)
-	lvx	v0,r4,r11
-	VPERM(v11,v1,v0,v16)
-	addi	r4,r4,64
-	stvx	v8,0,r3
-	stvx	v9,r3,r9
-	stvx	v10,r3,r10
-	stvx	v11,r3,r11
-	addi	r3,r3,64
-
-9:	bf	cr7*4+2,10f
-	lvx	v1,0,r4
-	VPERM(v8,v0,v1,v16)
-	lvx	v0,r4,r9
-	VPERM(v9,v1,v0,v16)
-	addi	r4,r4,32
-	stvx	v8,0,r3
-	stvx	v9,r3,r9
-	addi	r3,r3,32
-
-10:	bf	cr7*4+3,11f
-	lvx	v1,0,r4
-	VPERM(v8,v0,v1,v16)
-	addi	r4,r4,16
-	stvx	v8,0,r3
-	addi	r3,r3,16
-
-	/* Up to 15B to go */
-11:	clrldi	r5,r5,(64-4)
-	addi	r4,r4,-16	/* Unwind the +16 load offset */
-	mtocrf	0x01,r5
-	bf	cr7*4+0,12f
-	lwz	r0,0(r4)	/* Less chance of a reject with word ops */
-	lwz	r6,4(r4)
-	addi	r4,r4,8
-	stw	r0,0(r3)
-	stw	r6,4(r3)
-	addi	r3,r3,8
-
-12:	bf	cr7*4+1,13f
-	lwz	r0,0(r4)
-	addi	r4,r4,4
-	stw	r0,0(r3)
-	addi	r3,r3,4
-
-13:	bf	cr7*4+2,14f
-	lhz	r0,0(r4)
-	addi	r4,r4,2
-	sth	r0,0(r3)
-	addi	r3,r3,2
-
-14:	bf	cr7*4+3,15f
-	lbz	r0,0(r4)
-	stb	r0,0(r3)
-
-15:	addi	r1,r1,STACKFRAMESIZE
-	ld	r3,-STACKFRAMESIZE+STK_REG(R31)(r1)
-	b	CFUNC(exit_vmx_ops)		/* tail call optimise */
-#endif /* CONFIG_ALTIVEC */
+../../../../../arch/powerpc/lib/memcpy_power7.S
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/powerpc/mce/vas-api.h linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/mce/vas-api.h
--- linux-6.16.7/tools/testing/selftests/powerpc/mce/vas-api.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/mce/vas-api.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,28 +1 @@
-/* SPDX-License-Identifier: GPL-2.0+ WITH Linux-syscall-note */
-/*
- * Copyright 2019 IBM Corp.
- */
-
-#ifndef _UAPI_MISC_VAS_H
-#define _UAPI_MISC_VAS_H
-
-#include <linux/types.h>
-
-#include <asm/ioctl.h>
-
-#define VAS_MAGIC	'v'
-#define VAS_TX_WIN_OPEN	_IOW(VAS_MAGIC, 0x20, struct vas_tx_win_open_attr)
-
-/* Flags to VAS TX open window ioctl */
-/* To allocate a window with QoS credit, otherwise use default credit */
-#define VAS_TX_WIN_FLAG_QOS_CREDIT	0x0000000000000001
-
-struct vas_tx_win_open_attr {
-	__u32	version;
-	__s16	vas_id;	/* specific instance of vas or -1 for default */
-	__u16	reserved1;
-	__u64	flags;
-	__u64	reserved2[6];
-};
-
-#endif /* _UAPI_MISC_VAS_H */
+../../../../../arch/powerpc/include/uapi/asm/vas-api.h
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/powerpc/nx-gzip/include/vas-api.h linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/nx-gzip/include/vas-api.h
--- linux-6.16.7/tools/testing/selftests/powerpc/nx-gzip/include/vas-api.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/nx-gzip/include/vas-api.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,28 +1 @@
-/* SPDX-License-Identifier: GPL-2.0+ WITH Linux-syscall-note */
-/*
- * Copyright 2019 IBM Corp.
- */
-
-#ifndef _UAPI_MISC_VAS_H
-#define _UAPI_MISC_VAS_H
-
-#include <linux/types.h>
-
-#include <asm/ioctl.h>
-
-#define VAS_MAGIC	'v'
-#define VAS_TX_WIN_OPEN	_IOW(VAS_MAGIC, 0x20, struct vas_tx_win_open_attr)
-
-/* Flags to VAS TX open window ioctl */
-/* To allocate a window with QoS credit, otherwise use default credit */
-#define VAS_TX_WIN_FLAG_QOS_CREDIT	0x0000000000000001
-
-struct vas_tx_win_open_attr {
-	__u32	version;
-	__s16	vas_id;	/* specific instance of vas or -1 for default */
-	__u16	reserved1;
-	__u64	flags;
-	__u64	reserved2[6];
-};
-
-#endif /* _UAPI_MISC_VAS_H */
+../../../../../../arch/powerpc/include/uapi/asm/vas-api.h
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/powerpc/primitives/asm/asm-compat.h linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/primitives/asm/asm-compat.h
--- linux-6.16.7/tools/testing/selftests/powerpc/primitives/asm/asm-compat.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/primitives/asm/asm-compat.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,68 +1 @@
-#ifndef _ASM_POWERPC_ASM_COMPAT_H
-#define _ASM_POWERPC_ASM_COMPAT_H
-
-#include <asm/asm-const.h>
-#include <asm/types.h>
-#include <asm/ppc-opcode.h>
-
-#ifdef __powerpc64__
-
-/* operations for longs and pointers */
-#define PPC_LL		stringify_in_c(ld)
-#define PPC_STL		stringify_in_c(std)
-#define PPC_STLU	stringify_in_c(stdu)
-#define PPC_LCMPI	stringify_in_c(cmpdi)
-#define PPC_LCMPLI	stringify_in_c(cmpldi)
-#define PPC_LCMP	stringify_in_c(cmpd)
-#define PPC_LONG	stringify_in_c(.8byte)
-#define PPC_LONG_ALIGN	stringify_in_c(.balign 8)
-#define PPC_TLNEI	stringify_in_c(tdnei)
-#define PPC_LLARX	stringify_in_c(ldarx)
-#define PPC_STLCX	stringify_in_c(stdcx.)
-#define PPC_CNTLZL	stringify_in_c(cntlzd)
-#define PPC_MTOCRF(FXM, RS) MTOCRF((FXM), RS)
-#define PPC_SRL		stringify_in_c(srd)
-#define PPC_LR_STKOFF	16
-#define PPC_MIN_STKFRM	112
-
-#ifdef __BIG_ENDIAN__
-#define LWZX_BE	stringify_in_c(lwzx)
-#define LDX_BE	stringify_in_c(ldx)
-#define STWX_BE	stringify_in_c(stwx)
-#define STDX_BE	stringify_in_c(stdx)
-#else
-#define LWZX_BE	stringify_in_c(lwbrx)
-#define LDX_BE	stringify_in_c(ldbrx)
-#define STWX_BE	stringify_in_c(stwbrx)
-#define STDX_BE	stringify_in_c(stdbrx)
-#endif
-
-#ifdef CONFIG_CC_IS_CLANG
-#define DS_FORM_CONSTRAINT "Z<>"
-#else
-#define DS_FORM_CONSTRAINT "YZ<>"
-#endif
-
-#else /* 32-bit */
-
-/* operations for longs and pointers */
-#define PPC_LL		stringify_in_c(lwz)
-#define PPC_STL		stringify_in_c(stw)
-#define PPC_STLU	stringify_in_c(stwu)
-#define PPC_LCMPI	stringify_in_c(cmpwi)
-#define PPC_LCMPLI	stringify_in_c(cmplwi)
-#define PPC_LCMP	stringify_in_c(cmpw)
-#define PPC_LONG	stringify_in_c(.long)
-#define PPC_LONG_ALIGN	stringify_in_c(.balign 4)
-#define PPC_TLNEI	stringify_in_c(twnei)
-#define PPC_LLARX	stringify_in_c(lwarx)
-#define PPC_STLCX	stringify_in_c(stwcx.)
-#define PPC_CNTLZL	stringify_in_c(cntlzw)
-#define PPC_MTOCRF	stringify_in_c(mtcrf)
-#define PPC_SRL		stringify_in_c(srw)
-#define PPC_LR_STKOFF	4
-#define PPC_MIN_STKFRM	16
-
-#endif
-
-#endif /* _ASM_POWERPC_ASM_COMPAT_H */
+../.././../../../../arch/powerpc/include/asm/asm-compat.h
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/powerpc/primitives/asm/asm-const.h linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/primitives/asm/asm-const.h
--- linux-6.16.7/tools/testing/selftests/powerpc/primitives/asm/asm-const.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/primitives/asm/asm-const.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,15 +1 @@
-#ifndef _ASM_POWERPC_ASM_CONST_H
-#define _ASM_POWERPC_ASM_CONST_H
-
-#ifdef __ASSEMBLY__
-#  define stringify_in_c(...)	__VA_ARGS__
-#  define ASM_CONST(x)		x
-#else
-/* This version of stringify will deal with commas... */
-#  define __stringify_in_c(...)	#__VA_ARGS__
-#  define stringify_in_c(...)	__stringify_in_c(__VA_ARGS__) " "
-#  define __ASM_CONST(x)	x##UL
-#  define ASM_CONST(x)		__ASM_CONST(x)
-#endif
-
-#endif /* _ASM_POWERPC_ASM_CONST_H */
+../../../../../../arch/powerpc/include/asm/asm-const.h
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/powerpc/primitives/asm/extable.h linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/primitives/asm/extable.h
--- linux-6.16.7/tools/testing/selftests/powerpc/primitives/asm/extable.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/primitives/asm/extable.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,44 +1 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef _ARCH_POWERPC_EXTABLE_H
-#define _ARCH_POWERPC_EXTABLE_H
-
-/*
- * The exception table consists of pairs of relative addresses: the first is
- * the address of an instruction that is allowed to fault, and the second is
- * the address at which the program should continue.  No registers are
- * modified, so it is entirely up to the continuation code to figure out what
- * to do.
- *
- * All the routines below use bits of fixup code that are out of line with the
- * main instruction path.  This means when everything is well, we don't even
- * have to jump over them.  Further, they do not intrude on our cache or tlb
- * entries.
- */
-
-#define ARCH_HAS_RELATIVE_EXTABLE
-
-#ifndef __ASSEMBLY__
-
-struct exception_table_entry {
-	int insn;
-	int fixup;
-};
-
-static inline unsigned long extable_fixup(const struct exception_table_entry *x)
-{
-	return (unsigned long)&x->fixup + x->fixup;
-}
-
-#endif
-
-/*
- * Helper macro for exception table entries
- */
-#define EX_TABLE(_fault, _target)		\
-	stringify_in_c(.section __ex_table,"a";)\
-	stringify_in_c(.balign 4;)		\
-	stringify_in_c(.long (_fault) - . ;)	\
-	stringify_in_c(.long (_target) - . ;)	\
-	stringify_in_c(.previous)
-
-#endif
+../../../../../../arch/powerpc/include/asm/extable.h
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/powerpc/primitives/asm/feature-fixups.h linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/primitives/asm/feature-fixups.h
--- linux-6.16.7/tools/testing/selftests/powerpc/primitives/asm/feature-fixups.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/primitives/asm/feature-fixups.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,301 +1 @@
-/* SPDX-License-Identifier: GPL-2.0-or-later */
-#ifndef __ASM_POWERPC_FEATURE_FIXUPS_H
-#define __ASM_POWERPC_FEATURE_FIXUPS_H
-
-#include <asm/asm-const.h>
-
-/*
- */
-
-/*
- * Feature section common macros
- *
- * Note that the entries now contain offsets between the table entry
- * and the code rather than absolute code pointers in order to be
- * useable with the vdso shared library. There is also an assumption
- * that values will be negative, that is, the fixup table has to be
- * located after the code it fixes up.
- */
-#if defined(CONFIG_PPC64) && !defined(__powerpc64__)
-/* 64 bits kernel, 32 bits code (ie. vdso32) */
-#define FTR_ENTRY_LONG		.8byte
-#define FTR_ENTRY_OFFSET	.long 0xffffffff; .long
-#elif defined(CONFIG_PPC64)
-#define FTR_ENTRY_LONG		.8byte
-#define FTR_ENTRY_OFFSET	.8byte
-#else
-#define FTR_ENTRY_LONG		.long
-#define FTR_ENTRY_OFFSET	.long
-#endif
-
-#define START_FTR_SECTION(label)	label##1:
-
-#define FTR_SECTION_ELSE_NESTED(label)			\
-label##2:						\
-	.pushsection __ftr_alt_##label,"a";		\
-	.align 2;					\
-label##3:
-
-
-#ifndef CONFIG_CC_IS_CLANG
-#define CHECK_ALT_SIZE(else_size, body_size)			\
-	.ifgt (else_size) - (body_size);			\
-	.error "Feature section else case larger than body";	\
-	.endif;
-#else
-/*
- * If we use the ifgt syntax above, clang's assembler complains about the
- * expression being non-absolute when the code appears in an inline assembly
- * statement.
- * As a workaround use an .org directive that has no effect if the else case
- * instructions are smaller than the body, but fails otherwise.
- */
-#define CHECK_ALT_SIZE(else_size, body_size)			\
-	.org . + ((else_size) > (body_size));
-#endif
-
-#define MAKE_FTR_SECTION_ENTRY(msk, val, label, sect)		\
-label##4:							\
-	.popsection;						\
-	.pushsection sect,"a";					\
-	.align 3;						\
-label##5:							\
-	FTR_ENTRY_LONG msk;					\
-	FTR_ENTRY_LONG val;					\
-	FTR_ENTRY_OFFSET label##1b-label##5b;			\
-	FTR_ENTRY_OFFSET label##2b-label##5b;			\
-	FTR_ENTRY_OFFSET label##3b-label##5b;			\
-	FTR_ENTRY_OFFSET label##4b-label##5b;			\
-	CHECK_ALT_SIZE((label##4b-label##3b), (label##2b-label##1b)); \
-	.popsection;
-
-
-/* CPU feature dependent sections */
-#define BEGIN_FTR_SECTION_NESTED(label)	START_FTR_SECTION(label)
-#define BEGIN_FTR_SECTION		START_FTR_SECTION(97)
-
-#define END_FTR_SECTION_NESTED(msk, val, label) 		\
-	FTR_SECTION_ELSE_NESTED(label)				\
-	MAKE_FTR_SECTION_ENTRY(msk, val, label, __ftr_fixup)
-
-#define END_FTR_SECTION(msk, val)		\
-	END_FTR_SECTION_NESTED(msk, val, 97)
-
-#define END_FTR_SECTION_NESTED_IFSET(msk, label)	\
-	END_FTR_SECTION_NESTED((msk), (msk), label)
-
-#define END_FTR_SECTION_IFSET(msk)	END_FTR_SECTION((msk), (msk))
-#define END_FTR_SECTION_IFCLR(msk)	END_FTR_SECTION((msk), 0)
-
-/* CPU feature sections with alternatives, use BEGIN_FTR_SECTION to start */
-#define FTR_SECTION_ELSE	FTR_SECTION_ELSE_NESTED(97)
-#define ALT_FTR_SECTION_END_NESTED(msk, val, label)	\
-	MAKE_FTR_SECTION_ENTRY(msk, val, label, __ftr_fixup)
-#define ALT_FTR_SECTION_END_NESTED_IFSET(msk, label)	\
-	ALT_FTR_SECTION_END_NESTED(msk, msk, label)
-#define ALT_FTR_SECTION_END_NESTED_IFCLR(msk, label)	\
-	ALT_FTR_SECTION_END_NESTED(msk, 0, label)
-#define ALT_FTR_SECTION_END(msk, val)	\
-	ALT_FTR_SECTION_END_NESTED(msk, val, 97)
-#define ALT_FTR_SECTION_END_IFSET(msk)	\
-	ALT_FTR_SECTION_END_NESTED_IFSET(msk, 97)
-#define ALT_FTR_SECTION_END_IFCLR(msk)	\
-	ALT_FTR_SECTION_END_NESTED_IFCLR(msk, 97)
-
-/* MMU feature dependent sections */
-#define BEGIN_MMU_FTR_SECTION_NESTED(label)	START_FTR_SECTION(label)
-#define BEGIN_MMU_FTR_SECTION			START_FTR_SECTION(97)
-
-#define END_MMU_FTR_SECTION_NESTED(msk, val, label) 		\
-	FTR_SECTION_ELSE_NESTED(label)				\
-	MAKE_FTR_SECTION_ENTRY(msk, val, label, __mmu_ftr_fixup)
-
-#define END_MMU_FTR_SECTION(msk, val)		\
-	END_MMU_FTR_SECTION_NESTED(msk, val, 97)
-
-#define END_MMU_FTR_SECTION_NESTED_IFSET(msk, label)	\
-	END_MMU_FTR_SECTION_NESTED((msk), (msk), label)
-
-#define END_MMU_FTR_SECTION_NESTED_IFCLR(msk, label)	\
-	END_MMU_FTR_SECTION_NESTED((msk), 0, label)
-
-#define END_MMU_FTR_SECTION_IFSET(msk)	END_MMU_FTR_SECTION((msk), (msk))
-#define END_MMU_FTR_SECTION_IFCLR(msk)	END_MMU_FTR_SECTION((msk), 0)
-
-/* MMU feature sections with alternatives, use BEGIN_FTR_SECTION to start */
-#define MMU_FTR_SECTION_ELSE_NESTED(label)	FTR_SECTION_ELSE_NESTED(label)
-#define MMU_FTR_SECTION_ELSE	MMU_FTR_SECTION_ELSE_NESTED(97)
-#define ALT_MMU_FTR_SECTION_END_NESTED(msk, val, label)	\
-	MAKE_FTR_SECTION_ENTRY(msk, val, label, __mmu_ftr_fixup)
-#define ALT_MMU_FTR_SECTION_END_NESTED_IFSET(msk, label)	\
-	ALT_MMU_FTR_SECTION_END_NESTED(msk, msk, label)
-#define ALT_MMU_FTR_SECTION_END_NESTED_IFCLR(msk, label)	\
-	ALT_MMU_FTR_SECTION_END_NESTED(msk, 0, label)
-#define ALT_MMU_FTR_SECTION_END(msk, val)	\
-	ALT_MMU_FTR_SECTION_END_NESTED(msk, val, 97)
-#define ALT_MMU_FTR_SECTION_END_IFSET(msk)	\
-	ALT_MMU_FTR_SECTION_END_NESTED_IFSET(msk, 97)
-#define ALT_MMU_FTR_SECTION_END_IFCLR(msk)	\
-	ALT_MMU_FTR_SECTION_END_NESTED_IFCLR(msk, 97)
-
-/* Firmware feature dependent sections */
-#define BEGIN_FW_FTR_SECTION_NESTED(label)	START_FTR_SECTION(label)
-#define BEGIN_FW_FTR_SECTION			START_FTR_SECTION(97)
-
-#define END_FW_FTR_SECTION_NESTED(msk, val, label) 		\
-	FTR_SECTION_ELSE_NESTED(label)				\
-	MAKE_FTR_SECTION_ENTRY(msk, val, label, __fw_ftr_fixup)
-
-#define END_FW_FTR_SECTION(msk, val)		\
-	END_FW_FTR_SECTION_NESTED(msk, val, 97)
-
-#define END_FW_FTR_SECTION_IFSET(msk)	END_FW_FTR_SECTION((msk), (msk))
-#define END_FW_FTR_SECTION_IFCLR(msk)	END_FW_FTR_SECTION((msk), 0)
-
-/* Firmware feature sections with alternatives */
-#define FW_FTR_SECTION_ELSE_NESTED(label)	FTR_SECTION_ELSE_NESTED(label)
-#define FW_FTR_SECTION_ELSE	FTR_SECTION_ELSE_NESTED(97)
-#define ALT_FW_FTR_SECTION_END_NESTED(msk, val, label)	\
-	MAKE_FTR_SECTION_ENTRY(msk, val, label, __fw_ftr_fixup)
-#define ALT_FW_FTR_SECTION_END_NESTED_IFSET(msk, label)	\
-	ALT_FW_FTR_SECTION_END_NESTED(msk, msk, label)
-#define ALT_FW_FTR_SECTION_END_NESTED_IFCLR(msk, label)	\
-	ALT_FW_FTR_SECTION_END_NESTED(msk, 0, label)
-#define ALT_FW_FTR_SECTION_END(msk, val)	\
-	ALT_FW_FTR_SECTION_END_NESTED(msk, val, 97)
-#define ALT_FW_FTR_SECTION_END_IFSET(msk)	\
-	ALT_FW_FTR_SECTION_END_NESTED_IFSET(msk, 97)
-#define ALT_FW_FTR_SECTION_END_IFCLR(msk)	\
-	ALT_FW_FTR_SECTION_END_NESTED_IFCLR(msk, 97)
-
-#ifndef __ASSEMBLY__
-
-#define ASM_FTR_IF(section_if, section_else, msk, val)	\
-	stringify_in_c(BEGIN_FTR_SECTION)			\
-	section_if "; "						\
-	stringify_in_c(FTR_SECTION_ELSE)			\
-	section_else "; "					\
-	stringify_in_c(ALT_FTR_SECTION_END((msk), (val)))
-
-#define ASM_FTR_IFSET(section_if, section_else, msk)	\
-	ASM_FTR_IF(section_if, section_else, (msk), (msk))
-
-#define ASM_FTR_IFCLR(section_if, section_else, msk)	\
-	ASM_FTR_IF(section_if, section_else, (msk), 0)
-
-#define ASM_MMU_FTR_IF(section_if, section_else, msk, val)	\
-	stringify_in_c(BEGIN_MMU_FTR_SECTION)			\
-	section_if "; "						\
-	stringify_in_c(MMU_FTR_SECTION_ELSE)			\
-	section_else "; "					\
-	stringify_in_c(ALT_MMU_FTR_SECTION_END((msk), (val)))
-
-#define ASM_MMU_FTR_IFSET(section_if, section_else, msk)	\
-	ASM_MMU_FTR_IF(section_if, section_else, (msk), (msk))
-
-#define ASM_MMU_FTR_IFCLR(section_if, section_else, msk)	\
-	ASM_MMU_FTR_IF(section_if, section_else, (msk), 0)
-
-#endif /* __ASSEMBLY__ */
-
-/* LWSYNC feature sections */
-#define START_LWSYNC_SECTION(label)	label##1:
-#define MAKE_LWSYNC_SECTION_ENTRY(label, sect)		\
-label##2:						\
-	.pushsection sect,"a";				\
-	.align 2;					\
-label##3:					       	\
-	FTR_ENTRY_OFFSET label##1b-label##3b;		\
-	.popsection;
-
-#define STF_ENTRY_BARRIER_FIXUP_SECTION			\
-953:							\
-	.pushsection __stf_entry_barrier_fixup,"a";	\
-	.align 2;					\
-954:							\
-	FTR_ENTRY_OFFSET 953b-954b;			\
-	.popsection;
-
-#define STF_EXIT_BARRIER_FIXUP_SECTION			\
-955:							\
-	.pushsection __stf_exit_barrier_fixup,"a";	\
-	.align 2;					\
-956:							\
-	FTR_ENTRY_OFFSET 955b-956b;			\
-	.popsection;
-
-#define UACCESS_FLUSH_FIXUP_SECTION			\
-959:							\
-	.pushsection __uaccess_flush_fixup,"a";		\
-	.align 2;					\
-960:							\
-	FTR_ENTRY_OFFSET 959b-960b;			\
-	.popsection;
-
-#define ENTRY_FLUSH_FIXUP_SECTION			\
-957:							\
-	.pushsection __entry_flush_fixup,"a";		\
-	.align 2;					\
-958:							\
-	FTR_ENTRY_OFFSET 957b-958b;			\
-	.popsection;
-
-#define SCV_ENTRY_FLUSH_FIXUP_SECTION			\
-957:							\
-	.pushsection __scv_entry_flush_fixup,"a";	\
-	.align 2;					\
-958:							\
-	FTR_ENTRY_OFFSET 957b-958b;			\
-	.popsection;
-
-#define RFI_FLUSH_FIXUP_SECTION				\
-951:							\
-	.pushsection __rfi_flush_fixup,"a";		\
-	.align 2;					\
-952:							\
-	FTR_ENTRY_OFFSET 951b-952b;			\
-	.popsection;
-
-#define NOSPEC_BARRIER_FIXUP_SECTION			\
-953:							\
-	.pushsection __barrier_nospec_fixup,"a";	\
-	.align 2;					\
-954:							\
-	FTR_ENTRY_OFFSET 953b-954b;			\
-	.popsection;
-
-#define START_BTB_FLUSH_SECTION			\
-955:							\
-
-#define END_BTB_FLUSH_SECTION			\
-956:							\
-	.pushsection __btb_flush_fixup,"a";	\
-	.align 2;							\
-957:						\
-	FTR_ENTRY_OFFSET 955b-957b;			\
-	FTR_ENTRY_OFFSET 956b-957b;			\
-	.popsection;
-
-#ifndef __ASSEMBLY__
-#include <linux/types.h>
-
-extern long stf_barrier_fallback;
-extern long entry_flush_fallback;
-extern long scv_entry_flush_fallback;
-extern long __start___stf_entry_barrier_fixup, __stop___stf_entry_barrier_fixup;
-extern long __start___stf_exit_barrier_fixup, __stop___stf_exit_barrier_fixup;
-extern long __start___uaccess_flush_fixup, __stop___uaccess_flush_fixup;
-extern long __start___entry_flush_fixup, __stop___entry_flush_fixup;
-extern long __start___scv_entry_flush_fixup, __stop___scv_entry_flush_fixup;
-extern long __start___rfi_flush_fixup, __stop___rfi_flush_fixup;
-extern long __start___barrier_nospec_fixup, __stop___barrier_nospec_fixup;
-extern long __start__btb_flush_fixup, __stop__btb_flush_fixup;
-
-extern bool static_key_feature_checks_initialized;
-
-void apply_feature_fixups(void);
-void update_mmu_feature_fixups(unsigned long mask);
-void setup_feature_keys(void);
-#endif
-
-#endif /* __ASM_POWERPC_FEATURE_FIXUPS_H */
+../../../../../../arch/powerpc/include/asm/feature-fixups.h
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/powerpc/primitives/asm/ppc_asm.h linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/primitives/asm/ppc_asm.h
--- linux-6.16.7/tools/testing/selftests/powerpc/primitives/asm/ppc_asm.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/primitives/asm/ppc_asm.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,906 +1 @@
-/*
- * Copyright (C) 1995-1999 Gary Thomas, Paul Mackerras, Cort Dougan.
- */
-#ifndef _ASM_POWERPC_PPC_ASM_H
-#define _ASM_POWERPC_PPC_ASM_H
-
-#include <linux/stringify.h>
-#include <asm/asm-compat.h>
-#include <asm/processor.h>
-#include <asm/ppc-opcode.h>
-#include <asm/firmware.h>
-#include <asm/feature-fixups.h>
-#include <asm/extable.h>
-
-#ifdef __ASSEMBLY__
-
-#define SZL			(BITS_PER_LONG/8)
-
-/*
- * This expands to a sequence of operations with reg incrementing from
- * start to end inclusive, of this form:
- *
- *   op  reg, (offset + (width * reg))(base)
- *
- * Note that offset is not the offset of the first operation unless start
- * is zero (or width is zero).
- */
-.macro OP_REGS op, width, start, end, base, offset
-	.Lreg=\start
-	.rept (\end - \start + 1)
-	\op	.Lreg, \offset + \width * .Lreg(\base)
-	.Lreg=.Lreg+1
-	.endr
-.endm
-
-/*
- * This expands to a sequence of register clears for regs start to end
- * inclusive, of the form:
- *
- *   li rN, 0
- */
-.macro ZEROIZE_REGS start, end
-	.Lreg=\start
-	.rept (\end - \start + 1)
-	li	.Lreg, 0
-	.Lreg=.Lreg+1
-	.endr
-.endm
-
-/*
- * Macros for storing registers into and loading registers from
- * exception frames.
- */
-#ifdef __powerpc64__
-#define SAVE_GPRS(start, end, base)	OP_REGS std, 8, start, end, base, GPR0
-#define REST_GPRS(start, end, base)	OP_REGS ld, 8, start, end, base, GPR0
-#define SAVE_NVGPRS(base)		SAVE_GPRS(14, 31, base)
-#define REST_NVGPRS(base)		REST_GPRS(14, 31, base)
-#else
-#define SAVE_GPRS(start, end, base)	OP_REGS stw, 4, start, end, base, GPR0
-#define REST_GPRS(start, end, base)	OP_REGS lwz, 4, start, end, base, GPR0
-#define SAVE_NVGPRS(base)		SAVE_GPRS(13, 31, base)
-#define REST_NVGPRS(base)		REST_GPRS(13, 31, base)
-#endif
-
-#define	ZEROIZE_GPRS(start, end)	ZEROIZE_REGS start, end
-#ifdef __powerpc64__
-#define	ZEROIZE_NVGPRS()		ZEROIZE_GPRS(14, 31)
-#else
-#define	ZEROIZE_NVGPRS()		ZEROIZE_GPRS(13, 31)
-#endif
-#define	ZEROIZE_GPR(n)			ZEROIZE_GPRS(n, n)
-
-#define SAVE_GPR(n, base)		SAVE_GPRS(n, n, base)
-#define REST_GPR(n, base)		REST_GPRS(n, n, base)
-
-/* macros for handling user register sanitisation */
-#ifdef CONFIG_INTERRUPT_SANITIZE_REGISTERS
-#define SANITIZE_SYSCALL_GPRS()			ZEROIZE_GPR(0);		\
-						ZEROIZE_GPRS(5, 12);	\
-						ZEROIZE_NVGPRS()
-#define SANITIZE_GPR(n)				ZEROIZE_GPR(n)
-#define SANITIZE_GPRS(start, end)		ZEROIZE_GPRS(start, end)
-#define SANITIZE_NVGPRS()			ZEROIZE_NVGPRS()
-#define SANITIZE_RESTORE_NVGPRS()		REST_NVGPRS(r1)
-#define HANDLER_RESTORE_NVGPRS()
-#else
-#define SANITIZE_SYSCALL_GPRS()
-#define SANITIZE_GPR(n)
-#define SANITIZE_GPRS(start, end)
-#define SANITIZE_NVGPRS()
-#define SANITIZE_RESTORE_NVGPRS()
-#define HANDLER_RESTORE_NVGPRS()		REST_NVGPRS(r1)
-#endif /* CONFIG_INTERRUPT_SANITIZE_REGISTERS */
-
-#define SAVE_FPR(n, base)	stfd	n,8*TS_FPRWIDTH*(n)(base)
-#define SAVE_2FPRS(n, base)	SAVE_FPR(n, base); SAVE_FPR(n+1, base)
-#define SAVE_4FPRS(n, base)	SAVE_2FPRS(n, base); SAVE_2FPRS(n+2, base)
-#define SAVE_8FPRS(n, base)	SAVE_4FPRS(n, base); SAVE_4FPRS(n+4, base)
-#define SAVE_16FPRS(n, base)	SAVE_8FPRS(n, base); SAVE_8FPRS(n+8, base)
-#define SAVE_32FPRS(n, base)	SAVE_16FPRS(n, base); SAVE_16FPRS(n+16, base)
-#define REST_FPR(n, base)	lfd	n,8*TS_FPRWIDTH*(n)(base)
-#define REST_2FPRS(n, base)	REST_FPR(n, base); REST_FPR(n+1, base)
-#define REST_4FPRS(n, base)	REST_2FPRS(n, base); REST_2FPRS(n+2, base)
-#define REST_8FPRS(n, base)	REST_4FPRS(n, base); REST_4FPRS(n+4, base)
-#define REST_16FPRS(n, base)	REST_8FPRS(n, base); REST_8FPRS(n+8, base)
-#define REST_32FPRS(n, base)	REST_16FPRS(n, base); REST_16FPRS(n+16, base)
-
-#define SAVE_VR(n,b,base)	li b,16*(n);  stvx n,base,b
-#define SAVE_2VRS(n,b,base)	SAVE_VR(n,b,base); SAVE_VR(n+1,b,base)
-#define SAVE_4VRS(n,b,base)	SAVE_2VRS(n,b,base); SAVE_2VRS(n+2,b,base)
-#define SAVE_8VRS(n,b,base)	SAVE_4VRS(n,b,base); SAVE_4VRS(n+4,b,base)
-#define SAVE_16VRS(n,b,base)	SAVE_8VRS(n,b,base); SAVE_8VRS(n+8,b,base)
-#define SAVE_32VRS(n,b,base)	SAVE_16VRS(n,b,base); SAVE_16VRS(n+16,b,base)
-#define REST_VR(n,b,base)	li b,16*(n); lvx n,base,b
-#define REST_2VRS(n,b,base)	REST_VR(n,b,base); REST_VR(n+1,b,base)
-#define REST_4VRS(n,b,base)	REST_2VRS(n,b,base); REST_2VRS(n+2,b,base)
-#define REST_8VRS(n,b,base)	REST_4VRS(n,b,base); REST_4VRS(n+4,b,base)
-#define REST_16VRS(n,b,base)	REST_8VRS(n,b,base); REST_8VRS(n+8,b,base)
-#define REST_32VRS(n,b,base)	REST_16VRS(n,b,base); REST_16VRS(n+16,b,base)
-
-#ifdef __BIG_ENDIAN__
-#define STXVD2X_ROT(n,b,base)		STXVD2X(n,b,base)
-#define LXVD2X_ROT(n,b,base)		LXVD2X(n,b,base)
-#else
-#define STXVD2X_ROT(n,b,base)		XXSWAPD(n,n);		\
-					STXVD2X(n,b,base);	\
-					XXSWAPD(n,n)
-
-#define LXVD2X_ROT(n,b,base)		LXVD2X(n,b,base);	\
-					XXSWAPD(n,n)
-#endif
-/* Save the lower 32 VSRs in the thread VSR region */
-#define SAVE_VSR(n,b,base)	li b,16*(n);  STXVD2X_ROT(n,R##base,R##b)
-#define SAVE_2VSRS(n,b,base)	SAVE_VSR(n,b,base); SAVE_VSR(n+1,b,base)
-#define SAVE_4VSRS(n,b,base)	SAVE_2VSRS(n,b,base); SAVE_2VSRS(n+2,b,base)
-#define SAVE_8VSRS(n,b,base)	SAVE_4VSRS(n,b,base); SAVE_4VSRS(n+4,b,base)
-#define SAVE_16VSRS(n,b,base)	SAVE_8VSRS(n,b,base); SAVE_8VSRS(n+8,b,base)
-#define SAVE_32VSRS(n,b,base)	SAVE_16VSRS(n,b,base); SAVE_16VSRS(n+16,b,base)
-#define REST_VSR(n,b,base)	li b,16*(n); LXVD2X_ROT(n,R##base,R##b)
-#define REST_2VSRS(n,b,base)	REST_VSR(n,b,base); REST_VSR(n+1,b,base)
-#define REST_4VSRS(n,b,base)	REST_2VSRS(n,b,base); REST_2VSRS(n+2,b,base)
-#define REST_8VSRS(n,b,base)	REST_4VSRS(n,b,base); REST_4VSRS(n+4,b,base)
-#define REST_16VSRS(n,b,base)	REST_8VSRS(n,b,base); REST_8VSRS(n+8,b,base)
-#define REST_32VSRS(n,b,base)	REST_16VSRS(n,b,base); REST_16VSRS(n+16,b,base)
-
-/*
- * b = base register for addressing, o = base offset from register of 1st EVR
- * n = first EVR, s = scratch
- */
-#define SAVE_EVR(n,s,b,o)	evmergehi s,s,n; stw s,o+4*(n)(b)
-#define SAVE_2EVRS(n,s,b,o)	SAVE_EVR(n,s,b,o); SAVE_EVR(n+1,s,b,o)
-#define SAVE_4EVRS(n,s,b,o)	SAVE_2EVRS(n,s,b,o); SAVE_2EVRS(n+2,s,b,o)
-#define SAVE_8EVRS(n,s,b,o)	SAVE_4EVRS(n,s,b,o); SAVE_4EVRS(n+4,s,b,o)
-#define SAVE_16EVRS(n,s,b,o)	SAVE_8EVRS(n,s,b,o); SAVE_8EVRS(n+8,s,b,o)
-#define SAVE_32EVRS(n,s,b,o)	SAVE_16EVRS(n,s,b,o); SAVE_16EVRS(n+16,s,b,o)
-#define REST_EVR(n,s,b,o)	lwz s,o+4*(n)(b); evmergelo n,s,n
-#define REST_2EVRS(n,s,b,o)	REST_EVR(n,s,b,o); REST_EVR(n+1,s,b,o)
-#define REST_4EVRS(n,s,b,o)	REST_2EVRS(n,s,b,o); REST_2EVRS(n+2,s,b,o)
-#define REST_8EVRS(n,s,b,o)	REST_4EVRS(n,s,b,o); REST_4EVRS(n+4,s,b,o)
-#define REST_16EVRS(n,s,b,o)	REST_8EVRS(n,s,b,o); REST_8EVRS(n+8,s,b,o)
-#define REST_32EVRS(n,s,b,o)	REST_16EVRS(n,s,b,o); REST_16EVRS(n+16,s,b,o)
-
-/* Macros to adjust thread priority for hardware multithreading */
-#define HMT_VERY_LOW	or	31,31,31	# very low priority
-#define HMT_LOW		or	1,1,1
-#define HMT_MEDIUM_LOW  or	6,6,6		# medium low priority
-#define HMT_MEDIUM	or	2,2,2
-#define HMT_MEDIUM_HIGH or	5,5,5		# medium high priority
-#define HMT_HIGH	or	3,3,3
-#define HMT_EXTRA_HIGH	or	7,7,7		# power7 only
-
-#ifdef CONFIG_PPC64
-#define ULONG_SIZE 	8
-#else
-#define ULONG_SIZE	4
-#endif
-#define __VCPU_GPR(n)	(VCPU_GPRS + (n * ULONG_SIZE))
-#define VCPU_GPR(n)	__VCPU_GPR(__REG_##n)
-
-#ifdef __KERNEL__
-
-/*
- * Used to name C functions called from asm
- */
-#if defined(__powerpc64__) && defined(CONFIG_PPC_KERNEL_PCREL)
-#define CFUNC(name) name@notoc
-#else
-#define CFUNC(name) name
-#endif
-
-/*
- * We use __powerpc64__ here because we want the compat VDSO to use the 32-bit
- * version below in the else case of the ifdef.
- */
-#ifdef __powerpc64__
-
-#define STACKFRAMESIZE 256
-#define __STK_REG(i)   (112 + ((i)-14)*8)
-#define STK_REG(i)     __STK_REG(__REG_##i)
-
-#ifdef CONFIG_PPC64_ELF_ABI_V2
-#define STK_GOT		24
-#define STK_PARAM_AREA	32
-#else
-#define STK_GOT		40
-#define STK_PARAM_AREA	48
-#endif
-
-#define __STK_PARAM(i)	(STK_PARAM_AREA + ((i)-3)*8)
-#define STK_PARAM(i)	__STK_PARAM(__REG_##i)
-
-#ifdef CONFIG_PPC64_ELF_ABI_V2
-
-#define _GLOBAL(name) \
-	.align 2 ; \
-	.type name,@function; \
-	.globl name; \
-name:
-
-#ifdef CONFIG_PPC_KERNEL_PCREL
-#define _GLOBAL_TOC _GLOBAL
-#else
-#define _GLOBAL_TOC(name) \
-	.align 2 ; \
-	.type name,@function; \
-	.globl name; \
-name: \
-0:	addis r2,r12,(.TOC.-0b)@ha; \
-	addi r2,r2,(.TOC.-0b)@l; \
-	.localentry name,.-name
-#endif
-
-#define DOTSYM(a)	a
-
-#else
-
-#define XGLUE(a,b) a##b
-#define GLUE(a,b) XGLUE(a,b)
-
-#define _GLOBAL(name) \
-	.align 2 ; \
-	.globl name; \
-	.globl GLUE(.,name); \
-	.pushsection ".opd","aw"; \
-name: \
-	.quad GLUE(.,name); \
-	.quad .TOC.@tocbase; \
-	.quad 0; \
-	.popsection; \
-	.type GLUE(.,name),@function; \
-GLUE(.,name):
-
-#define _GLOBAL_TOC(name) _GLOBAL(name)
-
-#define DOTSYM(a)	GLUE(.,a)
-
-#endif
-
-#else /* 32-bit */
-
-#define _GLOBAL(n)	\
-	.globl n;	\
-n:
-
-#define _GLOBAL_TOC(name) _GLOBAL(name)
-
-#define DOTSYM(a)	a
-
-#endif
-
-/*
- * __kprobes (the C annotation) puts the symbol into the .kprobes.text
- * section, which gets emitted at the end of regular text.
- *
- * _ASM_NOKPROBE_SYMBOL and NOKPROBE_SYMBOL just adds the symbol to
- * a blacklist. The former is for core kprobe functions/data, the
- * latter is for those that incdentially must be excluded from probing
- * and allows them to be linked at more optimal location within text.
- */
-#ifdef CONFIG_KPROBES
-#define _ASM_NOKPROBE_SYMBOL(entry)			\
-	.pushsection "_kprobe_blacklist","aw";		\
-	PPC_LONG (entry) ;				\
-	.popsection
-#else
-#define _ASM_NOKPROBE_SYMBOL(entry)
-#endif
-
-#define FUNC_START(name)	_GLOBAL(name)
-#define FUNC_END(name)
-
-/* 
- * LOAD_REG_IMMEDIATE(rn, expr)
- *   Loads the value of the constant expression 'expr' into register 'rn'
- *   using immediate instructions only.  Use this when it's important not
- *   to reference other data (i.e. on ppc64 when the TOC pointer is not
- *   valid) and when 'expr' is a constant or absolute address.
- *
- * LOAD_REG_ADDR(rn, name)
- *   Loads the address of label 'name' into register 'rn'.  Use this when
- *   you don't particularly need immediate instructions only, but you need
- *   the whole address in one register (e.g. it's a structure address and
- *   you want to access various offsets within it).  On ppc32 this is
- *   identical to LOAD_REG_IMMEDIATE.
- *
- * LOAD_REG_ADDR_PIC(rn, name)
- *   Loads the address of label 'name' into register 'run'. Use this when
- *   the kernel doesn't run at the linked or relocated address. Please
- *   note that this macro will clobber the lr register.
- *
- * LOAD_REG_ADDRBASE(rn, name)
- * ADDROFF(name)
- *   LOAD_REG_ADDRBASE loads part of the address of label 'name' into
- *   register 'rn'.  ADDROFF(name) returns the remainder of the address as
- *   a constant expression.  ADDROFF(name) is a signed expression < 16 bits
- *   in size, so is suitable for use directly as an offset in load and store
- *   instructions.  Use this when loading/storing a single word or less as:
- *      LOAD_REG_ADDRBASE(rX, name)
- *      ld	rY,ADDROFF(name)(rX)
- */
-
-/* Be careful, this will clobber the lr register. */
-#define LOAD_REG_ADDR_PIC(reg, name)		\
-	bcl	20,31,$+4;			\
-0:	mflr	reg;				\
-	addis	reg,reg,(name - 0b)@ha;		\
-	addi	reg,reg,(name - 0b)@l;
-
-#if defined(__powerpc64__) && defined(HAVE_AS_ATHIGH)
-#define __AS_ATHIGH high
-#else
-#define __AS_ATHIGH h
-#endif
-
-.macro __LOAD_REG_IMMEDIATE_32 r, x
-	.if (\x) >= 0x8000 || (\x) < -0x8000
-		lis \r, (\x)@__AS_ATHIGH
-		.if (\x) & 0xffff != 0
-			ori \r, \r, (\x)@l
-		.endif
-	.else
-		li \r, (\x)@l
-	.endif
-.endm
-
-.macro __LOAD_REG_IMMEDIATE r, x
-	.if (\x) >= 0x80000000 || (\x) < -0x80000000
-		__LOAD_REG_IMMEDIATE_32 \r, (\x) >> 32
-		sldi	\r, \r, 32
-		.if (\x) & 0xffff0000 != 0
-			oris \r, \r, (\x)@__AS_ATHIGH
-		.endif
-		.if (\x) & 0xffff != 0
-			ori \r, \r, (\x)@l
-		.endif
-	.else
-		__LOAD_REG_IMMEDIATE_32 \r, \x
-	.endif
-.endm
-
-#ifdef __powerpc64__
-
-#ifdef CONFIG_PPC_KERNEL_PCREL
-#define __LOAD_PACA_TOC(reg)			\
-	li	reg,-1
-#else
-#define __LOAD_PACA_TOC(reg)			\
-	ld	reg,PACATOC(r13)
-#endif
-
-#define LOAD_PACA_TOC()				\
-	__LOAD_PACA_TOC(r2)
-
-#define LOAD_REG_IMMEDIATE(reg, expr) __LOAD_REG_IMMEDIATE reg, expr
-
-#define LOAD_REG_IMMEDIATE_SYM(reg, tmp, expr)	\
-	lis	tmp, (expr)@highest;		\
-	lis	reg, (expr)@__AS_ATHIGH;	\
-	ori	tmp, tmp, (expr)@higher;	\
-	ori	reg, reg, (expr)@l;		\
-	rldimi	reg, tmp, 32, 0
-
-#ifdef CONFIG_PPC_KERNEL_PCREL
-#define LOAD_REG_ADDR(reg,name)			\
-	pla	reg,name@pcrel
-
-#else
-#define LOAD_REG_ADDR(reg,name)			\
-	addis	reg,r2,name@toc@ha;		\
-	addi	reg,reg,name@toc@l
-#endif
-
-#ifdef CONFIG_PPC_BOOK3E_64
-/*
- * This is used in register-constrained interrupt handlers. Not to be used
- * by BOOK3S. ld complains with "got/toc optimization is not supported" if r2
- * is not used for the TOC offset, so use @got(tocreg). If the interrupt
- * handlers saved r2 instead, LOAD_REG_ADDR could be used.
- */
-#define LOAD_REG_ADDR_ALTTOC(reg,tocreg,name)	\
-	ld	reg,name@got(tocreg)
-#endif
-
-#define LOAD_REG_ADDRBASE(reg,name)	LOAD_REG_ADDR(reg,name)
-#define ADDROFF(name)			0
-
-/* offsets for stack frame layout */
-#define LRSAVE	16
-
-/*
- * GCC stack frames follow a different pattern on 32 vs 64. This can be used
- * to make asm frames be consistent with C.
- */
-#define PPC_CREATE_STACK_FRAME(size)			\
-	mflr		r0;				\
-	std		r0,16(r1);			\
-	stdu		r1,-(size)(r1)
-
-#else /* 32-bit */
-
-#define LOAD_REG_IMMEDIATE(reg, expr) __LOAD_REG_IMMEDIATE_32 reg, expr
-
-#define LOAD_REG_IMMEDIATE_SYM(reg,expr)		\
-	lis	reg,(expr)@ha;		\
-	addi	reg,reg,(expr)@l;
-
-#define LOAD_REG_ADDR(reg,name)		LOAD_REG_IMMEDIATE_SYM(reg, name)
-
-#define LOAD_REG_ADDRBASE(reg, name)	lis	reg,name@ha
-#define ADDROFF(name)			name@l
-
-/* offsets for stack frame layout */
-#define LRSAVE	4
-
-#define PPC_CREATE_STACK_FRAME(size)			\
-	stwu		r1,-(size)(r1);			\
-	mflr		r0;				\
-	stw		r0,(size+4)(r1)
-
-#endif
-
-/* various errata or part fixups */
-#if defined(CONFIG_PPC_CELL) || defined(CONFIG_PPC_E500)
-#define MFTB(dest)			\
-90:	mfspr dest, SPRN_TBRL;		\
-BEGIN_FTR_SECTION_NESTED(96);		\
-	cmpwi dest,0;			\
-	beq-  90b;			\
-END_FTR_SECTION_NESTED(CPU_FTR_CELL_TB_BUG, CPU_FTR_CELL_TB_BUG, 96)
-#else
-#define MFTB(dest)			MFTBL(dest)
-#endif
-
-#ifdef CONFIG_PPC_8xx
-#define MFTBL(dest)			mftb dest
-#define MFTBU(dest)			mftbu dest
-#else
-#define MFTBL(dest)			mfspr dest, SPRN_TBRL
-#define MFTBU(dest)			mfspr dest, SPRN_TBRU
-#endif
-
-#ifndef CONFIG_SMP
-#define TLBSYNC
-#else
-#define TLBSYNC		tlbsync; sync
-#endif
-
-#ifdef CONFIG_PPC64
-#define MTOCRF(FXM, RS)			\
-	BEGIN_FTR_SECTION_NESTED(848);	\
-	mtcrf	(FXM), RS;		\
-	FTR_SECTION_ELSE_NESTED(848);	\
-	mtocrf (FXM), RS;		\
-	ALT_FTR_SECTION_END_NESTED_IFCLR(CPU_FTR_NOEXECUTE, 848)
-#endif
-
-/*
- * This instruction is not implemented on the PPC 603 or 601; however, on
- * the 403GCX and 405GP tlbia IS defined and tlbie is not.
- * All of these instructions exist in the 8xx, they have magical powers,
- * and they must be used.
- */
-
-#if !defined(CONFIG_44x) && !defined(CONFIG_PPC_8xx)
-#define tlbia					\
-	li	r4,1024;			\
-	mtctr	r4;				\
-	lis	r4,KERNELBASE@h;		\
-	.machine push;				\
-	.machine "power4";			\
-0:	tlbie	r4;				\
-	.machine pop;				\
-	addi	r4,r4,0x1000;			\
-	bdnz	0b
-#endif
-
-
-#ifdef CONFIG_IBM440EP_ERR42
-#define PPC440EP_ERR42 isync
-#else
-#define PPC440EP_ERR42
-#endif
-
-/* The following stops all load and store data streams associated with stream
- * ID (ie. streams created explicitly).  The embedded and server mnemonics for
- * dcbt are different so this must only be used for server.
- */
-#define DCBT_BOOK3S_STOP_ALL_STREAM_IDS(scratch)	\
-       lis     scratch,0x60000000@h;			\
-       .machine push;					\
-       .machine power4;					\
-       dcbt    0,scratch,0b01010;			\
-       .machine pop;
-
-#define DCBT_SETUP_STREAMS(from, from_parms, to, to_parms, scratch)	\
-	lis	scratch,0x8000;	/* GO=1 */				\
-	clrldi	scratch,scratch,32;					\
-	.machine push;							\
-	.machine power4;						\
-	/* setup read stream 0 */					\
-	dcbt	0,from,0b01000;		/* addr from */			\
-	dcbt	0,from_parms,0b01010;	/* length and depth from */	\
-	/* setup write stream 1 */					\
-	dcbtst	0,to,0b01000;		/* addr to */			\
-	dcbtst	0,to_parms,0b01010;	/* length and depth to */	\
-	eieio;								\
-	dcbt	0,scratch,0b01010;	/* all streams GO */		\
-	.machine pop;
-
-/*
- * toreal/fromreal/tophys/tovirt macros. 32-bit BookE makes them
- * keep the address intact to be compatible with code shared with
- * 32-bit classic.
- *
- * On the other hand, I find it useful to have them behave as expected
- * by their name (ie always do the addition) on 64-bit BookE
- */
-#if defined(CONFIG_BOOKE) && !defined(CONFIG_PPC64)
-#define toreal(rd)
-#define fromreal(rd)
-
-/*
- * We use addis to ensure compatibility with the "classic" ppc versions of
- * these macros, which use rs = 0 to get the tophys offset in rd, rather than
- * converting the address in r0, and so this version has to do that too
- * (i.e. set register rd to 0 when rs == 0).
- */
-#define tophys(rd,rs)				\
-	addis	rd,rs,0
-
-#define tovirt(rd,rs)				\
-	addis	rd,rs,0
-
-#elif defined(CONFIG_PPC64)
-#define toreal(rd)		/* we can access c000... in real mode */
-#define fromreal(rd)
-
-#define tophys(rd,rs)                           \
-	clrldi	rd,rs,2
-
-#define tovirt(rd,rs)                           \
-	rotldi	rd,rs,16;			\
-	ori	rd,rd,((KERNELBASE>>48)&0xFFFF);\
-	rotldi	rd,rd,48
-#else
-#define toreal(rd)	tophys(rd,rd)
-#define fromreal(rd)	tovirt(rd,rd)
-
-#define tophys(rd, rs)	addis	rd, rs, -PAGE_OFFSET@h
-#define tovirt(rd, rs)	addis	rd, rs, PAGE_OFFSET@h
-#endif
-
-#ifdef CONFIG_PPC_BOOK3S_64
-#define MTMSRD(r)	mtmsrd	r
-#define MTMSR_EERI(reg)	mtmsrd	reg,1
-#else
-#define MTMSRD(r)	mtmsr	r
-#define MTMSR_EERI(reg)	mtmsr	reg
-#endif
-
-#endif /* __KERNEL__ */
-
-/* The boring bits... */
-
-/* Condition Register Bit Fields */
-
-#define	cr0	0
-#define	cr1	1
-#define	cr2	2
-#define	cr3	3
-#define	cr4	4
-#define	cr5	5
-#define	cr6	6
-#define	cr7	7
-
-
-/*
- * General Purpose Registers (GPRs)
- *
- * The lower case r0-r31 should be used in preference to the upper
- * case R0-R31 as they provide more error checking in the assembler.
- * Use R0-31 only when really nessesary.
- */
-
-#define	r0	%r0
-#define	r1	%r1
-#define	r2	%r2
-#define	r3	%r3
-#define	r4	%r4
-#define	r5	%r5
-#define	r6	%r6
-#define	r7	%r7
-#define	r8	%r8
-#define	r9	%r9
-#define	r10	%r10
-#define	r11	%r11
-#define	r12	%r12
-#define	r13	%r13
-#define	r14	%r14
-#define	r15	%r15
-#define	r16	%r16
-#define	r17	%r17
-#define	r18	%r18
-#define	r19	%r19
-#define	r20	%r20
-#define	r21	%r21
-#define	r22	%r22
-#define	r23	%r23
-#define	r24	%r24
-#define	r25	%r25
-#define	r26	%r26
-#define	r27	%r27
-#define	r28	%r28
-#define	r29	%r29
-#define	r30	%r30
-#define	r31	%r31
-
-
-/* Floating Point Registers (FPRs) */
-
-#define	fr0	0
-#define	fr1	1
-#define	fr2	2
-#define	fr3	3
-#define	fr4	4
-#define	fr5	5
-#define	fr6	6
-#define	fr7	7
-#define	fr8	8
-#define	fr9	9
-#define	fr10	10
-#define	fr11	11
-#define	fr12	12
-#define	fr13	13
-#define	fr14	14
-#define	fr15	15
-#define	fr16	16
-#define	fr17	17
-#define	fr18	18
-#define	fr19	19
-#define	fr20	20
-#define	fr21	21
-#define	fr22	22
-#define	fr23	23
-#define	fr24	24
-#define	fr25	25
-#define	fr26	26
-#define	fr27	27
-#define	fr28	28
-#define	fr29	29
-#define	fr30	30
-#define	fr31	31
-
-/* AltiVec Registers (VPRs) */
-
-#define	v0	0
-#define	v1	1
-#define	v2	2
-#define	v3	3
-#define	v4	4
-#define	v5	5
-#define	v6	6
-#define	v7	7
-#define	v8	8
-#define	v9	9
-#define	v10	10
-#define	v11	11
-#define	v12	12
-#define	v13	13
-#define	v14	14
-#define	v15	15
-#define	v16	16
-#define	v17	17
-#define	v18	18
-#define	v19	19
-#define	v20	20
-#define	v21	21
-#define	v22	22
-#define	v23	23
-#define	v24	24
-#define	v25	25
-#define	v26	26
-#define	v27	27
-#define	v28	28
-#define	v29	29
-#define	v30	30
-#define	v31	31
-
-/* VSX Registers (VSRs) */
-
-#define	vs0	0
-#define	vs1	1
-#define	vs2	2
-#define	vs3	3
-#define	vs4	4
-#define	vs5	5
-#define	vs6	6
-#define	vs7	7
-#define	vs8	8
-#define	vs9	9
-#define	vs10	10
-#define	vs11	11
-#define	vs12	12
-#define	vs13	13
-#define	vs14	14
-#define	vs15	15
-#define	vs16	16
-#define	vs17	17
-#define	vs18	18
-#define	vs19	19
-#define	vs20	20
-#define	vs21	21
-#define	vs22	22
-#define	vs23	23
-#define	vs24	24
-#define	vs25	25
-#define	vs26	26
-#define	vs27	27
-#define	vs28	28
-#define	vs29	29
-#define	vs30	30
-#define	vs31	31
-#define	vs32	32
-#define	vs33	33
-#define	vs34	34
-#define	vs35	35
-#define	vs36	36
-#define	vs37	37
-#define	vs38	38
-#define	vs39	39
-#define	vs40	40
-#define	vs41	41
-#define	vs42	42
-#define	vs43	43
-#define	vs44	44
-#define	vs45	45
-#define	vs46	46
-#define	vs47	47
-#define	vs48	48
-#define	vs49	49
-#define	vs50	50
-#define	vs51	51
-#define	vs52	52
-#define	vs53	53
-#define	vs54	54
-#define	vs55	55
-#define	vs56	56
-#define	vs57	57
-#define	vs58	58
-#define	vs59	59
-#define	vs60	60
-#define	vs61	61
-#define	vs62	62
-#define	vs63	63
-
-/* SPE Registers (EVPRs) */
-
-#define	evr0	0
-#define	evr1	1
-#define	evr2	2
-#define	evr3	3
-#define	evr4	4
-#define	evr5	5
-#define	evr6	6
-#define	evr7	7
-#define	evr8	8
-#define	evr9	9
-#define	evr10	10
-#define	evr11	11
-#define	evr12	12
-#define	evr13	13
-#define	evr14	14
-#define	evr15	15
-#define	evr16	16
-#define	evr17	17
-#define	evr18	18
-#define	evr19	19
-#define	evr20	20
-#define	evr21	21
-#define	evr22	22
-#define	evr23	23
-#define	evr24	24
-#define	evr25	25
-#define	evr26	26
-#define	evr27	27
-#define	evr28	28
-#define	evr29	29
-#define	evr30	30
-#define	evr31	31
-
-#define RFSCV	.long 0x4c0000a4
-
-/*
- * Create an endian fixup trampoline
- *
- * This starts with a "tdi 0,0,0x48" instruction which is
- * essentially a "trap never", and thus akin to a nop.
- *
- * The opcode for this instruction read with the wrong endian
- * however results in a b . + 8
- *
- * So essentially we use that trick to execute the following
- * trampoline in "reverse endian" if we are running with the
- * MSR_LE bit set the "wrong" way for whatever endianness the
- * kernel is built for.
- */
-
-#ifdef CONFIG_PPC_BOOK3E_64
-#define FIXUP_ENDIAN
-#else
-/*
- * This version may be used in HV or non-HV context.
- * MSR[EE] must be disabled.
- */
-#define FIXUP_ENDIAN						   \
-	tdi   0,0,0x48;	  /* Reverse endian of b . + 8		*/ \
-	b     191f;	  /* Skip trampoline if endian is good	*/ \
-	.long 0xa600607d; /* mfmsr r11				*/ \
-	.long 0x01006b69; /* xori r11,r11,1			*/ \
-	.long 0x00004039; /* li r10,0				*/ \
-	.long 0x6401417d; /* mtmsrd r10,1			*/ \
-	.long 0x05009f42; /* bcl 20,31,$+4			*/ \
-	.long 0xa602487d; /* mflr r10				*/ \
-	.long 0x14004a39; /* addi r10,r10,20			*/ \
-	.long 0xa6035a7d; /* mtsrr0 r10				*/ \
-	.long 0xa6037b7d; /* mtsrr1 r11				*/ \
-	.long 0x2400004c; /* rfid				*/ \
-191:
-
-/*
- * This version that may only be used with MSR[HV]=1
- * - Does not clear MSR[RI], so more robust.
- * - Slightly smaller and faster.
- */
-#define FIXUP_ENDIAN_HV						   \
-	tdi   0,0,0x48;	  /* Reverse endian of b . + 8		*/ \
-	b     191f;	  /* Skip trampoline if endian is good	*/ \
-	.long 0xa600607d; /* mfmsr r11				*/ \
-	.long 0x01006b69; /* xori r11,r11,1			*/ \
-	.long 0x05009f42; /* bcl 20,31,$+4			*/ \
-	.long 0xa602487d; /* mflr r10				*/ \
-	.long 0x14004a39; /* addi r10,r10,20			*/ \
-	.long 0xa64b5a7d; /* mthsrr0 r10			*/ \
-	.long 0xa64b7b7d; /* mthsrr1 r11			*/ \
-	.long 0x2402004c; /* hrfid				*/ \
-191:
-
-#endif /* !CONFIG_PPC_BOOK3E_64 */
-
-#endif /*  __ASSEMBLY__ */
-
-#define SOFT_MASK_TABLE(_start, _end)		\
-	stringify_in_c(.section __soft_mask_table,"a";)\
-	stringify_in_c(.balign 8;)		\
-	stringify_in_c(.llong (_start);)	\
-	stringify_in_c(.llong (_end);)		\
-	stringify_in_c(.previous)
-
-#define RESTART_TABLE(_start, _end, _target)	\
-	stringify_in_c(.section __restart_table,"a";)\
-	stringify_in_c(.balign 8;)		\
-	stringify_in_c(.llong (_start);)	\
-	stringify_in_c(.llong (_end);)		\
-	stringify_in_c(.llong (_target);)	\
-	stringify_in_c(.previous)
-
-#ifdef CONFIG_PPC_E500
-#define BTB_FLUSH(reg)			\
-	lis reg,BUCSR_INIT@h;		\
-	ori reg,reg,BUCSR_INIT@l;	\
-	mtspr SPRN_BUCSR,reg;		\
-	isync;
-#else
-#define BTB_FLUSH(reg)
-#endif /* CONFIG_PPC_E500 */
-
-#if defined(CONFIG_PPC64_ELF_ABI_V1)
-#define STACK_FRAME_PARAMS 48
-#elif defined(CONFIG_PPC64_ELF_ABI_V2)
-#define STACK_FRAME_PARAMS 32
-#elif defined(CONFIG_PPC32)
-#define STACK_FRAME_PARAMS 8
-#endif
-
-#endif /* _ASM_POWERPC_PPC_ASM_H */
+../../../../../../arch/powerpc/include/asm/ppc_asm.h
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/powerpc/primitives/linux/wordpart.h linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/primitives/linux/wordpart.h
--- linux-6.16.7/tools/testing/selftests/powerpc/primitives/linux/wordpart.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/primitives/linux/wordpart.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,57 +1 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-
-#ifndef _LINUX_WORDPART_H
-#define _LINUX_WORDPART_H
-
-/**
- * upper_32_bits - return bits 32-63 of a number
- * @n: the number we're accessing
- *
- * A basic shift-right of a 64- or 32-bit quantity.  Use this to suppress
- * the "right shift count >= width of type" warning when that quantity is
- * 32-bits.
- */
-#define upper_32_bits(n) ((u32)(((n) >> 16) >> 16))
-
-/**
- * lower_32_bits - return bits 0-31 of a number
- * @n: the number we're accessing
- */
-#define lower_32_bits(n) ((u32)((n) & 0xffffffff))
-
-/**
- * upper_16_bits - return bits 16-31 of a number
- * @n: the number we're accessing
- */
-#define upper_16_bits(n) ((u16)((n) >> 16))
-
-/**
- * lower_16_bits - return bits 0-15 of a number
- * @n: the number we're accessing
- */
-#define lower_16_bits(n) ((u16)((n) & 0xffff))
-
-/**
- * REPEAT_BYTE - repeat the value @x multiple times as an unsigned long value
- * @x: value to repeat
- *
- * NOTE: @x is not checked for > 0xff; larger values produce odd results.
- */
-#define REPEAT_BYTE(x)	((~0ul / 0xff) * (x))
-
-/**
- * REPEAT_BYTE_U32 - repeat the value @x multiple times as a u32 value
- * @x: value to repeat
- *
- * NOTE: @x is not checked for > 0xff; larger values produce odd results.
- */
-#define REPEAT_BYTE_U32(x)	lower_32_bits(REPEAT_BYTE(x))
-
-/* Set bits in the first 'n' bytes when loaded from memory */
-#ifdef __LITTLE_ENDIAN
-#  define aligned_byte_mask(n) ((1UL << 8*(n))-1)
-#else
-#  define aligned_byte_mask(n) (~0xffUL << (BITS_PER_LONG - 8 - 8*(n)))
-#endif
-
-#endif // _LINUX_WORDPART_H
+../../../../../../include/linux/wordpart.h
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/powerpc/primitives/word-at-a-time.h linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/primitives/word-at-a-time.h
--- linux-6.16.7/tools/testing/selftests/powerpc/primitives/word-at-a-time.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/primitives/word-at-a-time.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,206 +1 @@
-#ifndef _ASM_WORD_AT_A_TIME_H
-#define _ASM_WORD_AT_A_TIME_H
-
-/*
- * Word-at-a-time interfaces for PowerPC.
- */
-#include <linux/bitops.h>
-#include <linux/wordpart.h>
-#include <asm/asm-compat.h>
-#include <asm/extable.h>
-
-#ifdef __BIG_ENDIAN__
-
-struct word_at_a_time {
-	const unsigned long high_bits, low_bits;
-};
-
-#define WORD_AT_A_TIME_CONSTANTS { REPEAT_BYTE(0xfe) + 1, REPEAT_BYTE(0x7f) }
-
-/* Bit set in the bytes that have a zero */
-static inline long prep_zero_mask(unsigned long val, unsigned long rhs, const struct word_at_a_time *c)
-{
-	unsigned long mask = (val & c->low_bits) + c->low_bits;
-	return ~(mask | rhs);
-}
-
-#define create_zero_mask(mask) (mask)
-
-static inline long find_zero(unsigned long mask)
-{
-	long leading_zero_bits;
-
-	asm (PPC_CNTLZL "%0,%1" : "=r" (leading_zero_bits) : "r" (mask));
-	return leading_zero_bits >> 3;
-}
-
-static inline unsigned long has_zero(unsigned long val, unsigned long *data, const struct word_at_a_time *c)
-{
-	unsigned long rhs = val | c->low_bits;
-	*data = rhs;
-	return (val + c->high_bits) & ~rhs;
-}
-
-static inline unsigned long zero_bytemask(unsigned long mask)
-{
-	return ~1ul << __fls(mask);
-}
-
-#else
-
-#ifdef CONFIG_64BIT
-
-/* unused */
-struct word_at_a_time {
-};
-
-#define WORD_AT_A_TIME_CONSTANTS { }
-
-/* This will give us 0xff for a NULL char and 0x00 elsewhere */
-static inline unsigned long has_zero(unsigned long a, unsigned long *bits, const struct word_at_a_time *c)
-{
-	unsigned long ret;
-	unsigned long zero = 0;
-
-	asm("cmpb %0,%1,%2" : "=r" (ret) : "r" (a), "r" (zero));
-	*bits = ret;
-
-	return ret;
-}
-
-static inline unsigned long prep_zero_mask(unsigned long a, unsigned long bits, const struct word_at_a_time *c)
-{
-	return bits;
-}
-
-/* Alan Modra's little-endian strlen tail for 64-bit */
-static inline unsigned long create_zero_mask(unsigned long bits)
-{
-	unsigned long leading_zero_bits;
-	long trailing_zero_bit_mask;
-
-	asm("addi	%1,%2,-1\n\t"
-	    "andc	%1,%1,%2\n\t"
-	    "popcntd	%0,%1"
-		: "=r" (leading_zero_bits), "=&r" (trailing_zero_bit_mask)
-		: "b" (bits));
-
-	return leading_zero_bits;
-}
-
-static inline unsigned long find_zero(unsigned long mask)
-{
-	return mask >> 3;
-}
-
-/* This assumes that we never ask for an all 1s bitmask */
-static inline unsigned long zero_bytemask(unsigned long mask)
-{
-	return (1UL << mask) - 1;
-}
-
-#else	/* 32-bit case */
-
-struct word_at_a_time {
-	const unsigned long one_bits, high_bits;
-};
-
-#define WORD_AT_A_TIME_CONSTANTS { REPEAT_BYTE(0x01), REPEAT_BYTE(0x80) }
-
-/*
- * This is largely generic for little-endian machines, but the
- * optimal byte mask counting is probably going to be something
- * that is architecture-specific. If you have a reliably fast
- * bit count instruction, that might be better than the multiply
- * and shift, for example.
- */
-
-/* Carl Chatfield / Jan Achrenius G+ version for 32-bit */
-static inline long count_masked_bytes(long mask)
-{
-	/* (000000 0000ff 00ffff ffffff) -> ( 1 1 2 3 ) */
-	long a = (0x0ff0001+mask) >> 23;
-	/* Fix the 1 for 00 case */
-	return a & mask;
-}
-
-static inline unsigned long create_zero_mask(unsigned long bits)
-{
-	bits = (bits - 1) & ~bits;
-	return bits >> 7;
-}
-
-static inline unsigned long find_zero(unsigned long mask)
-{
-	return count_masked_bytes(mask);
-}
-
-/* Return nonzero if it has a zero */
-static inline unsigned long has_zero(unsigned long a, unsigned long *bits, const struct word_at_a_time *c)
-{
-	unsigned long mask = ((a - c->one_bits) & ~a) & c->high_bits;
-	*bits = mask;
-	return mask;
-}
-
-static inline unsigned long prep_zero_mask(unsigned long a, unsigned long bits, const struct word_at_a_time *c)
-{
-	return bits;
-}
-
-/* The mask we created is directly usable as a bytemask */
-#define zero_bytemask(mask) (mask)
-
-#endif /* CONFIG_64BIT */
-
-#endif /* __BIG_ENDIAN__ */
-
-/*
- * We use load_unaligned_zero() in a selftest, which builds a userspace
- * program. Some linker scripts seem to discard the .fixup section, so allow
- * the test code to use a different section name.
- */
-#ifndef FIXUP_SECTION
-#define FIXUP_SECTION ".fixup"
-#endif
-
-static inline unsigned long load_unaligned_zeropad(const void *addr)
-{
-	unsigned long ret, offset, tmp;
-
-	asm(
-	"1:	" PPC_LL "%[ret], 0(%[addr])\n"
-	"2:\n"
-	".section " FIXUP_SECTION ",\"ax\"\n"
-	"3:	"
-#ifdef __powerpc64__
-	"clrrdi		%[tmp], %[addr], 3\n\t"
-	"clrlsldi	%[offset], %[addr], 61, 3\n\t"
-	"ld		%[ret], 0(%[tmp])\n\t"
-#ifdef __BIG_ENDIAN__
-	"sld		%[ret], %[ret], %[offset]\n\t"
-#else
-	"srd		%[ret], %[ret], %[offset]\n\t"
-#endif
-#else
-	"clrrwi		%[tmp], %[addr], 2\n\t"
-	"clrlslwi	%[offset], %[addr], 30, 3\n\t"
-	"lwz		%[ret], 0(%[tmp])\n\t"
-#ifdef __BIG_ENDIAN__
-	"slw		%[ret], %[ret], %[offset]\n\t"
-#else
-	"srw		%[ret], %[ret], %[offset]\n\t"
-#endif
-#endif
-	"b	2b\n"
-	".previous\n"
-	EX_TABLE(1b, 3b)
-	: [tmp] "=&b" (tmp), [offset] "=&r" (offset), [ret] "=&r" (ret)
-	: [addr] "b" (addr), "m" (*(unsigned long *)addr));
-
-	return ret;
-}
-
-#undef FIXUP_SECTION
-
-#endif /* _ASM_WORD_AT_A_TIME_H */
+../../../../../arch/powerpc/include/asm/word-at-a-time.h
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/powerpc/stringloops/memcmp_32.S linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/stringloops/memcmp_32.S
--- linux-6.16.7/tools/testing/selftests/powerpc/stringloops/memcmp_32.S	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/stringloops/memcmp_32.S	2025-09-11 09:47:42.000000000 -0600
@@ -1,45 +1 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-
-/*
- * memcmp for PowerPC32
- *
- * Copyright (C) 1996 Paul Mackerras.
- *
- */
-
-#include <linux/export.h>
-#include <asm/ppc_asm.h>
-
-	.text
-
-_GLOBAL(memcmp)
-	srawi.	r7, r5, 2		/* Divide len by 4 */
-	mr	r6, r3
-	beq-	3f
-	mtctr	r7
-	li	r7, 0
-1:	lwzx	r3, r6, r7
-	lwzx	r0, r4, r7
-	addi	r7, r7, 4
-	cmplw	cr0, r3, r0
-	bdnzt	eq, 1b
-	bne	5f
-3:	andi.	r3, r5, 3
-	beqlr
-	cmplwi	cr1, r3, 2
-	blt-	cr1, 4f
-	lhzx	r3, r6, r7
-	lhzx	r0, r4, r7
-	addi	r7, r7, 2
-	subf.	r3, r0, r3
-	beqlr	cr1
-	bnelr
-4:	lbzx	r3, r6, r7
-	lbzx	r0, r4, r7
-	subf.	r3, r0, r3
-	blr
-5:	li	r3, 1
-	bgtlr
-	li	r3, -1
-	blr
-EXPORT_SYMBOL(memcmp)
+../../../../../arch/powerpc/lib/memcmp_32.S
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/powerpc/stringloops/memcmp_64.S linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/stringloops/memcmp_64.S
--- linux-6.16.7/tools/testing/selftests/powerpc/stringloops/memcmp_64.S	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/stringloops/memcmp_64.S	2025-09-11 09:47:42.000000000 -0600
@@ -1,638 +1 @@
-/* SPDX-License-Identifier: GPL-2.0-or-later */
-/*
- * Author: Anton Blanchard <anton@au.ibm.com>
- * Copyright 2015 IBM Corporation.
- */
-#include <linux/export.h>
-#include <asm/ppc_asm.h>
-#include <asm/ppc-opcode.h>
-
-#define off8	r6
-#define off16	r7
-#define off24	r8
-
-#define rA	r9
-#define rB	r10
-#define rC	r11
-#define rD	r27
-#define rE	r28
-#define rF	r29
-#define rG	r30
-#define rH	r31
-
-#ifdef __LITTLE_ENDIAN__
-#define LH	lhbrx
-#define LW	lwbrx
-#define LD	ldbrx
-#define LVS	lvsr
-#define VPERM(_VRT,_VRA,_VRB,_VRC) \
-	vperm _VRT,_VRB,_VRA,_VRC
-#else
-#define LH	lhzx
-#define LW	lwzx
-#define LD	ldx
-#define LVS	lvsl
-#define VPERM(_VRT,_VRA,_VRB,_VRC) \
-	vperm _VRT,_VRA,_VRB,_VRC
-#endif
-
-#define VMX_THRESH 4096
-#define ENTER_VMX_OPS	\
-	mflr    r0;	\
-	std     r3,-STACKFRAMESIZE+STK_REG(R31)(r1); \
-	std     r4,-STACKFRAMESIZE+STK_REG(R30)(r1); \
-	std     r5,-STACKFRAMESIZE+STK_REG(R29)(r1); \
-	std     r0,16(r1); \
-	stdu    r1,-STACKFRAMESIZE(r1); \
-	bl      CFUNC(enter_vmx_ops); \
-	cmpwi   cr1,r3,0; \
-	ld      r0,STACKFRAMESIZE+16(r1); \
-	ld      r3,STK_REG(R31)(r1); \
-	ld      r4,STK_REG(R30)(r1); \
-	ld      r5,STK_REG(R29)(r1); \
-	addi	r1,r1,STACKFRAMESIZE; \
-	mtlr    r0
-
-#define EXIT_VMX_OPS \
-	mflr    r0; \
-	std     r3,-STACKFRAMESIZE+STK_REG(R31)(r1); \
-	std     r4,-STACKFRAMESIZE+STK_REG(R30)(r1); \
-	std     r5,-STACKFRAMESIZE+STK_REG(R29)(r1); \
-	std     r0,16(r1); \
-	stdu    r1,-STACKFRAMESIZE(r1); \
-	bl      CFUNC(exit_vmx_ops); \
-	ld      r0,STACKFRAMESIZE+16(r1); \
-	ld      r3,STK_REG(R31)(r1); \
-	ld      r4,STK_REG(R30)(r1); \
-	ld      r5,STK_REG(R29)(r1); \
-	addi	r1,r1,STACKFRAMESIZE; \
-	mtlr    r0
-
-/*
- * LD_VSR_CROSS16B load the 2nd 16 bytes for _vaddr which is unaligned with
- * 16 bytes boundary and permute the result with the 1st 16 bytes.
-
- *    |  y y y y y y y y y y y y y 0 1 2 | 3 4 5 6 7 8 9 a b c d e f z z z |
- *    ^                                  ^                                 ^
- * 0xbbbb10                          0xbbbb20                          0xbbb30
- *                                 ^
- *                                _vaddr
- *
- *
- * _vmask is the mask generated by LVS
- * _v1st_qw is the 1st aligned QW of current addr which is already loaded.
- *   for example: 0xyyyyyyyyyyyyy012 for big endian
- * _v2nd_qw is the 2nd aligned QW of cur _vaddr to be loaded.
- *   for example: 0x3456789abcdefzzz for big endian
- * The permute result is saved in _v_res.
- *   for example: 0x0123456789abcdef for big endian.
- */
-#define LD_VSR_CROSS16B(_vaddr,_vmask,_v1st_qw,_v2nd_qw,_v_res) \
-        lvx     _v2nd_qw,_vaddr,off16; \
-        VPERM(_v_res,_v1st_qw,_v2nd_qw,_vmask)
-
-/*
- * There are 2 categories for memcmp:
- * 1) src/dst has the same offset to the 8 bytes boundary. The handlers
- * are named like .Lsameoffset_xxxx
- * 2) src/dst has different offset to the 8 bytes boundary. The handlers
- * are named like .Ldiffoffset_xxxx
- */
-_GLOBAL_TOC(memcmp)
-	cmpdi	cr1,r5,0
-
-	/* Use the short loop if the src/dst addresses are not
-	 * with the same offset of 8 bytes align boundary.
-	 */
-	xor	r6,r3,r4
-	andi.	r6,r6,7
-
-	/* Fall back to short loop if compare at aligned addrs
-	 * with less than 8 bytes.
-	 */
-	cmpdi   cr6,r5,7
-
-	beq	cr1,.Lzero
-	bgt	cr6,.Lno_short
-
-.Lshort:
-	mtctr	r5
-1:	lbz	rA,0(r3)
-	lbz	rB,0(r4)
-	subf.	rC,rB,rA
-	bne	.Lnon_zero
-	bdz	.Lzero
-
-	lbz	rA,1(r3)
-	lbz	rB,1(r4)
-	subf.	rC,rB,rA
-	bne	.Lnon_zero
-	bdz	.Lzero
-
-	lbz	rA,2(r3)
-	lbz	rB,2(r4)
-	subf.	rC,rB,rA
-	bne	.Lnon_zero
-	bdz	.Lzero
-
-	lbz	rA,3(r3)
-	lbz	rB,3(r4)
-	subf.	rC,rB,rA
-	bne	.Lnon_zero
-
-	addi	r3,r3,4
-	addi	r4,r4,4
-
-	bdnz	1b
-
-.Lzero:
-	li	r3,0
-	blr
-
-.Lno_short:
-	dcbt	0,r3
-	dcbt	0,r4
-	bne	.Ldiffoffset_8bytes_make_align_start
-
-
-.Lsameoffset_8bytes_make_align_start:
-	/* attempt to compare bytes not aligned with 8 bytes so that
-	 * rest comparison can run based on 8 bytes alignment.
-	 */
-	andi.   r6,r3,7
-
-	/* Try to compare the first double word which is not 8 bytes aligned:
-	 * load the first double word at (src & ~7UL) and shift left appropriate
-	 * bits before comparision.
-	 */
-	rlwinm  r6,r3,3,26,28
-	beq     .Lsameoffset_8bytes_aligned
-	clrrdi	r3,r3,3
-	clrrdi	r4,r4,3
-	LD	rA,0,r3
-	LD	rB,0,r4
-	sld	rA,rA,r6
-	sld	rB,rB,r6
-	cmpld	cr0,rA,rB
-	srwi	r6,r6,3
-	bne	cr0,.LcmpAB_lightweight
-	subfic  r6,r6,8
-	subf.	r5,r6,r5
-	addi	r3,r3,8
-	addi	r4,r4,8
-	beq	.Lzero
-
-.Lsameoffset_8bytes_aligned:
-	/* now we are aligned with 8 bytes.
-	 * Use .Llong loop if left cmp bytes are equal or greater than 32B.
-	 */
-	cmpdi   cr6,r5,31
-	bgt	cr6,.Llong
-
-.Lcmp_lt32bytes:
-	/* compare 1 ~ 31 bytes, at least r3 addr is 8 bytes aligned now */
-	cmpdi   cr5,r5,7
-	srdi    r0,r5,3
-	ble	cr5,.Lcmp_rest_lt8bytes
-
-	/* handle 8 ~ 31 bytes */
-	clrldi  r5,r5,61
-	mtctr   r0
-2:
-	LD	rA,0,r3
-	LD	rB,0,r4
-	cmpld	cr0,rA,rB
-	addi	r3,r3,8
-	addi	r4,r4,8
-	bne	cr0,.LcmpAB_lightweight
-	bdnz	2b
-
-	cmpwi   r5,0
-	beq	.Lzero
-
-.Lcmp_rest_lt8bytes:
-	/*
-	 * Here we have less than 8 bytes to compare. At least s1 is aligned to
-	 * 8 bytes, but s2 may not be. We must make sure s2 + 7 doesn't cross a
-	 * page boundary, otherwise we might read past the end of the buffer and
-	 * trigger a page fault. We use 4K as the conservative minimum page
-	 * size. If we detect that case we go to the byte-by-byte loop.
-	 *
-	 * Otherwise the next double word is loaded from s1 and s2, and shifted
-	 * right to compare the appropriate bits.
-	 */
-	clrldi	r6,r4,(64-12)	// r6 = r4 & 0xfff
-	cmpdi	r6,0xff8
-	bgt	.Lshort
-
-	subfic  r6,r5,8
-	slwi	r6,r6,3
-	LD	rA,0,r3
-	LD	rB,0,r4
-	srd	rA,rA,r6
-	srd	rB,rB,r6
-	cmpld	cr0,rA,rB
-	bne	cr0,.LcmpAB_lightweight
-	b	.Lzero
-
-.Lnon_zero:
-	mr	r3,rC
-	blr
-
-.Llong:
-#ifdef CONFIG_ALTIVEC
-BEGIN_FTR_SECTION
-	/* Try to use vmx loop if length is equal or greater than 4K */
-	cmpldi  cr6,r5,VMX_THRESH
-	bge	cr6,.Lsameoffset_vmx_cmp
-END_FTR_SECTION_IFSET(CPU_FTR_ARCH_207S)
-
-.Llong_novmx_cmp:
-#endif
-	/* At least s1 addr is aligned with 8 bytes */
-	li	off8,8
-	li	off16,16
-	li	off24,24
-
-	std	r31,-8(r1)
-	std	r30,-16(r1)
-	std	r29,-24(r1)
-	std	r28,-32(r1)
-	std	r27,-40(r1)
-
-	srdi	r0,r5,5
-	mtctr	r0
-	andi.	r5,r5,31
-
-	LD	rA,0,r3
-	LD	rB,0,r4
-
-	LD	rC,off8,r3
-	LD	rD,off8,r4
-
-	LD	rE,off16,r3
-	LD	rF,off16,r4
-
-	LD	rG,off24,r3
-	LD	rH,off24,r4
-	cmpld	cr0,rA,rB
-
-	addi	r3,r3,32
-	addi	r4,r4,32
-
-	bdz	.Lfirst32
-
-	LD	rA,0,r3
-	LD	rB,0,r4
-	cmpld	cr1,rC,rD
-
-	LD	rC,off8,r3
-	LD	rD,off8,r4
-	cmpld	cr6,rE,rF
-
-	LD	rE,off16,r3
-	LD	rF,off16,r4
-	cmpld	cr7,rG,rH
-	bne	cr0,.LcmpAB
-
-	LD	rG,off24,r3
-	LD	rH,off24,r4
-	cmpld	cr0,rA,rB
-	bne	cr1,.LcmpCD
-
-	addi	r3,r3,32
-	addi	r4,r4,32
-
-	bdz	.Lsecond32
-
-	.balign	16
-
-1:	LD	rA,0,r3
-	LD	rB,0,r4
-	cmpld	cr1,rC,rD
-	bne	cr6,.LcmpEF
-
-	LD	rC,off8,r3
-	LD	rD,off8,r4
-	cmpld	cr6,rE,rF
-	bne	cr7,.LcmpGH
-
-	LD	rE,off16,r3
-	LD	rF,off16,r4
-	cmpld	cr7,rG,rH
-	bne	cr0,.LcmpAB
-
-	LD	rG,off24,r3
-	LD	rH,off24,r4
-	cmpld	cr0,rA,rB
-	bne	cr1,.LcmpCD
-
-	addi	r3,r3,32
-	addi	r4,r4,32
-
-	bdnz	1b
-
-.Lsecond32:
-	cmpld	cr1,rC,rD
-	bne	cr6,.LcmpEF
-
-	cmpld	cr6,rE,rF
-	bne	cr7,.LcmpGH
-
-	cmpld	cr7,rG,rH
-	bne	cr0,.LcmpAB
-
-	bne	cr1,.LcmpCD
-	bne	cr6,.LcmpEF
-	bne	cr7,.LcmpGH
-
-.Ltail:
-	ld	r31,-8(r1)
-	ld	r30,-16(r1)
-	ld	r29,-24(r1)
-	ld	r28,-32(r1)
-	ld	r27,-40(r1)
-
-	cmpdi	r5,0
-	beq	.Lzero
-	b	.Lshort
-
-.Lfirst32:
-	cmpld	cr1,rC,rD
-	cmpld	cr6,rE,rF
-	cmpld	cr7,rG,rH
-
-	bne	cr0,.LcmpAB
-	bne	cr1,.LcmpCD
-	bne	cr6,.LcmpEF
-	bne	cr7,.LcmpGH
-
-	b	.Ltail
-
-.LcmpAB:
-	li	r3,1
-	bgt	cr0,.Lout
-	li	r3,-1
-	b	.Lout
-
-.LcmpCD:
-	li	r3,1
-	bgt	cr1,.Lout
-	li	r3,-1
-	b	.Lout
-
-.LcmpEF:
-	li	r3,1
-	bgt	cr6,.Lout
-	li	r3,-1
-	b	.Lout
-
-.LcmpGH:
-	li	r3,1
-	bgt	cr7,.Lout
-	li	r3,-1
-
-.Lout:
-	ld	r31,-8(r1)
-	ld	r30,-16(r1)
-	ld	r29,-24(r1)
-	ld	r28,-32(r1)
-	ld	r27,-40(r1)
-	blr
-
-.LcmpAB_lightweight:   /* skip NV GPRS restore */
-	li	r3,1
-	bgtlr
-	li	r3,-1
-	blr
-
-#ifdef CONFIG_ALTIVEC
-.Lsameoffset_vmx_cmp:
-	/* Enter with src/dst addrs has the same offset with 8 bytes
-	 * align boundary.
-	 *
-	 * There is an optimization based on following fact: memcmp()
-	 * prones to fail early at the first 32 bytes.
-	 * Before applying VMX instructions which will lead to 32x128bits
-	 * VMX regs load/restore penalty, we compare the first 32 bytes
-	 * so that we can catch the ~80% fail cases.
-	 */
-
-	li	r0,4
-	mtctr	r0
-.Lsameoffset_prechk_32B_loop:
-	LD	rA,0,r3
-	LD	rB,0,r4
-	cmpld	cr0,rA,rB
-	addi	r3,r3,8
-	addi	r4,r4,8
-	bne     cr0,.LcmpAB_lightweight
-	addi	r5,r5,-8
-	bdnz	.Lsameoffset_prechk_32B_loop
-
-	ENTER_VMX_OPS
-	beq     cr1,.Llong_novmx_cmp
-
-3:
-	/* need to check whether r4 has the same offset with r3
-	 * for 16 bytes boundary.
-	 */
-	xor	r0,r3,r4
-	andi.	r0,r0,0xf
-	bne	.Ldiffoffset_vmx_cmp_start
-
-	/* len is no less than 4KB. Need to align with 16 bytes further.
-	 */
-	andi.	rA,r3,8
-	LD	rA,0,r3
-	beq	4f
-	LD	rB,0,r4
-	cmpld	cr0,rA,rB
-	addi	r3,r3,8
-	addi	r4,r4,8
-	addi	r5,r5,-8
-
-	beq	cr0,4f
-	/* save and restore cr0 */
-	mfocrf  r5,128
-	EXIT_VMX_OPS
-	mtocrf  128,r5
-	b	.LcmpAB_lightweight
-
-4:
-	/* compare 32 bytes for each loop */
-	srdi	r0,r5,5
-	mtctr	r0
-	clrldi  r5,r5,59
-	li	off16,16
-
-.balign 16
-5:
-	lvx 	v0,0,r3
-	lvx 	v1,0,r4
-	VCMPEQUD_RC(v0,v0,v1)
-	bnl	cr6,7f
-	lvx 	v0,off16,r3
-	lvx 	v1,off16,r4
-	VCMPEQUD_RC(v0,v0,v1)
-	bnl	cr6,6f
-	addi	r3,r3,32
-	addi	r4,r4,32
-	bdnz	5b
-
-	EXIT_VMX_OPS
-	cmpdi	r5,0
-	beq	.Lzero
-	b	.Lcmp_lt32bytes
-
-6:
-	addi	r3,r3,16
-	addi	r4,r4,16
-
-7:
-	/* diff the last 16 bytes */
-	EXIT_VMX_OPS
-	LD	rA,0,r3
-	LD	rB,0,r4
-	cmpld	cr0,rA,rB
-	li	off8,8
-	bne	cr0,.LcmpAB_lightweight
-
-	LD	rA,off8,r3
-	LD	rB,off8,r4
-	cmpld	cr0,rA,rB
-	bne	cr0,.LcmpAB_lightweight
-	b	.Lzero
-#endif
-
-.Ldiffoffset_8bytes_make_align_start:
-	/* now try to align s1 with 8 bytes */
-	rlwinm  r6,r3,3,26,28
-	beq     .Ldiffoffset_align_s1_8bytes
-
-	clrrdi	r3,r3,3
-	LD	rA,0,r3
-	LD	rB,0,r4  /* unaligned load */
-	sld	rA,rA,r6
-	srd	rA,rA,r6
-	srd	rB,rB,r6
-	cmpld	cr0,rA,rB
-	srwi	r6,r6,3
-	bne	cr0,.LcmpAB_lightweight
-
-	subfic  r6,r6,8
-	subf.	r5,r6,r5
-	addi	r3,r3,8
-	add	r4,r4,r6
-
-	beq	.Lzero
-
-.Ldiffoffset_align_s1_8bytes:
-	/* now s1 is aligned with 8 bytes. */
-#ifdef CONFIG_ALTIVEC
-BEGIN_FTR_SECTION
-	/* only do vmx ops when the size equal or greater than 4K bytes */
-	cmpdi	cr5,r5,VMX_THRESH
-	bge	cr5,.Ldiffoffset_vmx_cmp
-END_FTR_SECTION_IFSET(CPU_FTR_ARCH_207S)
-
-.Ldiffoffset_novmx_cmp:
-#endif
-
-
-	cmpdi   cr5,r5,31
-	ble	cr5,.Lcmp_lt32bytes
-
-#ifdef CONFIG_ALTIVEC
-	b	.Llong_novmx_cmp
-#else
-	b	.Llong
-#endif
-
-#ifdef CONFIG_ALTIVEC
-.Ldiffoffset_vmx_cmp:
-	/* perform a 32 bytes pre-checking before
-	 * enable VMX operations.
-	 */
-	li	r0,4
-	mtctr	r0
-.Ldiffoffset_prechk_32B_loop:
-	LD	rA,0,r3
-	LD	rB,0,r4
-	cmpld	cr0,rA,rB
-	addi	r3,r3,8
-	addi	r4,r4,8
-	bne     cr0,.LcmpAB_lightweight
-	addi	r5,r5,-8
-	bdnz	.Ldiffoffset_prechk_32B_loop
-
-	ENTER_VMX_OPS
-	beq     cr1,.Ldiffoffset_novmx_cmp
-
-.Ldiffoffset_vmx_cmp_start:
-	/* Firstly try to align r3 with 16 bytes */
-	andi.   r6,r3,0xf
-	li	off16,16
-	beq     .Ldiffoffset_vmx_s1_16bytes_align
-
-	LVS	v3,0,r3
-	LVS	v4,0,r4
-
-	lvx     v5,0,r3
-	lvx     v6,0,r4
-	LD_VSR_CROSS16B(r3,v3,v5,v7,v9)
-	LD_VSR_CROSS16B(r4,v4,v6,v8,v10)
-
-	VCMPEQUB_RC(v7,v9,v10)
-	bnl	cr6,.Ldiffoffset_vmx_diff_found
-
-	subfic  r6,r6,16
-	subf    r5,r6,r5
-	add     r3,r3,r6
-	add     r4,r4,r6
-
-.Ldiffoffset_vmx_s1_16bytes_align:
-	/* now s1 is aligned with 16 bytes */
-	lvx     v6,0,r4
-	LVS	v4,0,r4
-	srdi	r6,r5,5  /* loop for 32 bytes each */
-	clrldi  r5,r5,59
-	mtctr	r6
-
-.balign	16
-.Ldiffoffset_vmx_32bytesloop:
-	/* the first qw of r4 was saved in v6 */
-	lvx	v9,0,r3
-	LD_VSR_CROSS16B(r4,v4,v6,v8,v10)
-	VCMPEQUB_RC(v7,v9,v10)
-	vor	v6,v8,v8
-	bnl	cr6,.Ldiffoffset_vmx_diff_found
-
-	addi	r3,r3,16
-	addi	r4,r4,16
-
-	lvx	v9,0,r3
-	LD_VSR_CROSS16B(r4,v4,v6,v8,v10)
-	VCMPEQUB_RC(v7,v9,v10)
-	vor	v6,v8,v8
-	bnl	cr6,.Ldiffoffset_vmx_diff_found
-
-	addi	r3,r3,16
-	addi	r4,r4,16
-
-	bdnz	.Ldiffoffset_vmx_32bytesloop
-
-	EXIT_VMX_OPS
-
-	cmpdi	r5,0
-	beq	.Lzero
-	b	.Lcmp_lt32bytes
-
-.Ldiffoffset_vmx_diff_found:
-	EXIT_VMX_OPS
-	/* anyway, the diff will appear in next 16 bytes */
-	li	r5,16
-	b	.Lcmp_lt32bytes
-
-#endif
-EXPORT_SYMBOL(memcmp)
+../../../../../arch/powerpc/lib/memcmp_64.S
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/powerpc/stringloops/strlen_32.S linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/stringloops/strlen_32.S
--- linux-6.16.7/tools/testing/selftests/powerpc/stringloops/strlen_32.S	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/stringloops/strlen_32.S	2025-09-11 09:47:42.000000000 -0600
@@ -1,78 +1 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * strlen() for PPC32
- *
- * Copyright (C) 2018 Christophe Leroy CS Systemes d'Information.
- *
- * Inspired from glibc implementation
- */
-#include <linux/export.h>
-#include <asm/ppc_asm.h>
-#include <asm/cache.h>
-
-	.text
-
-/*
- * Algorithm:
- *
- * 1) Given a word 'x', we can test to see if it contains any 0 bytes
- *    by subtracting 0x01010101, and seeing if any of the high bits of each
- *    byte changed from 0 to 1. This works because the least significant
- *    0 byte must have had no incoming carry (otherwise it's not the least
- *    significant), so it is 0x00 - 0x01 == 0xff. For all other
- *    byte values, either they have the high bit set initially, or when
- *    1 is subtracted you get a value in the range 0x00-0x7f, none of which
- *    have their high bit set. The expression here is
- *    (x - 0x01010101) & ~x & 0x80808080), which gives 0x00000000 when
- *    there were no 0x00 bytes in the word.  You get 0x80 in bytes that
- *    match, but possibly false 0x80 matches in the next more significant
- *    byte to a true match due to carries.  For little-endian this is
- *    of no consequence since the least significant match is the one
- *    we're interested in, but big-endian needs method 2 to find which
- *    byte matches.
- * 2) Given a word 'x', we can test to see _which_ byte was zero by
- *    calculating ~(((x & ~0x80808080) - 0x80808080 - 1) | x | ~0x80808080).
- *    This produces 0x80 in each byte that was zero, and 0x00 in all
- *    the other bytes. The '| ~0x80808080' clears the low 7 bits in each
- *    byte, and the '| x' part ensures that bytes with the high bit set
- *    produce 0x00. The addition will carry into the high bit of each byte
- *    iff that byte had one of its low 7 bits set. We can then just see
- *    which was the most significant bit set and divide by 8 to find how
- *    many to add to the index.
- *    This is from the book 'The PowerPC Compiler Writer's Guide',
- *    by Steve Hoxey, Faraydon Karim, Bill Hay and Hank Warren.
- */
-
-_GLOBAL(strlen)
-	andi.   r0, r3, 3
-	lis	r7, 0x0101
-	addi	r10, r3, -4
-	addic	r7, r7, 0x0101	/* r7 = 0x01010101 (lomagic) & clear XER[CA] */
-	rotlwi	r6, r7, 31 	/* r6 = 0x80808080 (himagic) */
-	bne-	3f
-	.balign IFETCH_ALIGN_BYTES
-1:	lwzu	r9, 4(r10)
-2:	subf	r8, r7, r9
-	and.	r8, r8, r6
-	beq+	1b
-	andc.	r8, r8, r9
-	beq+	1b
-	andc	r8, r9, r6
-	orc	r9, r9, r6
-	subfe	r8, r6, r8
-	nor	r8, r8, r9
-	cntlzw	r8, r8
-	subf	r3, r3, r10
-	srwi	r8, r8, 3
-	add	r3, r3, r8
-	blr
-
-	/* Missaligned string: make sure bytes before string are seen not 0 */
-3:	xor	r10, r10, r0
-	orc	r8, r8, r8
-	lwzu	r9, 4(r10)
-	slwi	r0, r0, 3
-	srw	r8, r8, r0
-	orc	r9, r9, r8
-	b	2b
-EXPORT_SYMBOL(strlen)
+../../../../../arch/powerpc/lib/strlen_32.S
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/powerpc/vphn/asm/vphn.h linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/vphn/asm/vphn.h
--- linux-6.16.7/tools/testing/selftests/powerpc/vphn/asm/vphn.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/vphn/asm/vphn.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,24 +1 @@
-/* SPDX-License-Identifier: GPL-2.0-or-later */
-#ifndef _ASM_POWERPC_VPHN_H
-#define _ASM_POWERPC_VPHN_H
-
-/* The H_HOME_NODE_ASSOCIATIVITY h_call returns 6 64-bit registers. */
-#define VPHN_REGISTER_COUNT 6
-
-/*
- * 6 64-bit registers unpacked into up to 24 be32 associativity values. To
- * form the complete property we have to add the length in the first cell.
- */
-#define VPHN_ASSOC_BUFSIZE (VPHN_REGISTER_COUNT*sizeof(u64)/sizeof(u16) + 1)
-
-/*
- * The H_HOME_NODE_ASSOCIATIVITY hcall takes two values for flags:
- * 1 for retrieving associativity information for a guest cpu
- * 2 for retrieving associativity information for a host/hypervisor cpu
- */
-#define VPHN_FLAG_VCPU	1
-#define VPHN_FLAG_PCPU	2
-
-long hcall_vphn(unsigned long cpu, u64 flags, __be32 *associativity);
-
-#endif // _ASM_POWERPC_VPHN_H
+../../../../../../arch/powerpc/include/asm/vphn.h
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/powerpc/vphn/vphn.c linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/vphn/vphn.c
--- linux-6.16.7/tools/testing/selftests/powerpc/vphn/vphn.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/vphn/vphn.c	2025-09-11 09:47:42.000000000 -0600
@@ -1,90 +1 @@
-// SPDX-License-Identifier: GPL-2.0
-#include <asm/byteorder.h>
-#include <asm/vphn.h>
-
-/*
- * The associativity domain numbers are returned from the hypervisor as a
- * stream of mixed 16-bit and 32-bit fields. The stream is terminated by the
- * special value of "all ones" (aka. 0xffff) and its size may not exceed 48
- * bytes.
- *
- *    --- 16-bit fields -->
- *  _________________________
- *  |  0  |  1  |  2  |  3  |   be_packed[0]
- *  ------+-----+-----+------
- *  _________________________
- *  |  4  |  5  |  6  |  7  |   be_packed[1]
- *  -------------------------
- *            ...
- *  _________________________
- *  | 20  | 21  | 22  | 23  |   be_packed[5]
- *  -------------------------
- *
- * Convert to the sequence they would appear in the ibm,associativity property.
- */
-static int vphn_unpack_associativity(const long *packed, __be32 *unpacked)
-{
-	__be64 be_packed[VPHN_REGISTER_COUNT];
-	int i, nr_assoc_doms = 0;
-	const __be16 *field = (const __be16 *) be_packed;
-	u16 last = 0;
-	bool is_32bit = false;
-
-#define VPHN_FIELD_UNUSED	(0xffff)
-#define VPHN_FIELD_MSB		(0x8000)
-#define VPHN_FIELD_MASK		(~VPHN_FIELD_MSB)
-
-	/* Let's fix the values returned by plpar_hcall9() */
-	for (i = 0; i < VPHN_REGISTER_COUNT; i++)
-		be_packed[i] = cpu_to_be64(packed[i]);
-
-	for (i = 1; i < VPHN_ASSOC_BUFSIZE; i++) {
-		u16 new = be16_to_cpup(field++);
-
-		if (is_32bit) {
-			/*
-			 * Let's concatenate the 16 bits of this field to the
-			 * 15 lower bits of the previous field
-			 */
-			unpacked[++nr_assoc_doms] =
-				cpu_to_be32(last << 16 | new);
-			is_32bit = false;
-		} else if (new == VPHN_FIELD_UNUSED)
-			/* This is the list terminator */
-			break;
-		else if (new & VPHN_FIELD_MSB) {
-			/* Data is in the lower 15 bits of this field */
-			unpacked[++nr_assoc_doms] =
-				cpu_to_be32(new & VPHN_FIELD_MASK);
-		} else {
-			/*
-			 * Data is in the lower 15 bits of this field
-			 * concatenated with the next 16 bit field
-			 */
-			last = new;
-			is_32bit = true;
-		}
-	}
-
-	/* The first cell contains the length of the property */
-	unpacked[0] = cpu_to_be32(nr_assoc_doms);
-
-	return nr_assoc_doms;
-}
-
-/* NOTE: This file is included by a selftest and built in userspace. */
-#ifdef __KERNEL__
-#include <asm/hvcall.h>
-
-long hcall_vphn(unsigned long cpu, u64 flags, __be32 *associativity)
-{
-	long rc;
-	long retbuf[PLPAR_HCALL9_BUFSIZE] = {0};
-
-	rc = plpar_hcall9(H_HOME_NODE_ASSOCIATIVITY, retbuf, flags, cpu);
-	if (rc == H_SUCCESS)
-		vphn_unpack_associativity(retbuf, associativity);
-
-	return rc;
-}
-#endif
+../../../../../arch/powerpc/platforms/pseries/vphn.c
\ No newline at end of file
diff -Nrup linux-6.16.7/arch/arm/boot/dts/allwinner/sun8i-a23-ippo-q8h-v1.2.dts linux-lenovo-x13s-linux-6.16.y/arch/arm/boot/dts/allwinner/sun8i-a23-ippo-q8h-v1.2.dts
--- linux-6.16.7/arch/arm/boot/dts/allwinner/sun8i-a23-ippo-q8h-v1.2.dts	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm/boot/dts/allwinner/sun8i-a23-ippo-q8h-v1.2.dts	2025-09-11 09:47:42.000000000 -0600
@@ -1,73 +1 @@
-/*
- * Copyright 2015 Hans de Goede <hdegoede@redhat.com>
- *
- * This file is dual-licensed: you can use it either under the terms
- * of the GPL or the X11 license, at your option. Note that this dual
- * licensing only applies to this file, and not this project as a
- * whole.
- *
- *  a) This file is free software; you can redistribute it and/or
- *     modify it under the terms of the GNU General Public License as
- *     published by the Free Software Foundation; either version 2 of the
- *     License, or (at your option) any later version.
- *
- *     This file is distributed in the hope that it will be useful,
- *     but WITHOUT ANY WARRANTY; without even the implied warranty of
- *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *     GNU General Public License for more details.
- *
- * Or, alternatively,
- *
- *  b) Permission is hereby granted, free of charge, to any person
- *     obtaining a copy of this software and associated documentation
- *     files (the "Software"), to deal in the Software without
- *     restriction, including without limitation the rights to use,
- *     copy, modify, merge, publish, distribute, sublicense, and/or
- *     sell copies of the Software, and to permit persons to whom the
- *     Software is furnished to do so, subject to the following
- *     conditions:
- *
- *     The above copyright notice and this permission notice shall be
- *     included in all copies or substantial portions of the Software.
- *
- *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
- *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
- *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- *     OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/dts-v1/;
-#include "sun8i-a23.dtsi"
-#include "sun8i-q8-common.dtsi"
-
-/ {
-	model = "Q8 A23 Tablet";
-	compatible = "allwinner,q8-a23", "allwinner,sun8i-a23";
-};
-
-&codec {
-	allwinner,pa-gpios = <&pio 7 9 GPIO_ACTIVE_HIGH>; /* PH9 */
-	allwinner,audio-routing =
-		"Headphone", "HP",
-		"Headphone", "HPCOM",
-		"Speaker", "HP",
-		"MIC1", "Mic",
-		"MIC2", "Headset Mic",
-		"Mic",  "MBIAS",
-		"Headset Mic", "HBIAS";
-	status = "okay";
-};
-
-&panel {
-	compatible = "bananapi,s070wv20-ct16";
-};
-
-&tcon0_out {
-	tcon0_out_lcd: endpoint {
-		remote-endpoint = <&panel_input>;
-	};
-};
+sun8i-a23-q8-tablet.dts
\ No newline at end of file
diff -Nrup linux-6.16.7/arch/arm/boot/dts/allwinner/sun8i-a23-ippo-q8h-v5.dts linux-lenovo-x13s-linux-6.16.y/arch/arm/boot/dts/allwinner/sun8i-a23-ippo-q8h-v5.dts
--- linux-6.16.7/arch/arm/boot/dts/allwinner/sun8i-a23-ippo-q8h-v5.dts	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm/boot/dts/allwinner/sun8i-a23-ippo-q8h-v5.dts	2025-09-11 09:47:42.000000000 -0600
@@ -1,73 +1 @@
-/*
- * Copyright 2015 Hans de Goede <hdegoede@redhat.com>
- *
- * This file is dual-licensed: you can use it either under the terms
- * of the GPL or the X11 license, at your option. Note that this dual
- * licensing only applies to this file, and not this project as a
- * whole.
- *
- *  a) This file is free software; you can redistribute it and/or
- *     modify it under the terms of the GNU General Public License as
- *     published by the Free Software Foundation; either version 2 of the
- *     License, or (at your option) any later version.
- *
- *     This file is distributed in the hope that it will be useful,
- *     but WITHOUT ANY WARRANTY; without even the implied warranty of
- *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *     GNU General Public License for more details.
- *
- * Or, alternatively,
- *
- *  b) Permission is hereby granted, free of charge, to any person
- *     obtaining a copy of this software and associated documentation
- *     files (the "Software"), to deal in the Software without
- *     restriction, including without limitation the rights to use,
- *     copy, modify, merge, publish, distribute, sublicense, and/or
- *     sell copies of the Software, and to permit persons to whom the
- *     Software is furnished to do so, subject to the following
- *     conditions:
- *
- *     The above copyright notice and this permission notice shall be
- *     included in all copies or substantial portions of the Software.
- *
- *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
- *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
- *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- *     OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/dts-v1/;
-#include "sun8i-a23.dtsi"
-#include "sun8i-q8-common.dtsi"
-
-/ {
-	model = "Q8 A23 Tablet";
-	compatible = "allwinner,q8-a23", "allwinner,sun8i-a23";
-};
-
-&codec {
-	allwinner,pa-gpios = <&pio 7 9 GPIO_ACTIVE_HIGH>; /* PH9 */
-	allwinner,audio-routing =
-		"Headphone", "HP",
-		"Headphone", "HPCOM",
-		"Speaker", "HP",
-		"MIC1", "Mic",
-		"MIC2", "Headset Mic",
-		"Mic",  "MBIAS",
-		"Headset Mic", "HBIAS";
-	status = "okay";
-};
-
-&panel {
-	compatible = "bananapi,s070wv20-ct16";
-};
-
-&tcon0_out {
-	tcon0_out_lcd: endpoint {
-		remote-endpoint = <&panel_input>;
-	};
-};
+sun8i-a23-q8-tablet.dts
\ No newline at end of file
diff -Nrup linux-6.16.7/arch/arm/boot/dts/allwinner/sun8i-a33-et-q8-v1.6.dts linux-lenovo-x13s-linux-6.16.y/arch/arm/boot/dts/allwinner/sun8i-a33-et-q8-v1.6.dts
--- linux-6.16.7/arch/arm/boot/dts/allwinner/sun8i-a33-et-q8-v1.6.dts	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm/boot/dts/allwinner/sun8i-a33-et-q8-v1.6.dts	2025-09-11 09:47:42.000000000 -0600
@@ -1,57 +1 @@
-/*
- * Copyright 2015 Hans de Goede <hdegoede@redhat.com>
- *
- * This file is dual-licensed: you can use it either under the terms
- * of the GPL or the X11 license, at your option. Note that this dual
- * licensing only applies to this file, and not this project as a
- * whole.
- *
- *  a) This file is free software; you can redistribute it and/or
- *     modify it under the terms of the GNU General Public License as
- *     published by the Free Software Foundation; either version 2 of the
- *     License, or (at your option) any later version.
- *
- *     This file is distributed in the hope that it will be useful,
- *     but WITHOUT ANY WARRANTY; without even the implied warranty of
- *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *     GNU General Public License for more details.
- *
- * Or, alternatively,
- *
- *  b) Permission is hereby granted, free of charge, to any person
- *     obtaining a copy of this software and associated documentation
- *     files (the "Software"), to deal in the Software without
- *     restriction, including without limitation the rights to use,
- *     copy, modify, merge, publish, distribute, sublicense, and/or
- *     sell copies of the Software, and to permit persons to whom the
- *     Software is furnished to do so, subject to the following
- *     conditions:
- *
- *     The above copyright notice and this permission notice shall be
- *     included in all copies or substantial portions of the Software.
- *
- *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
- *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
- *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- *     OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/dts-v1/;
-#include "sun8i-a33.dtsi"
-#include "sun8i-q8-common.dtsi"
-
-/ {
-	model = "Q8 A33 Tablet";
-	compatible = "allwinner,q8-a33", "allwinner,sun8i-a33";
-};
-
-&tcon0_out {
-	tcon0_out_lcd: endpoint@0 {
-		reg = <0>;
-		remote-endpoint = <&panel_input>;
-	};
-};
+sun8i-a33-q8-tablet.dts
\ No newline at end of file
diff -Nrup linux-6.16.7/arch/arm/boot/dts/allwinner/sun8i-a33-ippo-q8h-v1.2.dts linux-lenovo-x13s-linux-6.16.y/arch/arm/boot/dts/allwinner/sun8i-a33-ippo-q8h-v1.2.dts
--- linux-6.16.7/arch/arm/boot/dts/allwinner/sun8i-a33-ippo-q8h-v1.2.dts	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm/boot/dts/allwinner/sun8i-a33-ippo-q8h-v1.2.dts	2025-09-11 09:47:42.000000000 -0600
@@ -1,57 +1 @@
-/*
- * Copyright 2015 Hans de Goede <hdegoede@redhat.com>
- *
- * This file is dual-licensed: you can use it either under the terms
- * of the GPL or the X11 license, at your option. Note that this dual
- * licensing only applies to this file, and not this project as a
- * whole.
- *
- *  a) This file is free software; you can redistribute it and/or
- *     modify it under the terms of the GNU General Public License as
- *     published by the Free Software Foundation; either version 2 of the
- *     License, or (at your option) any later version.
- *
- *     This file is distributed in the hope that it will be useful,
- *     but WITHOUT ANY WARRANTY; without even the implied warranty of
- *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *     GNU General Public License for more details.
- *
- * Or, alternatively,
- *
- *  b) Permission is hereby granted, free of charge, to any person
- *     obtaining a copy of this software and associated documentation
- *     files (the "Software"), to deal in the Software without
- *     restriction, including without limitation the rights to use,
- *     copy, modify, merge, publish, distribute, sublicense, and/or
- *     sell copies of the Software, and to permit persons to whom the
- *     Software is furnished to do so, subject to the following
- *     conditions:
- *
- *     The above copyright notice and this permission notice shall be
- *     included in all copies or substantial portions of the Software.
- *
- *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
- *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
- *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- *     OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/dts-v1/;
-#include "sun8i-a33.dtsi"
-#include "sun8i-q8-common.dtsi"
-
-/ {
-	model = "Q8 A33 Tablet";
-	compatible = "allwinner,q8-a33", "allwinner,sun8i-a33";
-};
-
-&tcon0_out {
-	tcon0_out_lcd: endpoint@0 {
-		reg = <0>;
-		remote-endpoint = <&panel_input>;
-	};
-};
+sun8i-a33-q8-tablet.dts
\ No newline at end of file
diff -Nrup linux-6.16.7/arch/arm/configs/qcom_defconfig linux-lenovo-x13s-linux-6.16.y/arch/arm/configs/qcom_defconfig
--- linux-6.16.7/arch/arm/configs/qcom_defconfig	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm/configs/qcom_defconfig	2025-09-11 09:47:42.000000000 -0600
@@ -57,7 +57,7 @@ CONFIG_MAC80211=m
 CONFIG_RFKILL=y
 CONFIG_PCI=y
 CONFIG_PCI_MSI=y
-CONFIG_PCIE_QCOM=y
+CONFIG_PCIE_QCOM=m
 CONFIG_DEVTMPFS=y
 CONFIG_DEVTMPFS_MOUNT=y
 CONFIG_MTD=y
diff -Nrup linux-6.16.7/arch/arm64/boot/dts/qcom/sa8295p-adp.dts linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sa8295p-adp.dts
--- linux-6.16.7/arch/arm64/boot/dts/qcom/sa8295p-adp.dts	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sa8295p-adp.dts	2025-09-11 09:47:42.000000000 -0600
@@ -631,12 +631,10 @@
 };
 
 &usb_0 {
-	status = "okay";
-};
-
-&usb_0_dwc3 {
 	/* TODO: Define USB-C connector properly */
 	dr_mode = "peripheral";
+
+	status = "okay";
 };
 
 &usb_0_hsphy {
@@ -655,12 +653,10 @@
 };
 
 &usb_1 {
-	status = "okay";
-};
-
-&usb_1_dwc3 {
 	/* TODO: Define USB-C connector properly */
 	dr_mode = "host";
+
+	status = "okay";
 };
 
 &usb_1_hsphy {
diff -Nrup linux-6.16.7/arch/arm64/boot/dts/qcom/sa8540p-ride.dts linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sa8540p-ride.dts
--- linux-6.16.7/arch/arm64/boot/dts/qcom/sa8540p-ride.dts	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sa8540p-ride.dts	2025-09-11 09:47:42.000000000 -0600
@@ -462,11 +462,8 @@
 };
 
 &usb_0 {
-	status = "okay";
-};
-
-&usb_0_dwc3 {
 	dr_mode = "peripheral";
+	status = "okay";
 };
 
 &usb_0_hsphy {
diff -Nrup linux-6.16.7/arch/arm64/boot/dts/qcom/sc8280xp-crd.dts linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sc8280xp-crd.dts
--- linux-6.16.7/arch/arm64/boot/dts/qcom/sc8280xp-crd.dts	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sc8280xp-crd.dts	2025-09-11 09:47:42.000000000 -0600
@@ -815,11 +815,9 @@
 };
 
 &usb_0 {
-	status = "okay";
-};
-
-&usb_0_dwc3 {
 	dr_mode = "host";
+
+	status = "okay";
 };
 
 &usb_0_dwc3_hs {
@@ -852,11 +850,9 @@
 };
 
 &usb_1 {
-	status = "okay";
-};
-
-&usb_1_dwc3 {
 	dr_mode = "host";
+
+	status = "okay";
 };
 
 &usb_1_dwc3_hs {
diff -Nrup linux-6.16.7/arch/arm64/boot/dts/qcom/sc8280xp.dtsi linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sc8280xp.dtsi
--- linux-6.16.7/arch/arm64/boot/dts/qcom/sc8280xp.dtsi	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sc8280xp.dtsi	2025-09-11 09:47:42.000000000 -0600
@@ -10,6 +10,7 @@
 #include <dt-bindings/clock/qcom,rpmh.h>
 #include <dt-bindings/clock/qcom,sc8280xp-camcc.h>
 #include <dt-bindings/clock/qcom,sc8280xp-lpasscc.h>
+#include <dt-bindings/clock/qcom,sm8350-videocc.h>
 #include <dt-bindings/interconnect/qcom,osm-l3.h>
 #include <dt-bindings/interconnect/qcom,sc8280xp.h>
 #include <dt-bindings/interrupt-controller/arm-gic.h>
@@ -390,6 +391,15 @@
 		reg = <0x0 0x80000000 0x0 0x0>;
 	};
 
+	cci_opp_table: opp-table-cci {
+		compatible = "operating-points-v2";
+
+		opp-37500000 {
+			opp-hz = /bits/ 64 <37500000>;
+			required-opps = <&rpmhpd_opp_low_svs>;
+		};
+	};
+
 	cpu0_opp_table: opp-table-cpu0 {
 		compatible = "operating-points-v2";
 		opp-shared;
@@ -690,6 +700,11 @@
 			no-map;
 		};
 
+		pil_video_mem: pil_video_region@86700000 {
+			reg = <0 0x86700000 0 0x500000>;
+			no-map;
+		};
+
 		pil_adsp_mem: adsp-region@86c00000 {
 			reg = <0 0x86c00000 0 0x2000000>;
 			no-map;
@@ -3556,12 +3571,9 @@
 			interrupts = <GIC_SPI 582 IRQ_TYPE_LEVEL_HIGH>;
 		};
 
-		usb_2: usb@a4f8800 {
-			compatible = "qcom,sc8280xp-dwc3-mp", "qcom,dwc3";
-			reg = <0 0x0a4f8800 0 0x400>;
-			#address-cells = <2>;
-			#size-cells = <2>;
-			ranges;
+		usb_2: usb@a400000 {
+			compatible = "qcom,sc8280xp-dwc3-mp", "qcom,snps-dwc3";
+			reg = <0 0x0a400000 0 0x10000>;
 
 			clocks = <&gcc GCC_CFG_NOC_USB3_MP_AXI_CLK>,
 				 <&gcc GCC_USB30_MP_MASTER_CLK>,
@@ -3579,7 +3591,8 @@
 					  <&gcc GCC_USB30_MP_MASTER_CLK>;
 			assigned-clock-rates = <19200000>, <200000000>;
 
-			interrupts-extended = <&intc GIC_SPI 130 IRQ_TYPE_LEVEL_HIGH>,
+			interrupts-extended = <&intc GIC_SPI 133 IRQ_TYPE_LEVEL_HIGH>,
+					      <&intc GIC_SPI 130 IRQ_TYPE_LEVEL_HIGH>,
 					      <&intc GIC_SPI 135 IRQ_TYPE_LEVEL_HIGH>,
 					      <&intc GIC_SPI 857 IRQ_TYPE_LEVEL_HIGH>,
 					      <&intc GIC_SPI 856 IRQ_TYPE_LEVEL_HIGH>,
@@ -3598,7 +3611,8 @@
 					      <&pdc 16 IRQ_TYPE_LEVEL_HIGH>,
 					      <&pdc 17 IRQ_TYPE_LEVEL_HIGH>;
 
-			interrupt-names = "pwr_event_1", "pwr_event_2",
+			interrupt-names = "dwc_usb3",
+					  "pwr_event_1", "pwr_event_2",
 					  "pwr_event_3", "pwr_event_4",
 					  "hs_phy_1",	 "hs_phy_2",
 					  "hs_phy_3",	 "hs_phy_4",
@@ -3608,6 +3622,7 @@
 					  "dp_hs_phy_4", "dm_hs_phy_4",
 					  "ss_phy_1",	 "ss_phy_2";
 
+			iommus = <&apps_smmu 0x800 0x0>;
 			power-domains = <&gcc USB30_MP_GDSC>;
 			required-opps = <&rpmhpd_opp_nom>;
 
@@ -3617,35 +3632,28 @@
 					<&gem_noc MASTER_APPSS_PROC 0 &config_noc SLAVE_USB3_MP 0>;
 			interconnect-names = "usb-ddr", "apps-usb";
 
+			phys = <&usb_2_hsphy0>, <&usb_2_qmpphy0>,
+			       <&usb_2_hsphy1>, <&usb_2_qmpphy1>,
+			       <&usb_2_hsphy2>,
+			       <&usb_2_hsphy3>;
+			phy-names = "usb2-0", "usb3-0",
+				    "usb2-1", "usb3-1",
+				    "usb2-2",
+				    "usb2-3";
+
 			wakeup-source;
 
-			status = "disabled";
+			dr_mode = "host";
 
-			usb_2_dwc3: usb@a400000 {
-				compatible = "snps,dwc3";
-				reg = <0 0x0a400000 0 0xcd00>;
-				interrupts = <GIC_SPI 133 IRQ_TYPE_LEVEL_HIGH>;
-				iommus = <&apps_smmu 0x800 0x0>;
-				phys = <&usb_2_hsphy0>, <&usb_2_qmpphy0>,
-				       <&usb_2_hsphy1>, <&usb_2_qmpphy1>,
-				       <&usb_2_hsphy2>,
-				       <&usb_2_hsphy3>;
-				phy-names = "usb2-0", "usb3-0",
-					    "usb2-1", "usb3-1",
-					    "usb2-2",
-					    "usb2-3";
-				dr_mode = "host";
-				snps,dis-u1-entry-quirk;
-				snps,dis-u2-entry-quirk;
-			};
+			snps,dis-u1-entry-quirk;
+			snps,dis-u2-entry-quirk;
+
+			status = "disabled";
 		};
 
-		usb_0: usb@a6f8800 {
-			compatible = "qcom,sc8280xp-dwc3", "qcom,dwc3";
-			reg = <0 0x0a6f8800 0 0x400>;
-			#address-cells = <2>;
-			#size-cells = <2>;
-			ranges;
+		usb_0: usb@a600000 {
+			compatible = "qcom,sc8280xp-dwc3", "qcom,snps-dwc3";
+			reg = <0 0x0a600000 0 0x10000>;
 
 			clocks = <&gcc GCC_CFG_NOC_USB3_PRIM_AXI_CLK>,
 				 <&gcc GCC_USB30_PRIM_MASTER_CLK>,
@@ -3663,17 +3671,20 @@
 					  <&gcc GCC_USB30_PRIM_MASTER_CLK>;
 			assigned-clock-rates = <19200000>, <200000000>;
 
-			interrupts-extended = <&intc GIC_SPI 804 IRQ_TYPE_LEVEL_HIGH>,
+			interrupts-extended = <&intc GIC_SPI 803 IRQ_TYPE_LEVEL_HIGH>,
+					      <&intc GIC_SPI 804 IRQ_TYPE_LEVEL_HIGH>,
 					      <&intc GIC_SPI 805 IRQ_TYPE_LEVEL_HIGH>,
 					      <&pdc 14 IRQ_TYPE_EDGE_BOTH>,
 					      <&pdc 15 IRQ_TYPE_EDGE_BOTH>,
 					      <&pdc 138 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "pwr_event",
+			interrupt-names = "dwc_usb3",
+					  "pwr_event",
 					  "hs_phy_irq",
 					  "dp_hs_phy_irq",
 					  "dm_hs_phy_irq",
 					  "ss_phy_irq";
 
+			iommus = <&apps_smmu 0x820 0x0>;
 			power-domains = <&gcc USB30_PRIM_GDSC>;
 			required-opps = <&rpmhpd_opp_nom>;
 
@@ -3683,45 +3694,40 @@
 					<&gem_noc MASTER_APPSS_PROC 0 &config_noc SLAVE_USB3_0 0>;
 			interconnect-names = "usb-ddr", "apps-usb";
 
+			phys = <&usb_0_hsphy>, <&usb_0_qmpphy QMP_USB43DP_USB3_PHY>;
+			phy-names = "usb2-phy", "usb3-phy";
+
 			wakeup-source;
 
-			status = "disabled";
+			snps,dis-u1-entry-quirk;
+			snps,dis-u2-entry-quirk;
 
-			usb_0_dwc3: usb@a600000 {
-				compatible = "snps,dwc3";
-				reg = <0 0x0a600000 0 0xcd00>;
-				interrupts = <GIC_SPI 803 IRQ_TYPE_LEVEL_HIGH>;
-				iommus = <&apps_smmu 0x820 0x0>;
-				phys = <&usb_0_hsphy>, <&usb_0_qmpphy QMP_USB43DP_USB3_PHY>;
-				phy-names = "usb2-phy", "usb3-phy";
-				snps,dis-u1-entry-quirk;
-				snps,dis-u2-entry-quirk;
+			status = "disabled";
 
-				ports {
-					#address-cells = <1>;
-					#size-cells = <0>;
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
 
-					port@0 {
-						reg = <0>;
+				port@0 {
+					reg = <0>;
 
-						usb_0_dwc3_hs: endpoint {
-						};
+					usb_0_dwc3_hs: endpoint {
 					};
+				};
 
-					port@1 {
-						reg = <1>;
+				port@1 {
+					reg = <1>;
 
-						usb_0_dwc3_ss: endpoint {
-							remote-endpoint = <&usb_0_qmpphy_usb_ss_in>;
-						};
+					usb_0_dwc3_ss: endpoint {
+						remote-endpoint = <&usb_0_qmpphy_usb_ss_in>;
 					};
 				};
 			};
 		};
 
-		usb_1: usb@a8f8800 {
-			compatible = "qcom,sc8280xp-dwc3", "qcom,dwc3";
-			reg = <0 0x0a8f8800 0 0x400>;
+		usb_1: usb@a800000 {
+			compatible = "qcom,sc8280xp-dwc3", "qcom,snps-dwc3";
+			reg = <0 0x0a800000 0 0x10000>;
 			#address-cells = <2>;
 			#size-cells = <2>;
 			ranges;
@@ -3742,17 +3748,20 @@
 					  <&gcc GCC_USB30_SEC_MASTER_CLK>;
 			assigned-clock-rates = <19200000>, <200000000>;
 
-			interrupts-extended = <&intc GIC_SPI 811 IRQ_TYPE_LEVEL_HIGH>,
+			interrupts-extended = <&intc GIC_SPI 810 IRQ_TYPE_LEVEL_HIGH>,
+					      <&intc GIC_SPI 811 IRQ_TYPE_LEVEL_HIGH>,
 					      <&intc GIC_SPI 790 IRQ_TYPE_LEVEL_HIGH>,
 					      <&pdc 12 IRQ_TYPE_EDGE_BOTH>,
 					      <&pdc 13 IRQ_TYPE_EDGE_BOTH>,
 					      <&pdc 136 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "pwr_event",
+			interrupt-names = "dwc_usb3",
+					  "pwr_event",
 					  "hs_phy_irq",
 					  "dp_hs_phy_irq",
 					  "dm_hs_phy_irq",
 					  "ss_phy_irq";
 
+			iommus = <&apps_smmu 0x860 0x0>;
 			power-domains = <&gcc USB30_SEC_GDSC>;
 			required-opps = <&rpmhpd_opp_nom>;
 
@@ -3762,42 +3771,109 @@
 					<&gem_noc MASTER_APPSS_PROC 0 &config_noc SLAVE_USB3_1 0>;
 			interconnect-names = "usb-ddr", "apps-usb";
 
+			phys = <&usb_1_hsphy>, <&usb_1_qmpphy QMP_USB43DP_USB3_PHY>;
+			phy-names = "usb2-phy", "usb3-phy";
+
 			wakeup-source;
 
-			status = "disabled";
+			snps,dis-u1-entry-quirk;
+			snps,dis-u2-entry-quirk;
 
-			usb_1_dwc3: usb@a800000 {
-				compatible = "snps,dwc3";
-				reg = <0 0x0a800000 0 0xcd00>;
-				interrupts = <GIC_SPI 810 IRQ_TYPE_LEVEL_HIGH>;
-				iommus = <&apps_smmu 0x860 0x0>;
-				phys = <&usb_1_hsphy>, <&usb_1_qmpphy QMP_USB43DP_USB3_PHY>;
-				phy-names = "usb2-phy", "usb3-phy";
-				snps,dis-u1-entry-quirk;
-				snps,dis-u2-entry-quirk;
+			status = "disabled";
 
-				ports {
-					#address-cells = <1>;
-					#size-cells = <0>;
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
 
-					port@0 {
-						reg = <0>;
+				port@0 {
+					reg = <0>;
 
-						usb_1_dwc3_hs: endpoint {
-						};
+					usb_1_dwc3_hs: endpoint {
 					};
+				};
 
-					port@1 {
-						reg = <1>;
+				port@1 {
+					reg = <1>;
 
-						usb_1_dwc3_ss: endpoint {
-							remote-endpoint = <&usb_1_qmpphy_usb_ss_in>;
-						};
+					usb_1_dwc3_ss: endpoint {
+						remote-endpoint = <&usb_1_qmpphy_usb_ss_in>;
 					};
 				};
 			};
 		};
 
+		venus: video-codec@aa00000 {
+			compatible = "qcom,sm8350-venus";
+			reg = <0 0x0aa00000 0 0x100000>;
+			interrupts = <GIC_SPI 174 IRQ_TYPE_LEVEL_HIGH>;
+
+			clocks = <&gcc GCC_VIDEO_AXI0_CLK>,
+				 <&videocc VIDEO_CC_MVS0C_CLK>,
+				 <&videocc VIDEO_CC_MVS0_CLK>;
+			clock-names = "iface",
+				      "core",
+				      "vcodec0_core";
+			power-domains = <&videocc MVS0C_GDSC>,
+					<&videocc MVS0_GDSC>,
+					<&rpmhpd SC8280XP_MX>;
+			power-domain-names = "venus",
+					     "vcodec0",
+					     "mx";
+
+			resets = <&gcc GCC_VIDEO_AXI0_CLK_ARES>;
+			reset-names = "core";
+
+			interconnects = <&gem_noc MASTER_APPSS_PROC 0 &config_noc SLAVE_VENUS_CFG 0>,
+					<&mmss_noc MASTER_VIDEO_P0 0 &mc_virt SLAVE_EBI1 0>,
+					<&mmss_noc MASTER_VIDEO_P0 0 &gem_noc SLAVE_LLCC 0>;
+			interconnect-names = "cpu-cfg",
+					     "video-mem",
+					     "video-llcc";
+
+			operating-points-v2 = <&venus_opp_table>;
+			iommus = <&apps_smmu 0x2e00 0x400>;
+			memory-region = <&pil_video_mem>;
+
+			status = "disabled";
+
+			venus_opp_table: opp-table {
+				compatible = "operating-points-v2";
+
+				opp-720000000 {
+					opp-hz = /bits/ 64 <720000000>;
+					required-opps = <&rpmhpd_opp_low_svs>;
+				};
+
+				opp-1014000000 {
+					opp-hz = /bits/ 64 <1014000000>;
+					required-opps = <&rpmhpd_opp_svs>;
+				};
+
+				opp-1098000000 {
+					opp-hz = /bits/ 64 <1098000000>;
+					required-opps = <&rpmhpd_opp_svs_l1>;
+				};
+
+				opp-1332000000 {
+					opp-hz = /bits/ 64 <1332000000>;
+					required-opps = <&rpmhpd_opp_nom>;
+				};
+			};
+		};
+
+		videocc: clock-controller@abf0000 {
+			compatible = "qcom,sc8280xp-videocc";
+			reg = <0 0x0abf0000 0 0x10000>;
+			clocks = <&rpmhcc RPMH_CXO_CLK>,
+				 <&rpmhcc RPMH_CXO_CLK_A>,
+				 <&sleep_clk>;
+			power-domains = <&rpmhpd SC8280XP_MMCX>;
+			required-opps = <&rpmhpd_opp_low_svs>;
+			#clock-cells = <1>;
+			#reset-cells = <1>;
+			#power-domain-cells = <1>;
+		};
+
 		cci0: cci@ac4a000 {
 			compatible = "qcom,sc8280xp-cci", "qcom,msm8996-cci";
 			reg = <0 0x0ac4a000 0 0x1000>;
@@ -3813,6 +3889,7 @@
 				      "cpas_ahb",
 				      "cci";
 
+			operating-points-v2 = <&cci_opp_table>;
 			power-domains = <&camcc TITAN_TOP_GDSC>;
 
 			pinctrl-0 = <&cci0_default>;
@@ -3854,6 +3931,7 @@
 				      "cpas_ahb",
 				      "cci";
 
+			operating-points-v2 = <&cci_opp_table>;
 			power-domains = <&camcc TITAN_TOP_GDSC>;
 
 			pinctrl-0 = <&cci1_default>;
@@ -3894,6 +3972,8 @@
 				      "slow_ahb_src",
 				      "cpas_ahb",
 				      "cci";
+
+			operating-points-v2 = <&cci_opp_table>;
 			power-domains = <&camcc TITAN_TOP_GDSC>;
 
 			pinctrl-0 = <&cci2_default>;
@@ -3924,7 +4004,7 @@
 			compatible = "qcom,sc8280xp-cci", "qcom,msm8996-cci";
 			reg = <0 0x0ac4d000 0 0x1000>;
 
-			interrupts = <GIC_SPI 650 IRQ_TYPE_EDGE_RISING>;
+			interrupts = <GIC_SPI 771 IRQ_TYPE_EDGE_RISING>;
 
 			clocks = <&camcc CAMCC_CAMNOC_AXI_CLK>,
 				 <&camcc CAMCC_SLOW_AHB_CLK_SRC>,
@@ -3935,6 +4015,7 @@
 				      "cpas_ahb",
 				      "cci";
 
+			operating-points-v2 = <&cci_opp_table>;
 			power-domains = <&camcc TITAN_TOP_GDSC>;
 
 			pinctrl-0 = <&cci3_default>;
diff -Nrup linux-6.16.7/arch/arm64/boot/dts/qcom/sc8280xp-huawei-gaokun3.dts linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sc8280xp-huawei-gaokun3.dts
--- linux-6.16.7/arch/arm64/boot/dts/qcom/sc8280xp-huawei-gaokun3.dts	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sc8280xp-huawei-gaokun3.dts	2025-09-11 09:47:42.000000000 -0600
@@ -1123,11 +1123,8 @@
 };
 
 &usb_0 {
-	status = "okay";
-};
-
-&usb_0_dwc3 {
 	dr_mode = "host";
+	status = "okay";
 };
 
 &usb_0_dwc3_hs {
@@ -1160,11 +1157,8 @@
 };
 
 &usb_1 {
-	status = "okay";
-};
-
-&usb_1_dwc3 {
 	dr_mode = "host";
+	status = "okay";
 };
 
 &usb_1_dwc3_hs {
diff -Nrup linux-6.16.7/arch/arm64/boot/dts/qcom/sc8280xp-lenovo-thinkpad-x13s.dts linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sc8280xp-lenovo-thinkpad-x13s.dts
--- linux-6.16.7/arch/arm64/boot/dts/qcom/sc8280xp-lenovo-thinkpad-x13s.dts	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sc8280xp-lenovo-thinkpad-x13s.dts	2025-09-11 09:47:42.000000000 -0600
@@ -83,14 +83,11 @@
 		pinctrl-names = "default";
 		pinctrl-0 = <&cam_indicator_en>;
 
-		led-camera-indicator {
-			label = "white:camera-indicator";
+		privacy_led: privacy-led {
 			function = LED_FUNCTION_INDICATOR;
 			color = <LED_COLOR_ID_WHITE>;
 			gpios = <&tlmm 28 GPIO_ACTIVE_HIGH>;
-			linux,default-trigger = "none";
 			default-state = "off";
-			/* Reuse as a panic indicator until we get a "camera on" trigger */
 			panic-indicator;
 		};
 	};
@@ -685,6 +682,9 @@
 		pinctrl-names = "default";
 		pinctrl-0 = <&cam_rgb_default>;
 
+		leds = <&privacy_led>;
+		led-names = "privacy";
+
 		clocks = <&camcc CAMCC_MCLK3_CLK>;
 
 		orientation = <0>;	/* Front facing */
@@ -726,7 +726,7 @@
 };
 
 &mdss0_dp0_out {
-	data-lanes = <0 1>;
+	data-lanes = <0 1 2 3>;
 	remote-endpoint = <&usb_0_qmpphy_dp_in>;
 };
 
@@ -735,7 +735,7 @@
 };
 
 &mdss0_dp1_out {
-	data-lanes = <0 1>;
+	data-lanes = <0 1 2 3>;
 	remote-endpoint = <&usb_1_qmpphy_dp_in>;
 };
 
@@ -1337,11 +1337,9 @@
 };
 
 &usb_0 {
-	status = "okay";
-};
-
-&usb_0_dwc3 {
 	dr_mode = "host";
+
+	status = "okay";
 };
 
 &usb_0_dwc3_hs {
@@ -1360,6 +1358,7 @@
 	vdda-phy-supply = <&vreg_l9d>;
 	vdda-pll-supply = <&vreg_l4d>;
 
+	mode-switch;
 	orientation-switch;
 
 	status = "okay";
@@ -1374,11 +1373,8 @@
 };
 
 &usb_1 {
-	status = "okay";
-};
-
-&usb_1_dwc3 {
 	dr_mode = "host";
+	status = "okay";
 };
 
 &usb_1_dwc3_hs {
@@ -1397,6 +1393,7 @@
 	vdda-phy-supply = <&vreg_l4b>;
 	vdda-pll-supply = <&vreg_l3b>;
 
+	mode-switch;
 	orientation-switch;
 
 	status = "okay";
@@ -1471,6 +1468,11 @@
 	status = "okay";
 };
 
+&venus {
+	firmware-name = "qcom/sc8280xp/LENOVO/21BX/qcvss8280.mbn";
+	status = "okay";
+};
+
 &wsamacro {
 	status = "okay";
 };
diff -Nrup linux-6.16.7/arch/arm64/boot/dts/qcom/sc8280xp-microsoft-arcata.dts linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sc8280xp-microsoft-arcata.dts
--- linux-6.16.7/arch/arm64/boot/dts/qcom/sc8280xp-microsoft-arcata.dts	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sc8280xp-microsoft-arcata.dts	2025-09-11 09:47:42.000000000 -0600
@@ -749,11 +749,8 @@
 };
 
 &usb_0 {
-	status = "okay";
-};
-
-&usb_0_dwc3 {
 	dr_mode = "host";
+	status = "okay";
 };
 
 &usb_0_dwc3_hs {
@@ -786,11 +783,8 @@
 };
 
 &usb_1 {
-	status = "okay";
-};
-
-&usb_1_dwc3 {
 	dr_mode = "host";
+	status = "okay";
 };
 
 &usb_1_dwc3_hs {
diff -Nrup linux-6.16.7/arch/arm64/boot/dts/qcom/sc8280xp-microsoft-blackrock.dts linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sc8280xp-microsoft-blackrock.dts
--- linux-6.16.7/arch/arm64/boot/dts/qcom/sc8280xp-microsoft-blackrock.dts	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sc8280xp-microsoft-blackrock.dts	2025-09-11 09:47:42.000000000 -0600
@@ -982,11 +982,9 @@
 };
 
 &usb_0 {
-	status = "okay";
-};
-
-&usb_0_dwc3 {
 	dr_mode = "host";
+
+	status = "okay";
 };
 
 &usb_0_dwc3_hs {
@@ -1019,11 +1017,9 @@
 };
 
 &usb_1 {
-	status = "okay";
-};
-
-&usb_1_dwc3 {
 	dr_mode = "host";
+
+	status = "okay";
 };
 
 &usb_1_dwc3_hs {
@@ -1059,12 +1055,10 @@
 	pinctrl-0 = <&usb2_en_state>;
 	pinctrl-names = "default";
 
-	status = "okay";
-};
-
-&usb_2_dwc3 {
 	phys = <&usb_2_hsphy0>, <&usb_2_qmpphy0>;
 	phy-names = "usb2-0", "usb3-0";
+
+	status = "okay";
 };
 
 &usb_2_hsphy0 {
diff -Nrup linux-6.16.7/arch/arm64/boot/dts/qcom/x1-crd.dtsi linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/x1-crd.dtsi
--- linux-6.16.7/arch/arm64/boot/dts/qcom/x1-crd.dtsi	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/x1-crd.dtsi	2025-09-11 09:47:42.000000000 -0600
@@ -17,6 +17,7 @@
 
 	aliases {
 		serial0 = &uart21;
+		serial1 = &uart14;
 	};
 
 	wcd938x: audio-codec {
@@ -491,6 +492,48 @@
 		regulator-boot-on;
 	};
 
+	vreg_wcn_3p3: regulator-wcn-3p3 {
+		compatible = "regulator-fixed";
+
+		regulator-name = "VREG_WCN_3P3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+
+		gpio = <&tlmm 214 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		pinctrl-0 = <&wcn_sw_en>;
+		pinctrl-names = "default";
+
+		regulator-boot-on;
+	};
+
+	/*
+	 * TODO: These two regulators are actually part of the removable M.2
+	 * card and not the CRD mainboard. Need to describe this differently.
+	 * Functionally it works correctly, because all we need to do is to
+	 * turn on the actual 3.3V supply above.
+	 */
+	vreg_wcn_0p95: regulator-wcn-0p95 {
+		compatible = "regulator-fixed";
+
+		regulator-name = "VREG_WCN_0P95";
+		regulator-min-microvolt = <950000>;
+		regulator-max-microvolt = <950000>;
+
+		vin-supply = <&vreg_wcn_3p3>;
+	};
+
+	vreg_wcn_1p9: regulator-wcn-1p9 {
+		compatible = "regulator-fixed";
+
+		regulator-name = "VREG_WCN_1P9";
+		regulator-min-microvolt = <1900000>;
+		regulator-max-microvolt = <1900000>;
+
+		vin-supply = <&vreg_wcn_3p3>;
+	};
+
 	vreg_wwan: regulator-wwan {
 		compatible = "regulator-fixed";
 
@@ -506,6 +549,65 @@
 
 		regulator-boot-on;
 	};
+
+	wcn7850-pmu {
+		compatible = "qcom,wcn7850-pmu";
+
+		vdd-supply = <&vreg_wcn_0p95>;
+		vddio-supply = <&vreg_l15b_1p8>;
+		vddaon-supply = <&vreg_wcn_0p95>;
+		vdddig-supply = <&vreg_wcn_0p95>;
+		vddrfa1p2-supply = <&vreg_wcn_1p9>;
+		vddrfa1p8-supply = <&vreg_wcn_1p9>;
+
+		wlan-enable-gpios = <&tlmm 117 GPIO_ACTIVE_HIGH>;
+		bt-enable-gpios = <&tlmm 116 GPIO_ACTIVE_HIGH>;
+
+		pinctrl-0 = <&wcn_wlan_bt_en>;
+		pinctrl-names = "default";
+
+		regulators {
+			vreg_pmu_rfa_cmn: ldo0 {
+				regulator-name = "vreg_pmu_rfa_cmn";
+			};
+
+			vreg_pmu_aon_0p59: ldo1 {
+				regulator-name = "vreg_pmu_aon_0p59";
+			};
+
+			vreg_pmu_wlcx_0p8: ldo2 {
+				regulator-name = "vreg_pmu_wlcx_0p8";
+			};
+
+			vreg_pmu_wlmx_0p85: ldo3 {
+				regulator-name = "vreg_pmu_wlmx_0p85";
+			};
+
+			vreg_pmu_btcmx_0p85: ldo4 {
+				regulator-name = "vreg_pmu_btcmx_0p85";
+			};
+
+			vreg_pmu_rfa_0p8: ldo5 {
+				regulator-name = "vreg_pmu_rfa_0p8";
+			};
+
+			vreg_pmu_rfa_1p2: ldo6 {
+				regulator-name = "vreg_pmu_rfa_1p2";
+			};
+
+			vreg_pmu_rfa_1p8: ldo7 {
+				regulator-name = "vreg_pmu_rfa_1p8";
+			};
+
+			vreg_pmu_pcie_0p9: ldo8 {
+				regulator-name = "vreg_pmu_pcie_0p9";
+			};
+
+			vreg_pmu_pcie_1p8: ldo9 {
+				regulator-name = "vreg_pmu_pcie_1p8";
+			};
+		};
+	};
 };
 
 &apps_rsc {
@@ -1016,6 +1118,27 @@
 	};
 };
 
+&i2c5 {
+	clock-frequency = <400000>;
+
+	status = "okay";
+
+	eusb6_repeater: redriver@4f {
+		compatible = "nxp,ptn3222";
+		reg = <0x4f>;
+
+		vdd1v8-supply = <&vreg_l4b_1p8>;
+		vdd3v3-supply = <&vreg_l13b_3p0>;
+
+		reset-gpios = <&tlmm 184 GPIO_ACTIVE_LOW>;
+
+		pinctrl-0 = <&eusb6_reset_n>;
+		pinctrl-names = "default";
+
+		#phy-cells = <0>;
+	};
+};
+
 &i2c7 {
 	clock-frequency = <400000>;
 
@@ -1206,6 +1329,23 @@
 	status = "okay";
 };
 
+&pcie4_port0 {
+	wifi@0 {
+		compatible = "pci17cb,1107";
+		reg = <0x10000 0x0 0x0 0x0 0x0>;
+
+		vddaon-supply = <&vreg_pmu_aon_0p59>;
+		vddwlcx-supply = <&vreg_pmu_wlcx_0p8>;
+		vddwlmx-supply = <&vreg_pmu_wlmx_0p85>;
+		vddrfacmn-supply = <&vreg_pmu_rfa_cmn>;
+		vddrfa0p8-supply = <&vreg_pmu_rfa_0p8>;
+		vddrfa1p2-supply = <&vreg_pmu_rfa_1p2>;
+		vddrfa1p8-supply = <&vreg_pmu_rfa_1p8>;
+		vddpcie0p9-supply = <&vreg_pmu_pcie_0p9>;
+		vddpcie1p8-supply = <&vreg_pmu_pcie_1p8>;
+	};
+};
+
 &pcie5 {
 	perst-gpios = <&tlmm 149 GPIO_ACTIVE_LOW>;
 	wake-gpios = <&tlmm 151 GPIO_ACTIVE_LOW>;
@@ -1466,6 +1606,14 @@
 		bias-disable;
 	};
 
+	eusb6_reset_n: eusb6-reset-n-state {
+		pins = "gpio184";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+		output-low;
+	};
+
 	hall_int_n_default: hall-int-n-state {
 		pins = "gpio92";
 		function = "gpio";
@@ -1639,6 +1787,20 @@
 		output-low;
 	};
 
+	wcn_sw_en: wcn-sw-en-state {
+		pins = "gpio214";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	wcn_wlan_bt_en: wcn-wlan-bt-en-state {
+		pins = "gpio116", "gpio117";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
 	wwan_sw_en: wwan-sw-en-state {
 		pins = "gpio221";
 		function = "gpio";
@@ -1647,6 +1809,23 @@
 	};
 };
 
+&uart14 {
+	status = "okay";
+
+	bluetooth {
+		compatible = "qcom,wcn7850-bt";
+		max-speed = <3200000>;
+
+		vddaon-supply = <&vreg_pmu_aon_0p59>;
+		vddwlcx-supply = <&vreg_pmu_wlcx_0p8>;
+		vddwlmx-supply = <&vreg_pmu_wlmx_0p85>;
+		vddrfacmn-supply = <&vreg_pmu_rfa_cmn>;
+		vddrfa0p8-supply = <&vreg_pmu_rfa_0p8>;
+		vddrfa1p2-supply = <&vreg_pmu_rfa_1p2>;
+		vddrfa1p8-supply = <&vreg_pmu_rfa_1p8>;
+	};
+};
+
 &uart21 {
 	compatible = "qcom,geni-debug-uart";
 	status = "okay";
@@ -1747,3 +1926,38 @@
 &usb_1_ss2_qmpphy_out {
 	remote-endpoint = <&retimer_ss2_ss_in>;
 };
+
+&usb_mp {
+	/* Only second port is used with USB 2.0 maximum speed */
+	status = "okay";
+};
+
+&usb_mp_hsphy0 {
+	vdd-supply = <&vreg_l2e_0p8>;
+	vdda12-supply = <&vreg_l3e_1p2>;
+
+	status = "okay";
+};
+
+&usb_mp_hsphy1 {
+	vdd-supply = <&vreg_l2e_0p8>;
+	vdda12-supply = <&vreg_l3e_1p2>;
+
+	phys = <&eusb6_repeater>;
+
+	status = "okay";
+};
+
+&usb_mp_qmpphy0 {
+	vdda-phy-supply = <&vreg_l3e_1p2>;
+	vdda-pll-supply = <&vreg_l3c_0p8>;
+
+	status = "okay";
+};
+
+&usb_mp_qmpphy1 {
+	vdda-phy-supply = <&vreg_l3e_1p2>;
+	vdda-pll-supply = <&vreg_l3c_0p8>;
+
+	status = "okay";
+};
diff -Nrup linux-6.16.7/arch/arm64/boot/dts/qcom/x1e78100-lenovo-thinkpad-t14s.dtsi linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/x1e78100-lenovo-thinkpad-t14s.dtsi
--- linux-6.16.7/arch/arm64/boot/dts/qcom/x1e78100-lenovo-thinkpad-t14s.dtsi	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/x1e78100-lenovo-thinkpad-t14s.dtsi	2025-09-11 09:47:42.000000000 -0600
@@ -20,6 +20,10 @@
 	compatible = "lenovo,thinkpad-t14s", "qcom,x1e78100", "qcom,x1e80100";
 	chassis-type = "laptop";
 
+	aliases {
+		serial1 = &uart14;
+	};
+
 	wcd938x: audio-codec {
 		compatible = "qcom,wcd9385-codec";
 
@@ -321,6 +325,48 @@
 		regulator-boot-on;
 	};
 
+	vreg_wcn_3p3: regulator-wcn-3p3 {
+		compatible = "regulator-fixed";
+
+		regulator-name = "VREG_WCN_3P3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+
+		gpio = <&tlmm 214 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		pinctrl-0 = <&wcn_sw_en>;
+		pinctrl-names = "default";
+
+		regulator-boot-on;
+	};
+
+	/*
+	 * TODO: These two regulators are actually part of the removable M.2
+	 * card and not the CRD mainboard. Need to describe this differently.
+	 * Functionally it works correctly, because all we need to do is to
+	 * turn on the actual 3.3V supply above.
+	 */
+	vreg_wcn_0p95: regulator-wcn-0p95 {
+		compatible = "regulator-fixed";
+
+		regulator-name = "VREG_WCN_0P95";
+		regulator-min-microvolt = <950000>;
+		regulator-max-microvolt = <950000>;
+
+		vin-supply = <&vreg_wcn_3p3>;
+	};
+
+	vreg_wcn_1p9: regulator-wcn-1p9 {
+		compatible = "regulator-fixed";
+
+		regulator-name = "VREG_WCN_1P9";
+		regulator-min-microvolt = <1900000>;
+		regulator-max-microvolt = <1900000>;
+
+		vin-supply = <&vreg_wcn_3p3>;
+	};
+
 	vreg_wwan: regulator-wwan {
 		compatible = "regulator-fixed";
 
@@ -415,6 +461,65 @@
 			};
 		};
 	};
+
+	wcn7850-pmu {
+		compatible = "qcom,wcn7850-pmu";
+
+		vdd-supply = <&vreg_wcn_0p95>;
+		vddio-supply = <&vreg_l15b_1p8>;
+		vddaon-supply = <&vreg_wcn_0p95>;
+		vdddig-supply = <&vreg_wcn_0p95>;
+		vddrfa1p2-supply = <&vreg_wcn_1p9>;
+		vddrfa1p8-supply = <&vreg_wcn_1p9>;
+
+		wlan-enable-gpios = <&tlmm 117 GPIO_ACTIVE_HIGH>;
+		bt-enable-gpios = <&tlmm 116 GPIO_ACTIVE_HIGH>;
+
+		pinctrl-0 = <&wcn_wlan_bt_en>;
+		pinctrl-names = "default";
+
+		regulators {
+			vreg_pmu_rfa_cmn: ldo0 {
+				regulator-name = "vreg_pmu_rfa_cmn";
+			};
+
+			vreg_pmu_aon_0p59: ldo1 {
+				regulator-name = "vreg_pmu_aon_0p59";
+			};
+
+			vreg_pmu_wlcx_0p8: ldo2 {
+				regulator-name = "vreg_pmu_wlcx_0p8";
+			};
+
+			vreg_pmu_wlmx_0p85: ldo3 {
+				regulator-name = "vreg_pmu_wlmx_0p85";
+			};
+
+			vreg_pmu_btcmx_0p85: ldo4 {
+				regulator-name = "vreg_pmu_btcmx_0p85";
+			};
+
+			vreg_pmu_rfa_0p8: ldo5 {
+				regulator-name = "vreg_pmu_rfa_0p8";
+			};
+
+			vreg_pmu_rfa_1p2: ldo6 {
+				regulator-name = "vreg_pmu_rfa_1p2";
+			};
+
+			vreg_pmu_rfa_1p8: ldo7 {
+				regulator-name = "vreg_pmu_rfa_1p8";
+			};
+
+			vreg_pmu_pcie_0p9: ldo8 {
+				regulator-name = "vreg_pmu_pcie_0p9";
+			};
+
+			vreg_pmu_pcie_1p8: ldo9 {
+				regulator-name = "vreg_pmu_pcie_1p8";
+			};
+		};
+	};
 };
 
 &apps_rsc {
@@ -1061,6 +1166,23 @@
 	status = "okay";
 };
 
+&pcie4_port0 {
+	wifi@0 {
+		compatible = "pci17cb,1107";
+		reg = <0x10000 0x0 0x0 0x0 0x0>;
+
+		vddaon-supply = <&vreg_pmu_aon_0p59>;
+		vddwlcx-supply = <&vreg_pmu_wlcx_0p8>;
+		vddwlmx-supply = <&vreg_pmu_wlmx_0p85>;
+		vddrfacmn-supply = <&vreg_pmu_rfa_cmn>;
+		vddrfa0p8-supply = <&vreg_pmu_rfa_0p8>;
+		vddrfa1p2-supply = <&vreg_pmu_rfa_1p2>;
+		vddrfa1p8-supply = <&vreg_pmu_rfa_1p8>;
+		vddpcie0p9-supply = <&vreg_pmu_pcie_0p9>;
+		vddpcie1p8-supply = <&vreg_pmu_pcie_1p8>;
+	};
+};
+
 &pcie5 {
 	perst-gpios = <&tlmm 149 GPIO_ACTIVE_LOW>;
 	wake-gpios = <&tlmm 151 GPIO_ACTIVE_LOW>;
@@ -1450,6 +1572,20 @@
 		output-low;
 	};
 
+	wcn_sw_en: wcn-sw-en-state {
+		pins = "gpio214";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	wcn_wlan_bt_en: wcn-wlan-bt-en-state {
+		pins = "gpio116", "gpio117";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
 	wwan_sw_en: wwan-sw-en-state {
 		pins = "gpio221";
 		function = "gpio";
@@ -1458,6 +1594,23 @@
 	};
 };
 
+&uart14 {
+	status = "okay";
+
+	bluetooth {
+		compatible = "qcom,wcn7850-bt";
+		max-speed = <3200000>;
+
+		vddaon-supply = <&vreg_pmu_aon_0p59>;
+		vddwlcx-supply = <&vreg_pmu_wlcx_0p8>;
+		vddwlmx-supply = <&vreg_pmu_wlmx_0p85>;
+		vddrfacmn-supply = <&vreg_pmu_rfa_cmn>;
+		vddrfa0p8-supply = <&vreg_pmu_rfa_0p8>;
+		vddrfa1p2-supply = <&vreg_pmu_rfa_1p2>;
+		vddrfa1p8-supply = <&vreg_pmu_rfa_1p8>;
+	};
+};
+
 &usb_1_ss0_hsphy {
 	vdd-supply = <&vreg_l3j_0p8>;
 	vdda12-supply = <&vreg_l2j_1p2>;
diff -Nrup linux-6.16.7/arch/arm64/boot/dts/qcom/x1e78100-lenovo-thinkpad-t14s-oled.dts linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/x1e78100-lenovo-thinkpad-t14s-oled.dts
--- linux-6.16.7/arch/arm64/boot/dts/qcom/x1e78100-lenovo-thinkpad-t14s-oled.dts	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/x1e78100-lenovo-thinkpad-t14s-oled.dts	2025-09-11 09:47:42.000000000 -0600
@@ -10,3 +10,11 @@
 	compatible = "lenovo,thinkpad-t14s-oled", "lenovo,thinkpad-t14s",
 		     "qcom,x1e78100", "qcom,x1e80100";
 };
+
+&panel {
+	compatible = "samsung,atna40yk20", "samsung,atna33xc20";
+	enable-gpios = <&pmc8380_3_gpios 4 GPIO_ACTIVE_HIGH>;
+
+	pinctrl-0 = <&edp_bl_en>;
+	pinctrl-names = "default";
+};
diff -Nrup linux-6.16.7/arch/arm64/boot/dts/qcom/x1e80100-dell-xps13-9345.dts linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/x1e80100-dell-xps13-9345.dts
--- linux-6.16.7/arch/arm64/boot/dts/qcom/x1e80100-dell-xps13-9345.dts	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/x1e80100-dell-xps13-9345.dts	2025-09-11 09:47:42.000000000 -0600
@@ -22,6 +22,7 @@
 
 	aliases {
 		serial0 = &uart21;
+		serial1 = &uart14;
 	};
 
 	gpio-keys {
@@ -288,6 +289,101 @@
 		regulator-always-on;
 		regulator-boot-on;
 	};
+
+	vreg_wcn_0p95: regulator-wcn-0p95 {
+		compatible = "regulator-fixed";
+
+		regulator-name = "VREG_WCN_0P95";
+		regulator-min-microvolt = <950000>;
+		regulator-max-microvolt = <950000>;
+
+		vin-supply = <&vreg_wcn_3p3>;
+	};
+
+	vreg_wcn_1p9: regulator-wcn-1p9 {
+		compatible = "regulator-fixed";
+
+		regulator-name = "VREG_WCN_1P9";
+		regulator-min-microvolt = <1900000>;
+		regulator-max-microvolt = <1900000>;
+
+		vin-supply = <&vreg_wcn_3p3>;
+	};
+
+	vreg_wcn_3p3: regulator-wcn-3p3 {
+		compatible = "regulator-fixed";
+
+		regulator-name = "VREG_WCN_3P3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+
+		gpio = <&tlmm 214 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		pinctrl-0 = <&wcn_sw_en>;
+		pinctrl-names = "default";
+
+		regulator-boot-on;
+	};
+
+	wcn7850-pmu {
+		compatible = "qcom,wcn7850-pmu";
+
+		vdd-supply = <&vreg_wcn_0p95>;
+		vddio-supply = <&vreg_l15b_1p8>;
+		vddaon-supply = <&vreg_wcn_0p95>;
+		vdddig-supply = <&vreg_wcn_0p95>;
+		vddrfa1p2-supply = <&vreg_wcn_1p9>;
+		vddrfa1p8-supply = <&vreg_wcn_1p9>;
+
+		wlan-enable-gpios = <&tlmm 117 GPIO_ACTIVE_HIGH>;
+		bt-enable-gpios = <&tlmm 116 GPIO_ACTIVE_HIGH>;
+
+		pinctrl-0 = <&wcn_wlan_bt_en>;
+		pinctrl-names = "default";
+
+		regulators {
+			vreg_pmu_rfa_cmn: ldo0 {
+				regulator-name = "vreg_pmu_rfa_cmn";
+			};
+
+			vreg_pmu_aon_0p59: ldo1 {
+				regulator-name = "vreg_pmu_aon_0p59";
+			};
+
+			vreg_pmu_wlcx_0p8: ldo2 {
+				regulator-name = "vreg_pmu_wlcx_0p8";
+			};
+
+			vreg_pmu_wlmx_0p85: ldo3 {
+				regulator-name = "vreg_pmu_wlmx_0p85";
+			};
+
+			vreg_pmu_btcmx_0p85: ldo4 {
+				regulator-name = "vreg_pmu_btcmx_0p85";
+			};
+
+			vreg_pmu_rfa_0p8: ldo5 {
+				regulator-name = "vreg_pmu_rfa_0p8";
+			};
+
+			vreg_pmu_rfa_1p2: ldo6 {
+				regulator-name = "vreg_pmu_rfa_1p2";
+			};
+
+			vreg_pmu_rfa_1p8: ldo7 {
+				regulator-name = "vreg_pmu_rfa_1p8";
+			};
+
+			vreg_pmu_pcie_0p9: ldo8 {
+				regulator-name = "vreg_pmu_pcie_0p9";
+			};
+
+			vreg_pmu_pcie_1p8: ldo9 {
+				regulator-name = "vreg_pmu_pcie_1p8";
+			};
+		};
+	};
 };
 
 &apps_rsc {
@@ -848,6 +944,23 @@
 	status = "okay";
 };
 
+&pcie4_port0 {
+	wifi@0 {
+		compatible = "pci17cb,1107";
+		reg = <0x10000 0x0 0x0 0x0 0x0>;
+
+		vddaon-supply = <&vreg_pmu_aon_0p59>;
+		vddwlcx-supply = <&vreg_pmu_wlcx_0p8>;
+		vddwlmx-supply = <&vreg_pmu_wlmx_0p85>;
+		vddrfacmn-supply = <&vreg_pmu_rfa_cmn>;
+		vddrfa0p8-supply = <&vreg_pmu_rfa_0p8>;
+		vddrfa1p2-supply = <&vreg_pmu_rfa_1p2>;
+		vddrfa1p8-supply = <&vreg_pmu_rfa_1p8>;
+		vddpcie0p9-supply = <&vreg_pmu_pcie_0p9>;
+		vddpcie1p8-supply = <&vreg_pmu_pcie_1p8>;
+	};
+};
+
 &pcie6a {
 	perst-gpios = <&tlmm 152 GPIO_ACTIVE_LOW>;
 	wake-gpios = <&tlmm 154 GPIO_ACTIVE_LOW>;
@@ -1102,6 +1215,37 @@
 			drive-strength = <2>;
 		};
 	};
+
+	wcn_sw_en: wcn-sw-en-state {
+		pins = "gpio214";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	wcn_wlan_bt_en: wcn-wlan-bt-en-state {
+		pins = "gpio116", "gpio117";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+};
+
+&uart14 {
+	status = "okay";
+
+	bluetooth {
+		compatible = "qcom,wcn7850-bt";
+		max-speed = <3200000>;
+
+		vddaon-supply = <&vreg_pmu_aon_0p59>;
+		vddwlcx-supply = <&vreg_pmu_wlcx_0p8>;
+		vddwlmx-supply = <&vreg_pmu_wlmx_0p85>;
+		vddrfacmn-supply = <&vreg_pmu_rfa_cmn>;
+		vddrfa0p8-supply = <&vreg_pmu_rfa_0p8>;
+		vddrfa1p2-supply = <&vreg_pmu_rfa_1p2>;
+		vddrfa1p8-supply = <&vreg_pmu_rfa_1p8>;
+	};
 };
 
 &uart21 {
diff -Nrup linux-6.16.7/arch/arm64/boot/dts/qcom/x1e80100-pmics.dtsi linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/x1e80100-pmics.dtsi
--- linux-6.16.7/arch/arm64/boot/dts/qcom/x1e80100-pmics.dtsi	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/x1e80100-pmics.dtsi	2025-09-11 09:47:42.000000000 -0600
@@ -475,6 +475,8 @@
 		#address-cells = <1>;
 		#size-cells = <0>;
 
+		status = "disabled";
+
 		pm8010_temp_alarm: temp-alarm@2400 {
 			compatible = "qcom,spmi-temp-alarm";
 			reg = <0x2400>;
diff -Nrup linux-6.16.7/arch/arm64/boot/dts/renesas/r9a07g054l2-smarc-cru-csi-ov5645.dtso linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/renesas/r9a07g054l2-smarc-cru-csi-ov5645.dtso
--- linux-6.16.7/arch/arm64/boot/dts/renesas/r9a07g054l2-smarc-cru-csi-ov5645.dtso	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/renesas/r9a07g054l2-smarc-cru-csi-ov5645.dtso	2025-09-11 09:47:42.000000000 -0600
@@ -1,21 +1 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Device Tree overlay for the RZ/{G2L, V2L} SMARC EVK with OV5645 camera
- * connected to CSI and CRU enabled.
- *
- * Copyright (C) 2023 Renesas Electronics Corp.
- */
-
-/dts-v1/;
-/plugin/;
-
-#include <dt-bindings/gpio/gpio.h>
-#include <dt-bindings/pinctrl/rzg2l-pinctrl.h>
-
-#define OV5645_PARENT_I2C i2c0
-#include "rz-smarc-cru-csi-ov5645.dtsi"
-
-&ov5645 {
-	enable-gpios = <&pinctrl RZG2L_GPIO(2, 0) GPIO_ACTIVE_HIGH>;
-	reset-gpios = <&pinctrl RZG2L_GPIO(40, 2) GPIO_ACTIVE_LOW>;
-};
+r9a07g044l2-smarc-cru-csi-ov5645.dtso
\ No newline at end of file
diff -Nrup linux-6.16.7/arch/arm64/configs/defconfig linux-lenovo-x13s-linux-6.16.y/arch/arm64/configs/defconfig
--- linux-6.16.7/arch/arm64/configs/defconfig	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/configs/defconfig	2025-09-11 09:47:42.000000000 -0600
@@ -236,7 +236,7 @@ CONFIG_PCIE_HISI_STB=y
 CONFIG_PCIE_ARMADA_8K=y
 CONFIG_PCIE_TEGRA194_HOST=m
 CONFIG_PCIE_TEGRA194_EP=m
-CONFIG_PCIE_QCOM=y
+CONFIG_PCIE_QCOM=m
 CONFIG_PCIE_RCAR_GEN4_HOST=m
 CONFIG_PCIE_RCAR_GEN4_EP=m
 CONFIG_PCIE_ROCKCHIP_DW_HOST=y
diff -Nrup linux-6.16.7/arch/arm64/configs/johan_defconfig linux-lenovo-x13s-linux-6.16.y/arch/arm64/configs/johan_defconfig
--- linux-6.16.7/arch/arm64/configs/johan_defconfig	1969-12-31 17:00:00.000000000 -0700
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/configs/johan_defconfig	2025-09-11 09:47:42.000000000 -0600
@@ -0,0 +1,429 @@
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_AUDIT=y
+CONFIG_NO_HZ_IDLE=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_BPF_SYSCALL=y
+CONFIG_BPF_JIT=y
+CONFIG_PREEMPT=y
+CONFIG_IRQ_TIME_ACCOUNTING=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_NUMA_BALANCING=y
+CONFIG_MEMCG=y
+CONFIG_BLK_CGROUP=y
+CONFIG_CGROUP_PIDS=y
+CONFIG_CGROUP_HUGETLB=y
+CONFIG_CPUSETS=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_CGROUP_PERF=y
+CONFIG_CGROUP_BPF=y
+CONFIG_USER_NS=y
+CONFIG_SCHED_AUTOGROUP=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_PROFILING=y
+CONFIG_ARCH_QCOM=y
+# CONFIG_AMPERE_ERRATUM_AC04_CPU_23 is not set
+# CONFIG_ARM64_ERRATUM_2077057 is not set
+# CONFIG_ARM64_ERRATUM_3194386 is not set
+# CONFIG_ROCKCHIP_ERRATUM_3568002 is not set
+# CONFIG_ROCKCHIP_ERRATUM_3588001 is not set
+CONFIG_ARM64_VA_BITS_48=y
+CONFIG_SCHED_MC=y
+CONFIG_SCHED_SMT=y
+CONFIG_NUMA=y
+CONFIG_COMPAT=y
+# CONFIG_ARM64_POE is not set
+CONFIG_RANDOMIZE_BASE=y
+CONFIG_HIBERNATION=y
+CONFIG_WQ_POWER_EFFICIENT_DEFAULT=y
+CONFIG_ENERGY_MODEL=y
+CONFIG_CPU_IDLE=y
+CONFIG_ARM_PSCI_CPUIDLE=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=m
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=m
+CONFIG_CPUFREQ_DT_PLATDEV=y
+CONFIG_ARM_QCOM_CPUFREQ_HW=y
+CONFIG_ARM_SCMI_CPUFREQ=y
+CONFIG_JUMP_LABEL=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_BLOCK_LEGACY_AUTOLOAD is not set
+# CONFIG_IOSCHED_BFQ is not set
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_BINFMT_MISC=m
+CONFIG_KSM=y
+CONFIG_MEMORY_FAILURE=y
+CONFIG_TRANSPARENT_HUGEPAGE=y
+CONFIG_CMA=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IPV6=m
+CONFIG_IPV6_MULTIPLE_TABLES=y
+CONFIG_NETFILTER=y
+CONFIG_NF_CONNTRACK=m
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NETFILTER_XTABLES_COMPAT=y
+CONFIG_NETFILTER_XT_MARK=m
+CONFIG_NETFILTER_XT_TARGET_LOG=m
+CONFIG_NETFILTER_XT_MATCH_ADDRTYPE=m
+CONFIG_NETFILTER_XT_MATCH_COMMENT=m
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=m
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=m
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_IP_NF_RAW=m
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_TARGET_REJECT=m
+CONFIG_IP6_NF_MANGLE=m
+CONFIG_IP6_NF_RAW=m
+CONFIG_QRTR_SMD=m
+CONFIG_QRTR_TUN=m
+CONFIG_BT=m
+CONFIG_BT_RFCOMM=m
+CONFIG_BT_HIDP=m
+CONFIG_BT_HCIUART=m
+CONFIG_BT_HCIUART_QCA=y
+CONFIG_CFG80211=m
+CONFIG_MAC80211=m
+CONFIG_MAC80211_LEDS=y
+CONFIG_RFKILL=m
+CONFIG_PCI=y
+CONFIG_PCIEPORTBUS=y
+CONFIG_PCIEAER=y
+CONFIG_PCIE_QCOM=m
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_FW_LOADER_USER_HELPER=y
+CONFIG_FW_LOADER_COMPRESS=y
+CONFIG_FW_LOADER_COMPRESS_ZSTD=y
+# CONFIG_QCOM_EBI2 is not set
+CONFIG_MHI_BUS_PCI_GENERIC=m
+CONFIG_ARM_SCMI_PROTOCOL=y
+CONFIG_EFI_CAPSULE_LOADER=y
+CONFIG_QCOM_QSEECOM=y
+CONFIG_QCOM_QSEECOM_UEFISECAPP=y
+CONFIG_ZRAM=m
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_NVME=m
+CONFIG_QCOM_FASTRPC=m
+CONFIG_SCSI=y
+# CONFIG_SCSI_PROC_FS is not set
+CONFIG_BLK_DEV_SD=y
+# CONFIG_SCSI_LOWLEVEL is not set
+CONFIG_MD=y
+CONFIG_BLK_DEV_DM=m
+CONFIG_DM_CRYPT=m
+CONFIG_NETDEVICES=y
+CONFIG_WIREGUARD=m
+CONFIG_TUN=y
+CONFIG_VETH=m
+CONFIG_MHI_NET=m
+# CONFIG_ETHERNET is not set
+CONFIG_USB_NET_DRIVERS=m
+CONFIG_USB_RTL8152=m
+# CONFIG_WLAN_VENDOR_ADMTEK is not set
+CONFIG_ATH11K=m
+CONFIG_ATH11K_PCI=m
+CONFIG_ATH12K=m
+# CONFIG_WLAN_VENDOR_ATMEL is not set
+# CONFIG_WLAN_VENDOR_BROADCOM is not set
+# CONFIG_WLAN_VENDOR_INTEL is not set
+# CONFIG_WLAN_VENDOR_INTERSIL is not set
+# CONFIG_WLAN_VENDOR_MARVELL is not set
+# CONFIG_WLAN_VENDOR_MEDIATEK is not set
+# CONFIG_WLAN_VENDOR_MICROCHIP is not set
+# CONFIG_WLAN_VENDOR_PURELIFI is not set
+# CONFIG_WLAN_VENDOR_RALINK is not set
+# CONFIG_WLAN_VENDOR_REALTEK is not set
+# CONFIG_WLAN_VENDOR_RSI is not set
+# CONFIG_WLAN_VENDOR_SILABS is not set
+# CONFIG_WLAN_VENDOR_ST is not set
+# CONFIG_WLAN_VENDOR_TI is not set
+# CONFIG_WLAN_VENDOR_ZYDAS is not set
+# CONFIG_WLAN_VENDOR_QUANTENNA is not set
+CONFIG_WWAN=m
+CONFIG_MHI_WWAN_CTRL=m
+CONFIG_MHI_WWAN_MBIM=m
+CONFIG_INPUT_EVDEV=y
+# CONFIG_KEYBOARD_ATKBD is not set
+CONFIG_KEYBOARD_GPIO=y
+# CONFIG_INPUT_MOUSE is not set
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_PM8941_PWRKEY=y
+# CONFIG_SERIO is not set
+CONFIG_LEGACY_PTY_COUNT=16
+CONFIG_SERIAL_QCOM_GENI=y
+CONFIG_SERIAL_QCOM_GENI_CONSOLE=y
+CONFIG_SERIAL_DEV_BUS=y
+# CONFIG_DEVPORT is not set
+CONFIG_I2C_CHARDEV=m
+CONFIG_I2C_QCOM_CCI=m
+CONFIG_I2C_QCOM_GENI=m
+CONFIG_SPI=y
+CONFIG_SPI_QCOM_GENI=m
+CONFIG_SPMI=y
+CONFIG_PINCTRL_SINGLE=y
+CONFIG_PINCTRL_MSM=y
+CONFIG_PINCTRL_SC8280XP=y
+CONFIG_PINCTRL_X1E80100=y
+CONFIG_PINCTRL_QCOM_SPMI_PMIC=y
+CONFIG_PINCTRL_LPASS_LPI=m
+CONFIG_PINCTRL_SC8280XP_LPASS_LPI=m
+CONFIG_PINCTRL_SM8550_LPASS_LPI=m
+CONFIG_POWER_RESET_QCOM_PON=m
+CONFIG_BATTERY_QCOM_BATTMGR=m
+CONFIG_THERMAL=y
+CONFIG_THERMAL_GOV_POWER_ALLOCATOR=y
+CONFIG_CPU_THERMAL=y
+CONFIG_DEVFREQ_THERMAL=y
+CONFIG_THERMAL_EMULATION=y
+CONFIG_QCOM_TSENS=y
+CONFIG_QCOM_SPMI_ADC_TM5=m
+CONFIG_QCOM_SPMI_TEMP_ALARM=m
+CONFIG_QCOM_LMH=m
+CONFIG_WATCHDOG=y
+CONFIG_ARM_SBSA_WATCHDOG=y
+CONFIG_QCOM_WDT=m
+CONFIG_MFD_SPMI_PMIC=y
+CONFIG_MFD_QCOM_PM8008=m
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_REGULATOR_QCOM_PM8008=m
+CONFIG_REGULATOR_QCOM_RPMH=y
+CONFIG_MEDIA_SUPPORT=m
+CONFIG_MEDIA_CAMERA_SUPPORT=y
+CONFIG_MEDIA_PLATFORM_SUPPORT=y
+CONFIG_MEDIA_USB_SUPPORT=y
+CONFIG_USB_VIDEO_CLASS=m
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_V4L_MEM2MEM_DRIVERS=y
+CONFIG_VIDEO_QCOM_CAMSS=m
+CONFIG_VIDEO_QCOM_VENUS=m
+CONFIG_VIDEO_OV5675=m
+CONFIG_DRM=m
+CONFIG_DRM_MALI_DISPLAY=m
+CONFIG_DRM_MSM=m
+# CONFIG_DRM_MSM_MDP4 is not set
+# CONFIG_DRM_MSM_MDP5 is not set
+# CONFIG_DRM_MSM_DSI is not set
+# CONFIG_DRM_MSM_HDMI is not set
+CONFIG_DRM_PANEL_SAMSUNG_ATNA33XC20=m
+CONFIG_DRM_PANEL_EDP=m
+CONFIG_DRM_DISPLAY_CONNECTOR=m
+CONFIG_FB=y
+CONFIG_FB_EFI=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_PWM=m
+CONFIG_SOUND=m
+CONFIG_SND=m
+# CONFIG_SND_SUPPORT_OLD_API is not set
+# CONFIG_SND_DRIVERS is not set
+# CONFIG_SND_PCI is not set
+# CONFIG_SND_SPI is not set
+CONFIG_SND_USB_AUDIO=m
+CONFIG_SND_SOC=m
+CONFIG_SND_SOC_QCOM=m
+CONFIG_SND_SOC_SC8280XP=m
+CONFIG_SND_SOC_X1E80100=m
+CONFIG_SND_SOC_WCD938X_SDW=m
+CONFIG_SND_SOC_WSA883X=m
+CONFIG_SND_SOC_WSA884X=m
+CONFIG_SND_SOC_LPASS_WSA_MACRO=m
+CONFIG_SND_SOC_LPASS_VA_MACRO=m
+CONFIG_SND_SOC_LPASS_RX_MACRO=m
+CONFIG_SND_SOC_LPASS_TX_MACRO=m
+CONFIG_UHID=m
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_ITE is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_REDRAGON is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+CONFIG_HID_MULTITOUCH=m
+CONFIG_I2C_HID_OF=m
+CONFIG_I2C_HID_OF_ELAN=m
+CONFIG_USB=y
+# CONFIG_USB_PCI is not set
+CONFIG_USB_OTG=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_STORAGE=m
+CONFIG_USB_DWC3=y
+# CONFIG_USB_DWC3_OF_SIMPLE is not set
+CONFIG_USB_SERIAL=m
+CONFIG_USB_SERIAL_FTDI_SIO=m
+CONFIG_USB_GADGET=y
+CONFIG_USB_CONFIGFS=m
+CONFIG_USB_CONFIGFS_SERIAL=y
+CONFIG_TYPEC=m
+CONFIG_TYPEC_TCPM=m
+CONFIG_TYPEC_TCPCI=m
+CONFIG_TYPEC_UCSI=m
+CONFIG_UCSI_PMIC_GLINK=m
+CONFIG_TYPEC_MUX_GPIO_SBU=m
+CONFIG_TYPEC_MUX_PS883X=m
+CONFIG_MMC=m
+CONFIG_MMC_SDHCI=m
+CONFIG_MMC_SDHCI_PLTFM=m
+CONFIG_MMC_SDHCI_MSM=m
+CONFIG_SCSI_UFSHCD=y
+CONFIG_SCSI_UFSHCD_PLATFORM=y
+CONFIG_SCSI_UFS_QCOM=m
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=m
+CONFIG_LEDS_CLASS_MULTICOLOR=m
+CONFIG_LEDS_GPIO=m
+CONFIG_LEDS_QCOM_LPG=m
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_LEDS_TRIGGER_CPU=y
+CONFIG_LEDS_TRIGGER_DEFAULT_ON=y
+CONFIG_LEDS_TRIGGER_PANIC=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_PM8XXX=m
+CONFIG_DMADEVICES=y
+CONFIG_UDMABUF=y
+# CONFIG_VIRTIO_MENU is not set
+# CONFIG_VHOST_MENU is not set
+# CONFIG_SURFACE_PLATFORMS is not set
+CONFIG_COMMON_CLK_QCOM=y
+CONFIG_CLK_X1E80100_CAMCC=y
+CONFIG_CLK_X1E80100_DISPCC=m
+CONFIG_CLK_X1E80100_GPUCC=m
+CONFIG_CLK_X1E80100_TCSRCC=m
+CONFIG_QCOM_CLK_RPMH=y
+CONFIG_SC_CAMCC_8280XP=m
+CONFIG_SC_DISPCC_8280XP=m
+CONFIG_SC_GCC_8280XP=y
+CONFIG_SC_GPUCC_8280XP=m
+CONFIG_SC_LPASSCC_8280XP=m
+CONFIG_SM_VIDEOCC_8350=m
+CONFIG_HWSPINLOCK=y
+CONFIG_HWSPINLOCK_QCOM=y
+# CONFIG_FSL_ERRATUM_A008585 is not set
+# CONFIG_HISILICON_ERRATUM_161010101 is not set
+CONFIG_MAILBOX=y
+CONFIG_QCOM_CPUCP_MBOX=m
+CONFIG_QCOM_IPCC=y
+CONFIG_ARM_SMMU=y
+CONFIG_ARM_SMMU_V3=y
+CONFIG_QCOM_IOMMU=y
+CONFIG_REMOTEPROC=y
+CONFIG_QCOM_Q6V5_ADSP=m
+CONFIG_QCOM_Q6V5_PAS=m
+CONFIG_QCOM_SYSMON=m
+CONFIG_RPMSG_CHAR=m
+CONFIG_RPMSG_CTRL=m
+CONFIG_RPMSG_QCOM_GLINK_SMEM=m
+CONFIG_SOUNDWIRE=m
+CONFIG_SOUNDWIRE_QCOM=m
+CONFIG_QCOM_AOSS_QMP=y
+CONFIG_QCOM_COMMAND_DB=y
+CONFIG_QCOM_GENI_SE=y
+CONFIG_QCOM_LLCC=m
+CONFIG_QCOM_PMIC_GLINK=m
+CONFIG_QCOM_RPMH=y
+CONFIG_QCOM_SMEM=y
+CONFIG_QCOM_SMP2P=y
+CONFIG_QCOM_SOCINFO=m
+CONFIG_QCOM_STATS=m
+CONFIG_QCOM_APR=m
+CONFIG_QCOM_ICC_BWMON=m
+CONFIG_QCOM_RPMHPD=y
+CONFIG_IIO=m
+CONFIG_QCOM_SPMI_ADC5=m
+CONFIG_PWM=y
+CONFIG_QCOM_PDC=y
+CONFIG_RESET_GPIO=m
+CONFIG_RESET_QCOM_AOSS=y
+CONFIG_RESET_QCOM_PDC=m
+CONFIG_PHY_SNPS_EUSB2=m
+CONFIG_PHY_NXP_PTN3222=m
+CONFIG_PHY_QCOM_EDP=m
+CONFIG_PHY_QCOM_QMP=m
+# CONFIG_PHY_QCOM_QMP_PCIE_8996 is not set
+CONFIG_PHY_QCOM_EUSB2_REPEATER=m
+CONFIG_PHY_QCOM_USB_SNPS_FEMTO_V2=m
+CONFIG_NVMEM_QCOM_QFPROM=y
+CONFIG_NVMEM_SPMI_SDAM=m
+CONFIG_MUX_GPIO=m
+# CONFIG_SLIMBUS is not set
+CONFIG_INTERCONNECT_QCOM=y
+CONFIG_INTERCONNECT_QCOM_OSM_L3=m
+CONFIG_INTERCONNECT_QCOM_SC8280XP=y
+CONFIG_INTERCONNECT_QCOM_X1E80100=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_FANOTIFY=y
+CONFIG_QUOTA=y
+CONFIG_AUTOFS_FS=m
+CONFIG_FUSE_FS=m
+CONFIG_OVERLAY_FS=m
+CONFIG_VFAT_FS=y
+CONFIG_NTFS_FS=m
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_HUGETLBFS=y
+CONFIG_CONFIGFS_FS=y
+CONFIG_EFIVAR_FS=y
+# CONFIG_NETWORK_FILESYSTEMS is not set
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_SECURITY=y
+CONFIG_SECURITY_LANDLOCK=y
+# CONFIG_INTEGRITY is not set
+CONFIG_LSM="landlock,lockdown,yama,loadpin,safesetid,integrity,bpf"
+CONFIG_CRYPTO_NULL=y
+CONFIG_CRYPTO_DES=m
+CONFIG_CRYPTO_SHA256=y
+CONFIG_CRYPTO_CRC32C=y
+CONFIG_CRYPTO_ANSI_CPRNG=y
+CONFIG_CRYPTO_DRBG_MENU=y
+CONFIG_CRYPTO_USER_API_HASH=m
+CONFIG_CRYPTO_USER_API_SKCIPHER=m
+CONFIG_CRYPTO_GHASH_ARM64_CE=y
+CONFIG_CRYPTO_SHA1_ARM64_CE=y
+CONFIG_CRYPTO_SHA512_ARM64_CE=m
+CONFIG_CRYPTO_SHA3_ARM64=m
+CONFIG_CRYPTO_SM3_ARM64_CE=m
+CONFIG_CRYPTO_AES_ARM64_BS=m
+CONFIG_CRYPTO_AES_ARM64_CE_CCM=y
+CONFIG_CRYPTO_DEV_QCOM_RNG=m
+CONFIG_CRYPTO_DEV_CCREE=m
+CONFIG_DMA_CMA=y
+CONFIG_CMA_SIZE_MBYTES=128
+CONFIG_PRINTK_TIME=y
+CONFIG_DYNAMIC_DEBUG=y
+CONFIG_DEBUG_KERNEL=y
+CONFIG_DEBUG_FS=y
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_FTRACE is not set
+# CONFIG_RUNTIME_TESTING_MENU is not set
diff -Nrup linux-6.16.7/arch/arm64/tools/syscall_64.tbl linux-lenovo-x13s-linux-6.16.y/arch/arm64/tools/syscall_64.tbl
--- linux-6.16.7/arch/arm64/tools/syscall_64.tbl	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/tools/syscall_64.tbl	2025-09-11 09:47:42.000000000 -0600
@@ -1,410 +1 @@
-# SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note
-#
-# This file contains the system call numbers for all of the
-# more recently added architectures.
-#
-# As a basic principle, no duplication of functionality
-# should be added, e.g. we don't use lseek when llseek
-# is present. New architectures should use this file
-# and implement the less feature-full calls in user space.
-#
-0	common	io_setup			sys_io_setup			compat_sys_io_setup
-1	common	io_destroy			sys_io_destroy
-2	common	io_submit			sys_io_submit			compat_sys_io_submit
-3	common	io_cancel			sys_io_cancel
-4	time32	io_getevents			sys_io_getevents_time32
-4	64	io_getevents			sys_io_getevents
-5	common	setxattr			sys_setxattr
-6	common	lsetxattr			sys_lsetxattr
-7	common	fsetxattr			sys_fsetxattr
-8	common	getxattr			sys_getxattr
-9	common	lgetxattr			sys_lgetxattr
-10	common	fgetxattr			sys_fgetxattr
-11	common	listxattr			sys_listxattr
-12	common	llistxattr			sys_llistxattr
-13	common	flistxattr			sys_flistxattr
-14	common	removexattr			sys_removexattr
-15	common	lremovexattr			sys_lremovexattr
-16	common	fremovexattr			sys_fremovexattr
-17	common	getcwd				sys_getcwd
-18	common	lookup_dcookie			sys_ni_syscall
-19	common	eventfd2			sys_eventfd2
-20	common	epoll_create1			sys_epoll_create1
-21	common	epoll_ctl			sys_epoll_ctl
-22	common	epoll_pwait			sys_epoll_pwait			compat_sys_epoll_pwait
-23	common	dup				sys_dup
-24	common	dup3				sys_dup3
-25	32	fcntl64				sys_fcntl64			compat_sys_fcntl64
-25	64	fcntl				sys_fcntl
-26	common	inotify_init1			sys_inotify_init1
-27	common	inotify_add_watch		sys_inotify_add_watch
-28	common	inotify_rm_watch		sys_inotify_rm_watch
-29	common	ioctl				sys_ioctl			compat_sys_ioctl
-30	common	ioprio_set			sys_ioprio_set
-31	common	ioprio_get			sys_ioprio_get
-32	common	flock				sys_flock
-33	common	mknodat				sys_mknodat
-34	common	mkdirat				sys_mkdirat
-35	common	unlinkat			sys_unlinkat
-36	common	symlinkat			sys_symlinkat
-37	common	linkat				sys_linkat
-# renameat is superseded with flags by renameat2
-38	renameat renameat			sys_renameat
-39	common	umount2				sys_umount
-40	common	mount				sys_mount
-41	common	pivot_root			sys_pivot_root
-42	common	nfsservctl			sys_ni_syscall
-43	32	statfs64			sys_statfs64			compat_sys_statfs64
-43	64	statfs				sys_statfs
-44	32	fstatfs64			sys_fstatfs64			compat_sys_fstatfs64
-44	64	fstatfs				sys_fstatfs
-45	32	truncate64			sys_truncate64			compat_sys_truncate64
-45	64	truncate			sys_truncate
-46	32	ftruncate64			sys_ftruncate64			compat_sys_ftruncate64
-46	64	ftruncate			sys_ftruncate
-47	common	fallocate			sys_fallocate			compat_sys_fallocate
-48	common	faccessat			sys_faccessat
-49	common	chdir				sys_chdir
-50	common	fchdir				sys_fchdir
-51	common	chroot				sys_chroot
-52	common	fchmod				sys_fchmod
-53	common	fchmodat			sys_fchmodat
-54	common	fchownat			sys_fchownat
-55	common	fchown				sys_fchown
-56	common	openat				sys_openat
-57	common	close				sys_close
-58	common	vhangup				sys_vhangup
-59	common	pipe2				sys_pipe2
-60	common	quotactl			sys_quotactl
-61	common	getdents64			sys_getdents64
-62	32	llseek				sys_llseek
-62	64	lseek				sys_lseek
-63	common	read				sys_read
-64	common	write				sys_write
-65	common	readv				sys_readv			sys_readv
-66	common	writev				sys_writev			sys_writev
-67	common	pread64				sys_pread64			compat_sys_pread64
-68	common	pwrite64			sys_pwrite64			compat_sys_pwrite64
-69	common	preadv				sys_preadv			compat_sys_preadv
-70	common	pwritev				sys_pwritev			compat_sys_pwritev
-71	32	sendfile64			sys_sendfile64
-71	64	sendfile			sys_sendfile64
-72	time32	pselect6			sys_pselect6_time32		compat_sys_pselect6_time32
-72	64	pselect6			sys_pselect6
-73	time32	ppoll				sys_ppoll_time32		compat_sys_ppoll_time32
-73	64	ppoll				sys_ppoll
-74	common	signalfd4			sys_signalfd4			compat_sys_signalfd4
-75	common	vmsplice			sys_vmsplice
-76	common	splice				sys_splice
-77	common	tee				sys_tee
-78	common	readlinkat			sys_readlinkat
-79	stat64	fstatat64			sys_fstatat64
-79	64	newfstatat			sys_newfstatat
-80	stat64	fstat64				sys_fstat64
-80	64	fstat				sys_newfstat
-81	common	sync				sys_sync
-82	common	fsync				sys_fsync
-83	common	fdatasync			sys_fdatasync
-84	common	sync_file_range			sys_sync_file_range		compat_sys_sync_file_range
-85	common	timerfd_create			sys_timerfd_create
-86	time32	timerfd_settime			sys_timerfd_settime32
-86	64	timerfd_settime			sys_timerfd_settime
-87	time32	timerfd_gettime			sys_timerfd_gettime32
-87	64	timerfd_gettime			sys_timerfd_gettime
-88	time32	utimensat			sys_utimensat_time32
-88	64	utimensat			sys_utimensat
-89	common	acct				sys_acct
-90	common	capget				sys_capget
-91	common	capset				sys_capset
-92	common	personality			sys_personality
-93	common	exit				sys_exit
-94	common	exit_group			sys_exit_group
-95	common	waitid				sys_waitid			compat_sys_waitid
-96	common	set_tid_address			sys_set_tid_address
-97	common	unshare				sys_unshare
-98	time32	futex				sys_futex_time32
-98	64	futex				sys_futex
-99	common	set_robust_list			sys_set_robust_list		compat_sys_set_robust_list
-100	common	get_robust_list			sys_get_robust_list		compat_sys_get_robust_list
-101	time32	nanosleep			sys_nanosleep_time32
-101	64	nanosleep			sys_nanosleep
-102	common	getitimer			sys_getitimer			compat_sys_getitimer
-103	common	setitimer			sys_setitimer			compat_sys_setitimer
-104	common	kexec_load			sys_kexec_load			compat_sys_kexec_load
-105	common	init_module			sys_init_module
-106	common	delete_module			sys_delete_module
-107	common	timer_create			sys_timer_create		compat_sys_timer_create
-108	time32	timer_gettime			sys_timer_gettime32
-108	64	timer_gettime			sys_timer_gettime
-109	common	timer_getoverrun		sys_timer_getoverrun
-110	time32	timer_settime			sys_timer_settime32
-110	64	timer_settime			sys_timer_settime
-111	common	timer_delete			sys_timer_delete
-112	time32	clock_settime			sys_clock_settime32
-112	64	clock_settime			sys_clock_settime
-113	time32	clock_gettime			sys_clock_gettime32
-113	64	clock_gettime			sys_clock_gettime
-114	time32	clock_getres			sys_clock_getres_time32
-114	64	clock_getres			sys_clock_getres
-115	time32	clock_nanosleep			sys_clock_nanosleep_time32
-115	64	clock_nanosleep			sys_clock_nanosleep
-116	common	syslog				sys_syslog
-117	common	ptrace				sys_ptrace			compat_sys_ptrace
-118	common	sched_setparam			sys_sched_setparam
-119	common	sched_setscheduler		sys_sched_setscheduler
-120	common	sched_getscheduler		sys_sched_getscheduler
-121	common	sched_getparam			sys_sched_getparam
-122	common	sched_setaffinity		sys_sched_setaffinity		compat_sys_sched_setaffinity
-123	common	sched_getaffinity		sys_sched_getaffinity		compat_sys_sched_getaffinity
-124	common	sched_yield			sys_sched_yield
-125	common	sched_get_priority_max		sys_sched_get_priority_max
-126	common	sched_get_priority_min		sys_sched_get_priority_min
-127	time32	sched_rr_get_interval		sys_sched_rr_get_interval_time32
-127	64	sched_rr_get_interval		sys_sched_rr_get_interval
-128	common	restart_syscall			sys_restart_syscall
-129	common	kill				sys_kill
-130	common	tkill				sys_tkill
-131	common	tgkill				sys_tgkill
-132	common	sigaltstack			sys_sigaltstack			compat_sys_sigaltstack
-133	common	rt_sigsuspend			sys_rt_sigsuspend		compat_sys_rt_sigsuspend
-134	common	rt_sigaction			sys_rt_sigaction		compat_sys_rt_sigaction
-135	common	rt_sigprocmask			sys_rt_sigprocmask		compat_sys_rt_sigprocmask
-136	common	rt_sigpending			sys_rt_sigpending		compat_sys_rt_sigpending
-137	time32	rt_sigtimedwait			sys_rt_sigtimedwait_time32	compat_sys_rt_sigtimedwait_time32
-137	64	rt_sigtimedwait			sys_rt_sigtimedwait
-138	common	rt_sigqueueinfo			sys_rt_sigqueueinfo		compat_sys_rt_sigqueueinfo
-139	common	rt_sigreturn			sys_rt_sigreturn		compat_sys_rt_sigreturn
-140	common	setpriority			sys_setpriority
-141	common	getpriority			sys_getpriority
-142	common	reboot				sys_reboot
-143	common	setregid			sys_setregid
-144	common	setgid				sys_setgid
-145	common	setreuid			sys_setreuid
-146	common	setuid				sys_setuid
-147	common	setresuid			sys_setresuid
-148	common	getresuid			sys_getresuid
-149	common	setresgid			sys_setresgid
-150	common	getresgid			sys_getresgid
-151	common	setfsuid			sys_setfsuid
-152	common	setfsgid			sys_setfsgid
-153	common	times				sys_times			compat_sys_times
-154	common	setpgid				sys_setpgid
-155	common	getpgid				sys_getpgid
-156	common	getsid				sys_getsid
-157	common	setsid				sys_setsid
-158	common	getgroups			sys_getgroups
-159	common	setgroups			sys_setgroups
-160	common	uname				sys_newuname
-161	common	sethostname			sys_sethostname
-162	common	setdomainname			sys_setdomainname
-# getrlimit and setrlimit are superseded with prlimit64
-163	rlimit	getrlimit			sys_getrlimit			compat_sys_getrlimit
-164	rlimit	setrlimit			sys_setrlimit			compat_sys_setrlimit
-165	common	getrusage			sys_getrusage			compat_sys_getrusage
-166	common	umask				sys_umask
-167	common	prctl				sys_prctl
-168	common	getcpu				sys_getcpu
-169	time32	gettimeofday			sys_gettimeofday		compat_sys_gettimeofday
-169	64	gettimeofday			sys_gettimeofday
-170	time32	settimeofday			sys_settimeofday		compat_sys_settimeofday
-170	64	settimeofday			sys_settimeofday
-171	time32	adjtimex			sys_adjtimex_time32
-171	64	adjtimex			sys_adjtimex
-172	common	getpid				sys_getpid
-173	common	getppid				sys_getppid
-174	common	getuid				sys_getuid
-175	common	geteuid				sys_geteuid
-176	common	getgid				sys_getgid
-177	common	getegid				sys_getegid
-178	common	gettid				sys_gettid
-179	common	sysinfo				sys_sysinfo			compat_sys_sysinfo
-180	common	mq_open				sys_mq_open			compat_sys_mq_open
-181	common	mq_unlink			sys_mq_unlink
-182	time32	mq_timedsend			sys_mq_timedsend_time32
-182	64	mq_timedsend			sys_mq_timedsend
-183	time32	mq_timedreceive			sys_mq_timedreceive_time32
-183	64	mq_timedreceive			sys_mq_timedreceive
-184	common	mq_notify			sys_mq_notify			compat_sys_mq_notify
-185	common	mq_getsetattr			sys_mq_getsetattr		compat_sys_mq_getsetattr
-186	common	msgget				sys_msgget
-187	common	msgctl				sys_msgctl			compat_sys_msgctl
-188	common	msgrcv				sys_msgrcv			compat_sys_msgrcv
-189	common	msgsnd				sys_msgsnd			compat_sys_msgsnd
-190	common	semget				sys_semget
-191	common	semctl				sys_semctl			compat_sys_semctl
-192	time32	semtimedop			sys_semtimedop_time32
-192	64	semtimedop			sys_semtimedop
-193	common	semop				sys_semop
-194	common	shmget				sys_shmget
-195	common	shmctl				sys_shmctl			compat_sys_shmctl
-196	common	shmat				sys_shmat			compat_sys_shmat
-197	common	shmdt				sys_shmdt
-198	common	socket				sys_socket
-199	common	socketpair			sys_socketpair
-200	common	bind				sys_bind
-201	common	listen				sys_listen
-202	common	accept				sys_accept
-203	common	connect				sys_connect
-204	common	getsockname			sys_getsockname
-205	common	getpeername			sys_getpeername
-206	common	sendto				sys_sendto
-207	common	recvfrom			sys_recvfrom			compat_sys_recvfrom
-208	common	setsockopt			sys_setsockopt			sys_setsockopt
-209	common	getsockopt			sys_getsockopt			sys_getsockopt
-210	common	shutdown			sys_shutdown
-211	common	sendmsg				sys_sendmsg			compat_sys_sendmsg
-212	common	recvmsg				sys_recvmsg			compat_sys_recvmsg
-213	common	readahead			sys_readahead			compat_sys_readahead
-214	common	brk				sys_brk
-215	common	munmap				sys_munmap
-216	common	mremap				sys_mremap
-217	common	add_key				sys_add_key
-218	common	request_key			sys_request_key
-219	common	keyctl				sys_keyctl			compat_sys_keyctl
-220	common	clone				sys_clone
-221	common	execve				sys_execve			compat_sys_execve
-222	32	mmap2				sys_mmap2
-222	64	mmap				sys_mmap
-223	32	fadvise64_64			sys_fadvise64_64		compat_sys_fadvise64_64
-223	64	fadvise64			sys_fadvise64_64
-224	common	swapon				sys_swapon
-225	common	swapoff				sys_swapoff
-226	common	mprotect			sys_mprotect
-227	common	msync				sys_msync
-228	common	mlock				sys_mlock
-229	common	munlock				sys_munlock
-230	common	mlockall			sys_mlockall
-231	common	munlockall			sys_munlockall
-232	common	mincore				sys_mincore
-233	common	madvise				sys_madvise
-234	common	remap_file_pages		sys_remap_file_pages
-235	common	mbind				sys_mbind
-236	common	get_mempolicy			sys_get_mempolicy
-237	common	set_mempolicy			sys_set_mempolicy
-238	common	migrate_pages			sys_migrate_pages
-239	common	move_pages			sys_move_pages
-240	common	rt_tgsigqueueinfo		sys_rt_tgsigqueueinfo		compat_sys_rt_tgsigqueueinfo
-241	common	perf_event_open			sys_perf_event_open
-242	common	accept4				sys_accept4
-243	time32	recvmmsg			sys_recvmmsg_time32		compat_sys_recvmmsg_time32
-243	64	recvmmsg			sys_recvmmsg
-# Architectures may provide up to 16 syscalls of their own between 244 and 259
-244	arc	cacheflush			sys_cacheflush
-245	arc	arc_settls			sys_arc_settls
-246	arc	arc_gettls			sys_arc_gettls
-247	arc	sysfs				sys_sysfs
-248	arc	arc_usr_cmpxchg			sys_arc_usr_cmpxchg
-
-244	csky	set_thread_area			sys_set_thread_area
-245	csky	cacheflush			sys_cacheflush
-
-244	nios2	cacheflush			sys_cacheflush
-
-244	or1k	or1k_atomic			sys_or1k_atomic
-
-258	riscv	riscv_hwprobe			sys_riscv_hwprobe
-259	riscv	riscv_flush_icache		sys_riscv_flush_icache
-
-260	time32	wait4				sys_wait4			compat_sys_wait4
-260	64	wait4				sys_wait4
-261	common	prlimit64			sys_prlimit64
-262	common	fanotify_init			sys_fanotify_init
-263	common	fanotify_mark			sys_fanotify_mark
-264	common	name_to_handle_at		sys_name_to_handle_at
-265	common	open_by_handle_at		sys_open_by_handle_at
-266	time32	clock_adjtime			sys_clock_adjtime32
-266	64	clock_adjtime			sys_clock_adjtime
-267	common	syncfs				sys_syncfs
-268	common	setns				sys_setns
-269	common	sendmmsg			sys_sendmmsg			compat_sys_sendmmsg
-270	common	process_vm_readv		sys_process_vm_readv
-271	common	process_vm_writev		sys_process_vm_writev
-272	common	kcmp				sys_kcmp
-273	common	finit_module			sys_finit_module
-274	common	sched_setattr			sys_sched_setattr
-275	common	sched_getattr			sys_sched_getattr
-276	common	renameat2			sys_renameat2
-277	common	seccomp				sys_seccomp
-278	common	getrandom			sys_getrandom
-279	common	memfd_create			sys_memfd_create
-280	common	bpf				sys_bpf
-281	common	execveat			sys_execveat			compat_sys_execveat
-282	common	userfaultfd			sys_userfaultfd
-283	common	membarrier			sys_membarrier
-284	common	mlock2				sys_mlock2
-285	common	copy_file_range			sys_copy_file_range
-286	common	preadv2				sys_preadv2			compat_sys_preadv2
-287	common	pwritev2			sys_pwritev2			compat_sys_pwritev2
-288	common	pkey_mprotect			sys_pkey_mprotect
-289	common	pkey_alloc			sys_pkey_alloc
-290	common	pkey_free			sys_pkey_free
-291	common	statx				sys_statx
-292	time32	io_pgetevents			sys_io_pgetevents_time32	compat_sys_io_pgetevents
-292	64	io_pgetevents			sys_io_pgetevents
-293	common	rseq				sys_rseq
-294	common	kexec_file_load			sys_kexec_file_load
-# 295 through 402 are unassigned to sync up with generic numbers don't use
-403	32	clock_gettime64			sys_clock_gettime
-404	32	clock_settime64			sys_clock_settime
-405	32	clock_adjtime64			sys_clock_adjtime
-406	32	clock_getres_time64		sys_clock_getres
-407	32	clock_nanosleep_time64		sys_clock_nanosleep
-408	32	timer_gettime64			sys_timer_gettime
-409	32	timer_settime64			sys_timer_settime
-410	32	timerfd_gettime64		sys_timerfd_gettime
-411	32	timerfd_settime64		sys_timerfd_settime
-412	32	utimensat_time64		sys_utimensat
-413	32	pselect6_time64			sys_pselect6			compat_sys_pselect6_time64
-414	32	ppoll_time64			sys_ppoll			compat_sys_ppoll_time64
-416	32	io_pgetevents_time64		sys_io_pgetevents		compat_sys_io_pgetevents_time64
-417	32	recvmmsg_time64			sys_recvmmsg			compat_sys_recvmmsg_time64
-418	32	mq_timedsend_time64		sys_mq_timedsend
-419	32	mq_timedreceive_time64		sys_mq_timedreceive
-420	32	semtimedop_time64		sys_semtimedop
-421	32	rt_sigtimedwait_time64		sys_rt_sigtimedwait		compat_sys_rt_sigtimedwait_time64
-422	32	futex_time64			sys_futex
-423	32	sched_rr_get_interval_time64	sys_sched_rr_get_interval
-424	common	pidfd_send_signal		sys_pidfd_send_signal
-425	common	io_uring_setup			sys_io_uring_setup
-426	common	io_uring_enter			sys_io_uring_enter
-427	common	io_uring_register		sys_io_uring_register
-428	common	open_tree			sys_open_tree
-429	common	move_mount			sys_move_mount
-430	common	fsopen				sys_fsopen
-431	common	fsconfig			sys_fsconfig
-432	common	fsmount				sys_fsmount
-433	common	fspick				sys_fspick
-434	common	pidfd_open			sys_pidfd_open
-435	common	clone3				sys_clone3
-436	common	close_range			sys_close_range
-437	common	openat2				sys_openat2
-438	common	pidfd_getfd			sys_pidfd_getfd
-439	common	faccessat2			sys_faccessat2
-440	common	process_madvise			sys_process_madvise
-441	common	epoll_pwait2			sys_epoll_pwait2		compat_sys_epoll_pwait2
-442	common	mount_setattr			sys_mount_setattr
-443	common	quotactl_fd			sys_quotactl_fd
-444	common	landlock_create_ruleset		sys_landlock_create_ruleset
-445	common	landlock_add_rule		sys_landlock_add_rule
-446	common	landlock_restrict_self		sys_landlock_restrict_self
-447	memfd_secret	memfd_secret		sys_memfd_secret
-448	common	process_mrelease		sys_process_mrelease
-449	common	futex_waitv			sys_futex_waitv
-450	common	set_mempolicy_home_node		sys_set_mempolicy_home_node
-451	common	cachestat			sys_cachestat
-452	common	fchmodat2			sys_fchmodat2
-453	common	map_shadow_stack		sys_map_shadow_stack
-454	common	futex_wake			sys_futex_wake
-455	common	futex_wait			sys_futex_wait
-456	common	futex_requeue			sys_futex_requeue
-457	common	statmount			sys_statmount
-458	common	listmount			sys_listmount
-459	common	lsm_get_self_attr		sys_lsm_get_self_attr
-460	common	lsm_set_self_attr		sys_lsm_set_self_attr
-461	common	lsm_list_modules		sys_lsm_list_modules
-462	common	mseal				sys_mseal
-463	common	setxattrat			sys_setxattrat
-464	common	getxattrat			sys_getxattrat
-465	common	listxattrat			sys_listxattrat
-466	common	removexattrat			sys_removexattrat
-467	common	open_tree_attr			sys_open_tree_attr
+../../../scripts/syscall.tbl
\ No newline at end of file
diff -Nrup linux-6.16.7/arch/powerpc/configs/kvm_guest.config linux-lenovo-x13s-linux-6.16.y/arch/powerpc/configs/kvm_guest.config
--- linux-6.16.7/arch/powerpc/configs/kvm_guest.config	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/powerpc/configs/kvm_guest.config	2025-09-11 09:47:42.000000000 -0600
@@ -1,35 +1 @@
-# Help: Bootable as a KVM guest
-CONFIG_NET=y
-CONFIG_NET_CORE=y
-CONFIG_NETDEVICES=y
-CONFIG_BLOCK=y
-CONFIG_BLK_DEV=y
-CONFIG_NETWORK_FILESYSTEMS=y
-CONFIG_INET=y
-CONFIG_TTY=y
-CONFIG_SERIAL_8250=y
-CONFIG_SERIAL_8250_CONSOLE=y
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-CONFIG_BINFMT_ELF=y
-CONFIG_PCI=y
-CONFIG_PCI_MSI=y
-CONFIG_DEBUG_KERNEL=y
-CONFIG_VIRTUALIZATION=y
-CONFIG_HYPERVISOR_GUEST=y
-CONFIG_PARAVIRT=y
-CONFIG_KVM_GUEST=y
-CONFIG_S390_GUEST=y
-CONFIG_VIRTIO=y
-CONFIG_VIRTIO_MENU=y
-CONFIG_VIRTIO_PCI=y
-CONFIG_VIRTIO_BLK=y
-CONFIG_VIRTIO_CONSOLE=y
-CONFIG_VIRTIO_NET=y
-CONFIG_9P_FS=y
-CONFIG_NET_9P=y
-CONFIG_NET_9P_VIRTIO=y
-CONFIG_SCSI_LOWLEVEL=y
-CONFIG_SCSI_VIRTIO=y
-CONFIG_VIRTIO_INPUT=y
-CONFIG_DRM_VIRTIO_GPU=y
+../../../kernel/configs/kvm_guest.config
\ No newline at end of file
diff -Nrup linux-6.16.7/arch/sparc/mm/init_64.c linux-lenovo-x13s-linux-6.16.y/arch/sparc/mm/init_64.c
--- linux-6.16.7/arch/sparc/mm/init_64.c	2025-09-13 16:15:37.959497541 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/sparc/mm/init_64.c	2025-09-11 09:47:42.000000000 -0600
@@ -3068,11 +3068,11 @@ static inline resource_size_t compute_ke
 static void __init kernel_lds_init(void)
 {
 	code_resource.start = compute_kern_paddr(_text);
-	code_resource.end   = compute_kern_paddr(_etext) - 1;
+	code_resource.end   = compute_kern_paddr(_etext - 1);
 	data_resource.start = compute_kern_paddr(_etext);
-	data_resource.end   = compute_kern_paddr(_edata) - 1;
+	data_resource.end   = compute_kern_paddr(_edata - 1);
 	bss_resource.start  = compute_kern_paddr(__bss_start);
-	bss_resource.end    = compute_kern_paddr(_end) - 1;
+	bss_resource.end    = compute_kern_paddr(_end - 1);
 }
 
 static int __init report_memory(void)
diff -Nrup linux-6.16.7/arch/sparc/mm/init_64.c.orig linux-lenovo-x13s-linux-6.16.y/arch/sparc/mm/init_64.c.orig
--- linux-6.16.7/arch/sparc/mm/init_64.c.orig	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/sparc/mm/init_64.c.orig	1969-12-31 17:00:00.000000000 -0700
@@ -1,3214 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- *  arch/sparc64/mm/init.c
- *
- *  Copyright (C) 1996-1999 David S. Miller (davem@caip.rutgers.edu)
- *  Copyright (C) 1997-1999 Jakub Jelinek (jj@sunsite.mff.cuni.cz)
- */
- 
-#include <linux/extable.h>
-#include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/string.h>
-#include <linux/init.h>
-#include <linux/memblock.h>
-#include <linux/mm.h>
-#include <linux/hugetlb.h>
-#include <linux/initrd.h>
-#include <linux/swap.h>
-#include <linux/pagemap.h>
-#include <linux/poison.h>
-#include <linux/fs.h>
-#include <linux/seq_file.h>
-#include <linux/kprobes.h>
-#include <linux/cache.h>
-#include <linux/sort.h>
-#include <linux/ioport.h>
-#include <linux/percpu.h>
-#include <linux/mmzone.h>
-#include <linux/gfp.h>
-#include <linux/bootmem_info.h>
-
-#include <asm/head.h>
-#include <asm/page.h>
-#include <asm/pgalloc.h>
-#include <asm/oplib.h>
-#include <asm/iommu.h>
-#include <asm/io.h>
-#include <linux/uaccess.h>
-#include <asm/mmu_context.h>
-#include <asm/tlbflush.h>
-#include <asm/dma.h>
-#include <asm/starfire.h>
-#include <asm/tlb.h>
-#include <asm/spitfire.h>
-#include <asm/sections.h>
-#include <asm/tsb.h>
-#include <asm/hypervisor.h>
-#include <asm/prom.h>
-#include <asm/mdesc.h>
-#include <asm/cpudata.h>
-#include <asm/setup.h>
-#include <asm/irq.h>
-
-#include "init_64.h"
-
-unsigned long kern_linear_pte_xor[4] __read_mostly;
-static unsigned long page_cache4v_flag;
-
-/* A bitmap, two bits for every 256MB of physical memory.  These two
- * bits determine what page size we use for kernel linear
- * translations.  They form an index into kern_linear_pte_xor[].  The
- * value in the indexed slot is XOR'd with the TLB miss virtual
- * address to form the resulting TTE.  The mapping is:
- *
- *	0	==>	4MB
- *	1	==>	256MB
- *	2	==>	2GB
- *	3	==>	16GB
- *
- * All sun4v chips support 256MB pages.  Only SPARC-T4 and later
- * support 2GB pages, and hopefully future cpus will support the 16GB
- * pages as well.  For slots 2 and 3, we encode a 256MB TTE xor there
- * if these larger page sizes are not supported by the cpu.
- *
- * It would be nice to determine this from the machine description
- * 'cpu' properties, but we need to have this table setup before the
- * MDESC is initialized.
- */
-
-#ifndef CONFIG_DEBUG_PAGEALLOC
-/* A special kernel TSB for 4MB, 256MB, 2GB and 16GB linear mappings.
- * Space is allocated for this right after the trap table in
- * arch/sparc64/kernel/head.S
- */
-extern struct tsb swapper_4m_tsb[KERNEL_TSB4M_NENTRIES];
-#endif
-extern struct tsb swapper_tsb[KERNEL_TSB_NENTRIES];
-
-static unsigned long cpu_pgsz_mask;
-
-#define MAX_BANKS	1024
-
-static struct linux_prom64_registers pavail[MAX_BANKS];
-static int pavail_ents;
-
-u64 numa_latency[MAX_NUMNODES][MAX_NUMNODES];
-
-static int cmp_p64(const void *a, const void *b)
-{
-	const struct linux_prom64_registers *x = a, *y = b;
-
-	if (x->phys_addr > y->phys_addr)
-		return 1;
-	if (x->phys_addr < y->phys_addr)
-		return -1;
-	return 0;
-}
-
-static void __init read_obp_memory(const char *property,
-				   struct linux_prom64_registers *regs,
-				   int *num_ents)
-{
-	phandle node = prom_finddevice("/memory");
-	int prop_size = prom_getproplen(node, property);
-	int ents, ret, i;
-
-	ents = prop_size / sizeof(struct linux_prom64_registers);
-	if (ents > MAX_BANKS) {
-		prom_printf("The machine has more %s property entries than "
-			    "this kernel can support (%d).\n",
-			    property, MAX_BANKS);
-		prom_halt();
-	}
-
-	ret = prom_getproperty(node, property, (char *) regs, prop_size);
-	if (ret == -1) {
-		prom_printf("Couldn't get %s property from /memory.\n",
-				property);
-		prom_halt();
-	}
-
-	/* Sanitize what we got from the firmware, by page aligning
-	 * everything.
-	 */
-	for (i = 0; i < ents; i++) {
-		unsigned long base, size;
-
-		base = regs[i].phys_addr;
-		size = regs[i].reg_size;
-
-		size &= PAGE_MASK;
-		if (base & ~PAGE_MASK) {
-			unsigned long new_base = PAGE_ALIGN(base);
-
-			size -= new_base - base;
-			if ((long) size < 0L)
-				size = 0UL;
-			base = new_base;
-		}
-		if (size == 0UL) {
-			/* If it is empty, simply get rid of it.
-			 * This simplifies the logic of the other
-			 * functions that process these arrays.
-			 */
-			memmove(&regs[i], &regs[i + 1],
-				(ents - i - 1) * sizeof(regs[0]));
-			i--;
-			ents--;
-			continue;
-		}
-		regs[i].phys_addr = base;
-		regs[i].reg_size = size;
-	}
-
-	*num_ents = ents;
-
-	sort(regs, ents, sizeof(struct linux_prom64_registers),
-	     cmp_p64, NULL);
-}
-
-/* Kernel physical address base and size in bytes.  */
-unsigned long kern_base __read_mostly;
-unsigned long kern_size __read_mostly;
-
-/* Initial ramdisk setup */
-extern unsigned long sparc_ramdisk_image64;
-extern unsigned int sparc_ramdisk_image;
-extern unsigned int sparc_ramdisk_size;
-
-struct page *mem_map_zero __read_mostly;
-EXPORT_SYMBOL(mem_map_zero);
-
-unsigned int sparc64_highest_unlocked_tlb_ent __read_mostly;
-
-unsigned long sparc64_kern_pri_context __read_mostly;
-unsigned long sparc64_kern_pri_nuc_bits __read_mostly;
-unsigned long sparc64_kern_sec_context __read_mostly;
-
-int num_kernel_image_mappings;
-
-#ifdef CONFIG_DEBUG_DCFLUSH
-atomic_t dcpage_flushes = ATOMIC_INIT(0);
-#ifdef CONFIG_SMP
-atomic_t dcpage_flushes_xcall = ATOMIC_INIT(0);
-#endif
-#endif
-
-inline void flush_dcache_folio_impl(struct folio *folio)
-{
-	unsigned int i, nr = folio_nr_pages(folio);
-
-	BUG_ON(tlb_type == hypervisor);
-#ifdef CONFIG_DEBUG_DCFLUSH
-	atomic_inc(&dcpage_flushes);
-#endif
-
-#ifdef DCACHE_ALIASING_POSSIBLE
-	for (i = 0; i < nr; i++)
-		__flush_dcache_page(folio_address(folio) + i * PAGE_SIZE,
-				    ((tlb_type == spitfire) &&
-				     folio_flush_mapping(folio) != NULL));
-#else
-	if (folio_flush_mapping(folio) != NULL &&
-	    tlb_type == spitfire) {
-		for (i = 0; i < nr; i++)
-			__flush_icache_page((pfn + i) * PAGE_SIZE);
-	}
-#endif
-}
-
-#define PG_dcache_dirty		PG_arch_1
-#define PG_dcache_cpu_shift	32UL
-#define PG_dcache_cpu_mask	\
-	((1UL<<ilog2(roundup_pow_of_two(NR_CPUS)))-1UL)
-
-#define dcache_dirty_cpu(folio) \
-	(((folio)->flags >> PG_dcache_cpu_shift) & PG_dcache_cpu_mask)
-
-static inline void set_dcache_dirty(struct folio *folio, int this_cpu)
-{
-	unsigned long mask = this_cpu;
-	unsigned long non_cpu_bits;
-
-	non_cpu_bits = ~(PG_dcache_cpu_mask << PG_dcache_cpu_shift);
-	mask = (mask << PG_dcache_cpu_shift) | (1UL << PG_dcache_dirty);
-
-	__asm__ __volatile__("1:\n\t"
-			     "ldx	[%2], %%g7\n\t"
-			     "and	%%g7, %1, %%g1\n\t"
-			     "or	%%g1, %0, %%g1\n\t"
-			     "casx	[%2], %%g7, %%g1\n\t"
-			     "cmp	%%g7, %%g1\n\t"
-			     "bne,pn	%%xcc, 1b\n\t"
-			     " nop"
-			     : /* no outputs */
-			     : "r" (mask), "r" (non_cpu_bits), "r" (&folio->flags)
-			     : "g1", "g7");
-}
-
-static inline void clear_dcache_dirty_cpu(struct folio *folio, unsigned long cpu)
-{
-	unsigned long mask = (1UL << PG_dcache_dirty);
-
-	__asm__ __volatile__("! test_and_clear_dcache_dirty\n"
-			     "1:\n\t"
-			     "ldx	[%2], %%g7\n\t"
-			     "srlx	%%g7, %4, %%g1\n\t"
-			     "and	%%g1, %3, %%g1\n\t"
-			     "cmp	%%g1, %0\n\t"
-			     "bne,pn	%%icc, 2f\n\t"
-			     " andn	%%g7, %1, %%g1\n\t"
-			     "casx	[%2], %%g7, %%g1\n\t"
-			     "cmp	%%g7, %%g1\n\t"
-			     "bne,pn	%%xcc, 1b\n\t"
-			     " nop\n"
-			     "2:"
-			     : /* no outputs */
-			     : "r" (cpu), "r" (mask), "r" (&folio->flags),
-			       "i" (PG_dcache_cpu_mask),
-			       "i" (PG_dcache_cpu_shift)
-			     : "g1", "g7");
-}
-
-static inline void tsb_insert(struct tsb *ent, unsigned long tag, unsigned long pte)
-{
-	unsigned long tsb_addr = (unsigned long) ent;
-
-	if (tlb_type == cheetah_plus || tlb_type == hypervisor)
-		tsb_addr = __pa(tsb_addr);
-
-	__tsb_insert(tsb_addr, tag, pte);
-}
-
-unsigned long _PAGE_ALL_SZ_BITS __read_mostly;
-
-static void flush_dcache(unsigned long pfn)
-{
-	struct page *page;
-
-	page = pfn_to_page(pfn);
-	if (page) {
-		struct folio *folio = page_folio(page);
-		unsigned long pg_flags;
-
-		pg_flags = folio->flags;
-		if (pg_flags & (1UL << PG_dcache_dirty)) {
-			int cpu = ((pg_flags >> PG_dcache_cpu_shift) &
-				   PG_dcache_cpu_mask);
-			int this_cpu = get_cpu();
-
-			/* This is just to optimize away some function calls
-			 * in the SMP case.
-			 */
-			if (cpu == this_cpu)
-				flush_dcache_folio_impl(folio);
-			else
-				smp_flush_dcache_folio_impl(folio, cpu);
-
-			clear_dcache_dirty_cpu(folio, cpu);
-
-			put_cpu();
-		}
-	}
-}
-
-/* mm->context.lock must be held */
-static void __update_mmu_tsb_insert(struct mm_struct *mm, unsigned long tsb_index,
-				    unsigned long tsb_hash_shift, unsigned long address,
-				    unsigned long tte)
-{
-	struct tsb *tsb = mm->context.tsb_block[tsb_index].tsb;
-	unsigned long tag;
-
-	if (unlikely(!tsb))
-		return;
-
-	tsb += ((address >> tsb_hash_shift) &
-		(mm->context.tsb_block[tsb_index].tsb_nentries - 1UL));
-	tag = (address >> 22UL);
-	tsb_insert(tsb, tag, tte);
-}
-
-#ifdef CONFIG_HUGETLB_PAGE
-static int __init hugetlbpage_init(void)
-{
-	hugetlb_add_hstate(HPAGE_64K_SHIFT - PAGE_SHIFT);
-	hugetlb_add_hstate(HPAGE_SHIFT - PAGE_SHIFT);
-	hugetlb_add_hstate(HPAGE_256MB_SHIFT - PAGE_SHIFT);
-	hugetlb_add_hstate(HPAGE_2GB_SHIFT - PAGE_SHIFT);
-
-	return 0;
-}
-
-arch_initcall(hugetlbpage_init);
-
-static void __init pud_huge_patch(void)
-{
-	struct pud_huge_patch_entry *p;
-	unsigned long addr;
-
-	p = &__pud_huge_patch;
-	addr = p->addr;
-	*(unsigned int *)addr = p->insn;
-
-	__asm__ __volatile__("flush %0" : : "r" (addr));
-}
-
-bool __init arch_hugetlb_valid_size(unsigned long size)
-{
-	unsigned int hugepage_shift = ilog2(size);
-	unsigned short hv_pgsz_idx;
-	unsigned int hv_pgsz_mask;
-
-	switch (hugepage_shift) {
-	case HPAGE_16GB_SHIFT:
-		hv_pgsz_mask = HV_PGSZ_MASK_16GB;
-		hv_pgsz_idx = HV_PGSZ_IDX_16GB;
-		pud_huge_patch();
-		break;
-	case HPAGE_2GB_SHIFT:
-		hv_pgsz_mask = HV_PGSZ_MASK_2GB;
-		hv_pgsz_idx = HV_PGSZ_IDX_2GB;
-		break;
-	case HPAGE_256MB_SHIFT:
-		hv_pgsz_mask = HV_PGSZ_MASK_256MB;
-		hv_pgsz_idx = HV_PGSZ_IDX_256MB;
-		break;
-	case HPAGE_SHIFT:
-		hv_pgsz_mask = HV_PGSZ_MASK_4MB;
-		hv_pgsz_idx = HV_PGSZ_IDX_4MB;
-		break;
-	case HPAGE_64K_SHIFT:
-		hv_pgsz_mask = HV_PGSZ_MASK_64K;
-		hv_pgsz_idx = HV_PGSZ_IDX_64K;
-		break;
-	default:
-		hv_pgsz_mask = 0;
-	}
-
-	if ((hv_pgsz_mask & cpu_pgsz_mask) == 0U)
-		return false;
-
-	return true;
-}
-#endif	/* CONFIG_HUGETLB_PAGE */
-
-void update_mmu_cache_range(struct vm_fault *vmf, struct vm_area_struct *vma,
-		unsigned long address, pte_t *ptep, unsigned int nr)
-{
-	struct mm_struct *mm;
-	unsigned long flags;
-	bool is_huge_tsb;
-	pte_t pte = *ptep;
-	unsigned int i;
-
-	if (tlb_type != hypervisor) {
-		unsigned long pfn = pte_pfn(pte);
-
-		if (pfn_valid(pfn))
-			flush_dcache(pfn);
-	}
-
-	mm = vma->vm_mm;
-
-	/* Don't insert a non-valid PTE into the TSB, we'll deadlock.  */
-	if (!pte_accessible(mm, pte))
-		return;
-
-	spin_lock_irqsave(&mm->context.lock, flags);
-
-	is_huge_tsb = false;
-#if defined(CONFIG_HUGETLB_PAGE) || defined(CONFIG_TRANSPARENT_HUGEPAGE)
-	if (mm->context.hugetlb_pte_count || mm->context.thp_pte_count) {
-		unsigned long hugepage_size = PAGE_SIZE;
-
-		if (is_vm_hugetlb_page(vma))
-			hugepage_size = huge_page_size(hstate_vma(vma));
-
-		if (hugepage_size >= PUD_SIZE) {
-			unsigned long mask = 0x1ffc00000UL;
-
-			/* Transfer bits [32:22] from address to resolve
-			 * at 4M granularity.
-			 */
-			pte_val(pte) &= ~mask;
-			pte_val(pte) |= (address & mask);
-		} else if (hugepage_size >= PMD_SIZE) {
-			/* We are fabricating 8MB pages using 4MB
-			 * real hw pages.
-			 */
-			pte_val(pte) |= (address & (1UL << REAL_HPAGE_SHIFT));
-		}
-
-		if (hugepage_size >= PMD_SIZE) {
-			__update_mmu_tsb_insert(mm, MM_TSB_HUGE,
-				REAL_HPAGE_SHIFT, address, pte_val(pte));
-			is_huge_tsb = true;
-		}
-	}
-#endif
-	if (!is_huge_tsb) {
-		for (i = 0; i < nr; i++) {
-			__update_mmu_tsb_insert(mm, MM_TSB_BASE, PAGE_SHIFT,
-						address, pte_val(pte));
-			address += PAGE_SIZE;
-			pte_val(pte) += PAGE_SIZE;
-		}
-	}
-
-	spin_unlock_irqrestore(&mm->context.lock, flags);
-}
-
-void flush_dcache_folio(struct folio *folio)
-{
-	unsigned long pfn = folio_pfn(folio);
-	struct address_space *mapping;
-	int this_cpu;
-
-	if (tlb_type == hypervisor)
-		return;
-
-	/* Do not bother with the expensive D-cache flush if it
-	 * is merely the zero page.  The 'bigcore' testcase in GDB
-	 * causes this case to run millions of times.
-	 */
-	if (is_zero_pfn(pfn))
-		return;
-
-	this_cpu = get_cpu();
-
-	mapping = folio_flush_mapping(folio);
-	if (mapping && !mapping_mapped(mapping)) {
-		bool dirty = test_bit(PG_dcache_dirty, &folio->flags);
-		if (dirty) {
-			int dirty_cpu = dcache_dirty_cpu(folio);
-
-			if (dirty_cpu == this_cpu)
-				goto out;
-			smp_flush_dcache_folio_impl(folio, dirty_cpu);
-		}
-		set_dcache_dirty(folio, this_cpu);
-	} else {
-		/* We could delay the flush for the !folio_mapping
-		 * case too.  But that case is for exec env/arg
-		 * pages and those are %99 certainly going to get
-		 * faulted into the tlb (and thus flushed) anyways.
-		 */
-		flush_dcache_folio_impl(folio);
-	}
-
-out:
-	put_cpu();
-}
-EXPORT_SYMBOL(flush_dcache_folio);
-
-void __kprobes flush_icache_range(unsigned long start, unsigned long end)
-{
-	/* Cheetah and Hypervisor platform cpus have coherent I-cache. */
-	if (tlb_type == spitfire) {
-		unsigned long kaddr;
-
-		/* This code only runs on Spitfire cpus so this is
-		 * why we can assume _PAGE_PADDR_4U.
-		 */
-		for (kaddr = start; kaddr < end; kaddr += PAGE_SIZE) {
-			unsigned long paddr, mask = _PAGE_PADDR_4U;
-
-			if (kaddr >= PAGE_OFFSET)
-				paddr = kaddr & mask;
-			else {
-				pte_t *ptep = virt_to_kpte(kaddr);
-
-				paddr = pte_val(*ptep) & mask;
-			}
-			__flush_icache_page(paddr);
-		}
-	}
-}
-EXPORT_SYMBOL(flush_icache_range);
-
-void mmu_info(struct seq_file *m)
-{
-	static const char *pgsz_strings[] = {
-		"8K", "64K", "512K", "4MB", "32MB",
-		"256MB", "2GB", "16GB",
-	};
-	int i, printed;
-
-	if (tlb_type == cheetah)
-		seq_printf(m, "MMU Type\t: Cheetah\n");
-	else if (tlb_type == cheetah_plus)
-		seq_printf(m, "MMU Type\t: Cheetah+\n");
-	else if (tlb_type == spitfire)
-		seq_printf(m, "MMU Type\t: Spitfire\n");
-	else if (tlb_type == hypervisor)
-		seq_printf(m, "MMU Type\t: Hypervisor (sun4v)\n");
-	else
-		seq_printf(m, "MMU Type\t: ???\n");
-
-	seq_printf(m, "MMU PGSZs\t: ");
-	printed = 0;
-	for (i = 0; i < ARRAY_SIZE(pgsz_strings); i++) {
-		if (cpu_pgsz_mask & (1UL << i)) {
-			seq_printf(m, "%s%s",
-				   printed ? "," : "", pgsz_strings[i]);
-			printed++;
-		}
-	}
-	seq_putc(m, '\n');
-
-#ifdef CONFIG_DEBUG_DCFLUSH
-	seq_printf(m, "DCPageFlushes\t: %d\n",
-		   atomic_read(&dcpage_flushes));
-#ifdef CONFIG_SMP
-	seq_printf(m, "DCPageFlushesXC\t: %d\n",
-		   atomic_read(&dcpage_flushes_xcall));
-#endif /* CONFIG_SMP */
-#endif /* CONFIG_DEBUG_DCFLUSH */
-}
-
-struct linux_prom_translation prom_trans[512] __read_mostly;
-unsigned int prom_trans_ents __read_mostly;
-
-unsigned long kern_locked_tte_data;
-
-/* The obp translations are saved based on 8k pagesize, since obp can
- * use a mixture of pagesizes. Misses to the LOW_OBP_ADDRESS ->
- * HI_OBP_ADDRESS range are handled in ktlb.S.
- */
-static inline int in_obp_range(unsigned long vaddr)
-{
-	return (vaddr >= LOW_OBP_ADDRESS &&
-		vaddr < HI_OBP_ADDRESS);
-}
-
-static int cmp_ptrans(const void *a, const void *b)
-{
-	const struct linux_prom_translation *x = a, *y = b;
-
-	if (x->virt > y->virt)
-		return 1;
-	if (x->virt < y->virt)
-		return -1;
-	return 0;
-}
-
-/* Read OBP translations property into 'prom_trans[]'.  */
-static void __init read_obp_translations(void)
-{
-	int n, node, ents, first, last, i;
-
-	node = prom_finddevice("/virtual-memory");
-	n = prom_getproplen(node, "translations");
-	if (unlikely(n == 0 || n == -1)) {
-		prom_printf("prom_mappings: Couldn't get size.\n");
-		prom_halt();
-	}
-	if (unlikely(n > sizeof(prom_trans))) {
-		prom_printf("prom_mappings: Size %d is too big.\n", n);
-		prom_halt();
-	}
-
-	if ((n = prom_getproperty(node, "translations",
-				  (char *)&prom_trans[0],
-				  sizeof(prom_trans))) == -1) {
-		prom_printf("prom_mappings: Couldn't get property.\n");
-		prom_halt();
-	}
-
-	n = n / sizeof(struct linux_prom_translation);
-
-	ents = n;
-
-	sort(prom_trans, ents, sizeof(struct linux_prom_translation),
-	     cmp_ptrans, NULL);
-
-	/* Now kick out all the non-OBP entries.  */
-	for (i = 0; i < ents; i++) {
-		if (in_obp_range(prom_trans[i].virt))
-			break;
-	}
-	first = i;
-	for (; i < ents; i++) {
-		if (!in_obp_range(prom_trans[i].virt))
-			break;
-	}
-	last = i;
-
-	for (i = 0; i < (last - first); i++) {
-		struct linux_prom_translation *src = &prom_trans[i + first];
-		struct linux_prom_translation *dest = &prom_trans[i];
-
-		*dest = *src;
-	}
-	for (; i < ents; i++) {
-		struct linux_prom_translation *dest = &prom_trans[i];
-		dest->virt = dest->size = dest->data = 0x0UL;
-	}
-
-	prom_trans_ents = last - first;
-
-	if (tlb_type == spitfire) {
-		/* Clear diag TTE bits. */
-		for (i = 0; i < prom_trans_ents; i++)
-			prom_trans[i].data &= ~0x0003fe0000000000UL;
-	}
-
-	/* Force execute bit on.  */
-	for (i = 0; i < prom_trans_ents; i++)
-		prom_trans[i].data |= (tlb_type == hypervisor ?
-				       _PAGE_EXEC_4V : _PAGE_EXEC_4U);
-}
-
-static void __init hypervisor_tlb_lock(unsigned long vaddr,
-				       unsigned long pte,
-				       unsigned long mmu)
-{
-	unsigned long ret = sun4v_mmu_map_perm_addr(vaddr, 0, pte, mmu);
-
-	if (ret != 0) {
-		prom_printf("hypervisor_tlb_lock[%lx:%x:%lx:%lx]: "
-			    "errors with %lx\n", vaddr, 0, pte, mmu, ret);
-		prom_halt();
-	}
-}
-
-static unsigned long kern_large_tte(unsigned long paddr);
-
-static void __init remap_kernel(void)
-{
-	unsigned long phys_page, tte_vaddr, tte_data;
-	int i, tlb_ent = sparc64_highest_locked_tlbent();
-
-	tte_vaddr = (unsigned long) KERNBASE;
-	phys_page = (prom_boot_mapping_phys_low >> ILOG2_4MB) << ILOG2_4MB;
-	tte_data = kern_large_tte(phys_page);
-
-	kern_locked_tte_data = tte_data;
-
-	/* Now lock us into the TLBs via Hypervisor or OBP. */
-	if (tlb_type == hypervisor) {
-		for (i = 0; i < num_kernel_image_mappings; i++) {
-			hypervisor_tlb_lock(tte_vaddr, tte_data, HV_MMU_DMMU);
-			hypervisor_tlb_lock(tte_vaddr, tte_data, HV_MMU_IMMU);
-			tte_vaddr += 0x400000;
-			tte_data += 0x400000;
-		}
-	} else {
-		for (i = 0; i < num_kernel_image_mappings; i++) {
-			prom_dtlb_load(tlb_ent - i, tte_data, tte_vaddr);
-			prom_itlb_load(tlb_ent - i, tte_data, tte_vaddr);
-			tte_vaddr += 0x400000;
-			tte_data += 0x400000;
-		}
-		sparc64_highest_unlocked_tlb_ent = tlb_ent - i;
-	}
-	if (tlb_type == cheetah_plus) {
-		sparc64_kern_pri_context = (CTX_CHEETAH_PLUS_CTX0 |
-					    CTX_CHEETAH_PLUS_NUC);
-		sparc64_kern_pri_nuc_bits = CTX_CHEETAH_PLUS_NUC;
-		sparc64_kern_sec_context = CTX_CHEETAH_PLUS_CTX0;
-	}
-}
-
-
-static void __init inherit_prom_mappings(void)
-{
-	/* Now fixup OBP's idea about where we really are mapped. */
-	printk("Remapping the kernel... ");
-	remap_kernel();
-	printk("done.\n");
-}
-
-void prom_world(int enter)
-{
-	/*
-	 * No need to change the address space any more, just flush
-	 * the register windows
-	 */
-	__asm__ __volatile__("flushw");
-}
-
-void __flush_dcache_range(unsigned long start, unsigned long end)
-{
-	unsigned long va;
-
-	if (tlb_type == spitfire) {
-		int n = 0;
-
-		for (va = start; va < end; va += 32) {
-			spitfire_put_dcache_tag(va & 0x3fe0, 0x0);
-			if (++n >= 512)
-				break;
-		}
-	} else if (tlb_type == cheetah || tlb_type == cheetah_plus) {
-		start = __pa(start);
-		end = __pa(end);
-		for (va = start; va < end; va += 32)
-			__asm__ __volatile__("stxa %%g0, [%0] %1\n\t"
-					     "membar #Sync"
-					     : /* no outputs */
-					     : "r" (va),
-					       "i" (ASI_DCACHE_INVALIDATE));
-	}
-}
-EXPORT_SYMBOL(__flush_dcache_range);
-
-/* get_new_mmu_context() uses "cache + 1".  */
-DEFINE_SPINLOCK(ctx_alloc_lock);
-unsigned long tlb_context_cache = CTX_FIRST_VERSION;
-#define MAX_CTX_NR	(1UL << CTX_NR_BITS)
-#define CTX_BMAP_SLOTS	BITS_TO_LONGS(MAX_CTX_NR)
-DECLARE_BITMAP(mmu_context_bmap, MAX_CTX_NR);
-DEFINE_PER_CPU(struct mm_struct *, per_cpu_secondary_mm) = {0};
-
-static void mmu_context_wrap(void)
-{
-	unsigned long old_ver = tlb_context_cache & CTX_VERSION_MASK;
-	unsigned long new_ver, new_ctx, old_ctx;
-	struct mm_struct *mm;
-	int cpu;
-
-	bitmap_zero(mmu_context_bmap, 1 << CTX_NR_BITS);
-
-	/* Reserve kernel context */
-	set_bit(0, mmu_context_bmap);
-
-	new_ver = (tlb_context_cache & CTX_VERSION_MASK) + CTX_FIRST_VERSION;
-	if (unlikely(new_ver == 0))
-		new_ver = CTX_FIRST_VERSION;
-	tlb_context_cache = new_ver;
-
-	/*
-	 * Make sure that any new mm that are added into per_cpu_secondary_mm,
-	 * are going to go through get_new_mmu_context() path.
-	 */
-	mb();
-
-	/*
-	 * Updated versions to current on those CPUs that had valid secondary
-	 * contexts
-	 */
-	for_each_online_cpu(cpu) {
-		/*
-		 * If a new mm is stored after we took this mm from the array,
-		 * it will go into get_new_mmu_context() path, because we
-		 * already bumped the version in tlb_context_cache.
-		 */
-		mm = per_cpu(per_cpu_secondary_mm, cpu);
-
-		if (unlikely(!mm || mm == &init_mm))
-			continue;
-
-		old_ctx = mm->context.sparc64_ctx_val;
-		if (likely((old_ctx & CTX_VERSION_MASK) == old_ver)) {
-			new_ctx = (old_ctx & ~CTX_VERSION_MASK) | new_ver;
-			set_bit(new_ctx & CTX_NR_MASK, mmu_context_bmap);
-			mm->context.sparc64_ctx_val = new_ctx;
-		}
-	}
-}
-
-/* Caller does TLB context flushing on local CPU if necessary.
- * The caller also ensures that CTX_VALID(mm->context) is false.
- *
- * We must be careful about boundary cases so that we never
- * let the user have CTX 0 (nucleus) or we ever use a CTX
- * version of zero (and thus NO_CONTEXT would not be caught
- * by version mis-match tests in mmu_context.h).
- *
- * Always invoked with interrupts disabled.
- */
-void get_new_mmu_context(struct mm_struct *mm)
-{
-	unsigned long ctx, new_ctx;
-	unsigned long orig_pgsz_bits;
-
-	spin_lock(&ctx_alloc_lock);
-retry:
-	/* wrap might have happened, test again if our context became valid */
-	if (unlikely(CTX_VALID(mm->context)))
-		goto out;
-	orig_pgsz_bits = (mm->context.sparc64_ctx_val & CTX_PGSZ_MASK);
-	ctx = (tlb_context_cache + 1) & CTX_NR_MASK;
-	new_ctx = find_next_zero_bit(mmu_context_bmap, 1 << CTX_NR_BITS, ctx);
-	if (new_ctx >= (1 << CTX_NR_BITS)) {
-		new_ctx = find_next_zero_bit(mmu_context_bmap, ctx, 1);
-		if (new_ctx >= ctx) {
-			mmu_context_wrap();
-			goto retry;
-		}
-	}
-	if (mm->context.sparc64_ctx_val)
-		cpumask_clear(mm_cpumask(mm));
-	mmu_context_bmap[new_ctx>>6] |= (1UL << (new_ctx & 63));
-	new_ctx |= (tlb_context_cache & CTX_VERSION_MASK);
-	tlb_context_cache = new_ctx;
-	mm->context.sparc64_ctx_val = new_ctx | orig_pgsz_bits;
-out:
-	spin_unlock(&ctx_alloc_lock);
-}
-
-static int numa_enabled = 1;
-static int numa_debug;
-
-static int __init early_numa(char *p)
-{
-	if (!p)
-		return 0;
-
-	if (strstr(p, "off"))
-		numa_enabled = 0;
-
-	if (strstr(p, "debug"))
-		numa_debug = 1;
-
-	return 0;
-}
-early_param("numa", early_numa);
-
-#define numadbg(f, a...) \
-do {	if (numa_debug) \
-		printk(KERN_INFO f, ## a); \
-} while (0)
-
-static void __init find_ramdisk(unsigned long phys_base)
-{
-#ifdef CONFIG_BLK_DEV_INITRD
-	if (sparc_ramdisk_image || sparc_ramdisk_image64) {
-		unsigned long ramdisk_image;
-
-		/* Older versions of the bootloader only supported a
-		 * 32-bit physical address for the ramdisk image
-		 * location, stored at sparc_ramdisk_image.  Newer
-		 * SILO versions set sparc_ramdisk_image to zero and
-		 * provide a full 64-bit physical address at
-		 * sparc_ramdisk_image64.
-		 */
-		ramdisk_image = sparc_ramdisk_image;
-		if (!ramdisk_image)
-			ramdisk_image = sparc_ramdisk_image64;
-
-		/* Another bootloader quirk.  The bootloader normalizes
-		 * the physical address to KERNBASE, so we have to
-		 * factor that back out and add in the lowest valid
-		 * physical page address to get the true physical address.
-		 */
-		ramdisk_image -= KERNBASE;
-		ramdisk_image += phys_base;
-
-		numadbg("Found ramdisk at physical address 0x%lx, size %u\n",
-			ramdisk_image, sparc_ramdisk_size);
-
-		initrd_start = ramdisk_image;
-		initrd_end = ramdisk_image + sparc_ramdisk_size;
-
-		memblock_reserve(initrd_start, sparc_ramdisk_size);
-
-		initrd_start += PAGE_OFFSET;
-		initrd_end += PAGE_OFFSET;
-	}
-#endif
-}
-
-struct node_mem_mask {
-	unsigned long mask;
-	unsigned long match;
-};
-static struct node_mem_mask node_masks[MAX_NUMNODES];
-static int num_node_masks;
-
-#ifdef CONFIG_NUMA
-
-struct mdesc_mlgroup {
-	u64	node;
-	u64	latency;
-	u64	match;
-	u64	mask;
-};
-
-static struct mdesc_mlgroup *mlgroups;
-static int num_mlgroups;
-
-int numa_cpu_lookup_table[NR_CPUS];
-cpumask_t numa_cpumask_lookup_table[MAX_NUMNODES];
-
-struct mdesc_mblock {
-	u64	base;
-	u64	size;
-	u64	offset; /* RA-to-PA */
-};
-static struct mdesc_mblock *mblocks;
-static int num_mblocks;
-
-static struct mdesc_mblock * __init addr_to_mblock(unsigned long addr)
-{
-	struct mdesc_mblock *m = NULL;
-	int i;
-
-	for (i = 0; i < num_mblocks; i++) {
-		m = &mblocks[i];
-
-		if (addr >= m->base &&
-		    addr < (m->base + m->size)) {
-			break;
-		}
-	}
-
-	return m;
-}
-
-static u64 __init memblock_nid_range_sun4u(u64 start, u64 end, int *nid)
-{
-	int prev_nid, new_nid;
-
-	prev_nid = NUMA_NO_NODE;
-	for ( ; start < end; start += PAGE_SIZE) {
-		for (new_nid = 0; new_nid < num_node_masks; new_nid++) {
-			struct node_mem_mask *p = &node_masks[new_nid];
-
-			if ((start & p->mask) == p->match) {
-				if (prev_nid == NUMA_NO_NODE)
-					prev_nid = new_nid;
-				break;
-			}
-		}
-
-		if (new_nid == num_node_masks) {
-			prev_nid = 0;
-			WARN_ONCE(1, "addr[%Lx] doesn't match a NUMA node rule. Some memory will be owned by node 0.",
-				  start);
-			break;
-		}
-
-		if (prev_nid != new_nid)
-			break;
-	}
-	*nid = prev_nid;
-
-	return start > end ? end : start;
-}
-
-static u64 __init memblock_nid_range(u64 start, u64 end, int *nid)
-{
-	u64 ret_end, pa_start, m_mask, m_match, m_end;
-	struct mdesc_mblock *mblock;
-	int _nid, i;
-
-	if (tlb_type != hypervisor)
-		return memblock_nid_range_sun4u(start, end, nid);
-
-	mblock = addr_to_mblock(start);
-	if (!mblock) {
-		WARN_ONCE(1, "memblock_nid_range: Can't find mblock addr[%Lx]",
-			  start);
-
-		_nid = 0;
-		ret_end = end;
-		goto done;
-	}
-
-	pa_start = start + mblock->offset;
-	m_match = 0;
-	m_mask = 0;
-
-	for (_nid = 0; _nid < num_node_masks; _nid++) {
-		struct node_mem_mask *const m = &node_masks[_nid];
-
-		if ((pa_start & m->mask) == m->match) {
-			m_match = m->match;
-			m_mask = m->mask;
-			break;
-		}
-	}
-
-	if (num_node_masks == _nid) {
-		/* We could not find NUMA group, so default to 0, but lets
-		 * search for latency group, so we could calculate the correct
-		 * end address that we return
-		 */
-		_nid = 0;
-
-		for (i = 0; i < num_mlgroups; i++) {
-			struct mdesc_mlgroup *const m = &mlgroups[i];
-
-			if ((pa_start & m->mask) == m->match) {
-				m_match = m->match;
-				m_mask = m->mask;
-				break;
-			}
-		}
-
-		if (i == num_mlgroups) {
-			WARN_ONCE(1, "memblock_nid_range: Can't find latency group addr[%Lx]",
-				  start);
-
-			ret_end = end;
-			goto done;
-		}
-	}
-
-	/*
-	 * Each latency group has match and mask, and each memory block has an
-	 * offset.  An address belongs to a latency group if its address matches
-	 * the following formula: ((addr + offset) & mask) == match
-	 * It is, however, slow to check every single page if it matches a
-	 * particular latency group. As optimization we calculate end value by
-	 * using bit arithmetics.
-	 */
-	m_end = m_match + (1ul << __ffs(m_mask)) - mblock->offset;
-	m_end += pa_start & ~((1ul << fls64(m_mask)) - 1);
-	ret_end = m_end > end ? end : m_end;
-
-done:
-	*nid = _nid;
-	return ret_end;
-}
-#endif
-
-/* This must be invoked after performing all of the necessary
- * memblock_set_node() calls for 'nid'.  We need to be able to get
- * correct data from get_pfn_range_for_nid().
- */
-static void __init allocate_node_data(int nid)
-{
-	struct pglist_data *p;
-	unsigned long start_pfn, end_pfn;
-
-#ifdef CONFIG_NUMA
-	alloc_node_data(nid);
-
-	NODE_DATA(nid)->node_id = nid;
-#endif
-
-	p = NODE_DATA(nid);
-
-	get_pfn_range_for_nid(nid, &start_pfn, &end_pfn);
-	p->node_start_pfn = start_pfn;
-	p->node_spanned_pages = end_pfn - start_pfn;
-}
-
-static void init_node_masks_nonnuma(void)
-{
-#ifdef CONFIG_NUMA
-	int i;
-#endif
-
-	numadbg("Initializing tables for non-numa.\n");
-
-	node_masks[0].mask = 0;
-	node_masks[0].match = 0;
-	num_node_masks = 1;
-
-#ifdef CONFIG_NUMA
-	for (i = 0; i < NR_CPUS; i++)
-		numa_cpu_lookup_table[i] = 0;
-
-	cpumask_setall(&numa_cpumask_lookup_table[0]);
-#endif
-}
-
-#ifdef CONFIG_NUMA
-
-EXPORT_SYMBOL(numa_cpu_lookup_table);
-EXPORT_SYMBOL(numa_cpumask_lookup_table);
-
-static int scan_pio_for_cfg_handle(struct mdesc_handle *md, u64 pio,
-				   u32 cfg_handle)
-{
-	u64 arc;
-
-	mdesc_for_each_arc(arc, md, pio, MDESC_ARC_TYPE_FWD) {
-		u64 target = mdesc_arc_target(md, arc);
-		const u64 *val;
-
-		val = mdesc_get_property(md, target,
-					 "cfg-handle", NULL);
-		if (val && *val == cfg_handle)
-			return 0;
-	}
-	return -ENODEV;
-}
-
-static int scan_arcs_for_cfg_handle(struct mdesc_handle *md, u64 grp,
-				    u32 cfg_handle)
-{
-	u64 arc, candidate, best_latency = ~(u64)0;
-
-	candidate = MDESC_NODE_NULL;
-	mdesc_for_each_arc(arc, md, grp, MDESC_ARC_TYPE_FWD) {
-		u64 target = mdesc_arc_target(md, arc);
-		const char *name = mdesc_node_name(md, target);
-		const u64 *val;
-
-		if (strcmp(name, "pio-latency-group"))
-			continue;
-
-		val = mdesc_get_property(md, target, "latency", NULL);
-		if (!val)
-			continue;
-
-		if (*val < best_latency) {
-			candidate = target;
-			best_latency = *val;
-		}
-	}
-
-	if (candidate == MDESC_NODE_NULL)
-		return -ENODEV;
-
-	return scan_pio_for_cfg_handle(md, candidate, cfg_handle);
-}
-
-int of_node_to_nid(struct device_node *dp)
-{
-	const struct linux_prom64_registers *regs;
-	struct mdesc_handle *md;
-	u32 cfg_handle;
-	int count, nid;
-	u64 grp;
-
-	/* This is the right thing to do on currently supported
-	 * SUN4U NUMA platforms as well, as the PCI controller does
-	 * not sit behind any particular memory controller.
-	 */
-	if (!mlgroups)
-		return -1;
-
-	regs = of_get_property(dp, "reg", NULL);
-	if (!regs)
-		return -1;
-
-	cfg_handle = (regs->phys_addr >> 32UL) & 0x0fffffff;
-
-	md = mdesc_grab();
-
-	count = 0;
-	nid = NUMA_NO_NODE;
-	mdesc_for_each_node_by_name(md, grp, "group") {
-		if (!scan_arcs_for_cfg_handle(md, grp, cfg_handle)) {
-			nid = count;
-			break;
-		}
-		count++;
-	}
-
-	mdesc_release(md);
-
-	return nid;
-}
-
-static void __init add_node_ranges(void)
-{
-	phys_addr_t start, end;
-	unsigned long prev_max;
-	u64 i;
-
-memblock_resized:
-	prev_max = memblock.memory.max;
-
-	for_each_mem_range(i, &start, &end) {
-		while (start < end) {
-			unsigned long this_end;
-			int nid;
-
-			this_end = memblock_nid_range(start, end, &nid);
-
-			numadbg("Setting memblock NUMA node nid[%d] "
-				"start[%llx] end[%lx]\n",
-				nid, start, this_end);
-
-			memblock_set_node(start, this_end - start,
-					  &memblock.memory, nid);
-			if (memblock.memory.max != prev_max)
-				goto memblock_resized;
-			start = this_end;
-		}
-	}
-}
-
-static int __init grab_mlgroups(struct mdesc_handle *md)
-{
-	unsigned long paddr;
-	int count = 0;
-	u64 node;
-
-	mdesc_for_each_node_by_name(md, node, "memory-latency-group")
-		count++;
-	if (!count)
-		return -ENOENT;
-
-	paddr = memblock_phys_alloc(count * sizeof(struct mdesc_mlgroup),
-				    SMP_CACHE_BYTES);
-	if (!paddr)
-		return -ENOMEM;
-
-	mlgroups = __va(paddr);
-	num_mlgroups = count;
-
-	count = 0;
-	mdesc_for_each_node_by_name(md, node, "memory-latency-group") {
-		struct mdesc_mlgroup *m = &mlgroups[count++];
-		const u64 *val;
-
-		m->node = node;
-
-		val = mdesc_get_property(md, node, "latency", NULL);
-		m->latency = *val;
-		val = mdesc_get_property(md, node, "address-match", NULL);
-		m->match = *val;
-		val = mdesc_get_property(md, node, "address-mask", NULL);
-		m->mask = *val;
-
-		numadbg("MLGROUP[%d]: node[%llx] latency[%llx] "
-			"match[%llx] mask[%llx]\n",
-			count - 1, m->node, m->latency, m->match, m->mask);
-	}
-
-	return 0;
-}
-
-static int __init grab_mblocks(struct mdesc_handle *md)
-{
-	unsigned long paddr;
-	int count = 0;
-	u64 node;
-
-	mdesc_for_each_node_by_name(md, node, "mblock")
-		count++;
-	if (!count)
-		return -ENOENT;
-
-	paddr = memblock_phys_alloc(count * sizeof(struct mdesc_mblock),
-				    SMP_CACHE_BYTES);
-	if (!paddr)
-		return -ENOMEM;
-
-	mblocks = __va(paddr);
-	num_mblocks = count;
-
-	count = 0;
-	mdesc_for_each_node_by_name(md, node, "mblock") {
-		struct mdesc_mblock *m = &mblocks[count++];
-		const u64 *val;
-
-		val = mdesc_get_property(md, node, "base", NULL);
-		m->base = *val;
-		val = mdesc_get_property(md, node, "size", NULL);
-		m->size = *val;
-		val = mdesc_get_property(md, node,
-					 "address-congruence-offset", NULL);
-
-		/* The address-congruence-offset property is optional.
-		 * Explicity zero it be identifty this.
-		 */
-		if (val)
-			m->offset = *val;
-		else
-			m->offset = 0UL;
-
-		numadbg("MBLOCK[%d]: base[%llx] size[%llx] offset[%llx]\n",
-			count - 1, m->base, m->size, m->offset);
-	}
-
-	return 0;
-}
-
-static void __init numa_parse_mdesc_group_cpus(struct mdesc_handle *md,
-					       u64 grp, cpumask_t *mask)
-{
-	u64 arc;
-
-	cpumask_clear(mask);
-
-	mdesc_for_each_arc(arc, md, grp, MDESC_ARC_TYPE_BACK) {
-		u64 target = mdesc_arc_target(md, arc);
-		const char *name = mdesc_node_name(md, target);
-		const u64 *id;
-
-		if (strcmp(name, "cpu"))
-			continue;
-		id = mdesc_get_property(md, target, "id", NULL);
-		if (*id < nr_cpu_ids)
-			cpumask_set_cpu(*id, mask);
-	}
-}
-
-static struct mdesc_mlgroup * __init find_mlgroup(u64 node)
-{
-	int i;
-
-	for (i = 0; i < num_mlgroups; i++) {
-		struct mdesc_mlgroup *m = &mlgroups[i];
-		if (m->node == node)
-			return m;
-	}
-	return NULL;
-}
-
-int __node_distance(int from, int to)
-{
-	if ((from >= MAX_NUMNODES) || (to >= MAX_NUMNODES)) {
-		pr_warn("Returning default NUMA distance value for %d->%d\n",
-			from, to);
-		return (from == to) ? LOCAL_DISTANCE : REMOTE_DISTANCE;
-	}
-	return numa_latency[from][to];
-}
-EXPORT_SYMBOL(__node_distance);
-
-static int __init find_best_numa_node_for_mlgroup(struct mdesc_mlgroup *grp)
-{
-	int i;
-
-	for (i = 0; i < MAX_NUMNODES; i++) {
-		struct node_mem_mask *n = &node_masks[i];
-
-		if ((grp->mask == n->mask) && (grp->match == n->match))
-			break;
-	}
-	return i;
-}
-
-static void __init find_numa_latencies_for_group(struct mdesc_handle *md,
-						 u64 grp, int index)
-{
-	u64 arc;
-
-	mdesc_for_each_arc(arc, md, grp, MDESC_ARC_TYPE_FWD) {
-		int tnode;
-		u64 target = mdesc_arc_target(md, arc);
-		struct mdesc_mlgroup *m = find_mlgroup(target);
-
-		if (!m)
-			continue;
-		tnode = find_best_numa_node_for_mlgroup(m);
-		if (tnode == MAX_NUMNODES)
-			continue;
-		numa_latency[index][tnode] = m->latency;
-	}
-}
-
-static int __init numa_attach_mlgroup(struct mdesc_handle *md, u64 grp,
-				      int index)
-{
-	struct mdesc_mlgroup *candidate = NULL;
-	u64 arc, best_latency = ~(u64)0;
-	struct node_mem_mask *n;
-
-	mdesc_for_each_arc(arc, md, grp, MDESC_ARC_TYPE_FWD) {
-		u64 target = mdesc_arc_target(md, arc);
-		struct mdesc_mlgroup *m = find_mlgroup(target);
-		if (!m)
-			continue;
-		if (m->latency < best_latency) {
-			candidate = m;
-			best_latency = m->latency;
-		}
-	}
-	if (!candidate)
-		return -ENOENT;
-
-	if (num_node_masks != index) {
-		printk(KERN_ERR "Inconsistent NUMA state, "
-		       "index[%d] != num_node_masks[%d]\n",
-		       index, num_node_masks);
-		return -EINVAL;
-	}
-
-	n = &node_masks[num_node_masks++];
-
-	n->mask = candidate->mask;
-	n->match = candidate->match;
-
-	numadbg("NUMA NODE[%d]: mask[%lx] match[%lx] (latency[%llx])\n",
-		index, n->mask, n->match, candidate->latency);
-
-	return 0;
-}
-
-static int __init numa_parse_mdesc_group(struct mdesc_handle *md, u64 grp,
-					 int index)
-{
-	cpumask_t mask;
-	int cpu;
-
-	numa_parse_mdesc_group_cpus(md, grp, &mask);
-
-	for_each_cpu(cpu, &mask)
-		numa_cpu_lookup_table[cpu] = index;
-	cpumask_copy(&numa_cpumask_lookup_table[index], &mask);
-
-	if (numa_debug) {
-		printk(KERN_INFO "NUMA GROUP[%d]: cpus [ ", index);
-		for_each_cpu(cpu, &mask)
-			printk("%d ", cpu);
-		printk("]\n");
-	}
-
-	return numa_attach_mlgroup(md, grp, index);
-}
-
-static int __init numa_parse_mdesc(void)
-{
-	struct mdesc_handle *md = mdesc_grab();
-	int i, j, err, count;
-	u64 node;
-
-	node = mdesc_node_by_name(md, MDESC_NODE_NULL, "latency-groups");
-	if (node == MDESC_NODE_NULL) {
-		mdesc_release(md);
-		return -ENOENT;
-	}
-
-	err = grab_mblocks(md);
-	if (err < 0)
-		goto out;
-
-	err = grab_mlgroups(md);
-	if (err < 0)
-		goto out;
-
-	count = 0;
-	mdesc_for_each_node_by_name(md, node, "group") {
-		err = numa_parse_mdesc_group(md, node, count);
-		if (err < 0)
-			break;
-		count++;
-	}
-
-	count = 0;
-	mdesc_for_each_node_by_name(md, node, "group") {
-		find_numa_latencies_for_group(md, node, count);
-		count++;
-	}
-
-	/* Normalize numa latency matrix according to ACPI SLIT spec. */
-	for (i = 0; i < MAX_NUMNODES; i++) {
-		u64 self_latency = numa_latency[i][i];
-
-		for (j = 0; j < MAX_NUMNODES; j++) {
-			numa_latency[i][j] =
-				(numa_latency[i][j] * LOCAL_DISTANCE) /
-				self_latency;
-		}
-	}
-
-	add_node_ranges();
-
-	for (i = 0; i < num_node_masks; i++) {
-		allocate_node_data(i);
-		node_set_online(i);
-	}
-
-	err = 0;
-out:
-	mdesc_release(md);
-	return err;
-}
-
-static int __init numa_parse_jbus(void)
-{
-	unsigned long cpu, index;
-
-	/* NUMA node id is encoded in bits 36 and higher, and there is
-	 * a 1-to-1 mapping from CPU ID to NUMA node ID.
-	 */
-	index = 0;
-	for_each_present_cpu(cpu) {
-		numa_cpu_lookup_table[cpu] = index;
-		cpumask_copy(&numa_cpumask_lookup_table[index], cpumask_of(cpu));
-		node_masks[index].mask = ~((1UL << 36UL) - 1UL);
-		node_masks[index].match = cpu << 36UL;
-
-		index++;
-	}
-	num_node_masks = index;
-
-	add_node_ranges();
-
-	for (index = 0; index < num_node_masks; index++) {
-		allocate_node_data(index);
-		node_set_online(index);
-	}
-
-	return 0;
-}
-
-static int __init numa_parse_sun4u(void)
-{
-	if (tlb_type == cheetah || tlb_type == cheetah_plus) {
-		unsigned long ver;
-
-		__asm__ ("rdpr %%ver, %0" : "=r" (ver));
-		if ((ver >> 32UL) == __JALAPENO_ID ||
-		    (ver >> 32UL) == __SERRANO_ID)
-			return numa_parse_jbus();
-	}
-	return -1;
-}
-
-static int __init bootmem_init_numa(void)
-{
-	int i, j;
-	int err = -1;
-
-	numadbg("bootmem_init_numa()\n");
-
-	/* Some sane defaults for numa latency values */
-	for (i = 0; i < MAX_NUMNODES; i++) {
-		for (j = 0; j < MAX_NUMNODES; j++)
-			numa_latency[i][j] = (i == j) ?
-				LOCAL_DISTANCE : REMOTE_DISTANCE;
-	}
-
-	if (numa_enabled) {
-		if (tlb_type == hypervisor)
-			err = numa_parse_mdesc();
-		else
-			err = numa_parse_sun4u();
-	}
-	return err;
-}
-
-#else
-
-static int bootmem_init_numa(void)
-{
-	return -1;
-}
-
-#endif
-
-static void __init bootmem_init_nonnuma(void)
-{
-	unsigned long top_of_ram = memblock_end_of_DRAM();
-	unsigned long total_ram = memblock_phys_mem_size();
-
-	numadbg("bootmem_init_nonnuma()\n");
-
-	printk(KERN_INFO "Top of RAM: 0x%lx, Total RAM: 0x%lx\n",
-	       top_of_ram, total_ram);
-	printk(KERN_INFO "Memory hole size: %ldMB\n",
-	       (top_of_ram - total_ram) >> 20);
-
-	init_node_masks_nonnuma();
-	memblock_set_node(0, PHYS_ADDR_MAX, &memblock.memory, 0);
-	allocate_node_data(0);
-	node_set_online(0);
-}
-
-static unsigned long __init bootmem_init(unsigned long phys_base)
-{
-	unsigned long end_pfn;
-
-	end_pfn = memblock_end_of_DRAM() >> PAGE_SHIFT;
-	max_pfn = max_low_pfn = end_pfn;
-	min_low_pfn = (phys_base >> PAGE_SHIFT);
-
-	if (bootmem_init_numa() < 0)
-		bootmem_init_nonnuma();
-
-	/* Dump memblock with node info. */
-	memblock_dump_all();
-
-	/* XXX cpu notifier XXX */
-
-	sparse_init();
-
-	return end_pfn;
-}
-
-static struct linux_prom64_registers pall[MAX_BANKS] __initdata;
-static int pall_ents __initdata;
-
-static unsigned long max_phys_bits = 40;
-
-bool kern_addr_valid(unsigned long addr)
-{
-	pgd_t *pgd;
-	p4d_t *p4d;
-	pud_t *pud;
-	pmd_t *pmd;
-	pte_t *pte;
-
-	if ((long)addr < 0L) {
-		unsigned long pa = __pa(addr);
-
-		if ((pa >> max_phys_bits) != 0UL)
-			return false;
-
-		return pfn_valid(pa >> PAGE_SHIFT);
-	}
-
-	if (addr >= (unsigned long) KERNBASE &&
-	    addr < (unsigned long)&_end)
-		return true;
-
-	pgd = pgd_offset_k(addr);
-	if (pgd_none(*pgd))
-		return false;
-
-	p4d = p4d_offset(pgd, addr);
-	if (p4d_none(*p4d))
-		return false;
-
-	pud = pud_offset(p4d, addr);
-	if (pud_none(*pud))
-		return false;
-
-	if (pud_leaf(*pud))
-		return pfn_valid(pud_pfn(*pud));
-
-	pmd = pmd_offset(pud, addr);
-	if (pmd_none(*pmd))
-		return false;
-
-	if (pmd_leaf(*pmd))
-		return pfn_valid(pmd_pfn(*pmd));
-
-	pte = pte_offset_kernel(pmd, addr);
-	if (pte_none(*pte))
-		return false;
-
-	return pfn_valid(pte_pfn(*pte));
-}
-
-static unsigned long __ref kernel_map_hugepud(unsigned long vstart,
-					      unsigned long vend,
-					      pud_t *pud)
-{
-	const unsigned long mask16gb = (1UL << 34) - 1UL;
-	u64 pte_val = vstart;
-
-	/* Each PUD is 8GB */
-	if ((vstart & mask16gb) ||
-	    (vend - vstart <= mask16gb)) {
-		pte_val ^= kern_linear_pte_xor[2];
-		pud_val(*pud) = pte_val | _PAGE_PUD_HUGE;
-
-		return vstart + PUD_SIZE;
-	}
-
-	pte_val ^= kern_linear_pte_xor[3];
-	pte_val |= _PAGE_PUD_HUGE;
-
-	vend = vstart + mask16gb + 1UL;
-	while (vstart < vend) {
-		pud_val(*pud) = pte_val;
-
-		pte_val += PUD_SIZE;
-		vstart += PUD_SIZE;
-		pud++;
-	}
-	return vstart;
-}
-
-static bool kernel_can_map_hugepud(unsigned long vstart, unsigned long vend,
-				   bool guard)
-{
-	if (guard && !(vstart & ~PUD_MASK) && (vend - vstart) >= PUD_SIZE)
-		return true;
-
-	return false;
-}
-
-static unsigned long __ref kernel_map_hugepmd(unsigned long vstart,
-					      unsigned long vend,
-					      pmd_t *pmd)
-{
-	const unsigned long mask256mb = (1UL << 28) - 1UL;
-	const unsigned long mask2gb = (1UL << 31) - 1UL;
-	u64 pte_val = vstart;
-
-	/* Each PMD is 8MB */
-	if ((vstart & mask256mb) ||
-	    (vend - vstart <= mask256mb)) {
-		pte_val ^= kern_linear_pte_xor[0];
-		pmd_val(*pmd) = pte_val | _PAGE_PMD_HUGE;
-
-		return vstart + PMD_SIZE;
-	}
-
-	if ((vstart & mask2gb) ||
-	    (vend - vstart <= mask2gb)) {
-		pte_val ^= kern_linear_pte_xor[1];
-		pte_val |= _PAGE_PMD_HUGE;
-		vend = vstart + mask256mb + 1UL;
-	} else {
-		pte_val ^= kern_linear_pte_xor[2];
-		pte_val |= _PAGE_PMD_HUGE;
-		vend = vstart + mask2gb + 1UL;
-	}
-
-	while (vstart < vend) {
-		pmd_val(*pmd) = pte_val;
-
-		pte_val += PMD_SIZE;
-		vstart += PMD_SIZE;
-		pmd++;
-	}
-
-	return vstart;
-}
-
-static bool kernel_can_map_hugepmd(unsigned long vstart, unsigned long vend,
-				   bool guard)
-{
-	if (guard && !(vstart & ~PMD_MASK) && (vend - vstart) >= PMD_SIZE)
-		return true;
-
-	return false;
-}
-
-static unsigned long __ref kernel_map_range(unsigned long pstart,
-					    unsigned long pend, pgprot_t prot,
-					    bool use_huge)
-{
-	unsigned long vstart = PAGE_OFFSET + pstart;
-	unsigned long vend = PAGE_OFFSET + pend;
-	unsigned long alloc_bytes = 0UL;
-
-	if ((vstart & ~PAGE_MASK) || (vend & ~PAGE_MASK)) {
-		prom_printf("kernel_map: Unaligned physmem[%lx:%lx]\n",
-			    vstart, vend);
-		prom_halt();
-	}
-
-	while (vstart < vend) {
-		unsigned long this_end, paddr = __pa(vstart);
-		pgd_t *pgd = pgd_offset_k(vstart);
-		p4d_t *p4d;
-		pud_t *pud;
-		pmd_t *pmd;
-		pte_t *pte;
-
-		if (pgd_none(*pgd)) {
-			pud_t *new;
-
-			new = memblock_alloc_from(PAGE_SIZE, PAGE_SIZE,
-						  PAGE_SIZE);
-			if (!new)
-				goto err_alloc;
-			alloc_bytes += PAGE_SIZE;
-			pgd_populate(&init_mm, pgd, new);
-		}
-
-		p4d = p4d_offset(pgd, vstart);
-		if (p4d_none(*p4d)) {
-			pud_t *new;
-
-			new = memblock_alloc_from(PAGE_SIZE, PAGE_SIZE,
-						  PAGE_SIZE);
-			if (!new)
-				goto err_alloc;
-			alloc_bytes += PAGE_SIZE;
-			p4d_populate(&init_mm, p4d, new);
-		}
-
-		pud = pud_offset(p4d, vstart);
-		if (pud_none(*pud)) {
-			pmd_t *new;
-
-			if (kernel_can_map_hugepud(vstart, vend, use_huge)) {
-				vstart = kernel_map_hugepud(vstart, vend, pud);
-				continue;
-			}
-			new = memblock_alloc_from(PAGE_SIZE, PAGE_SIZE,
-						  PAGE_SIZE);
-			if (!new)
-				goto err_alloc;
-			alloc_bytes += PAGE_SIZE;
-			pud_populate(&init_mm, pud, new);
-		}
-
-		pmd = pmd_offset(pud, vstart);
-		if (pmd_none(*pmd)) {
-			pte_t *new;
-
-			if (kernel_can_map_hugepmd(vstart, vend, use_huge)) {
-				vstart = kernel_map_hugepmd(vstart, vend, pmd);
-				continue;
-			}
-			new = memblock_alloc_from(PAGE_SIZE, PAGE_SIZE,
-						  PAGE_SIZE);
-			if (!new)
-				goto err_alloc;
-			alloc_bytes += PAGE_SIZE;
-			pmd_populate_kernel(&init_mm, pmd, new);
-		}
-
-		pte = pte_offset_kernel(pmd, vstart);
-		this_end = (vstart + PMD_SIZE) & PMD_MASK;
-		if (this_end > vend)
-			this_end = vend;
-
-		while (vstart < this_end) {
-			pte_val(*pte) = (paddr | pgprot_val(prot));
-
-			vstart += PAGE_SIZE;
-			paddr += PAGE_SIZE;
-			pte++;
-		}
-	}
-
-	return alloc_bytes;
-
-err_alloc:
-	panic("%s: Failed to allocate %lu bytes align=%lx from=%lx\n",
-	      __func__, PAGE_SIZE, PAGE_SIZE, PAGE_SIZE);
-	return -ENOMEM;
-}
-
-static void __init flush_all_kernel_tsbs(void)
-{
-	int i;
-
-	for (i = 0; i < KERNEL_TSB_NENTRIES; i++) {
-		struct tsb *ent = &swapper_tsb[i];
-
-		ent->tag = (1UL << TSB_TAG_INVALID_BIT);
-	}
-#ifndef CONFIG_DEBUG_PAGEALLOC
-	for (i = 0; i < KERNEL_TSB4M_NENTRIES; i++) {
-		struct tsb *ent = &swapper_4m_tsb[i];
-
-		ent->tag = (1UL << TSB_TAG_INVALID_BIT);
-	}
-#endif
-}
-
-extern unsigned int kvmap_linear_patch[1];
-
-static void __init kernel_physical_mapping_init(void)
-{
-	unsigned long i, mem_alloced = 0UL;
-	bool use_huge = true;
-
-#ifdef CONFIG_DEBUG_PAGEALLOC
-	use_huge = false;
-#endif
-	for (i = 0; i < pall_ents; i++) {
-		unsigned long phys_start, phys_end;
-
-		phys_start = pall[i].phys_addr;
-		phys_end = phys_start + pall[i].reg_size;
-
-		mem_alloced += kernel_map_range(phys_start, phys_end,
-						PAGE_KERNEL, use_huge);
-	}
-
-	printk("Allocated %ld bytes for kernel page tables.\n",
-	       mem_alloced);
-
-	kvmap_linear_patch[0] = 0x01000000; /* nop */
-	flushi(&kvmap_linear_patch[0]);
-
-	flush_all_kernel_tsbs();
-
-	__flush_tlb_all();
-}
-
-#ifdef CONFIG_DEBUG_PAGEALLOC
-void __kernel_map_pages(struct page *page, int numpages, int enable)
-{
-	unsigned long phys_start = page_to_pfn(page) << PAGE_SHIFT;
-	unsigned long phys_end = phys_start + (numpages * PAGE_SIZE);
-
-	kernel_map_range(phys_start, phys_end,
-			 (enable ? PAGE_KERNEL : __pgprot(0)), false);
-
-	flush_tsb_kernel_range(PAGE_OFFSET + phys_start,
-			       PAGE_OFFSET + phys_end);
-
-	/* we should perform an IPI and flush all tlbs,
-	 * but that can deadlock->flush only current cpu.
-	 */
-	__flush_tlb_kernel_range(PAGE_OFFSET + phys_start,
-				 PAGE_OFFSET + phys_end);
-}
-#endif
-
-unsigned long __init find_ecache_flush_span(unsigned long size)
-{
-	int i;
-
-	for (i = 0; i < pavail_ents; i++) {
-		if (pavail[i].reg_size >= size)
-			return pavail[i].phys_addr;
-	}
-
-	return ~0UL;
-}
-
-unsigned long PAGE_OFFSET;
-EXPORT_SYMBOL(PAGE_OFFSET);
-
-unsigned long VMALLOC_END   = 0x0000010000000000UL;
-EXPORT_SYMBOL(VMALLOC_END);
-
-unsigned long sparc64_va_hole_top =    0xfffff80000000000UL;
-unsigned long sparc64_va_hole_bottom = 0x0000080000000000UL;
-
-static void __init setup_page_offset(void)
-{
-	if (tlb_type == cheetah || tlb_type == cheetah_plus) {
-		/* Cheetah/Panther support a full 64-bit virtual
-		 * address, so we can use all that our page tables
-		 * support.
-		 */
-		sparc64_va_hole_top =    0xfff0000000000000UL;
-		sparc64_va_hole_bottom = 0x0010000000000000UL;
-
-		max_phys_bits = 42;
-	} else if (tlb_type == hypervisor) {
-		switch (sun4v_chip_type) {
-		case SUN4V_CHIP_NIAGARA1:
-		case SUN4V_CHIP_NIAGARA2:
-			/* T1 and T2 support 48-bit virtual addresses.  */
-			sparc64_va_hole_top =    0xffff800000000000UL;
-			sparc64_va_hole_bottom = 0x0000800000000000UL;
-
-			max_phys_bits = 39;
-			break;
-		case SUN4V_CHIP_NIAGARA3:
-			/* T3 supports 48-bit virtual addresses.  */
-			sparc64_va_hole_top =    0xffff800000000000UL;
-			sparc64_va_hole_bottom = 0x0000800000000000UL;
-
-			max_phys_bits = 43;
-			break;
-		case SUN4V_CHIP_NIAGARA4:
-		case SUN4V_CHIP_NIAGARA5:
-		case SUN4V_CHIP_SPARC64X:
-		case SUN4V_CHIP_SPARC_M6:
-			/* T4 and later support 52-bit virtual addresses.  */
-			sparc64_va_hole_top =    0xfff8000000000000UL;
-			sparc64_va_hole_bottom = 0x0008000000000000UL;
-			max_phys_bits = 47;
-			break;
-		case SUN4V_CHIP_SPARC_M7:
-		case SUN4V_CHIP_SPARC_SN:
-			/* M7 and later support 52-bit virtual addresses.  */
-			sparc64_va_hole_top =    0xfff8000000000000UL;
-			sparc64_va_hole_bottom = 0x0008000000000000UL;
-			max_phys_bits = 49;
-			break;
-		case SUN4V_CHIP_SPARC_M8:
-		default:
-			/* M8 and later support 54-bit virtual addresses.
-			 * However, restricting M8 and above VA bits to 53
-			 * as 4-level page table cannot support more than
-			 * 53 VA bits.
-			 */
-			sparc64_va_hole_top =    0xfff0000000000000UL;
-			sparc64_va_hole_bottom = 0x0010000000000000UL;
-			max_phys_bits = 51;
-			break;
-		}
-	}
-
-	if (max_phys_bits > MAX_PHYS_ADDRESS_BITS) {
-		prom_printf("MAX_PHYS_ADDRESS_BITS is too small, need %lu\n",
-			    max_phys_bits);
-		prom_halt();
-	}
-
-	PAGE_OFFSET = sparc64_va_hole_top;
-	VMALLOC_END = ((sparc64_va_hole_bottom >> 1) +
-		       (sparc64_va_hole_bottom >> 2));
-
-	pr_info("MM: PAGE_OFFSET is 0x%016lx (max_phys_bits == %lu)\n",
-		PAGE_OFFSET, max_phys_bits);
-	pr_info("MM: VMALLOC [0x%016lx --> 0x%016lx]\n",
-		VMALLOC_START, VMALLOC_END);
-	pr_info("MM: VMEMMAP [0x%016lx --> 0x%016lx]\n",
-		VMEMMAP_BASE, VMEMMAP_BASE << 1);
-}
-
-static void __init tsb_phys_patch(void)
-{
-	struct tsb_ldquad_phys_patch_entry *pquad;
-	struct tsb_phys_patch_entry *p;
-
-	pquad = &__tsb_ldquad_phys_patch;
-	while (pquad < &__tsb_ldquad_phys_patch_end) {
-		unsigned long addr = pquad->addr;
-
-		if (tlb_type == hypervisor)
-			*(unsigned int *) addr = pquad->sun4v_insn;
-		else
-			*(unsigned int *) addr = pquad->sun4u_insn;
-		wmb();
-		__asm__ __volatile__("flush	%0"
-				     : /* no outputs */
-				     : "r" (addr));
-
-		pquad++;
-	}
-
-	p = &__tsb_phys_patch;
-	while (p < &__tsb_phys_patch_end) {
-		unsigned long addr = p->addr;
-
-		*(unsigned int *) addr = p->insn;
-		wmb();
-		__asm__ __volatile__("flush	%0"
-				     : /* no outputs */
-				     : "r" (addr));
-
-		p++;
-	}
-}
-
-/* Don't mark as init, we give this to the Hypervisor.  */
-#ifndef CONFIG_DEBUG_PAGEALLOC
-#define NUM_KTSB_DESCR	2
-#else
-#define NUM_KTSB_DESCR	1
-#endif
-static struct hv_tsb_descr ktsb_descr[NUM_KTSB_DESCR];
-
-/* The swapper TSBs are loaded with a base sequence of:
- *
- *	sethi	%uhi(SYMBOL), REG1
- *	sethi	%hi(SYMBOL), REG2
- *	or	REG1, %ulo(SYMBOL), REG1
- *	or	REG2, %lo(SYMBOL), REG2
- *	sllx	REG1, 32, REG1
- *	or	REG1, REG2, REG1
- *
- * When we use physical addressing for the TSB accesses, we patch the
- * first four instructions in the above sequence.
- */
-
-static void patch_one_ktsb_phys(unsigned int *start, unsigned int *end, unsigned long pa)
-{
-	unsigned long high_bits, low_bits;
-
-	high_bits = (pa >> 32) & 0xffffffff;
-	low_bits = (pa >> 0) & 0xffffffff;
-
-	while (start < end) {
-		unsigned int *ia = (unsigned int *)(unsigned long)*start;
-
-		ia[0] = (ia[0] & ~0x3fffff) | (high_bits >> 10);
-		__asm__ __volatile__("flush	%0" : : "r" (ia));
-
-		ia[1] = (ia[1] & ~0x3fffff) | (low_bits >> 10);
-		__asm__ __volatile__("flush	%0" : : "r" (ia + 1));
-
-		ia[2] = (ia[2] & ~0x1fff) | (high_bits & 0x3ff);
-		__asm__ __volatile__("flush	%0" : : "r" (ia + 2));
-
-		ia[3] = (ia[3] & ~0x1fff) | (low_bits & 0x3ff);
-		__asm__ __volatile__("flush	%0" : : "r" (ia + 3));
-
-		start++;
-	}
-}
-
-static void ktsb_phys_patch(void)
-{
-	extern unsigned int __swapper_tsb_phys_patch;
-	extern unsigned int __swapper_tsb_phys_patch_end;
-	unsigned long ktsb_pa;
-
-	ktsb_pa = kern_base + ((unsigned long)&swapper_tsb[0] - KERNBASE);
-	patch_one_ktsb_phys(&__swapper_tsb_phys_patch,
-			    &__swapper_tsb_phys_patch_end, ktsb_pa);
-#ifndef CONFIG_DEBUG_PAGEALLOC
-	{
-	extern unsigned int __swapper_4m_tsb_phys_patch;
-	extern unsigned int __swapper_4m_tsb_phys_patch_end;
-	ktsb_pa = (kern_base +
-		   ((unsigned long)&swapper_4m_tsb[0] - KERNBASE));
-	patch_one_ktsb_phys(&__swapper_4m_tsb_phys_patch,
-			    &__swapper_4m_tsb_phys_patch_end, ktsb_pa);
-	}
-#endif
-}
-
-static void __init sun4v_ktsb_init(void)
-{
-	unsigned long ktsb_pa;
-
-	/* First KTSB for PAGE_SIZE mappings.  */
-	ktsb_pa = kern_base + ((unsigned long)&swapper_tsb[0] - KERNBASE);
-
-	switch (PAGE_SIZE) {
-	case 8 * 1024:
-	default:
-		ktsb_descr[0].pgsz_idx = HV_PGSZ_IDX_8K;
-		ktsb_descr[0].pgsz_mask = HV_PGSZ_MASK_8K;
-		break;
-
-	case 64 * 1024:
-		ktsb_descr[0].pgsz_idx = HV_PGSZ_IDX_64K;
-		ktsb_descr[0].pgsz_mask = HV_PGSZ_MASK_64K;
-		break;
-
-	case 512 * 1024:
-		ktsb_descr[0].pgsz_idx = HV_PGSZ_IDX_512K;
-		ktsb_descr[0].pgsz_mask = HV_PGSZ_MASK_512K;
-		break;
-
-	case 4 * 1024 * 1024:
-		ktsb_descr[0].pgsz_idx = HV_PGSZ_IDX_4MB;
-		ktsb_descr[0].pgsz_mask = HV_PGSZ_MASK_4MB;
-		break;
-	}
-
-	ktsb_descr[0].assoc = 1;
-	ktsb_descr[0].num_ttes = KERNEL_TSB_NENTRIES;
-	ktsb_descr[0].ctx_idx = 0;
-	ktsb_descr[0].tsb_base = ktsb_pa;
-	ktsb_descr[0].resv = 0;
-
-#ifndef CONFIG_DEBUG_PAGEALLOC
-	/* Second KTSB for 4MB/256MB/2GB/16GB mappings.  */
-	ktsb_pa = (kern_base +
-		   ((unsigned long)&swapper_4m_tsb[0] - KERNBASE));
-
-	ktsb_descr[1].pgsz_idx = HV_PGSZ_IDX_4MB;
-	ktsb_descr[1].pgsz_mask = ((HV_PGSZ_MASK_4MB |
-				    HV_PGSZ_MASK_256MB |
-				    HV_PGSZ_MASK_2GB |
-				    HV_PGSZ_MASK_16GB) &
-				   cpu_pgsz_mask);
-	ktsb_descr[1].assoc = 1;
-	ktsb_descr[1].num_ttes = KERNEL_TSB4M_NENTRIES;
-	ktsb_descr[1].ctx_idx = 0;
-	ktsb_descr[1].tsb_base = ktsb_pa;
-	ktsb_descr[1].resv = 0;
-#endif
-}
-
-void sun4v_ktsb_register(void)
-{
-	unsigned long pa, ret;
-
-	pa = kern_base + ((unsigned long)&ktsb_descr[0] - KERNBASE);
-
-	ret = sun4v_mmu_tsb_ctx0(NUM_KTSB_DESCR, pa);
-	if (ret != 0) {
-		prom_printf("hypervisor_mmu_tsb_ctx0[%lx]: "
-			    "errors with %lx\n", pa, ret);
-		prom_halt();
-	}
-}
-
-static void __init sun4u_linear_pte_xor_finalize(void)
-{
-#ifndef CONFIG_DEBUG_PAGEALLOC
-	/* This is where we would add Panther support for
-	 * 32MB and 256MB pages.
-	 */
-#endif
-}
-
-static void __init sun4v_linear_pte_xor_finalize(void)
-{
-	unsigned long pagecv_flag;
-
-	/* Bit 9 of TTE is no longer CV bit on M7 processor and it instead
-	 * enables MCD error. Do not set bit 9 on M7 processor.
-	 */
-	switch (sun4v_chip_type) {
-	case SUN4V_CHIP_SPARC_M7:
-	case SUN4V_CHIP_SPARC_M8:
-	case SUN4V_CHIP_SPARC_SN:
-		pagecv_flag = 0x00;
-		break;
-	default:
-		pagecv_flag = _PAGE_CV_4V;
-		break;
-	}
-#ifndef CONFIG_DEBUG_PAGEALLOC
-	if (cpu_pgsz_mask & HV_PGSZ_MASK_256MB) {
-		kern_linear_pte_xor[1] = (_PAGE_VALID | _PAGE_SZ256MB_4V) ^
-			PAGE_OFFSET;
-		kern_linear_pte_xor[1] |= (_PAGE_CP_4V | pagecv_flag |
-					   _PAGE_P_4V | _PAGE_W_4V);
-	} else {
-		kern_linear_pte_xor[1] = kern_linear_pte_xor[0];
-	}
-
-	if (cpu_pgsz_mask & HV_PGSZ_MASK_2GB) {
-		kern_linear_pte_xor[2] = (_PAGE_VALID | _PAGE_SZ2GB_4V) ^
-			PAGE_OFFSET;
-		kern_linear_pte_xor[2] |= (_PAGE_CP_4V | pagecv_flag |
-					   _PAGE_P_4V | _PAGE_W_4V);
-	} else {
-		kern_linear_pte_xor[2] = kern_linear_pte_xor[1];
-	}
-
-	if (cpu_pgsz_mask & HV_PGSZ_MASK_16GB) {
-		kern_linear_pte_xor[3] = (_PAGE_VALID | _PAGE_SZ16GB_4V) ^
-			PAGE_OFFSET;
-		kern_linear_pte_xor[3] |= (_PAGE_CP_4V | pagecv_flag |
-					   _PAGE_P_4V | _PAGE_W_4V);
-	} else {
-		kern_linear_pte_xor[3] = kern_linear_pte_xor[2];
-	}
-#endif
-}
-
-/* paging_init() sets up the page tables */
-
-static unsigned long last_valid_pfn;
-
-static void sun4u_pgprot_init(void);
-static void sun4v_pgprot_init(void);
-
-#define _PAGE_CACHE_4U	(_PAGE_CP_4U | _PAGE_CV_4U)
-#define _PAGE_CACHE_4V	(_PAGE_CP_4V | _PAGE_CV_4V)
-#define __DIRTY_BITS_4U	 (_PAGE_MODIFIED_4U | _PAGE_WRITE_4U | _PAGE_W_4U)
-#define __DIRTY_BITS_4V	 (_PAGE_MODIFIED_4V | _PAGE_WRITE_4V | _PAGE_W_4V)
-#define __ACCESS_BITS_4U (_PAGE_ACCESSED_4U | _PAGE_READ_4U | _PAGE_R)
-#define __ACCESS_BITS_4V (_PAGE_ACCESSED_4V | _PAGE_READ_4V | _PAGE_R)
-
-/* We need to exclude reserved regions. This exclusion will include
- * vmlinux and initrd. To be more precise the initrd size could be used to
- * compute a new lower limit because it is freed later during initialization.
- */
-static void __init reduce_memory(phys_addr_t limit_ram)
-{
-	limit_ram += memblock_reserved_size();
-	memblock_enforce_memory_limit(limit_ram);
-}
-
-void __init paging_init(void)
-{
-	unsigned long end_pfn, shift, phys_base;
-	unsigned long real_end, i;
-
-	setup_page_offset();
-
-	/* These build time checkes make sure that the dcache_dirty_cpu()
-	 * folio->flags usage will work.
-	 *
-	 * When a page gets marked as dcache-dirty, we store the
-	 * cpu number starting at bit 32 in the folio->flags.  Also,
-	 * functions like clear_dcache_dirty_cpu use the cpu mask
-	 * in 13-bit signed-immediate instruction fields.
-	 */
-
-	/*
-	 * Page flags must not reach into upper 32 bits that are used
-	 * for the cpu number
-	 */
-	BUILD_BUG_ON(NR_PAGEFLAGS > 32);
-
-	/*
-	 * The bit fields placed in the high range must not reach below
-	 * the 32 bit boundary. Otherwise we cannot place the cpu field
-	 * at the 32 bit boundary.
-	 */
-	BUILD_BUG_ON(SECTIONS_WIDTH + NODES_WIDTH + ZONES_WIDTH +
-		ilog2(roundup_pow_of_two(NR_CPUS)) > 32);
-
-	BUILD_BUG_ON(NR_CPUS > 4096);
-
-	kern_base = (prom_boot_mapping_phys_low >> ILOG2_4MB) << ILOG2_4MB;
-	kern_size = (unsigned long)&_end - (unsigned long)KERNBASE;
-
-	/* Invalidate both kernel TSBs.  */
-	memset(swapper_tsb, 0x40, sizeof(swapper_tsb));
-#ifndef CONFIG_DEBUG_PAGEALLOC
-	memset(swapper_4m_tsb, 0x40, sizeof(swapper_4m_tsb));
-#endif
-
-	/* TTE.cv bit on sparc v9 occupies the same position as TTE.mcde
-	 * bit on M7 processor. This is a conflicting usage of the same
-	 * bit. Enabling TTE.cv on M7 would turn on Memory Corruption
-	 * Detection error on all pages and this will lead to problems
-	 * later. Kernel does not run with MCD enabled and hence rest
-	 * of the required steps to fully configure memory corruption
-	 * detection are not taken. We need to ensure TTE.mcde is not
-	 * set on M7 processor. Compute the value of cacheability
-	 * flag for use later taking this into consideration.
-	 */
-	switch (sun4v_chip_type) {
-	case SUN4V_CHIP_SPARC_M7:
-	case SUN4V_CHIP_SPARC_M8:
-	case SUN4V_CHIP_SPARC_SN:
-		page_cache4v_flag = _PAGE_CP_4V;
-		break;
-	default:
-		page_cache4v_flag = _PAGE_CACHE_4V;
-		break;
-	}
-
-	if (tlb_type == hypervisor)
-		sun4v_pgprot_init();
-	else
-		sun4u_pgprot_init();
-
-	if (tlb_type == cheetah_plus ||
-	    tlb_type == hypervisor) {
-		tsb_phys_patch();
-		ktsb_phys_patch();
-	}
-
-	if (tlb_type == hypervisor)
-		sun4v_patch_tlb_handlers();
-
-	/* Find available physical memory...
-	 *
-	 * Read it twice in order to work around a bug in openfirmware.
-	 * The call to grab this table itself can cause openfirmware to
-	 * allocate memory, which in turn can take away some space from
-	 * the list of available memory.  Reading it twice makes sure
-	 * we really do get the final value.
-	 */
-	read_obp_translations();
-	read_obp_memory("reg", &pall[0], &pall_ents);
-	read_obp_memory("available", &pavail[0], &pavail_ents);
-	read_obp_memory("available", &pavail[0], &pavail_ents);
-
-	phys_base = 0xffffffffffffffffUL;
-	for (i = 0; i < pavail_ents; i++) {
-		phys_base = min(phys_base, pavail[i].phys_addr);
-		memblock_add(pavail[i].phys_addr, pavail[i].reg_size);
-	}
-
-	memblock_reserve(kern_base, kern_size);
-
-	find_ramdisk(phys_base);
-
-	if (cmdline_memory_size)
-		reduce_memory(cmdline_memory_size);
-
-	memblock_allow_resize();
-	memblock_dump_all();
-
-	set_bit(0, mmu_context_bmap);
-
-	shift = kern_base + PAGE_OFFSET - ((unsigned long)KERNBASE);
-
-	real_end = (unsigned long)_end;
-	num_kernel_image_mappings = DIV_ROUND_UP(real_end - KERNBASE, 1 << ILOG2_4MB);
-	printk("Kernel: Using %d locked TLB entries for main kernel image.\n",
-	       num_kernel_image_mappings);
-
-	/* Set kernel pgd to upper alias so physical page computations
-	 * work.
-	 */
-	init_mm.pgd += ((shift) / (sizeof(pgd_t)));
-	
-	memset(swapper_pg_dir, 0, sizeof(swapper_pg_dir));
-
-	inherit_prom_mappings();
-	
-	/* Ok, we can use our TLB miss and window trap handlers safely.  */
-	setup_tba();
-
-	__flush_tlb_all();
-
-	prom_build_devicetree();
-	of_populate_present_mask();
-#ifndef CONFIG_SMP
-	of_fill_in_cpu_data();
-#endif
-
-	if (tlb_type == hypervisor) {
-		sun4v_mdesc_init();
-		mdesc_populate_present_mask(cpu_all_mask);
-#ifndef CONFIG_SMP
-		mdesc_fill_in_cpu_data(cpu_all_mask);
-#endif
-		mdesc_get_page_sizes(cpu_all_mask, &cpu_pgsz_mask);
-
-		sun4v_linear_pte_xor_finalize();
-
-		sun4v_ktsb_init();
-		sun4v_ktsb_register();
-	} else {
-		unsigned long impl, ver;
-
-		cpu_pgsz_mask = (HV_PGSZ_MASK_8K | HV_PGSZ_MASK_64K |
-				 HV_PGSZ_MASK_512K | HV_PGSZ_MASK_4MB);
-
-		__asm__ __volatile__("rdpr %%ver, %0" : "=r" (ver));
-		impl = ((ver >> 32) & 0xffff);
-		if (impl == PANTHER_IMPL)
-			cpu_pgsz_mask |= (HV_PGSZ_MASK_32MB |
-					  HV_PGSZ_MASK_256MB);
-
-		sun4u_linear_pte_xor_finalize();
-	}
-
-	/* Flush the TLBs and the 4M TSB so that the updated linear
-	 * pte XOR settings are realized for all mappings.
-	 */
-	__flush_tlb_all();
-#ifndef CONFIG_DEBUG_PAGEALLOC
-	memset(swapper_4m_tsb, 0x40, sizeof(swapper_4m_tsb));
-#endif
-	__flush_tlb_all();
-
-	/* Setup bootmem... */
-	last_valid_pfn = end_pfn = bootmem_init(phys_base);
-
-	kernel_physical_mapping_init();
-
-	{
-		unsigned long max_zone_pfns[MAX_NR_ZONES];
-
-		memset(max_zone_pfns, 0, sizeof(max_zone_pfns));
-
-		max_zone_pfns[ZONE_NORMAL] = end_pfn;
-
-		free_area_init(max_zone_pfns);
-	}
-
-	printk("Booting Linux...\n");
-}
-
-int page_in_phys_avail(unsigned long paddr)
-{
-	int i;
-
-	paddr &= PAGE_MASK;
-
-	for (i = 0; i < pavail_ents; i++) {
-		unsigned long start, end;
-
-		start = pavail[i].phys_addr;
-		end = start + pavail[i].reg_size;
-
-		if (paddr >= start && paddr < end)
-			return 1;
-	}
-	if (paddr >= kern_base && paddr < (kern_base + kern_size))
-		return 1;
-#ifdef CONFIG_BLK_DEV_INITRD
-	if (paddr >= __pa(initrd_start) &&
-	    paddr < __pa(PAGE_ALIGN(initrd_end)))
-		return 1;
-#endif
-
-	return 0;
-}
-
-static void __init register_page_bootmem_info(void)
-{
-#ifdef CONFIG_NUMA
-	int i;
-
-	for_each_online_node(i)
-		if (NODE_DATA(i)->node_spanned_pages)
-			register_page_bootmem_info_node(NODE_DATA(i));
-#endif
-}
-void __init mem_init(void)
-{
-	/*
-	 * Must be done after boot memory is put on freelist, because here we
-	 * might set fields in deferred struct pages that have not yet been
-	 * initialized, and memblock_free_all() initializes all the reserved
-	 * deferred pages for us.
-	 */
-	register_page_bootmem_info();
-
-	/*
-	 * Set up the zero page, mark it reserved, so that page count
-	 * is not manipulated when freeing the page from user ptes.
-	 */
-	mem_map_zero = alloc_pages(GFP_KERNEL|__GFP_ZERO, 0);
-	if (mem_map_zero == NULL) {
-		prom_printf("paging_init: Cannot alloc zero page.\n");
-		prom_halt();
-	}
-	mark_page_reserved(mem_map_zero);
-
-
-	if (tlb_type == cheetah || tlb_type == cheetah_plus)
-		cheetah_ecache_flush_init();
-}
-
-void free_initmem(void)
-{
-	unsigned long addr, initend;
-	int do_free = 1;
-
-	/* If the physical memory maps were trimmed by kernel command
-	 * line options, don't even try freeing this initmem stuff up.
-	 * The kernel image could have been in the trimmed out region
-	 * and if so the freeing below will free invalid page structs.
-	 */
-	if (cmdline_memory_size)
-		do_free = 0;
-
-	/*
-	 * The init section is aligned to 8k in vmlinux.lds. Page align for >8k pagesizes.
-	 */
-	addr = PAGE_ALIGN((unsigned long)(__init_begin));
-	initend = (unsigned long)(__init_end) & PAGE_MASK;
-	for (; addr < initend; addr += PAGE_SIZE) {
-		unsigned long page;
-
-		page = (addr +
-			((unsigned long) __va(kern_base)) -
-			((unsigned long) KERNBASE));
-		memset((void *)addr, POISON_FREE_INITMEM, PAGE_SIZE);
-
-		if (do_free)
-			free_reserved_page(virt_to_page(page));
-	}
-}
-
-pgprot_t PAGE_KERNEL __read_mostly;
-EXPORT_SYMBOL(PAGE_KERNEL);
-
-pgprot_t PAGE_KERNEL_LOCKED __read_mostly;
-pgprot_t PAGE_COPY __read_mostly;
-
-pgprot_t PAGE_SHARED __read_mostly;
-EXPORT_SYMBOL(PAGE_SHARED);
-
-unsigned long pg_iobits __read_mostly;
-
-unsigned long _PAGE_IE __read_mostly;
-EXPORT_SYMBOL(_PAGE_IE);
-
-unsigned long _PAGE_E __read_mostly;
-EXPORT_SYMBOL(_PAGE_E);
-
-unsigned long _PAGE_CACHE __read_mostly;
-EXPORT_SYMBOL(_PAGE_CACHE);
-
-#ifdef CONFIG_SPARSEMEM_VMEMMAP
-int __meminit vmemmap_populate(unsigned long vstart, unsigned long vend,
-			       int node, struct vmem_altmap *altmap)
-{
-	unsigned long pte_base;
-
-	pte_base = (_PAGE_VALID | _PAGE_SZ4MB_4U |
-		    _PAGE_CP_4U | _PAGE_CV_4U |
-		    _PAGE_P_4U | _PAGE_W_4U);
-	if (tlb_type == hypervisor)
-		pte_base = (_PAGE_VALID | _PAGE_SZ4MB_4V |
-			    page_cache4v_flag | _PAGE_P_4V | _PAGE_W_4V);
-
-	pte_base |= _PAGE_PMD_HUGE;
-
-	vstart = vstart & PMD_MASK;
-	vend = ALIGN(vend, PMD_SIZE);
-	for (; vstart < vend; vstart += PMD_SIZE) {
-		pgd_t *pgd = vmemmap_pgd_populate(vstart, node);
-		unsigned long pte;
-		p4d_t *p4d;
-		pud_t *pud;
-		pmd_t *pmd;
-
-		if (!pgd)
-			return -ENOMEM;
-
-		p4d = vmemmap_p4d_populate(pgd, vstart, node);
-		if (!p4d)
-			return -ENOMEM;
-
-		pud = vmemmap_pud_populate(p4d, vstart, node);
-		if (!pud)
-			return -ENOMEM;
-
-		pmd = pmd_offset(pud, vstart);
-		pte = pmd_val(*pmd);
-		if (!(pte & _PAGE_VALID)) {
-			void *block = vmemmap_alloc_block(PMD_SIZE, node);
-
-			if (!block)
-				return -ENOMEM;
-
-			pmd_val(*pmd) = pte_base | __pa(block);
-		}
-	}
-
-	return 0;
-}
-#endif /* CONFIG_SPARSEMEM_VMEMMAP */
-
-/* These are actually filled in at boot time by sun4{u,v}_pgprot_init() */
-static pgprot_t protection_map[16] __ro_after_init;
-
-static void prot_init_common(unsigned long page_none,
-			     unsigned long page_shared,
-			     unsigned long page_copy,
-			     unsigned long page_readonly,
-			     unsigned long page_exec_bit)
-{
-	PAGE_COPY = __pgprot(page_copy);
-	PAGE_SHARED = __pgprot(page_shared);
-
-	protection_map[0x0] = __pgprot(page_none);
-	protection_map[0x1] = __pgprot(page_readonly & ~page_exec_bit);
-	protection_map[0x2] = __pgprot(page_copy & ~page_exec_bit);
-	protection_map[0x3] = __pgprot(page_copy & ~page_exec_bit);
-	protection_map[0x4] = __pgprot(page_readonly);
-	protection_map[0x5] = __pgprot(page_readonly);
-	protection_map[0x6] = __pgprot(page_copy);
-	protection_map[0x7] = __pgprot(page_copy);
-	protection_map[0x8] = __pgprot(page_none);
-	protection_map[0x9] = __pgprot(page_readonly & ~page_exec_bit);
-	protection_map[0xa] = __pgprot(page_shared & ~page_exec_bit);
-	protection_map[0xb] = __pgprot(page_shared & ~page_exec_bit);
-	protection_map[0xc] = __pgprot(page_readonly);
-	protection_map[0xd] = __pgprot(page_readonly);
-	protection_map[0xe] = __pgprot(page_shared);
-	protection_map[0xf] = __pgprot(page_shared);
-}
-
-static void __init sun4u_pgprot_init(void)
-{
-	unsigned long page_none, page_shared, page_copy, page_readonly;
-	unsigned long page_exec_bit;
-	int i;
-
-	PAGE_KERNEL = __pgprot (_PAGE_PRESENT_4U | _PAGE_VALID |
-				_PAGE_CACHE_4U | _PAGE_P_4U |
-				__ACCESS_BITS_4U | __DIRTY_BITS_4U |
-				_PAGE_EXEC_4U);
-	PAGE_KERNEL_LOCKED = __pgprot (_PAGE_PRESENT_4U | _PAGE_VALID |
-				       _PAGE_CACHE_4U | _PAGE_P_4U |
-				       __ACCESS_BITS_4U | __DIRTY_BITS_4U |
-				       _PAGE_EXEC_4U | _PAGE_L_4U);
-
-	_PAGE_IE = _PAGE_IE_4U;
-	_PAGE_E = _PAGE_E_4U;
-	_PAGE_CACHE = _PAGE_CACHE_4U;
-
-	pg_iobits = (_PAGE_VALID | _PAGE_PRESENT_4U | __DIRTY_BITS_4U |
-		     __ACCESS_BITS_4U | _PAGE_E_4U);
-
-#ifdef CONFIG_DEBUG_PAGEALLOC
-	kern_linear_pte_xor[0] = _PAGE_VALID ^ PAGE_OFFSET;
-#else
-	kern_linear_pte_xor[0] = (_PAGE_VALID | _PAGE_SZ4MB_4U) ^
-		PAGE_OFFSET;
-#endif
-	kern_linear_pte_xor[0] |= (_PAGE_CP_4U | _PAGE_CV_4U |
-				   _PAGE_P_4U | _PAGE_W_4U);
-
-	for (i = 1; i < 4; i++)
-		kern_linear_pte_xor[i] = kern_linear_pte_xor[0];
-
-	_PAGE_ALL_SZ_BITS =  (_PAGE_SZ4MB_4U | _PAGE_SZ512K_4U |
-			      _PAGE_SZ64K_4U | _PAGE_SZ8K_4U |
-			      _PAGE_SZ32MB_4U | _PAGE_SZ256MB_4U);
-
-
-	page_none = _PAGE_PRESENT_4U | _PAGE_ACCESSED_4U | _PAGE_CACHE_4U;
-	page_shared = (_PAGE_VALID | _PAGE_PRESENT_4U | _PAGE_CACHE_4U |
-		       __ACCESS_BITS_4U | _PAGE_WRITE_4U | _PAGE_EXEC_4U);
-	page_copy   = (_PAGE_VALID | _PAGE_PRESENT_4U | _PAGE_CACHE_4U |
-		       __ACCESS_BITS_4U | _PAGE_EXEC_4U);
-	page_readonly   = (_PAGE_VALID | _PAGE_PRESENT_4U | _PAGE_CACHE_4U |
-			   __ACCESS_BITS_4U | _PAGE_EXEC_4U);
-
-	page_exec_bit = _PAGE_EXEC_4U;
-
-	prot_init_common(page_none, page_shared, page_copy, page_readonly,
-			 page_exec_bit);
-}
-
-static void __init sun4v_pgprot_init(void)
-{
-	unsigned long page_none, page_shared, page_copy, page_readonly;
-	unsigned long page_exec_bit;
-	int i;
-
-	PAGE_KERNEL = __pgprot (_PAGE_PRESENT_4V | _PAGE_VALID |
-				page_cache4v_flag | _PAGE_P_4V |
-				__ACCESS_BITS_4V | __DIRTY_BITS_4V |
-				_PAGE_EXEC_4V);
-	PAGE_KERNEL_LOCKED = PAGE_KERNEL;
-
-	_PAGE_IE = _PAGE_IE_4V;
-	_PAGE_E = _PAGE_E_4V;
-	_PAGE_CACHE = page_cache4v_flag;
-
-#ifdef CONFIG_DEBUG_PAGEALLOC
-	kern_linear_pte_xor[0] = _PAGE_VALID ^ PAGE_OFFSET;
-#else
-	kern_linear_pte_xor[0] = (_PAGE_VALID | _PAGE_SZ4MB_4V) ^
-		PAGE_OFFSET;
-#endif
-	kern_linear_pte_xor[0] |= (page_cache4v_flag | _PAGE_P_4V |
-				   _PAGE_W_4V);
-
-	for (i = 1; i < 4; i++)
-		kern_linear_pte_xor[i] = kern_linear_pte_xor[0];
-
-	pg_iobits = (_PAGE_VALID | _PAGE_PRESENT_4V | __DIRTY_BITS_4V |
-		     __ACCESS_BITS_4V | _PAGE_E_4V);
-
-	_PAGE_ALL_SZ_BITS = (_PAGE_SZ16GB_4V | _PAGE_SZ2GB_4V |
-			     _PAGE_SZ256MB_4V | _PAGE_SZ32MB_4V |
-			     _PAGE_SZ4MB_4V | _PAGE_SZ512K_4V |
-			     _PAGE_SZ64K_4V | _PAGE_SZ8K_4V);
-
-	page_none = _PAGE_PRESENT_4V | _PAGE_ACCESSED_4V | page_cache4v_flag;
-	page_shared = (_PAGE_VALID | _PAGE_PRESENT_4V | page_cache4v_flag |
-		       __ACCESS_BITS_4V | _PAGE_WRITE_4V | _PAGE_EXEC_4V);
-	page_copy   = (_PAGE_VALID | _PAGE_PRESENT_4V | page_cache4v_flag |
-		       __ACCESS_BITS_4V | _PAGE_EXEC_4V);
-	page_readonly = (_PAGE_VALID | _PAGE_PRESENT_4V | page_cache4v_flag |
-			 __ACCESS_BITS_4V | _PAGE_EXEC_4V);
-
-	page_exec_bit = _PAGE_EXEC_4V;
-
-	prot_init_common(page_none, page_shared, page_copy, page_readonly,
-			 page_exec_bit);
-}
-
-unsigned long pte_sz_bits(unsigned long sz)
-{
-	if (tlb_type == hypervisor) {
-		switch (sz) {
-		case 8 * 1024:
-		default:
-			return _PAGE_SZ8K_4V;
-		case 64 * 1024:
-			return _PAGE_SZ64K_4V;
-		case 512 * 1024:
-			return _PAGE_SZ512K_4V;
-		case 4 * 1024 * 1024:
-			return _PAGE_SZ4MB_4V;
-		}
-	} else {
-		switch (sz) {
-		case 8 * 1024:
-		default:
-			return _PAGE_SZ8K_4U;
-		case 64 * 1024:
-			return _PAGE_SZ64K_4U;
-		case 512 * 1024:
-			return _PAGE_SZ512K_4U;
-		case 4 * 1024 * 1024:
-			return _PAGE_SZ4MB_4U;
-		}
-	}
-}
-
-pte_t mk_pte_io(unsigned long page, pgprot_t prot, int space, unsigned long page_size)
-{
-	pte_t pte;
-
-	pte_val(pte)  = page | pgprot_val(pgprot_noncached(prot));
-	pte_val(pte) |= (((unsigned long)space) << 32);
-	pte_val(pte) |= pte_sz_bits(page_size);
-
-	return pte;
-}
-
-static unsigned long kern_large_tte(unsigned long paddr)
-{
-	unsigned long val;
-
-	val = (_PAGE_VALID | _PAGE_SZ4MB_4U |
-	       _PAGE_CP_4U | _PAGE_CV_4U | _PAGE_P_4U |
-	       _PAGE_EXEC_4U | _PAGE_L_4U | _PAGE_W_4U);
-	if (tlb_type == hypervisor)
-		val = (_PAGE_VALID | _PAGE_SZ4MB_4V |
-		       page_cache4v_flag | _PAGE_P_4V |
-		       _PAGE_EXEC_4V | _PAGE_W_4V);
-
-	return val | paddr;
-}
-
-/* If not locked, zap it. */
-void __flush_tlb_all(void)
-{
-	unsigned long pstate;
-	int i;
-
-	__asm__ __volatile__("flushw\n\t"
-			     "rdpr	%%pstate, %0\n\t"
-			     "wrpr	%0, %1, %%pstate"
-			     : "=r" (pstate)
-			     : "i" (PSTATE_IE));
-	if (tlb_type == hypervisor) {
-		sun4v_mmu_demap_all();
-	} else if (tlb_type == spitfire) {
-		for (i = 0; i < 64; i++) {
-			/* Spitfire Errata #32 workaround */
-			/* NOTE: Always runs on spitfire, so no
-			 *       cheetah+ page size encodings.
-			 */
-			__asm__ __volatile__("stxa	%0, [%1] %2\n\t"
-					     "flush	%%g6"
-					     : /* No outputs */
-					     : "r" (0),
-					     "r" (PRIMARY_CONTEXT), "i" (ASI_DMMU));
-
-			if (!(spitfire_get_dtlb_data(i) & _PAGE_L_4U)) {
-				__asm__ __volatile__("stxa %%g0, [%0] %1\n\t"
-						     "membar #Sync"
-						     : /* no outputs */
-						     : "r" (TLB_TAG_ACCESS), "i" (ASI_DMMU));
-				spitfire_put_dtlb_data(i, 0x0UL);
-			}
-
-			/* Spitfire Errata #32 workaround */
-			/* NOTE: Always runs on spitfire, so no
-			 *       cheetah+ page size encodings.
-			 */
-			__asm__ __volatile__("stxa	%0, [%1] %2\n\t"
-					     "flush	%%g6"
-					     : /* No outputs */
-					     : "r" (0),
-					     "r" (PRIMARY_CONTEXT), "i" (ASI_DMMU));
-
-			if (!(spitfire_get_itlb_data(i) & _PAGE_L_4U)) {
-				__asm__ __volatile__("stxa %%g0, [%0] %1\n\t"
-						     "membar #Sync"
-						     : /* no outputs */
-						     : "r" (TLB_TAG_ACCESS), "i" (ASI_IMMU));
-				spitfire_put_itlb_data(i, 0x0UL);
-			}
-		}
-	} else if (tlb_type == cheetah || tlb_type == cheetah_plus) {
-		cheetah_flush_dtlb_all();
-		cheetah_flush_itlb_all();
-	}
-	__asm__ __volatile__("wrpr	%0, 0, %%pstate"
-			     : : "r" (pstate));
-}
-
-static pte_t *__pte_alloc_one(struct mm_struct *mm)
-{
-	struct ptdesc *ptdesc = pagetable_alloc(GFP_KERNEL | __GFP_ZERO, 0);
-
-	if (!ptdesc)
-		return NULL;
-	if (!pagetable_pte_ctor(mm, ptdesc)) {
-		pagetable_free(ptdesc);
-		return NULL;
-	}
-	return ptdesc_address(ptdesc);
-}
-
-pte_t *pte_alloc_one_kernel(struct mm_struct *mm)
-{
-	return __pte_alloc_one(mm);
-}
-
-pgtable_t pte_alloc_one(struct mm_struct *mm)
-{
-	return __pte_alloc_one(mm);
-}
-
-static void __pte_free(pgtable_t pte)
-{
-	struct ptdesc *ptdesc = virt_to_ptdesc(pte);
-
-	pagetable_dtor(ptdesc);
-	pagetable_free(ptdesc);
-}
-
-void pte_free_kernel(struct mm_struct *mm, pte_t *pte)
-{
-	__pte_free(pte);
-}
-
-void pte_free(struct mm_struct *mm, pgtable_t pte)
-{
-	__pte_free(pte);
-}
-
-void pgtable_free(void *table, bool is_page)
-{
-	if (is_page)
-		__pte_free(table);
-	else
-		kmem_cache_free(pgtable_cache, table);
-}
-
-#ifdef CONFIG_TRANSPARENT_HUGEPAGE
-static void pte_free_now(struct rcu_head *head)
-{
-	struct page *page;
-
-	page = container_of(head, struct page, rcu_head);
-	__pte_free((pgtable_t)page_address(page));
-}
-
-void pte_free_defer(struct mm_struct *mm, pgtable_t pgtable)
-{
-	struct page *page;
-
-	page = virt_to_page(pgtable);
-	call_rcu(&page->rcu_head, pte_free_now);
-}
-
-void update_mmu_cache_pmd(struct vm_area_struct *vma, unsigned long addr,
-			  pmd_t *pmd)
-{
-	unsigned long pte, flags;
-	struct mm_struct *mm;
-	pmd_t entry = *pmd;
-
-	if (!pmd_leaf(entry) || !pmd_young(entry))
-		return;
-
-	pte = pmd_val(entry);
-
-	/* Don't insert a non-valid PMD into the TSB, we'll deadlock.  */
-	if (!(pte & _PAGE_VALID))
-		return;
-
-	/* We are fabricating 8MB pages using 4MB real hw pages.  */
-	pte |= (addr & (1UL << REAL_HPAGE_SHIFT));
-
-	mm = vma->vm_mm;
-
-	spin_lock_irqsave(&mm->context.lock, flags);
-
-	if (mm->context.tsb_block[MM_TSB_HUGE].tsb != NULL)
-		__update_mmu_tsb_insert(mm, MM_TSB_HUGE, REAL_HPAGE_SHIFT,
-					addr, pte);
-
-	spin_unlock_irqrestore(&mm->context.lock, flags);
-}
-#endif /* CONFIG_TRANSPARENT_HUGEPAGE */
-
-#if defined(CONFIG_HUGETLB_PAGE) || defined(CONFIG_TRANSPARENT_HUGEPAGE)
-static void context_reload(void *__data)
-{
-	struct mm_struct *mm = __data;
-
-	if (mm == current->mm)
-		load_secondary_context(mm);
-}
-
-void hugetlb_setup(struct pt_regs *regs)
-{
-	struct mm_struct *mm = current->mm;
-	struct tsb_config *tp;
-
-	if (faulthandler_disabled() || !mm) {
-		const struct exception_table_entry *entry;
-
-		entry = search_exception_tables(regs->tpc);
-		if (entry) {
-			regs->tpc = entry->fixup;
-			regs->tnpc = regs->tpc + 4;
-			return;
-		}
-		pr_alert("Unexpected HugeTLB setup in atomic context.\n");
-		die_if_kernel("HugeTSB in atomic", regs);
-	}
-
-	tp = &mm->context.tsb_block[MM_TSB_HUGE];
-	if (likely(tp->tsb == NULL))
-		tsb_grow(mm, MM_TSB_HUGE, 0);
-
-	tsb_context_switch(mm);
-	smp_tsb_sync(mm);
-
-	/* On UltraSPARC-III+ and later, configure the second half of
-	 * the Data-TLB for huge pages.
-	 */
-	if (tlb_type == cheetah_plus) {
-		bool need_context_reload = false;
-		unsigned long ctx;
-
-		spin_lock_irq(&ctx_alloc_lock);
-		ctx = mm->context.sparc64_ctx_val;
-		ctx &= ~CTX_PGSZ_MASK;
-		ctx |= CTX_PGSZ_BASE << CTX_PGSZ0_SHIFT;
-		ctx |= CTX_PGSZ_HUGE << CTX_PGSZ1_SHIFT;
-
-		if (ctx != mm->context.sparc64_ctx_val) {
-			/* When changing the page size fields, we
-			 * must perform a context flush so that no
-			 * stale entries match.  This flush must
-			 * occur with the original context register
-			 * settings.
-			 */
-			do_flush_tlb_mm(mm);
-
-			/* Reload the context register of all processors
-			 * also executing in this address space.
-			 */
-			mm->context.sparc64_ctx_val = ctx;
-			need_context_reload = true;
-		}
-		spin_unlock_irq(&ctx_alloc_lock);
-
-		if (need_context_reload)
-			on_each_cpu(context_reload, mm, 0);
-	}
-}
-#endif
-
-static struct resource code_resource = {
-	.name	= "Kernel code",
-	.flags	= IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM
-};
-
-static struct resource data_resource = {
-	.name	= "Kernel data",
-	.flags	= IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM
-};
-
-static struct resource bss_resource = {
-	.name	= "Kernel bss",
-	.flags	= IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM
-};
-
-static inline resource_size_t compute_kern_paddr(void *addr)
-{
-	return (resource_size_t) (addr - KERNBASE + kern_base);
-}
-
-static void __init kernel_lds_init(void)
-{
-	code_resource.start = compute_kern_paddr(_text);
-	code_resource.end   = compute_kern_paddr(_etext - 1);
-	data_resource.start = compute_kern_paddr(_etext);
-	data_resource.end   = compute_kern_paddr(_edata - 1);
-	bss_resource.start  = compute_kern_paddr(__bss_start);
-	bss_resource.end    = compute_kern_paddr(_end - 1);
-}
-
-static int __init report_memory(void)
-{
-	int i;
-	struct resource *res;
-
-	kernel_lds_init();
-
-	for (i = 0; i < pavail_ents; i++) {
-		res = kzalloc(sizeof(struct resource), GFP_KERNEL);
-
-		if (!res) {
-			pr_warn("Failed to allocate source.\n");
-			break;
-		}
-
-		res->name = "System RAM";
-		res->start = pavail[i].phys_addr;
-		res->end = pavail[i].phys_addr + pavail[i].reg_size - 1;
-		res->flags = IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM;
-
-		if (insert_resource(&iomem_resource, res) < 0) {
-			pr_warn("Resource insertion failed.\n");
-			break;
-		}
-
-		insert_resource(res, &code_resource);
-		insert_resource(res, &data_resource);
-		insert_resource(res, &bss_resource);
-	}
-
-	return 0;
-}
-arch_initcall(report_memory);
-
-#ifdef CONFIG_SMP
-#define do_flush_tlb_kernel_range	smp_flush_tlb_kernel_range
-#else
-#define do_flush_tlb_kernel_range	__flush_tlb_kernel_range
-#endif
-
-void flush_tlb_kernel_range(unsigned long start, unsigned long end)
-{
-	if (start < HI_OBP_ADDRESS && end > LOW_OBP_ADDRESS) {
-		if (start < LOW_OBP_ADDRESS) {
-			flush_tsb_kernel_range(start, LOW_OBP_ADDRESS);
-			do_flush_tlb_kernel_range(start, LOW_OBP_ADDRESS);
-		}
-		if (end > HI_OBP_ADDRESS) {
-			flush_tsb_kernel_range(HI_OBP_ADDRESS, end);
-			do_flush_tlb_kernel_range(HI_OBP_ADDRESS, end);
-		}
-	} else {
-		flush_tsb_kernel_range(start, end);
-		do_flush_tlb_kernel_range(start, end);
-	}
-}
-
-void copy_user_highpage(struct page *to, struct page *from,
-	unsigned long vaddr, struct vm_area_struct *vma)
-{
-	char *vfrom, *vto;
-
-	vfrom = kmap_atomic(from);
-	vto = kmap_atomic(to);
-	copy_user_page(vto, vfrom, vaddr, to);
-	kunmap_atomic(vto);
-	kunmap_atomic(vfrom);
-
-	/* If this page has ADI enabled, copy over any ADI tags
-	 * as well
-	 */
-	if (vma->vm_flags & VM_SPARC_ADI) {
-		unsigned long pfrom, pto, i, adi_tag;
-
-		pfrom = page_to_phys(from);
-		pto = page_to_phys(to);
-
-		for (i = pfrom; i < (pfrom + PAGE_SIZE); i += adi_blksize()) {
-			asm volatile("ldxa [%1] %2, %0\n\t"
-					: "=r" (adi_tag)
-					:  "r" (i), "i" (ASI_MCD_REAL));
-			asm volatile("stxa %0, [%1] %2\n\t"
-					:
-					: "r" (adi_tag), "r" (pto),
-					  "i" (ASI_MCD_REAL));
-			pto += adi_blksize();
-		}
-		asm volatile("membar #Sync\n\t");
-	}
-}
-EXPORT_SYMBOL(copy_user_highpage);
-
-void copy_highpage(struct page *to, struct page *from)
-{
-	char *vfrom, *vto;
-
-	vfrom = kmap_atomic(from);
-	vto = kmap_atomic(to);
-	copy_page(vto, vfrom);
-	kunmap_atomic(vto);
-	kunmap_atomic(vfrom);
-
-	/* If this platform is ADI enabled, copy any ADI tags
-	 * as well
-	 */
-	if (adi_capable()) {
-		unsigned long pfrom, pto, i, adi_tag;
-
-		pfrom = page_to_phys(from);
-		pto = page_to_phys(to);
-
-		for (i = pfrom; i < (pfrom + PAGE_SIZE); i += adi_blksize()) {
-			asm volatile("ldxa [%1] %2, %0\n\t"
-					: "=r" (adi_tag)
-					:  "r" (i), "i" (ASI_MCD_REAL));
-			asm volatile("stxa %0, [%1] %2\n\t"
-					:
-					: "r" (adi_tag), "r" (pto),
-					  "i" (ASI_MCD_REAL));
-			pto += adi_blksize();
-		}
-		asm volatile("membar #Sync\n\t");
-	}
-}
-EXPORT_SYMBOL(copy_highpage);
-
-pgprot_t vm_get_page_prot(unsigned long vm_flags)
-{
-	unsigned long prot = pgprot_val(protection_map[vm_flags &
-					(VM_READ|VM_WRITE|VM_EXEC|VM_SHARED)]);
-
-	if (vm_flags & VM_SPARC_ADI)
-		prot |= _PAGE_MCD_4V;
-
-	return __pgprot(prot);
-}
-EXPORT_SYMBOL(vm_get_page_prot);
diff -Nrup linux-6.16.7/arch/x86/include/asm/cpufeatures.h linux-lenovo-x13s-linux-6.16.y/arch/x86/include/asm/cpufeatures.h
--- linux-6.16.7/arch/x86/include/asm/cpufeatures.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/x86/include/asm/cpufeatures.h	2025-09-11 09:47:42.000000000 -0600
@@ -492,7 +492,6 @@
 #define X86_FEATURE_TSA_SQ_NO		(21*32+11) /* AMD CPU not vulnerable to TSA-SQ */
 #define X86_FEATURE_TSA_L1_NO		(21*32+12) /* AMD CPU not vulnerable to TSA-L1 */
 #define X86_FEATURE_CLEAR_CPU_BUF_VM	(21*32+13) /* Clear CPU buffers using VERW before VMRUN */
-#define X86_FEATURE_IBPB_EXIT_TO_USER	(21*32+14) /* Use IBPB on exit-to-userspace, see VMSCAPE bug */
 
 /*
  * BUG word(s)
@@ -549,5 +548,4 @@
 #define X86_BUG_ITS			X86_BUG( 1*32+ 7) /* "its" CPU is affected by Indirect Target Selection */
 #define X86_BUG_ITS_NATIVE_ONLY		X86_BUG( 1*32+ 8) /* "its_native_only" CPU is affected by ITS, VMX is not affected */
 #define X86_BUG_TSA			X86_BUG( 1*32+ 9) /* "tsa" CPU is affected by Transient Scheduler Attacks */
-#define X86_BUG_VMSCAPE			X86_BUG( 1*32+10) /* "vmscape" CPU is affected by VMSCAPE attacks from guests */
 #endif /* _ASM_X86_CPUFEATURES_H */
diff -Nrup linux-6.16.7/arch/x86/include/asm/entry-common.h linux-lenovo-x13s-linux-6.16.y/arch/x86/include/asm/entry-common.h
--- linux-6.16.7/arch/x86/include/asm/entry-common.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/x86/include/asm/entry-common.h	2025-09-11 09:47:42.000000000 -0600
@@ -93,13 +93,6 @@ static inline void arch_exit_to_user_mod
 	 * 8 (ia32) bits.
 	 */
 	choose_random_kstack_offset(rdtsc());
-
-	/* Avoid unnecessary reads of 'x86_ibpb_exit_to_user' */
-	if (cpu_feature_enabled(X86_FEATURE_IBPB_EXIT_TO_USER) &&
-	    this_cpu_read(x86_ibpb_exit_to_user)) {
-		indirect_branch_prediction_barrier();
-		this_cpu_write(x86_ibpb_exit_to_user, false);
-	}
 }
 #define arch_exit_to_user_mode_prepare arch_exit_to_user_mode_prepare
 
diff -Nrup linux-6.16.7/arch/x86/include/asm/nospec-branch.h linux-lenovo-x13s-linux-6.16.y/arch/x86/include/asm/nospec-branch.h
--- linux-6.16.7/arch/x86/include/asm/nospec-branch.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/x86/include/asm/nospec-branch.h	2025-09-11 09:47:42.000000000 -0600
@@ -530,8 +530,6 @@ void alternative_msr_write(unsigned int
 		: "memory");
 }
 
-DECLARE_PER_CPU(bool, x86_ibpb_exit_to_user);
-
 static inline void indirect_branch_prediction_barrier(void)
 {
 	asm_inline volatile(ALTERNATIVE("", "call write_ibpb", X86_FEATURE_IBPB)
diff -Nrup linux-6.16.7/arch/x86/Kconfig linux-lenovo-x13s-linux-6.16.y/arch/x86/Kconfig
--- linux-6.16.7/arch/x86/Kconfig	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/x86/Kconfig	2025-09-11 09:47:42.000000000 -0600
@@ -2704,15 +2704,6 @@ config MITIGATION_TSA
 	  security vulnerability on AMD CPUs which can lead to forwarding of
 	  invalid info to subsequent instructions and thus can affect their
 	  timing and thereby cause a leakage.
-
-config MITIGATION_VMSCAPE
-	bool "Mitigate VMSCAPE"
-	depends on KVM
-	default y
-	help
-	  Enable mitigation for VMSCAPE attacks. VMSCAPE is a hardware security
-	  vulnerability on Intel and AMD CPUs that may allow a guest to do
-	  Spectre v2 style attacks on userspace hypervisor.
 endif
 
 config ARCH_HAS_ADD_PAGES
diff -Nrup linux-6.16.7/arch/x86/kernel/cpu/bugs.c linux-lenovo-x13s-linux-6.16.y/arch/x86/kernel/cpu/bugs.c
--- linux-6.16.7/arch/x86/kernel/cpu/bugs.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/x86/kernel/cpu/bugs.c	2025-09-11 09:47:42.000000000 -0600
@@ -96,9 +96,6 @@ static void __init its_update_mitigation
 static void __init its_apply_mitigation(void);
 static void __init tsa_select_mitigation(void);
 static void __init tsa_apply_mitigation(void);
-static void __init vmscape_select_mitigation(void);
-static void __init vmscape_update_mitigation(void);
-static void __init vmscape_apply_mitigation(void);
 
 /* The base value of the SPEC_CTRL MSR without task-specific bits set */
 u64 x86_spec_ctrl_base;
@@ -108,14 +105,6 @@ EXPORT_SYMBOL_GPL(x86_spec_ctrl_base);
 DEFINE_PER_CPU(u64, x86_spec_ctrl_current);
 EXPORT_PER_CPU_SYMBOL_GPL(x86_spec_ctrl_current);
 
-/*
- * Set when the CPU has run a potentially malicious guest. An IBPB will
- * be needed to before running userspace. That IBPB will flush the branch
- * predictor content.
- */
-DEFINE_PER_CPU(bool, x86_ibpb_exit_to_user);
-EXPORT_PER_CPU_SYMBOL_GPL(x86_ibpb_exit_to_user);
-
 u64 x86_pred_cmd __ro_after_init = PRED_CMD_IBPB;
 
 static u64 __ro_after_init x86_arch_cap_msr;
@@ -238,7 +227,6 @@ void __init cpu_select_mitigations(void)
 	its_select_mitigation();
 	bhi_select_mitigation();
 	tsa_select_mitigation();
-	vmscape_select_mitigation();
 
 	/*
 	 * After mitigations are selected, some may need to update their
@@ -270,7 +258,6 @@ void __init cpu_select_mitigations(void)
 	bhi_update_mitigation();
 	/* srso_update_mitigation() depends on retbleed_update_mitigation(). */
 	srso_update_mitigation();
-	vmscape_update_mitigation();
 
 	spectre_v1_apply_mitigation();
 	spectre_v2_apply_mitigation();
@@ -288,7 +275,6 @@ void __init cpu_select_mitigations(void)
 	its_apply_mitigation();
 	bhi_apply_mitigation();
 	tsa_apply_mitigation();
-	vmscape_apply_mitigation();
 }
 
 /*
@@ -2369,6 +2355,88 @@ static void update_mds_branch_idle(void)
 	}
 }
 
+#define MDS_MSG_SMT "MDS CPU bug present and SMT on, data leak possible. See https://www.kernel.org/doc/html/latest/admin-guide/hw-vuln/mds.html for more details.\n"
+#define TAA_MSG_SMT "TAA CPU bug present and SMT on, data leak possible. See https://www.kernel.org/doc/html/latest/admin-guide/hw-vuln/tsx_async_abort.html for more details.\n"
+#define MMIO_MSG_SMT "MMIO Stale Data CPU bug present and SMT on, data leak possible. See https://www.kernel.org/doc/html/latest/admin-guide/hw-vuln/processor_mmio_stale_data.html for more details.\n"
+
+void cpu_bugs_smt_update(void)
+{
+	mutex_lock(&spec_ctrl_mutex);
+
+	if (sched_smt_active() && unprivileged_ebpf_enabled() &&
+	    spectre_v2_enabled == SPECTRE_V2_EIBRS_LFENCE)
+		pr_warn_once(SPECTRE_V2_EIBRS_LFENCE_EBPF_SMT_MSG);
+
+	switch (spectre_v2_user_stibp) {
+	case SPECTRE_V2_USER_NONE:
+		break;
+	case SPECTRE_V2_USER_STRICT:
+	case SPECTRE_V2_USER_STRICT_PREFERRED:
+		update_stibp_strict();
+		break;
+	case SPECTRE_V2_USER_PRCTL:
+	case SPECTRE_V2_USER_SECCOMP:
+		update_indir_branch_cond();
+		break;
+	}
+
+	switch (mds_mitigation) {
+	case MDS_MITIGATION_FULL:
+	case MDS_MITIGATION_AUTO:
+	case MDS_MITIGATION_VMWERV:
+		if (sched_smt_active() && !boot_cpu_has(X86_BUG_MSBDS_ONLY))
+			pr_warn_once(MDS_MSG_SMT);
+		update_mds_branch_idle();
+		break;
+	case MDS_MITIGATION_OFF:
+		break;
+	}
+
+	switch (taa_mitigation) {
+	case TAA_MITIGATION_VERW:
+	case TAA_MITIGATION_AUTO:
+	case TAA_MITIGATION_UCODE_NEEDED:
+		if (sched_smt_active())
+			pr_warn_once(TAA_MSG_SMT);
+		break;
+	case TAA_MITIGATION_TSX_DISABLED:
+	case TAA_MITIGATION_OFF:
+		break;
+	}
+
+	switch (mmio_mitigation) {
+	case MMIO_MITIGATION_VERW:
+	case MMIO_MITIGATION_AUTO:
+	case MMIO_MITIGATION_UCODE_NEEDED:
+		if (sched_smt_active())
+			pr_warn_once(MMIO_MSG_SMT);
+		break;
+	case MMIO_MITIGATION_OFF:
+		break;
+	}
+
+	switch (tsa_mitigation) {
+	case TSA_MITIGATION_USER_KERNEL:
+	case TSA_MITIGATION_VM:
+	case TSA_MITIGATION_AUTO:
+	case TSA_MITIGATION_FULL:
+		/*
+		 * TSA-SQ can potentially lead to info leakage between
+		 * SMT threads.
+		 */
+		if (sched_smt_active())
+			static_branch_enable(&cpu_buf_idle_clear);
+		else
+			static_branch_disable(&cpu_buf_idle_clear);
+		break;
+	case TSA_MITIGATION_NONE:
+	case TSA_MITIGATION_UCODE_NEEDED:
+		break;
+	}
+
+	mutex_unlock(&spec_ctrl_mutex);
+}
+
 #undef pr_fmt
 #define pr_fmt(fmt)	"Speculative Store Bypass: " fmt
 
@@ -3070,184 +3138,8 @@ static void __init srso_apply_mitigation
 }
 
 #undef pr_fmt
-#define pr_fmt(fmt)	"VMSCAPE: " fmt
-
-enum vmscape_mitigations {
-	VMSCAPE_MITIGATION_NONE,
-	VMSCAPE_MITIGATION_AUTO,
-	VMSCAPE_MITIGATION_IBPB_EXIT_TO_USER,
-	VMSCAPE_MITIGATION_IBPB_ON_VMEXIT,
-};
-
-static const char * const vmscape_strings[] = {
-	[VMSCAPE_MITIGATION_NONE]		= "Vulnerable",
-	/* [VMSCAPE_MITIGATION_AUTO] */
-	[VMSCAPE_MITIGATION_IBPB_EXIT_TO_USER]	= "Mitigation: IBPB before exit to userspace",
-	[VMSCAPE_MITIGATION_IBPB_ON_VMEXIT]	= "Mitigation: IBPB on VMEXIT",
-};
-
-static enum vmscape_mitigations vmscape_mitigation __ro_after_init =
-	IS_ENABLED(CONFIG_MITIGATION_VMSCAPE) ? VMSCAPE_MITIGATION_AUTO : VMSCAPE_MITIGATION_NONE;
-
-static int __init vmscape_parse_cmdline(char *str)
-{
-	if (!str)
-		return -EINVAL;
-
-	if (!strcmp(str, "off")) {
-		vmscape_mitigation = VMSCAPE_MITIGATION_NONE;
-	} else if (!strcmp(str, "ibpb")) {
-		vmscape_mitigation = VMSCAPE_MITIGATION_IBPB_EXIT_TO_USER;
-	} else if (!strcmp(str, "force")) {
-		setup_force_cpu_bug(X86_BUG_VMSCAPE);
-		vmscape_mitigation = VMSCAPE_MITIGATION_AUTO;
-	} else {
-		pr_err("Ignoring unknown vmscape=%s option.\n", str);
-	}
-
-	return 0;
-}
-early_param("vmscape", vmscape_parse_cmdline);
-
-static void __init vmscape_select_mitigation(void)
-{
-	if (cpu_mitigations_off() ||
-	    !boot_cpu_has_bug(X86_BUG_VMSCAPE) ||
-	    !boot_cpu_has(X86_FEATURE_IBPB)) {
-		vmscape_mitigation = VMSCAPE_MITIGATION_NONE;
-		return;
-	}
-
-	if (vmscape_mitigation == VMSCAPE_MITIGATION_AUTO)
-		vmscape_mitigation = VMSCAPE_MITIGATION_IBPB_EXIT_TO_USER;
-}
-
-static void __init vmscape_update_mitigation(void)
-{
-	if (!boot_cpu_has_bug(X86_BUG_VMSCAPE))
-		return;
-
-	if (retbleed_mitigation == RETBLEED_MITIGATION_IBPB ||
-	    srso_mitigation == SRSO_MITIGATION_IBPB_ON_VMEXIT)
-		vmscape_mitigation = VMSCAPE_MITIGATION_IBPB_ON_VMEXIT;
-
-	pr_info("%s\n", vmscape_strings[vmscape_mitigation]);
-}
-
-static void __init vmscape_apply_mitigation(void)
-{
-	if (vmscape_mitigation == VMSCAPE_MITIGATION_IBPB_EXIT_TO_USER)
-		setup_force_cpu_cap(X86_FEATURE_IBPB_EXIT_TO_USER);
-}
-
-#undef pr_fmt
 #define pr_fmt(fmt) fmt
 
-#define MDS_MSG_SMT "MDS CPU bug present and SMT on, data leak possible. See https://www.kernel.org/doc/html/latest/admin-guide/hw-vuln/mds.html for more details.\n"
-#define TAA_MSG_SMT "TAA CPU bug present and SMT on, data leak possible. See https://www.kernel.org/doc/html/latest/admin-guide/hw-vuln/tsx_async_abort.html for more details.\n"
-#define MMIO_MSG_SMT "MMIO Stale Data CPU bug present and SMT on, data leak possible. See https://www.kernel.org/doc/html/latest/admin-guide/hw-vuln/processor_mmio_stale_data.html for more details.\n"
-#define VMSCAPE_MSG_SMT "VMSCAPE: SMT on, STIBP is required for full protection. See https://www.kernel.org/doc/html/latest/admin-guide/hw-vuln/vmscape.html for more details.\n"
-
-void cpu_bugs_smt_update(void)
-{
-	mutex_lock(&spec_ctrl_mutex);
-
-	if (sched_smt_active() && unprivileged_ebpf_enabled() &&
-	    spectre_v2_enabled == SPECTRE_V2_EIBRS_LFENCE)
-		pr_warn_once(SPECTRE_V2_EIBRS_LFENCE_EBPF_SMT_MSG);
-
-	switch (spectre_v2_user_stibp) {
-	case SPECTRE_V2_USER_NONE:
-		break;
-	case SPECTRE_V2_USER_STRICT:
-	case SPECTRE_V2_USER_STRICT_PREFERRED:
-		update_stibp_strict();
-		break;
-	case SPECTRE_V2_USER_PRCTL:
-	case SPECTRE_V2_USER_SECCOMP:
-		update_indir_branch_cond();
-		break;
-	}
-
-	switch (mds_mitigation) {
-	case MDS_MITIGATION_FULL:
-	case MDS_MITIGATION_AUTO:
-	case MDS_MITIGATION_VMWERV:
-		if (sched_smt_active() && !boot_cpu_has(X86_BUG_MSBDS_ONLY))
-			pr_warn_once(MDS_MSG_SMT);
-		update_mds_branch_idle();
-		break;
-	case MDS_MITIGATION_OFF:
-		break;
-	}
-
-	switch (taa_mitigation) {
-	case TAA_MITIGATION_VERW:
-	case TAA_MITIGATION_AUTO:
-	case TAA_MITIGATION_UCODE_NEEDED:
-		if (sched_smt_active())
-			pr_warn_once(TAA_MSG_SMT);
-		break;
-	case TAA_MITIGATION_TSX_DISABLED:
-	case TAA_MITIGATION_OFF:
-		break;
-	}
-
-	switch (mmio_mitigation) {
-	case MMIO_MITIGATION_VERW:
-	case MMIO_MITIGATION_AUTO:
-	case MMIO_MITIGATION_UCODE_NEEDED:
-		if (sched_smt_active())
-			pr_warn_once(MMIO_MSG_SMT);
-		break;
-	case MMIO_MITIGATION_OFF:
-		break;
-	}
-
-	switch (tsa_mitigation) {
-	case TSA_MITIGATION_USER_KERNEL:
-	case TSA_MITIGATION_VM:
-	case TSA_MITIGATION_AUTO:
-	case TSA_MITIGATION_FULL:
-		/*
-		 * TSA-SQ can potentially lead to info leakage between
-		 * SMT threads.
-		 */
-		if (sched_smt_active())
-			static_branch_enable(&cpu_buf_idle_clear);
-		else
-			static_branch_disable(&cpu_buf_idle_clear);
-		break;
-	case TSA_MITIGATION_NONE:
-	case TSA_MITIGATION_UCODE_NEEDED:
-		break;
-	}
-
-	switch (vmscape_mitigation) {
-	case VMSCAPE_MITIGATION_NONE:
-	case VMSCAPE_MITIGATION_AUTO:
-		break;
-	case VMSCAPE_MITIGATION_IBPB_ON_VMEXIT:
-	case VMSCAPE_MITIGATION_IBPB_EXIT_TO_USER:
-		/*
-		 * Hypervisors can be attacked across-threads, warn for SMT when
-		 * STIBP is not already enabled system-wide.
-		 *
-		 * Intel eIBRS (!AUTOIBRS) implies STIBP on.
-		 */
-		if (!sched_smt_active() ||
-		    spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT ||
-		    spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT_PREFERRED ||
-		    (spectre_v2_in_eibrs_mode(spectre_v2_enabled) &&
-		     !boot_cpu_has(X86_FEATURE_AUTOIBRS)))
-			break;
-		pr_warn_once(VMSCAPE_MSG_SMT);
-		break;
-	}
-
-	mutex_unlock(&spec_ctrl_mutex);
-}
-
 #ifdef CONFIG_SYSFS
 
 #define L1TF_DEFAULT_MSG "Mitigation: PTE Inversion"
@@ -3496,11 +3388,6 @@ static ssize_t tsa_show_state(char *buf)
 	return sysfs_emit(buf, "%s\n", tsa_strings[tsa_mitigation]);
 }
 
-static ssize_t vmscape_show_state(char *buf)
-{
-	return sysfs_emit(buf, "%s\n", vmscape_strings[vmscape_mitigation]);
-}
-
 static ssize_t cpu_show_common(struct device *dev, struct device_attribute *attr,
 			       char *buf, unsigned int bug)
 {
@@ -3567,9 +3454,6 @@ static ssize_t cpu_show_common(struct de
 	case X86_BUG_TSA:
 		return tsa_show_state(buf);
 
-	case X86_BUG_VMSCAPE:
-		return vmscape_show_state(buf);
-
 	default:
 		break;
 	}
@@ -3661,11 +3545,6 @@ ssize_t cpu_show_tsa(struct device *dev,
 {
 	return cpu_show_common(dev, attr, buf, X86_BUG_TSA);
 }
-
-ssize_t cpu_show_vmscape(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	return cpu_show_common(dev, attr, buf, X86_BUG_VMSCAPE);
-}
 #endif
 
 void __warn_thunk(void)
diff -Nrup linux-6.16.7/arch/x86/kernel/cpu/common.c linux-lenovo-x13s-linux-6.16.y/arch/x86/kernel/cpu/common.c
--- linux-6.16.7/arch/x86/kernel/cpu/common.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/x86/kernel/cpu/common.c	2025-09-11 09:47:42.000000000 -0600
@@ -1235,71 +1235,55 @@ static const __initconst struct x86_cpu_
 #define ITS_NATIVE_ONLY	BIT(9)
 /* CPU is affected by Transient Scheduler Attacks */
 #define TSA		BIT(10)
-/* CPU is affected by VMSCAPE */
-#define VMSCAPE		BIT(11)
 
 static const struct x86_cpu_id cpu_vuln_blacklist[] __initconst = {
-	VULNBL_INTEL_STEPS(INTEL_SANDYBRIDGE_X,	     X86_STEP_MAX,	VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_SANDYBRIDGE,	     X86_STEP_MAX,	VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_IVYBRIDGE_X,	     X86_STEP_MAX,	VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_IVYBRIDGE,	     X86_STEP_MAX,	SRBDS | VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_HASWELL,	     X86_STEP_MAX,	SRBDS | VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_HASWELL_L,	     X86_STEP_MAX,	SRBDS | VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_HASWELL_G,	     X86_STEP_MAX,	SRBDS | VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_HASWELL_X,	     X86_STEP_MAX,	MMIO | VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_BROADWELL_D,	     X86_STEP_MAX,	MMIO | VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_BROADWELL_X,	     X86_STEP_MAX,	MMIO | VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_BROADWELL_G,	     X86_STEP_MAX,	SRBDS | VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_BROADWELL,	     X86_STEP_MAX,	SRBDS | VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_SKYLAKE_X,		      0x5,	MMIO | RETBLEED | GDS | VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_SKYLAKE_X,	     X86_STEP_MAX,	MMIO | RETBLEED | GDS | ITS | VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_SKYLAKE_L,	     X86_STEP_MAX,	MMIO | RETBLEED | GDS | SRBDS | VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_SKYLAKE,	     X86_STEP_MAX,	MMIO | RETBLEED | GDS | SRBDS | VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_KABYLAKE_L,		      0xb,	MMIO | RETBLEED | GDS | SRBDS | VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_KABYLAKE_L,	     X86_STEP_MAX,	MMIO | RETBLEED | GDS | SRBDS | ITS | VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_KABYLAKE,		      0xc,	MMIO | RETBLEED | GDS | SRBDS | VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_KABYLAKE,	     X86_STEP_MAX,	MMIO | RETBLEED | GDS | SRBDS | ITS | VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_CANNONLAKE_L,	     X86_STEP_MAX,	RETBLEED | VMSCAPE),
+	VULNBL_INTEL_STEPS(INTEL_IVYBRIDGE,	     X86_STEP_MAX,	SRBDS),
+	VULNBL_INTEL_STEPS(INTEL_HASWELL,	     X86_STEP_MAX,	SRBDS),
+	VULNBL_INTEL_STEPS(INTEL_HASWELL_L,	     X86_STEP_MAX,	SRBDS),
+	VULNBL_INTEL_STEPS(INTEL_HASWELL_G,	     X86_STEP_MAX,	SRBDS),
+	VULNBL_INTEL_STEPS(INTEL_HASWELL_X,	     X86_STEP_MAX,	MMIO),
+	VULNBL_INTEL_STEPS(INTEL_BROADWELL_D,	     X86_STEP_MAX,	MMIO),
+	VULNBL_INTEL_STEPS(INTEL_BROADWELL_G,	     X86_STEP_MAX,	SRBDS),
+	VULNBL_INTEL_STEPS(INTEL_BROADWELL_X,	     X86_STEP_MAX,	MMIO),
+	VULNBL_INTEL_STEPS(INTEL_BROADWELL,	     X86_STEP_MAX,	SRBDS),
+	VULNBL_INTEL_STEPS(INTEL_SKYLAKE_X,		      0x5,	MMIO | RETBLEED | GDS),
+	VULNBL_INTEL_STEPS(INTEL_SKYLAKE_X,	     X86_STEP_MAX,	MMIO | RETBLEED | GDS | ITS),
+	VULNBL_INTEL_STEPS(INTEL_SKYLAKE_L,	     X86_STEP_MAX,	MMIO | RETBLEED | GDS | SRBDS),
+	VULNBL_INTEL_STEPS(INTEL_SKYLAKE,	     X86_STEP_MAX,	MMIO | RETBLEED | GDS | SRBDS),
+	VULNBL_INTEL_STEPS(INTEL_KABYLAKE_L,		      0xb,	MMIO | RETBLEED | GDS | SRBDS),
+	VULNBL_INTEL_STEPS(INTEL_KABYLAKE_L,	     X86_STEP_MAX,	MMIO | RETBLEED | GDS | SRBDS | ITS),
+	VULNBL_INTEL_STEPS(INTEL_KABYLAKE,		      0xc,	MMIO | RETBLEED | GDS | SRBDS),
+	VULNBL_INTEL_STEPS(INTEL_KABYLAKE,	     X86_STEP_MAX,	MMIO | RETBLEED | GDS | SRBDS | ITS),
+	VULNBL_INTEL_STEPS(INTEL_CANNONLAKE_L,	     X86_STEP_MAX,	RETBLEED),
 	VULNBL_INTEL_STEPS(INTEL_ICELAKE_L,	     X86_STEP_MAX,	MMIO | MMIO_SBDS | RETBLEED | GDS | ITS | ITS_NATIVE_ONLY),
 	VULNBL_INTEL_STEPS(INTEL_ICELAKE_D,	     X86_STEP_MAX,	MMIO | GDS | ITS | ITS_NATIVE_ONLY),
 	VULNBL_INTEL_STEPS(INTEL_ICELAKE_X,	     X86_STEP_MAX,	MMIO | GDS | ITS | ITS_NATIVE_ONLY),
-	VULNBL_INTEL_STEPS(INTEL_COMETLAKE,	     X86_STEP_MAX,	MMIO | MMIO_SBDS | RETBLEED | GDS | ITS | VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_COMETLAKE_L,		      0x0,	MMIO | RETBLEED | ITS | VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_COMETLAKE_L,	     X86_STEP_MAX,	MMIO | MMIO_SBDS | RETBLEED | GDS | ITS | VMSCAPE),
+	VULNBL_INTEL_STEPS(INTEL_COMETLAKE,	     X86_STEP_MAX,	MMIO | MMIO_SBDS | RETBLEED | GDS | ITS),
+	VULNBL_INTEL_STEPS(INTEL_COMETLAKE_L,		      0x0,	MMIO | RETBLEED | ITS),
+	VULNBL_INTEL_STEPS(INTEL_COMETLAKE_L,	     X86_STEP_MAX,	MMIO | MMIO_SBDS | RETBLEED | GDS | ITS),
 	VULNBL_INTEL_STEPS(INTEL_TIGERLAKE_L,	     X86_STEP_MAX,	GDS | ITS | ITS_NATIVE_ONLY),
 	VULNBL_INTEL_STEPS(INTEL_TIGERLAKE,	     X86_STEP_MAX,	GDS | ITS | ITS_NATIVE_ONLY),
 	VULNBL_INTEL_STEPS(INTEL_LAKEFIELD,	     X86_STEP_MAX,	MMIO | MMIO_SBDS | RETBLEED),
 	VULNBL_INTEL_STEPS(INTEL_ROCKETLAKE,	     X86_STEP_MAX,	MMIO | RETBLEED | GDS | ITS | ITS_NATIVE_ONLY),
-	VULNBL_INTEL_TYPE(INTEL_ALDERLAKE,		     ATOM,	RFDS | VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_ALDERLAKE,	     X86_STEP_MAX,	VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_ALDERLAKE_L,	     X86_STEP_MAX,	RFDS | VMSCAPE),
-	VULNBL_INTEL_TYPE(INTEL_RAPTORLAKE,		     ATOM,	RFDS | VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_RAPTORLAKE,	     X86_STEP_MAX,	VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_RAPTORLAKE_P,	     X86_STEP_MAX,	RFDS | VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_RAPTORLAKE_S,	     X86_STEP_MAX,	RFDS | VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_METEORLAKE_L,	     X86_STEP_MAX,	VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_ARROWLAKE_H,	     X86_STEP_MAX,	VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_ARROWLAKE,	     X86_STEP_MAX,	VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_ARROWLAKE_U,	     X86_STEP_MAX,	VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_LUNARLAKE_M,	     X86_STEP_MAX,	VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_SAPPHIRERAPIDS_X,   X86_STEP_MAX,	VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_GRANITERAPIDS_X,    X86_STEP_MAX,	VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_EMERALDRAPIDS_X,    X86_STEP_MAX,	VMSCAPE),
-	VULNBL_INTEL_STEPS(INTEL_ATOM_GRACEMONT,     X86_STEP_MAX,	RFDS | VMSCAPE),
+	VULNBL_INTEL_TYPE(INTEL_ALDERLAKE,		     ATOM,	RFDS),
+	VULNBL_INTEL_STEPS(INTEL_ALDERLAKE_L,	     X86_STEP_MAX,	RFDS),
+	VULNBL_INTEL_TYPE(INTEL_RAPTORLAKE,		     ATOM,	RFDS),
+	VULNBL_INTEL_STEPS(INTEL_RAPTORLAKE_P,	     X86_STEP_MAX,	RFDS),
+	VULNBL_INTEL_STEPS(INTEL_RAPTORLAKE_S,	     X86_STEP_MAX,	RFDS),
+	VULNBL_INTEL_STEPS(INTEL_ATOM_GRACEMONT,     X86_STEP_MAX,	RFDS),
 	VULNBL_INTEL_STEPS(INTEL_ATOM_TREMONT,	     X86_STEP_MAX,	MMIO | MMIO_SBDS | RFDS),
 	VULNBL_INTEL_STEPS(INTEL_ATOM_TREMONT_D,     X86_STEP_MAX,	MMIO | RFDS),
 	VULNBL_INTEL_STEPS(INTEL_ATOM_TREMONT_L,     X86_STEP_MAX,	MMIO | MMIO_SBDS | RFDS),
 	VULNBL_INTEL_STEPS(INTEL_ATOM_GOLDMONT,      X86_STEP_MAX,	RFDS),
 	VULNBL_INTEL_STEPS(INTEL_ATOM_GOLDMONT_D,    X86_STEP_MAX,	RFDS),
 	VULNBL_INTEL_STEPS(INTEL_ATOM_GOLDMONT_PLUS, X86_STEP_MAX,	RFDS),
-	VULNBL_INTEL_STEPS(INTEL_ATOM_CRESTMONT_X,   X86_STEP_MAX,	VMSCAPE),
 
 	VULNBL_AMD(0x15, RETBLEED),
 	VULNBL_AMD(0x16, RETBLEED),
-	VULNBL_AMD(0x17, RETBLEED | SMT_RSB | SRSO | VMSCAPE),
-	VULNBL_HYGON(0x18, RETBLEED | SMT_RSB | SRSO | VMSCAPE),
-	VULNBL_AMD(0x19, SRSO | TSA | VMSCAPE),
-	VULNBL_AMD(0x1a, SRSO | VMSCAPE),
+	VULNBL_AMD(0x17, RETBLEED | SMT_RSB | SRSO),
+	VULNBL_HYGON(0x18, RETBLEED | SMT_RSB | SRSO),
+	VULNBL_AMD(0x19, SRSO | TSA),
+	VULNBL_AMD(0x1a, SRSO),
 	{}
 };
 
@@ -1558,14 +1542,6 @@ static void __init cpu_set_bug_bits(stru
 		}
 	}
 
-	/*
-	 * Set the bug only on bare-metal. A nested hypervisor should already be
-	 * deploying IBPB to isolate itself from nested guests.
-	 */
-	if (cpu_matches(cpu_vuln_blacklist, VMSCAPE) &&
-	    !boot_cpu_has(X86_FEATURE_HYPERVISOR))
-		setup_force_cpu_bug(X86_BUG_VMSCAPE);
-
 	if (cpu_matches(cpu_vuln_whitelist, NO_MELTDOWN))
 		return;
 
diff -Nrup linux-6.16.7/arch/x86/kvm/x86.c linux-lenovo-x13s-linux-6.16.y/arch/x86/kvm/x86.c
--- linux-6.16.7/arch/x86/kvm/x86.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/x86/kvm/x86.c	2025-09-11 09:47:42.000000000 -0600
@@ -11146,15 +11146,6 @@ static int vcpu_enter_guest(struct kvm_v
 		wrmsrq(MSR_IA32_XFD_ERR, 0);
 
 	/*
-	 * Mark this CPU as needing a branch predictor flush before running
-	 * userspace. Must be done before enabling preemption to ensure it gets
-	 * set for the CPU that actually ran the guest, and not the CPU that it
-	 * may migrate to.
-	 */
-	if (cpu_feature_enabled(X86_FEATURE_IBPB_EXIT_TO_USER))
-		this_cpu_write(x86_ibpb_exit_to_user, true);
-
-	/*
 	 * Consume any pending interrupts, including the possible source of
 	 * VM-Exit on SVM and any ticks that occur between VM-Exit and now.
 	 * An instruction is required after local_irq_enable() to fully unblock
diff -Nrup linux-6.16.7/distro/Kconfig linux-lenovo-x13s-linux-6.16.y/distro/Kconfig
--- linux-6.16.7/distro/Kconfig	2025-09-13 16:15:46.057136000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/distro/Kconfig	1969-12-31 17:00:00.000000000 -0700
@@ -1,310 +0,0 @@
-menu "Gentoo Linux"
-
-config GENTOO_LINUX
-	bool "Gentoo Linux support"
-
-	default y
-
-	select CPU_FREQ_DEFAULT_GOV_SCHEDUTIL
-
-	help
-		In order to boot Gentoo Linux a minimal set of config settings needs to
-		be enabled in the kernel; to avoid the users from having to enable them
-		manually as part of a Gentoo Linux installation or a new clean config,
-		we enable these config settings by default for convenience.
-
-		See the settings that become available for more details and fine-tuning.
-
-config GENTOO_LINUX_UDEV
-	bool "Linux dynamic and persistent device naming (userspace devfs) support"
-
-	depends on GENTOO_LINUX
-	default y if GENTOO_LINUX
-
-	select DEVTMPFS
-	select TMPFS
-	select UNIX
-
-	select MMU
-	select SHMEM
-
-	help
-		In order to boot Gentoo Linux a minimal set of config settings needs to
-		be enabled in the kernel; to avoid the users from having to enable them
-		manually as part of a Gentoo Linux installation or a new clean config,
-		we enable these config settings by default for convenience.
-
-		Currently this only selects TMPFS, DEVTMPFS and their dependencies.
-		TMPFS is enabled to maintain a tmpfs file system at /dev/shm, /run and
-		/sys/fs/cgroup; DEVTMPFS to maintain a devtmpfs file system at /dev.
-
-		Some of these are critical files that need to be available early in the
-		boot process; if not available, it causes sysfs and udev to malfunction.
-
-		To ensure Gentoo Linux boots, it is best to leave this setting enabled;
-		if you run a custom setup, you could consider whether to disable this.
-
-config GENTOO_LINUX_PORTAGE
-	bool "Select options required by Portage features"
-
-	depends on GENTOO_LINUX
-	default y if GENTOO_LINUX
-
-	select CGROUPS
-	select NAMESPACES
-	select IPC_NS
-	select NET_NS
-	select PID_NS
-	select SYSVIPC
-	select USER_NS
-	select UTS_NS
-
-	help
-		This enables options required by various Portage FEATURES.
-		Currently this selects:
-
-		CGROUPS     (required for FEATURES=cgroup)
-		IPC_NS      (required for FEATURES=ipc-sandbox)
-		NET_NS      (required for FEATURES=network-sandbox)
-		PID_NS		(required for FEATURES=pid-sandbox)
-		SYSVIPC     (required by IPC_NS)
-   
-
-		It is highly recommended that you leave this enabled as these FEATURES
-		are, or will soon be, enabled by default.
-
-menu "Support for init systems, system and service managers"
-	visible if GENTOO_LINUX
-
-config GENTOO_LINUX_INIT_SCRIPT
-	bool "OpenRC, runit and other script based systems and managers"
-
-	default y if GENTOO_LINUX
-
-	depends on GENTOO_LINUX
-
-	select BINFMT_SCRIPT
-	select CGROUPS
-	select EPOLL
-	select FILE_LOCKING
-	select INOTIFY_USER
-	select SIGNALFD
-	select TIMERFD
-
-	help
-		The init system is the first thing that loads after the kernel booted.
-
-		These config settings allow you to select which init systems to support;
-		instead of having to select all the individual settings all over the
-		place, these settings allows you to select all the settings at once.
-
-		This particular setting enables all the known requirements for OpenRC,
-		runit and similar script based systems and managers.
-
-		If you are unsure about this, it is best to leave this setting enabled.
-
-config GENTOO_LINUX_INIT_SYSTEMD
-	bool "systemd"
-
-	default n
-
-	depends on GENTOO_LINUX && GENTOO_LINUX_UDEV
-
-	select AUTOFS_FS
-	select BLK_DEV_BSG if SCSI
-	select BPF_SYSCALL
-	select CGROUP_BPF
-	select CGROUPS
-	select CRYPTO_HMAC 
-	select CRYPTO_SHA256
-	select CRYPTO_USER_API_HASH
-	select DEVPTS_MULTIPLE_INSTANCES
-	select DMIID if X86_32 || X86_64 || X86
-	select EPOLL
-	select FANOTIFY
-	select FHANDLE
-	select FILE_LOCKING
-	select INOTIFY_USER
-	select IPV6
-	select KCMP
-	select NET
-	select NET_NS
-	select PROC_FS
-	select SECCOMP if HAVE_ARCH_SECCOMP
-	select SECCOMP_FILTER if HAVE_ARCH_SECCOMP_FILTER
-	select SIGNALFD
-	select SYSFS
-	select TIMERFD
-	select TMPFS_POSIX_ACL
-	select TMPFS_XATTR
-
-	select ANON_INODES
-	select BLOCK
-	select EVENTFD
-	select FSNOTIFY
-	select INET
-	select NLATTR
-
-	help
-		The init system is the first thing that loads after the kernel booted.
-
-		These config settings allow you to select which init systems to support;
-		instead of having to select all the individual settings all over the
-		place, these settings allows you to select all the settings at once.
-
-		This particular setting enables all the known requirements for systemd;
-		it also enables suggested optional settings, as the package suggests to.
-
-endmenu
-
-menuconfig GENTOO_KERNEL_SELF_PROTECTION
-	bool "Kernel Self Protection Project"
-	depends on GENTOO_LINUX
-	help
-		Recommended Kernel settings based on the suggestions from the Kernel Self Protection Project
-		See: https://kernsec.org/wiki/index.php/Kernel_Self_Protection_Project/Recommended_Settings
-		Note, there may be additional settings for which the CONFIG_ setting is invisible in menuconfig due 
-		to unmet dependencies. Search for GENTOO_KERNEL_SELF_PROTECTION_COMMON and search for 
-		GENTOO_KERNEL_SELF_PROTECTION_{X86_64, ARM64, X86_32, ARM} for dependency information on your 
-		specific architecture.
-		Note 2: Please see the URL above for numeric settings, e.g. CONFIG_DEFAULT_MMAP_MIN_ADDR=65536
-		for X86_64
-
-if GENTOO_KERNEL_SELF_PROTECTION
-config GENTOO_KERNEL_SELF_PROTECTION_COMMON
-	bool "Enable Kernel Self Protection Project Recommendations"
-
-	depends on GENTOO_LINUX && !ACPI_CUSTOM_METHOD && !COMPAT_BRK && !PROC_KCORE && !COMPAT_VDSO && !KEXEC && !HIBERNATION && !LEGACY_PTYS && !X86_X32_ABI && !MODIFY_LDT_SYSCALL && GCC_PLUGINS && !IOMMU_DEFAULT_DMA_LAZY && !IOMMU_DEFAULT_PASSTHROUGH && IOMMU_DEFAULT_DMA_STRICT && SECURITY && !ARCH_EPHEMERAL_INODES  && RANDSTRUCT_PERFORMANCE
-
-	select BUG
-	select STRICT_KERNEL_RWX
-	select DEBUG_WX
-	select STACKPROTECTOR
-	select STACKPROTECTOR_STRONG
-	select STRICT_DEVMEM if DEVMEM=y
-	select IO_STRICT_DEVMEM if DEVMEM=y
-	select SYN_COOKIES
-	select DEBUG_CREDENTIALS
-	select DEBUG_NOTIFIERS
-	select DEBUG_LIST
-	select DEBUG_SG
-	select HARDENED_USERCOPY if HAVE_HARDENED_USERCOPY_ALLOCATOR=y
-	select KFENCE if HAVE_ARCH_KFENCE && (!SLAB || SLUB)
-	select PAGE_TABLE_CHECK if ARCH_SUPPORTS_PAGE_TABLE_CHECK=y && EXCLUSIVE_SYSTEM_RAM=y  
-	select PAGE_TABLE_CHECK_ENFORCED if PAGE_TABLE_CHECK=y
-	select RANDOMIZE_KSTACK_OFFSET_DEFAULT if HAVE_ARCH_RANDOMIZE_KSTACK_OFFSET && (INIT_STACK_NONE || !CC_IS_CLANG || CLANG_VERSION>=140000)
-	select SECURITY_LANDLOCK
-	select SCHED_CORE if SCHED_SMT
-	select BUG_ON_DATA_CORRUPTION
-	select RANDOM_KMALLOC_CACHES if SLUB_TINY=n
-	select SCHED_STACK_END_CHECK
-	select SECCOMP if HAVE_ARCH_SECCOMP
-	select SECCOMP_FILTER if HAVE_ARCH_SECCOMP_FILTER
-	select SECURITY_YAMA
-	select SLAB_FREELIST_RANDOM
-	select SLAB_FREELIST_HARDENED
-	select SHUFFLE_PAGE_ALLOCATOR
-	select SLUB_DEBUG
-	select UBSAN
-	select CC_HAS_UBSAN_BOUNDS_STRICT if !CC_HAS_UBSAN_ARRAY_BOUNDS
-	select UBSAN_BOUNDS
-	select UBSAN_SHIFT
-	select PAGE_POISONING
-	select PAGE_POISONING_NO_SANITY
-	select PAGE_POISONING_ZERO
-	select INIT_ON_ALLOC_DEFAULT_ON
-	select INIT_ON_FREE_DEFAULT_ON
-	select REFCOUNT_FULL
-	select FORTIFY_SOURCE
-	select SECURITY_DMESG_RESTRICT
-	select PANIC_ON_OOPS
-	select GCC_PLUGIN_LATENT_ENTROPY
-	select GCC_PLUGIN_STRUCTLEAK
-	select GCC_PLUGIN_STRUCTLEAK_BYREF_ALL
-	select GCC_PLUGIN_RANDSTRUCT 
-	select GCC_PLUGIN_RANDSTRUCT_PERFORMANCE
-	select ZERO_CALL_USED_REGS if CC_HAS_ZERO_CALL_USED_REGS
-
-	help
-		Search for GENTOO_KERNEL_SELF_PROTECTION_{X86_64, ARM64, X86_32, ARM} for dependency 
-		information on your specific architecture.  Note 2: Please see the URL above for 
-		numeric settings, e.g. CONFIG_DEFAULT_MMAP_MIN_ADDR=65536 for X86_64
-
-config GENTOO_KERNEL_SELF_PROTECTION_X86_64
-	bool "X86_64 KSPP Settings" if GENTOO_KERNEL_SELF_PROTECTION_COMMON
-
-	depends on !X86_MSR && X86_64 && GENTOO_KERNEL_SELF_PROTECTION
-	default n
-	
-	select GCC_PLUGIN_STACKLEAK
-	select X86_KERNEL_IBT if CC_HAS_IBT=y && HAVE_OBJTOOL=y && (!LD_IS_LLD=n || LLD_VERSION>=140000) 
-	select LEGACY_VSYSCALL_NONE
- 	select PAGE_TABLE_ISOLATION
-	select RANDOMIZE_BASE
-	select RANDOMIZE_MEMORY
-	select RELOCATABLE
-	select X86_USER_SHADOW_STACK if AS_WRUSS=y
-	select VMAP_STACK
-
-
-config GENTOO_KERNEL_SELF_PROTECTION_ARM64
-	bool "ARM64 KSPP Settings"
-
-	depends on ARM64
-	default n
-
-	select ARM64_BTI
-	select ARM64_E0PD
-	select ARM64_EPAN if ARM64_PAN=y
-	select ARM64_MTE if (ARM64_AS_HAS_MTE=y && ARM64_TAGGED_ADDR_ABI=y ) && ( AS_HAS_ARMV8_5=y ) && ( AS_HAS_LSE_ATOMICS=y )
-	select ARM64_PTR_AUTH
-	select ARM64_PTR_AUTH_KERNEL if ( ARM64_PTR_AUTH=y ) && (( CC_HAS_SIGN_RETURN_ADDRESS=y || CC_HAS_BRANCH_PROT_PAC_RET=y ) && AS_HAS_ARMV8_3=y ) && ( LD_IS_LLD=y || LD_VERSION >= 23301 || ( CC_IS_GCC=y && GCC_VERSION < 90100 )) && (CC_IS_CLANG=n || AS_HAS_CFI_NEGATE_RA_STATE=y ) && ((FUNCTION_GRAPH_TRACER=n || DYNAMIC_FTRACE_WITH_ARGS=y ))
-	select ARM64_BTI_KERNEL if ( ARM64_BTI=y ) && ( ARM64_PTR_AUTH_KERNEL=y ) && ( CC_HAS_BRANCH_PROT_PAC_RET_BTI=y ) && (CC_IS_GCC=n || GCC_VERSION >= 100100 ) && (CC_IS_GCC=n ) && ((FUNCTION_GRAPH_TRACE=n || DYNAMIC_FTRACE_WITH_ARG=y ))
-	select ARM64_SW_TTBR0_PAN
-	select CONFIG_UNMAP_KERNEL_AT_EL0
-	select GCC_PLUGIN_STACKLEAK
-	select KASAN_HW_TAGS if HAVE_ARCH_KASAN_HW_TAGS=y
-	select RANDOMIZE_BASE
-	select RELOCATABLE
-	select SHADOW_CALL_STACK if ARCH_SUPPORTS_SHADOW_CALL_STACK=y && (DYNAMIC_FTRACE_WITH_ARGS=y || DYNAMIC_FTRACE_WITH_REGS=y || FUNCTION_GRAPH_TRACER=n) && MMU=y 
-	select UNWIND_PATCH_PAC_INTO_SCS if (CC_IS_CLANG=y && CLANG_VERSION >= CONFIG_150000 ) && ( ARM64_PTR_AUTH_KERNEL=y && CC_HAS_BRANCH_PROT_PAC_RET=y ) && ( SHADOW_CALL_STACK=y )
-	select VMAP_STACK
-
-config GENTOO_KERNEL_SELF_PROTECTION_X86_32
-	bool "X86_32 KSPP Settings"
-
-	depends on !X86_MSR && !MODIFY_LDT_SYSCALL && !M486 && X86_32
-	default n
-
-	select HIGHMEM64G
-	select X86_PAE
-	select RANDOMIZE_BASE
-	select RELOCATABLE
-	select PAGE_TABLE_ISOLATION
-
-config GENTOO_KERNEL_SELF_PROTECTION_ARM
-	bool "ARM KSPP Settings"
-
-	depends on !OABI_COMPAT && ARM
-	default n
-
-	select VMSPLIT_3G
-	select STRICT_MEMORY_RWX
-	select CPU_SW_DOMAIN_PAN
-
-endif
-
-config GENTOO_PRINT_FIRMWARE_INFO
-	bool "Print firmware information that the kernel attempts to load"
-
-	depends on GENTOO_LINUX
-	default y
-
-	help
-		Enable this option to print information about firmware that the kernel
-		is attempting to load.  This information can be accessible via the
-		dmesg command-line utility
-
-		See the settings that become available for more details and fine-tuning.
-
-endmenu
diff -Nrup linux-6.16.7/Documentation/ABI/testing/sysfs-devices-system-cpu linux-lenovo-x13s-linux-6.16.y/Documentation/ABI/testing/sysfs-devices-system-cpu
--- linux-6.16.7/Documentation/ABI/testing/sysfs-devices-system-cpu	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/Documentation/ABI/testing/sysfs-devices-system-cpu	2025-09-11 09:47:42.000000000 -0600
@@ -586,7 +586,6 @@ What:		/sys/devices/system/cpu/vulnerabi
 		/sys/devices/system/cpu/vulnerabilities/srbds
 		/sys/devices/system/cpu/vulnerabilities/tsa
 		/sys/devices/system/cpu/vulnerabilities/tsx_async_abort
-		/sys/devices/system/cpu/vulnerabilities/vmscape
 Date:		January 2018
 Contact:	Linux kernel mailing list <linux-kernel@vger.kernel.org>
 Description:	Information about CPU vulnerabilities
diff -Nrup linux-6.16.7/Documentation/admin-guide/hw-vuln/index.rst linux-lenovo-x13s-linux-6.16.y/Documentation/admin-guide/hw-vuln/index.rst
--- linux-6.16.7/Documentation/admin-guide/hw-vuln/index.rst	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/Documentation/admin-guide/hw-vuln/index.rst	2025-09-11 09:47:42.000000000 -0600
@@ -25,4 +25,3 @@ are configurable at compile, boot or run
    rsb
    old_microcode
    indirect-target-selection
-   vmscape
diff -Nrup linux-6.16.7/Documentation/admin-guide/hw-vuln/vmscape.rst linux-lenovo-x13s-linux-6.16.y/Documentation/admin-guide/hw-vuln/vmscape.rst
--- linux-6.16.7/Documentation/admin-guide/hw-vuln/vmscape.rst	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/Documentation/admin-guide/hw-vuln/vmscape.rst	1969-12-31 17:00:00.000000000 -0700
@@ -1,110 +0,0 @@
-.. SPDX-License-Identifier: GPL-2.0
-
-VMSCAPE
-=======
-
-VMSCAPE is a vulnerability that may allow a guest to influence the branch
-prediction in host userspace. It particularly affects hypervisors like QEMU.
-
-Even if a hypervisor may not have any sensitive data like disk encryption keys,
-guest-userspace may be able to attack the guest-kernel using the hypervisor as
-a confused deputy.
-
-Affected processors
--------------------
-
-The following CPU families are affected by VMSCAPE:
-
-**Intel processors:**
-  - Skylake generation (Parts without Enhanced-IBRS)
-  - Cascade Lake generation - (Parts affected by ITS guest/host separation)
-  - Alder Lake and newer (Parts affected by BHI)
-
-Note that, BHI affected parts that use BHB clearing software mitigation e.g.
-Icelake are not vulnerable to VMSCAPE.
-
-**AMD processors:**
-  - Zen series (families 0x17, 0x19, 0x1a)
-
-** Hygon processors:**
- - Family 0x18
-
-Mitigation
-----------
-
-Conditional IBPB
-----------------
-
-Kernel tracks when a CPU has run a potentially malicious guest and issues an
-IBPB before the first exit to userspace after VM-exit. If userspace did not run
-between VM-exit and the next VM-entry, no IBPB is issued.
-
-Note that the existing userspace mitigation against Spectre-v2 is effective in
-protecting the userspace. They are insufficient to protect the userspace VMMs
-from a malicious guest. This is because Spectre-v2 mitigations are applied at
-context switch time, while the userspace VMM can run after a VM-exit without a
-context switch.
-
-Vulnerability enumeration and mitigation is not applied inside a guest. This is
-because nested hypervisors should already be deploying IBPB to isolate
-themselves from nested guests.
-
-SMT considerations
-------------------
-
-When Simultaneous Multi-Threading (SMT) is enabled, hypervisors can be
-vulnerable to cross-thread attacks. For complete protection against VMSCAPE
-attacks in SMT environments, STIBP should be enabled.
-
-The kernel will issue a warning if SMT is enabled without adequate STIBP
-protection. Warning is not issued when:
-
-- SMT is disabled
-- STIBP is enabled system-wide
-- Intel eIBRS is enabled (which implies STIBP protection)
-
-System information and options
-------------------------------
-
-The sysfs file showing VMSCAPE mitigation status is:
-
-  /sys/devices/system/cpu/vulnerabilities/vmscape
-
-The possible values in this file are:
-
- * 'Not affected':
-
-   The processor is not vulnerable to VMSCAPE attacks.
-
- * 'Vulnerable':
-
-   The processor is vulnerable and no mitigation has been applied.
-
- * 'Mitigation: IBPB before exit to userspace':
-
-   Conditional IBPB mitigation is enabled. The kernel tracks when a CPU has
-   run a potentially malicious guest and issues an IBPB before the first
-   exit to userspace after VM-exit.
-
- * 'Mitigation: IBPB on VMEXIT':
-
-   IBPB is issued on every VM-exit. This occurs when other mitigations like
-   RETBLEED or SRSO are already issuing IBPB on VM-exit.
-
-Mitigation control on the kernel command line
-----------------------------------------------
-
-The mitigation can be controlled via the ``vmscape=`` command line parameter:
-
- * ``vmscape=off``:
-
-   Disable the VMSCAPE mitigation.
-
- * ``vmscape=ibpb``:
-
-   Enable conditional IBPB mitigation (default when CONFIG_MITIGATION_VMSCAPE=y).
-
- * ``vmscape=force``:
-
-   Force vulnerability detection and mitigation even on processors that are
-   not known to be affected.
diff -Nrup linux-6.16.7/Documentation/admin-guide/kernel-parameters.txt linux-lenovo-x13s-linux-6.16.y/Documentation/admin-guide/kernel-parameters.txt
--- linux-6.16.7/Documentation/admin-guide/kernel-parameters.txt	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/Documentation/admin-guide/kernel-parameters.txt	2025-09-11 09:47:42.000000000 -0600
@@ -3774,7 +3774,6 @@
 					       srbds=off [X86,INTEL]
 					       ssbd=force-off [ARM64]
 					       tsx_async_abort=off [X86]
-					       vmscape=off [X86]
 
 				Exceptions:
 					       This does not have any effect on
@@ -7938,16 +7937,6 @@
 	vmpoff=		[KNL,S390] Perform z/VM CP command after power off.
 			Format: <command>
 
-	vmscape=	[X86] Controls mitigation for VMscape attacks.
-			VMscape attacks can leak information from a userspace
-			hypervisor to a guest via speculative side-channels.
-
-			off		- disable the mitigation
-			ibpb		- use Indirect Branch Prediction Barrier
-					  (IBPB) mitigation (default)
-			force		- force vulnerability detection even on
-					  unaffected processors
-
 	vsyscall=	[X86-64,EARLY]
 			Controls the behavior of vsyscalls (i.e. calls to
 			fixed addresses of 0xffffffffff600x00 from legacy
diff -Nrup linux-6.16.7/Documentation/Changes linux-lenovo-x13s-linux-6.16.y/Documentation/Changes
--- linux-6.16.7/Documentation/Changes	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/Documentation/Changes	2025-09-11 09:47:42.000000000 -0600
@@ -1,575 +1 @@
-.. _changes:
-
-Minimal requirements to compile the Kernel
-++++++++++++++++++++++++++++++++++++++++++
-
-Intro
-=====
-
-This document is designed to provide a list of the minimum levels of
-software necessary to run the current kernel version.
-
-This document is originally based on my "Changes" file for 2.0.x kernels
-and therefore owes credit to the same people as that file (Jared Mauch,
-Axel Boldt, Alessandro Sigala, and countless other users all over the
-'net).
-
-Current Minimal Requirements
-****************************
-
-Upgrade to at **least** these software revisions before thinking you've
-encountered a bug!  If you're unsure what version you're currently
-running, the suggested command should tell you.
-
-Again, keep in mind that this list assumes you are already functionally
-running a Linux kernel.  Also, not all tools are necessary on all
-systems; obviously, if you don't have any PC Card hardware, for example,
-you probably needn't concern yourself with pcmciautils.
-
-====================== ===============  ========================================
-        Program        Minimal version       Command to check the version
-====================== ===============  ========================================
-GNU C                  8.1              gcc --version
-Clang/LLVM (optional)  13.0.1           clang --version
-Rust (optional)        1.78.0           rustc --version
-bindgen (optional)     0.65.1           bindgen --version
-GNU make               4.0              make --version
-bash                   4.2              bash --version
-binutils               2.30             ld -v
-flex                   2.5.35           flex --version
-bison                  2.0              bison --version
-pahole                 1.16             pahole --version
-util-linux             2.10o            mount --version
-kmod                   13               depmod -V
-e2fsprogs              1.41.4           e2fsck -V
-jfsutils               1.1.3            fsck.jfs -V
-reiserfsprogs          3.6.3            reiserfsck -V
-xfsprogs               2.6.0            xfs_db -V
-squashfs-tools         4.0              mksquashfs -version
-btrfs-progs            0.18             btrfs --version
-pcmciautils            004              pccardctl -V
-quota-tools            3.09             quota -V
-PPP                    2.4.0            pppd --version
-nfs-utils              1.0.5            showmount --version
-procps                 3.2.0            ps --version
-udev                   081              udevd --version
-grub                   0.93             grub --version || grub-install --version
-mcelog                 0.6              mcelog --version
-iptables               1.4.2            iptables -V
-openssl & libcrypto    1.0.0            openssl version
-bc                     1.06.95          bc --version
-Sphinx\ [#f1]_         3.4.3            sphinx-build --version
-GNU tar                1.28             tar --version
-gtags (optional)       6.6.5            gtags --version
-mkimage (optional)     2017.01          mkimage --version
-Python (optional)      3.9.x            python3 --version
-GNU AWK (optional)     5.1.0            gawk --version
-====================== ===============  ========================================
-
-.. [#f1] Sphinx is needed only to build the Kernel documentation
-
-Kernel compilation
-******************
-
-GCC
----
-
-The gcc version requirements may vary depending on the type of CPU in your
-computer.
-
-Clang/LLVM (optional)
----------------------
-
-The latest formal release of clang and LLVM utils (according to
-`releases.llvm.org <https://releases.llvm.org>`_) are supported for building
-kernels. Older releases aren't guaranteed to work, and we may drop workarounds
-from the kernel that were used to support older versions. Please see additional
-docs on :ref:`Building Linux with Clang/LLVM <kbuild_llvm>`.
-
-Rust (optional)
----------------
-
-A recent version of the Rust compiler is required.
-
-Please see Documentation/rust/quick-start.rst for instructions on how to
-satisfy the build requirements of Rust support. In particular, the ``Makefile``
-target ``rustavailable`` is useful to check why the Rust toolchain may not
-be detected.
-
-bindgen (optional)
-------------------
-
-``bindgen`` is used to generate the Rust bindings to the C side of the kernel.
-It depends on ``libclang``.
-
-Make
-----
-
-You will need GNU make 4.0 or later to build the kernel.
-
-Bash
-----
-
-Some bash scripts are used for the kernel build.
-Bash 4.2 or newer is needed.
-
-Binutils
---------
-
-Binutils 2.30 or newer is needed to build the kernel.
-
-pkg-config
-----------
-
-The build system, as of 4.18, requires pkg-config to check for installed
-kconfig tools and to determine flags settings for use in
-'make {g,x}config'.  Previously pkg-config was being used but not
-verified or documented.
-
-Flex
-----
-
-Since Linux 4.16, the build system generates lexical analyzers
-during build.  This requires flex 2.5.35 or later.
-
-
-Bison
------
-
-Since Linux 4.16, the build system generates parsers
-during build.  This requires bison 2.0 or later.
-
-pahole
-------
-
-Since Linux 5.2, if CONFIG_DEBUG_INFO_BTF is selected, the build system
-generates BTF (BPF Type Format) from DWARF in vmlinux, a bit later from kernel
-modules as well.  This requires pahole v1.16 or later.
-
-It is found in the 'dwarves' or 'pahole' distro packages or from
-https://fedorapeople.org/~acme/dwarves/.
-
-Perl
-----
-
-You will need perl 5 and the following modules: ``Getopt::Long``,
-``Getopt::Std``, ``File::Basename``, and ``File::Find`` to build the kernel.
-
-BC
---
-
-You will need bc to build kernels 3.10 and higher
-
-
-OpenSSL
--------
-
-Module signing and external certificate handling use the OpenSSL program and
-crypto library to do key creation and signature generation.
-
-You will need openssl to build kernels 3.7 and higher if module signing is
-enabled.  You will also need openssl development packages to build kernels 4.3
-and higher.
-
-Tar
----
-
-GNU tar is needed if you want to enable access to the kernel headers via sysfs
-(CONFIG_IKHEADERS).
-
-gtags / GNU GLOBAL (optional)
------------------------------
-
-The kernel build requires GNU GLOBAL version 6.6.5 or later to generate
-tag files through ``make gtags``.  This is due to its use of the gtags
-``-C (--directory)`` flag.
-
-mkimage
--------
-
-This tool is used when building a Flat Image Tree (FIT), commonly used on ARM
-platforms. The tool is available via the ``u-boot-tools`` package or can be
-built from the U-Boot source code. See the instructions at
-https://docs.u-boot.org/en/latest/build/tools.html#building-tools-for-linux
-
-GNU AWK
--------
-
-GNU AWK is needed if you want kernel builds to generate address range data for
-builtin modules (CONFIG_BUILTIN_MODULE_RANGES).
-
-System utilities
-****************
-
-Architectural changes
----------------------
-
-DevFS has been obsoleted in favour of udev
-(https://www.kernel.org/pub/linux/utils/kernel/hotplug/)
-
-32-bit UID support is now in place.  Have fun!
-
-Linux documentation for functions is transitioning to inline
-documentation via specially-formatted comments near their
-definitions in the source.  These comments can be combined with ReST
-files the Documentation/ directory to make enriched documentation, which can
-then be converted to PostScript, HTML, LaTex, ePUB and PDF files.
-In order to convert from ReST format to a format of your choice, you'll need
-Sphinx.
-
-Util-linux
-----------
-
-New versions of util-linux provide ``fdisk`` support for larger disks,
-support new options to mount, recognize more supported partition
-types, and similar goodies.
-You'll probably want to upgrade.
-
-Ksymoops
---------
-
-If the unthinkable happens and your kernel oopses, you may need the
-ksymoops tool to decode it, but in most cases you don't.
-It is generally preferred to build the kernel with ``CONFIG_KALLSYMS`` so
-that it produces readable dumps that can be used as-is (this also
-produces better output than ksymoops).  If for some reason your kernel
-is not build with ``CONFIG_KALLSYMS`` and you have no way to rebuild and
-reproduce the Oops with that option, then you can still decode that Oops
-with ksymoops.
-
-Mkinitrd
---------
-
-These changes to the ``/lib/modules`` file tree layout also require that
-mkinitrd be upgraded.
-
-E2fsprogs
----------
-
-The latest version of ``e2fsprogs`` fixes several bugs in fsck and
-debugfs.  Obviously, it's a good idea to upgrade.
-
-JFSutils
---------
-
-The ``jfsutils`` package contains the utilities for the file system.
-The following utilities are available:
-
-- ``fsck.jfs`` - initiate replay of the transaction log, and check
-  and repair a JFS formatted partition.
-
-- ``mkfs.jfs`` - create a JFS formatted partition.
-
-- other file system utilities are also available in this package.
-
-Reiserfsprogs
--------------
-
-The reiserfsprogs package should be used for reiserfs-3.6.x
-(Linux kernels 2.4.x). It is a combined package and contains working
-versions of ``mkreiserfs``, ``resize_reiserfs``, ``debugreiserfs`` and
-``reiserfsck``. These utils work on both i386 and alpha platforms.
-
-Xfsprogs
---------
-
-The latest version of ``xfsprogs`` contains ``mkfs.xfs``, ``xfs_db``, and the
-``xfs_repair`` utilities, among others, for the XFS filesystem.  It is
-architecture independent and any version from 2.0.0 onward should
-work correctly with this version of the XFS kernel code (2.6.0 or
-later is recommended, due to some significant improvements).
-
-PCMCIAutils
------------
-
-PCMCIAutils replaces ``pcmcia-cs``. It properly sets up
-PCMCIA sockets at system startup and loads the appropriate modules
-for 16-bit PCMCIA devices if the kernel is modularized and the hotplug
-subsystem is used.
-
-Quota-tools
------------
-
-Support for 32 bit uid's and gid's is required if you want to use
-the newer version 2 quota format.  Quota-tools version 3.07 and
-newer has this support.  Use the recommended version or newer
-from the table above.
-
-Intel IA32 microcode
---------------------
-
-A driver has been added to allow updating of Intel IA32 microcode,
-accessible as a normal (misc) character device.  If you are not using
-udev you may need to::
-
-  mkdir /dev/cpu
-  mknod /dev/cpu/microcode c 10 184
-  chmod 0644 /dev/cpu/microcode
-
-as root before you can use this.  You'll probably also want to
-get the user-space microcode_ctl utility to use with this.
-
-udev
-----
-
-``udev`` is a userspace application for populating ``/dev`` dynamically with
-only entries for devices actually present. ``udev`` replaces the basic
-functionality of devfs, while allowing persistent device naming for
-devices.
-
-FUSE
-----
-
-Needs libfuse 2.4.0 or later.  Absolute minimum is 2.3.0 but mount
-options ``direct_io`` and ``kernel_cache`` won't work.
-
-Networking
-**********
-
-General changes
----------------
-
-If you have advanced network configuration needs, you should probably
-consider using the network tools from ip-route2.
-
-Packet Filter / NAT
--------------------
-The packet filtering and NAT code uses the same tools like the previous 2.4.x
-kernel series (iptables).  It still includes backwards-compatibility modules
-for 2.2.x-style ipchains and 2.0.x-style ipfwadm.
-
-PPP
----
-
-The PPP driver has been restructured to support multilink and to
-enable it to operate over diverse media layers.  If you use PPP,
-upgrade pppd to at least 2.4.0.
-
-If you are not using udev, you must have the device file /dev/ppp
-which can be made by::
-
-  mknod /dev/ppp c 108 0
-
-as root.
-
-NFS-utils
----------
-
-In ancient (2.4 and earlier) kernels, the nfs server needed to know
-about any client that expected to be able to access files via NFS.  This
-information would be given to the kernel by ``mountd`` when the client
-mounted the filesystem, or by ``exportfs`` at system startup.  exportfs
-would take information about active clients from ``/var/lib/nfs/rmtab``.
-
-This approach is quite fragile as it depends on rmtab being correct
-which is not always easy, particularly when trying to implement
-fail-over.  Even when the system is working well, ``rmtab`` suffers from
-getting lots of old entries that never get removed.
-
-With modern kernels we have the option of having the kernel tell mountd
-when it gets a request from an unknown host, and mountd can give
-appropriate export information to the kernel.  This removes the
-dependency on ``rmtab`` and means that the kernel only needs to know about
-currently active clients.
-
-To enable this new functionality, you need to::
-
-  mount -t nfsd nfsd /proc/fs/nfsd
-
-before running exportfs or mountd.  It is recommended that all NFS
-services be protected from the internet-at-large by a firewall where
-that is possible.
-
-mcelog
-------
-
-On x86 kernels the mcelog utility is needed to process and log machine check
-events when ``CONFIG_X86_MCE`` is enabled. Machine check events are errors
-reported by the CPU. Processing them is strongly encouraged.
-
-Kernel documentation
-********************
-
-Sphinx
-------
-
-Please see :ref:`sphinx_install` in :ref:`Documentation/doc-guide/sphinx.rst <sphinxdoc>`
-for details about Sphinx requirements.
-
-rustdoc
--------
-
-``rustdoc`` is used to generate the documentation for Rust code. Please see
-Documentation/rust/general-information.rst for more information.
-
-Getting updated software
-========================
-
-Kernel compilation
-******************
-
-gcc
----
-
-- <ftp://ftp.gnu.org/gnu/gcc/>
-
-Clang/LLVM
-----------
-
-- :ref:`Getting LLVM <getting_llvm>`.
-
-Rust
-----
-
-- Documentation/rust/quick-start.rst.
-
-bindgen
--------
-
-- Documentation/rust/quick-start.rst.
-
-Make
-----
-
-- <ftp://ftp.gnu.org/gnu/make/>
-
-Bash
-----
-
-- <ftp://ftp.gnu.org/gnu/bash/>
-
-Binutils
---------
-
-- <https://www.kernel.org/pub/linux/devel/binutils/>
-
-Flex
-----
-
-- <https://github.com/westes/flex/releases>
-
-Bison
------
-
-- <ftp://ftp.gnu.org/gnu/bison/>
-
-OpenSSL
--------
-
-- <https://www.openssl.org/>
-
-System utilities
-****************
-
-Util-linux
-----------
-
-- <https://www.kernel.org/pub/linux/utils/util-linux/>
-
-Kmod
-----
-
-- <https://www.kernel.org/pub/linux/utils/kernel/kmod/>
-- <https://git.kernel.org/pub/scm/utils/kernel/kmod/kmod.git>
-
-Ksymoops
---------
-
-- <https://www.kernel.org/pub/linux/utils/kernel/ksymoops/v2.4/>
-
-Mkinitrd
---------
-
-- <https://code.launchpad.net/initrd-tools/main>
-
-E2fsprogs
----------
-
-- <https://www.kernel.org/pub/linux/kernel/people/tytso/e2fsprogs/>
-- <https://git.kernel.org/pub/scm/fs/ext2/e2fsprogs.git/>
-
-JFSutils
---------
-
-- <https://jfs.sourceforge.net/>
-
-Reiserfsprogs
--------------
-
-- <https://git.kernel.org/pub/scm/linux/kernel/git/jeffm/reiserfsprogs.git/>
-
-Xfsprogs
---------
-
-- <https://git.kernel.org/pub/scm/fs/xfs/xfsprogs-dev.git>
-- <https://www.kernel.org/pub/linux/utils/fs/xfs/xfsprogs/>
-
-Pcmciautils
------------
-
-- <https://www.kernel.org/pub/linux/utils/kernel/pcmcia/>
-
-Quota-tools
------------
-
-- <https://sourceforge.net/projects/linuxquota/>
-
-
-Intel P6 microcode
-------------------
-
-- <https://downloadcenter.intel.com/>
-
-udev
-----
-
-- <https://www.freedesktop.org/software/systemd/man/udev.html>
-
-FUSE
-----
-
-- <https://github.com/libfuse/libfuse/releases>
-
-mcelog
-------
-
-- <https://www.mcelog.org/>
-
-Networking
-**********
-
-PPP
----
-
-- <https://download.samba.org/pub/ppp/>
-- <https://git.ozlabs.org/?p=ppp.git>
-- <https://github.com/paulusmack/ppp/>
-
-NFS-utils
----------
-
-- <https://sourceforge.net/project/showfiles.php?group_id=14>
-- <https://nfs.sourceforge.net/>
-
-Iptables
---------
-
-- <https://netfilter.org/projects/iptables/index.html>
-
-Ip-route2
----------
-
-- <https://www.kernel.org/pub/linux/utils/net/iproute2/>
-
-OProfile
---------
-
-- <https://oprofile.sf.net/download/>
-
-Kernel documentation
-********************
-
-Sphinx
-------
-
-- <https://www.sphinx-doc.org/>
+process/changes.rst
\ No newline at end of file
diff -Nrup linux-6.16.7/Documentation/devicetree/bindings/arm/psci.yaml linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/arm/psci.yaml
--- linux-6.16.7/Documentation/devicetree/bindings/arm/psci.yaml	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/arm/psci.yaml	2025-09-11 09:47:42.000000000 -0600
@@ -98,6 +98,12 @@ properties:
       [1] Kernel documentation - ARM idle states bindings
         Documentation/devicetree/bindings/cpu/idle-states.yaml
 
+  arm,psci-s2ram-param:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      power_state parameter denoting the S2RAM/S3-like system suspend state
+    maxItems: 1
+
 patternProperties:
   "^power-domain-":
     $ref: /schemas/power/power-domain.yaml#
diff -Nrup linux-6.16.7/Documentation/devicetree/bindings/i2c/qcom,i2c-cci.yaml linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/i2c/qcom,i2c-cci.yaml
--- linux-6.16.7/Documentation/devicetree/bindings/i2c/qcom,i2c-cci.yaml	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/i2c/qcom,i2c-cci.yaml	2025-09-11 09:47:42.000000000 -0600
@@ -54,6 +54,8 @@ properties:
   interrupts:
     maxItems: 1
 
+  operating-points-v2: true
+
   power-domains:
     maxItems: 1
 
diff -Nrup linux-6.16.7/Documentation/devicetree/bindings/leds/backlight/led-backlight.yaml linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/leds/backlight/led-backlight.yaml
--- linux-6.16.7/Documentation/devicetree/bindings/leds/backlight/led-backlight.yaml	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/leds/backlight/led-backlight.yaml	2025-09-11 09:47:42.000000000 -0600
@@ -23,11 +23,7 @@ properties:
   compatible:
     const: led-backlight
 
-  leds:
-    description: A list of LED nodes
-    $ref: /schemas/types.yaml#/definitions/phandle-array
-    items:
-      maxItems: 1
+  leds: true
 
 required:
   - compatible
diff -Nrup linux-6.16.7/Documentation/devicetree/bindings/leds/leds-consumer.yaml linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/leds/leds-consumer.yaml
--- linux-6.16.7/Documentation/devicetree/bindings/leds/leds-consumer.yaml	1969-12-31 17:00:00.000000000 -0700
+++ linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/leds/leds-consumer.yaml	2025-09-11 09:47:42.000000000 -0600
@@ -0,0 +1,67 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/leds/leds-consumer.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Common leds consumer
+
+maintainers:
+  - Aleksandrs Vinarskis <alex@vinarskis.com>
+
+description:
+  Some LED defined in DT are required by other DT consumers, for example
+  v4l2 subnode may require privacy or flash LED. Unlike trigger-source
+  approach which is typically used as 'soft' binding, referencing LED
+  devices by phandle makes things simpler when 'hard' binding is desired.
+
+  Document LED properties that its consumers may define.
+
+select: true
+
+properties:
+  leds:
+    oneOf:
+      - type: object
+      - $ref: /schemas/types.yaml#/definitions/phandle-array
+        description:
+          A list of LED device(s) required by a particular consumer.
+        items:
+          maxItems: 1
+
+  led-names:
+    description:
+      A list of device name(s). Used to map LED devices to their respective
+      functions, when consumer requires more than one LED.
+
+additionalProperties: true
+
+examples:
+  - |
+    #include <dt-bindings/gpio/gpio.h>
+    #include <dt-bindings/leds/common.h>
+
+    leds {
+        compatible = "gpio-leds";
+
+        privacy_led: privacy-led {
+            color = <LED_COLOR_ID_RED>;
+            default-state = "off";
+            function = LED_FUNCTION_INDICATOR;
+            gpios = <&tlmm 110 GPIO_ACTIVE_HIGH>;
+        };
+    };
+
+    i2c {
+      #address-cells = <1>;
+      #size-cells = <0>;
+
+      v4l2_node: camera@36 {
+        reg = <0x36>;
+
+        leds = <&privacy_led>;
+        led-names = "privacy";
+      };
+    };
+
+...
diff -Nrup linux-6.16.7/Documentation/devicetree/bindings/leds/leds-group-multicolor.yaml linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/leds/leds-group-multicolor.yaml
--- linux-6.16.7/Documentation/devicetree/bindings/leds/leds-group-multicolor.yaml	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/leds/leds-group-multicolor.yaml	2025-09-11 09:47:42.000000000 -0600
@@ -17,10 +17,7 @@ properties:
   compatible:
     const: leds-group-multicolor
 
-  leds:
-    description:
-      An aray of monochromatic leds
-    $ref: /schemas/types.yaml#/definitions/phandle-array
+  leds: true
 
 required:
   - leds
diff -Nrup linux-6.16.7/Documentation/devicetree/bindings/media/qcom,sm8350-venus.yaml linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/media/qcom,sm8350-venus.yaml
--- linux-6.16.7/Documentation/devicetree/bindings/media/qcom,sm8350-venus.yaml	1969-12-31 17:00:00.000000000 -0700
+++ linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/media/qcom,sm8350-venus.yaml	2025-09-11 09:47:42.000000000 -0600
@@ -0,0 +1,149 @@
+# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/media/qcom,sm8350-venus.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Qualcomm SM8350 Venus video encode and decode accelerators
+
+maintainers:
+  - Konrad Dybcio <konradybcio@kernel.org>
+
+description: |
+  The Venus Iris2 IP is a video encode and decode accelerator present
+  on Qualcomm platforms
+
+allOf:
+  - $ref: qcom,venus-common.yaml#
+
+properties:
+  compatible:
+    enum:
+      - qcom,sc8280xp-venus
+      - qcom,sm8350-venus
+
+  clocks:
+    maxItems: 3
+
+  clock-names:
+    items:
+      - const: iface
+      - const: core
+      - const: vcodec0_core
+
+  resets:
+    maxItems: 1
+
+  reset-names:
+    items:
+      - const: core
+
+  power-domains:
+    maxItems: 3
+
+  power-domain-names:
+    items:
+      - const: venus
+      - const: vcodec0
+      - const: mx
+
+  interconnects:
+    maxItems: 3
+
+  interconnect-names:
+    items:
+      - const: cpu-cfg
+      - const: video-mem
+      - const: video-llcc
+
+  operating-points-v2: true
+  opp-table:
+    type: object
+
+  iommus:
+    maxItems: 1
+
+  video-decoder:
+    type: object
+
+    properties:
+      compatible:
+        const: venus-decoder
+
+    required:
+      - compatible
+
+    additionalProperties: false
+
+  video-encoder:
+    type: object
+
+    properties:
+      compatible:
+        const: venus-encoder
+
+    required:
+      - compatible
+
+    additionalProperties: false
+
+required:
+  - compatible
+  - power-domain-names
+  - iommus
+  - video-decoder
+  - video-encoder
+
+unevaluatedProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/interrupt-controller/arm-gic.h>
+    #include <dt-bindings/clock/qcom,gcc-sm8350.h>
+    #include <dt-bindings/clock/qcom,sm8350-videocc.h>
+    #include <dt-bindings/interconnect/qcom,sm8350.h>
+    #include <dt-bindings/power/qcom-rpmpd.h>
+
+    venus: video-codec@aa00000 {
+        compatible = "qcom,sm8350-venus";
+        reg = <0x0aa00000 0x100000>;
+        interrupts = <GIC_SPI 174 IRQ_TYPE_LEVEL_HIGH>;
+
+        clocks = <&gcc GCC_VIDEO_AXI0_CLK>,
+                 <&videocc VIDEO_CC_MVS0C_CLK>,
+                 <&videocc VIDEO_CC_MVS0_CLK>;
+        clock-names = "iface",
+                      "core",
+                      "vcodec0_core";
+
+        resets = <&gcc GCC_VIDEO_AXI0_CLK_ARES>;
+        reset-names = "core";
+
+        power-domains = <&videocc MVS0C_GDSC>,
+                        <&videocc MVS0_GDSC>,
+                        <&rpmhpd SM8350_MX>;
+        power-domain-names = "venus",
+                             "vcodec0",
+                             "mx";
+
+        interconnects = <&gem_noc MASTER_APPSS_PROC 0 &config_noc SLAVE_VENUS_CFG 0>,
+                        <&mmss_noc MASTER_VIDEO_P0 0 &mc_virt SLAVE_EBI1 0>,
+                        <&mmss_noc MASTER_VIDEO_P0 0 &gem_noc SLAVE_LLCC 0>;
+        interconnect-names = "cpu-cfg",
+                             "video-mem",
+                             "video-llcc";
+
+        operating-points-v2 = <&venus_opp_table>;
+        iommus = <&apps_smmu 0x2100 0x400>;
+        memory-region = <&pil_video_mem>;
+
+        status = "disabled";
+
+        video-decoder {
+            compatible = "venus-decoder";
+        };
+
+        video-encoder {
+            compatible = "venus-encoder";
+        };
+    };
diff -Nrup linux-6.16.7/Documentation/devicetree/bindings/media/video-interface-devices.yaml linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/media/video-interface-devices.yaml
--- linux-6.16.7/Documentation/devicetree/bindings/media/video-interface-devices.yaml	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/media/video-interface-devices.yaml	2025-09-11 09:47:42.000000000 -0600
@@ -17,6 +17,14 @@ properties:
       An array of phandles, each referring to a flash LED, a sub-node of the LED
       driver device node.
 
+  leds:
+    minItems: 1
+    maxItems: 1
+
+  led-names:
+    enum:
+      - privacy
+
   lens-focus:
     $ref: /schemas/types.yaml#/definitions/phandle
     description:
diff -Nrup linux-6.16.7/Documentation/devicetree/bindings/phy/qcom,sc8280xp-qmp-usb43dp-phy.yaml linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/phy/qcom,sc8280xp-qmp-usb43dp-phy.yaml
--- linux-6.16.7/Documentation/devicetree/bindings/phy/qcom,sc8280xp-qmp-usb43dp-phy.yaml	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/phy/qcom,sc8280xp-qmp-usb43dp-phy.yaml	2025-09-11 09:47:42.000000000 -0600
@@ -72,10 +72,8 @@ properties:
     description:
       See include/dt-bindings/phy/phy-qcom-qmp.h
 
-  orientation-switch:
-    description:
-      Flag the PHY as possible handler of USB Type-C orientation switching
-    type: boolean
+  mode-switch: true
+  orientation-switch: true
 
   ports:
     $ref: /schemas/graph.yaml#/properties/ports
@@ -105,6 +103,7 @@ required:
   - "#phy-cells"
 
 allOf:
+  - $ref: /schemas/usb/usb-switch.yaml#
   - if:
       properties:
         compatible:
diff -Nrup linux-6.16.7/drivers/base/cpu.c linux-lenovo-x13s-linux-6.16.y/drivers/base/cpu.c
--- linux-6.16.7/drivers/base/cpu.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/base/cpu.c	2025-09-11 09:47:42.000000000 -0600
@@ -603,7 +603,6 @@ CPU_SHOW_VULN_FALLBACK(ghostwrite);
 CPU_SHOW_VULN_FALLBACK(old_microcode);
 CPU_SHOW_VULN_FALLBACK(indirect_target_selection);
 CPU_SHOW_VULN_FALLBACK(tsa);
-CPU_SHOW_VULN_FALLBACK(vmscape);
 
 static DEVICE_ATTR(meltdown, 0444, cpu_show_meltdown, NULL);
 static DEVICE_ATTR(spectre_v1, 0444, cpu_show_spectre_v1, NULL);
@@ -623,7 +622,6 @@ static DEVICE_ATTR(ghostwrite, 0444, cpu
 static DEVICE_ATTR(old_microcode, 0444, cpu_show_old_microcode, NULL);
 static DEVICE_ATTR(indirect_target_selection, 0444, cpu_show_indirect_target_selection, NULL);
 static DEVICE_ATTR(tsa, 0444, cpu_show_tsa, NULL);
-static DEVICE_ATTR(vmscape, 0444, cpu_show_vmscape, NULL);
 
 static struct attribute *cpu_root_vulnerabilities_attrs[] = {
 	&dev_attr_meltdown.attr,
@@ -644,7 +642,6 @@ static struct attribute *cpu_root_vulner
 	&dev_attr_old_microcode.attr,
 	&dev_attr_indirect_target_selection.attr,
 	&dev_attr_tsa.attr,
-	&dev_attr_vmscape.attr,
 	NULL
 };
 
diff -Nrup linux-6.16.7/drivers/base/firmware_loader/main.c linux-lenovo-x13s-linux-6.16.y/drivers/base/firmware_loader/main.c
--- linux-6.16.7/drivers/base/firmware_loader/main.c	2025-09-13 16:15:46.054046978 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/base/firmware_loader/main.c	2025-09-11 09:47:42.000000000 -0600
@@ -872,11 +872,6 @@ _request_firmware(const struct firmware
 
 	ret = _request_firmware_prepare(&fw, name, device, buf, size,
 					offset, opt_flags);
-
-#ifdef CONFIG_GENTOO_PRINT_FIRMWARE_INFO
-        printk(KERN_NOTICE "Loading firmware: %s\n", name);
-#endif
-
 	if (ret <= 0) /* error or already assigned */
 		goto out;
 
diff -Nrup linux-6.16.7/drivers/base/firmware_loader/main.c.orig linux-lenovo-x13s-linux-6.16.y/drivers/base/firmware_loader/main.c.orig
--- linux-6.16.7/drivers/base/firmware_loader/main.c.orig	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/base/firmware_loader/main.c.orig	1969-12-31 17:00:00.000000000 -0700
@@ -1,1698 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * main.c - Multi purpose firmware loading support
- *
- * Copyright (c) 2003 Manuel Estrada Sainz
- *
- * Please see Documentation/driver-api/firmware/ for more information.
- *
- */
-
-#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
-
-#include <linux/capability.h>
-#include <linux/device.h>
-#include <linux/kernel_read_file.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/initrd.h>
-#include <linux/timer.h>
-#include <linux/vmalloc.h>
-#include <linux/interrupt.h>
-#include <linux/bitops.h>
-#include <linux/mutex.h>
-#include <linux/workqueue.h>
-#include <linux/highmem.h>
-#include <linux/firmware.h>
-#include <linux/slab.h>
-#include <linux/sched.h>
-#include <linux/file.h>
-#include <linux/list.h>
-#include <linux/fs.h>
-#include <linux/async.h>
-#include <linux/pm.h>
-#include <linux/suspend.h>
-#include <linux/syscore_ops.h>
-#include <linux/reboot.h>
-#include <linux/security.h>
-#include <linux/zstd.h>
-#include <linux/xz.h>
-
-#include <generated/utsrelease.h>
-
-#include "../base.h"
-#include "firmware.h"
-#include "fallback.h"
-
-MODULE_AUTHOR("Manuel Estrada Sainz");
-MODULE_DESCRIPTION("Multi purpose firmware loading support");
-MODULE_LICENSE("GPL");
-
-struct firmware_cache {
-	/* firmware_buf instance will be added into the below list */
-	spinlock_t lock;
-	struct list_head head;
-	int state;
-
-#ifdef CONFIG_FW_CACHE
-	/*
-	 * Names of firmware images which have been cached successfully
-	 * will be added into the below list so that device uncache
-	 * helper can trace which firmware images have been cached
-	 * before.
-	 */
-	spinlock_t name_lock;
-	struct list_head fw_names;
-
-	struct delayed_work work;
-
-	struct notifier_block   pm_notify;
-#endif
-};
-
-struct fw_cache_entry {
-	struct list_head list;
-	const char *name;
-};
-
-struct fw_name_devm {
-	unsigned long magic;
-	const char *name;
-};
-
-static inline struct fw_priv *to_fw_priv(struct kref *ref)
-{
-	return container_of(ref, struct fw_priv, ref);
-}
-
-#define	FW_LOADER_NO_CACHE	0
-#define	FW_LOADER_START_CACHE	1
-
-/* fw_lock could be moved to 'struct fw_sysfs' but since it is just
- * guarding for corner cases a global lock should be OK */
-DEFINE_MUTEX(fw_lock);
-
-struct firmware_cache fw_cache;
-bool fw_load_abort_all;
-
-void fw_state_init(struct fw_priv *fw_priv)
-{
-	struct fw_state *fw_st = &fw_priv->fw_st;
-
-	init_completion(&fw_st->completion);
-	fw_st->status = FW_STATUS_UNKNOWN;
-}
-
-static inline int fw_state_wait(struct fw_priv *fw_priv)
-{
-	return __fw_state_wait_common(fw_priv, MAX_SCHEDULE_TIMEOUT);
-}
-
-static void fw_cache_piggyback_on_request(struct fw_priv *fw_priv);
-
-static struct fw_priv *__allocate_fw_priv(const char *fw_name,
-					  struct firmware_cache *fwc,
-					  void *dbuf,
-					  size_t size,
-					  size_t offset,
-					  u32 opt_flags)
-{
-	struct fw_priv *fw_priv;
-
-	/* For a partial read, the buffer must be preallocated. */
-	if ((opt_flags & FW_OPT_PARTIAL) && !dbuf)
-		return NULL;
-
-	/* Only partial reads are allowed to use an offset. */
-	if (offset != 0 && !(opt_flags & FW_OPT_PARTIAL))
-		return NULL;
-
-	fw_priv = kzalloc(sizeof(*fw_priv), GFP_ATOMIC);
-	if (!fw_priv)
-		return NULL;
-
-	fw_priv->fw_name = kstrdup_const(fw_name, GFP_ATOMIC);
-	if (!fw_priv->fw_name) {
-		kfree(fw_priv);
-		return NULL;
-	}
-
-	kref_init(&fw_priv->ref);
-	fw_priv->fwc = fwc;
-	fw_priv->data = dbuf;
-	fw_priv->allocated_size = size;
-	fw_priv->offset = offset;
-	fw_priv->opt_flags = opt_flags;
-	fw_state_init(fw_priv);
-#ifdef CONFIG_FW_LOADER_USER_HELPER
-	INIT_LIST_HEAD(&fw_priv->pending_list);
-#endif
-
-	pr_debug("%s: fw-%s fw_priv=%p\n", __func__, fw_name, fw_priv);
-
-	return fw_priv;
-}
-
-static struct fw_priv *__lookup_fw_priv(const char *fw_name)
-{
-	struct fw_priv *tmp;
-	struct firmware_cache *fwc = &fw_cache;
-
-	list_for_each_entry(tmp, &fwc->head, list)
-		if (!strcmp(tmp->fw_name, fw_name))
-			return tmp;
-	return NULL;
-}
-
-/* Returns 1 for batching firmware requests with the same name */
-int alloc_lookup_fw_priv(const char *fw_name, struct firmware_cache *fwc,
-			 struct fw_priv **fw_priv, void *dbuf, size_t size,
-			 size_t offset, u32 opt_flags)
-{
-	struct fw_priv *tmp;
-
-	spin_lock(&fwc->lock);
-	/*
-	 * Do not merge requests that are marked to be non-cached or
-	 * are performing partial reads.
-	 */
-	if (!(opt_flags & (FW_OPT_NOCACHE | FW_OPT_PARTIAL))) {
-		tmp = __lookup_fw_priv(fw_name);
-		if (tmp) {
-			kref_get(&tmp->ref);
-			spin_unlock(&fwc->lock);
-			*fw_priv = tmp;
-			pr_debug("batched request - sharing the same struct fw_priv and lookup for multiple requests\n");
-			return 1;
-		}
-	}
-
-	tmp = __allocate_fw_priv(fw_name, fwc, dbuf, size, offset, opt_flags);
-	if (tmp) {
-		INIT_LIST_HEAD(&tmp->list);
-		if (!(opt_flags & FW_OPT_NOCACHE))
-			list_add(&tmp->list, &fwc->head);
-	}
-	spin_unlock(&fwc->lock);
-
-	*fw_priv = tmp;
-
-	return tmp ? 0 : -ENOMEM;
-}
-
-static void __free_fw_priv(struct kref *ref)
-	__releases(&fwc->lock)
-{
-	struct fw_priv *fw_priv = to_fw_priv(ref);
-	struct firmware_cache *fwc = fw_priv->fwc;
-
-	pr_debug("%s: fw-%s fw_priv=%p data=%p size=%u\n",
-		 __func__, fw_priv->fw_name, fw_priv, fw_priv->data,
-		 (unsigned int)fw_priv->size);
-
-	list_del(&fw_priv->list);
-	spin_unlock(&fwc->lock);
-
-	if (fw_is_paged_buf(fw_priv))
-		fw_free_paged_buf(fw_priv);
-	else if (!fw_priv->allocated_size)
-		vfree(fw_priv->data);
-
-	kfree_const(fw_priv->fw_name);
-	kfree(fw_priv);
-}
-
-void free_fw_priv(struct fw_priv *fw_priv)
-{
-	struct firmware_cache *fwc = fw_priv->fwc;
-	spin_lock(&fwc->lock);
-	if (!kref_put(&fw_priv->ref, __free_fw_priv))
-		spin_unlock(&fwc->lock);
-}
-
-#ifdef CONFIG_FW_LOADER_PAGED_BUF
-bool fw_is_paged_buf(struct fw_priv *fw_priv)
-{
-	return fw_priv->is_paged_buf;
-}
-
-void fw_free_paged_buf(struct fw_priv *fw_priv)
-{
-	int i;
-
-	if (!fw_priv->pages)
-		return;
-
-	vunmap(fw_priv->data);
-
-	for (i = 0; i < fw_priv->nr_pages; i++)
-		__free_page(fw_priv->pages[i]);
-	kvfree(fw_priv->pages);
-	fw_priv->pages = NULL;
-	fw_priv->page_array_size = 0;
-	fw_priv->nr_pages = 0;
-	fw_priv->data = NULL;
-	fw_priv->size = 0;
-}
-
-int fw_grow_paged_buf(struct fw_priv *fw_priv, int pages_needed)
-{
-	/* If the array of pages is too small, grow it */
-	if (fw_priv->page_array_size < pages_needed) {
-		int new_array_size = max(pages_needed,
-					 fw_priv->page_array_size * 2);
-		struct page **new_pages;
-
-		new_pages = kvmalloc_array(new_array_size, sizeof(void *),
-					   GFP_KERNEL);
-		if (!new_pages)
-			return -ENOMEM;
-		memcpy(new_pages, fw_priv->pages,
-		       fw_priv->page_array_size * sizeof(void *));
-		memset(&new_pages[fw_priv->page_array_size], 0, sizeof(void *) *
-		       (new_array_size - fw_priv->page_array_size));
-		kvfree(fw_priv->pages);
-		fw_priv->pages = new_pages;
-		fw_priv->page_array_size = new_array_size;
-	}
-
-	while (fw_priv->nr_pages < pages_needed) {
-		fw_priv->pages[fw_priv->nr_pages] =
-			alloc_page(GFP_KERNEL | __GFP_HIGHMEM);
-
-		if (!fw_priv->pages[fw_priv->nr_pages])
-			return -ENOMEM;
-		fw_priv->nr_pages++;
-	}
-
-	return 0;
-}
-
-int fw_map_paged_buf(struct fw_priv *fw_priv)
-{
-	/* one pages buffer should be mapped/unmapped only once */
-	if (!fw_priv->pages)
-		return 0;
-
-	vunmap(fw_priv->data);
-	fw_priv->data = vmap(fw_priv->pages, fw_priv->nr_pages, 0,
-			     PAGE_KERNEL_RO);
-	if (!fw_priv->data)
-		return -ENOMEM;
-
-	return 0;
-}
-#endif
-
-/*
- * ZSTD-compressed firmware support
- */
-#ifdef CONFIG_FW_LOADER_COMPRESS_ZSTD
-static int fw_decompress_zstd(struct device *dev, struct fw_priv *fw_priv,
-			      size_t in_size, const void *in_buffer)
-{
-	size_t len, out_size, workspace_size;
-	void *workspace, *out_buf;
-	zstd_dctx *ctx;
-	int err;
-
-	if (fw_priv->allocated_size) {
-		out_size = fw_priv->allocated_size;
-		out_buf = fw_priv->data;
-	} else {
-		zstd_frame_header params;
-
-		if (zstd_get_frame_header(&params, in_buffer, in_size) ||
-		    params.frameContentSize == ZSTD_CONTENTSIZE_UNKNOWN) {
-			dev_dbg(dev, "%s: invalid zstd header\n", __func__);
-			return -EINVAL;
-		}
-		out_size = params.frameContentSize;
-		out_buf = vzalloc(out_size);
-		if (!out_buf)
-			return -ENOMEM;
-	}
-
-	workspace_size = zstd_dctx_workspace_bound();
-	workspace = kvzalloc(workspace_size, GFP_KERNEL);
-	if (!workspace) {
-		err = -ENOMEM;
-		goto error;
-	}
-
-	ctx = zstd_init_dctx(workspace, workspace_size);
-	if (!ctx) {
-		dev_dbg(dev, "%s: failed to initialize context\n", __func__);
-		err = -EINVAL;
-		goto error;
-	}
-
-	len = zstd_decompress_dctx(ctx, out_buf, out_size, in_buffer, in_size);
-	if (zstd_is_error(len)) {
-		dev_dbg(dev, "%s: failed to decompress: %d\n", __func__,
-			zstd_get_error_code(len));
-		err = -EINVAL;
-		goto error;
-	}
-
-	if (!fw_priv->allocated_size)
-		fw_priv->data = out_buf;
-	fw_priv->size = len;
-	err = 0;
-
- error:
-	kvfree(workspace);
-	if (err && !fw_priv->allocated_size)
-		vfree(out_buf);
-	return err;
-}
-#endif /* CONFIG_FW_LOADER_COMPRESS_ZSTD */
-
-/*
- * XZ-compressed firmware support
- */
-#ifdef CONFIG_FW_LOADER_COMPRESS_XZ
-/* show an error and return the standard error code */
-static int fw_decompress_xz_error(struct device *dev, enum xz_ret xz_ret)
-{
-	if (xz_ret != XZ_STREAM_END) {
-		dev_warn(dev, "xz decompression failed (xz_ret=%d)\n", xz_ret);
-		return xz_ret == XZ_MEM_ERROR ? -ENOMEM : -EINVAL;
-	}
-	return 0;
-}
-
-/* single-shot decompression onto the pre-allocated buffer */
-static int fw_decompress_xz_single(struct device *dev, struct fw_priv *fw_priv,
-				   size_t in_size, const void *in_buffer)
-{
-	struct xz_dec *xz_dec;
-	struct xz_buf xz_buf;
-	enum xz_ret xz_ret;
-
-	xz_dec = xz_dec_init(XZ_SINGLE, (u32)-1);
-	if (!xz_dec)
-		return -ENOMEM;
-
-	xz_buf.in_size = in_size;
-	xz_buf.in = in_buffer;
-	xz_buf.in_pos = 0;
-	xz_buf.out_size = fw_priv->allocated_size;
-	xz_buf.out = fw_priv->data;
-	xz_buf.out_pos = 0;
-
-	xz_ret = xz_dec_run(xz_dec, &xz_buf);
-	xz_dec_end(xz_dec);
-
-	fw_priv->size = xz_buf.out_pos;
-	return fw_decompress_xz_error(dev, xz_ret);
-}
-
-/* decompression on paged buffer and map it */
-static int fw_decompress_xz_pages(struct device *dev, struct fw_priv *fw_priv,
-				  size_t in_size, const void *in_buffer)
-{
-	struct xz_dec *xz_dec;
-	struct xz_buf xz_buf;
-	enum xz_ret xz_ret;
-	struct page *page;
-	int err = 0;
-
-	xz_dec = xz_dec_init(XZ_DYNALLOC, (u32)-1);
-	if (!xz_dec)
-		return -ENOMEM;
-
-	xz_buf.in_size = in_size;
-	xz_buf.in = in_buffer;
-	xz_buf.in_pos = 0;
-
-	fw_priv->is_paged_buf = true;
-	fw_priv->size = 0;
-	do {
-		if (fw_grow_paged_buf(fw_priv, fw_priv->nr_pages + 1)) {
-			err = -ENOMEM;
-			goto out;
-		}
-
-		/* decompress onto the new allocated page */
-		page = fw_priv->pages[fw_priv->nr_pages - 1];
-		xz_buf.out = kmap_local_page(page);
-		xz_buf.out_pos = 0;
-		xz_buf.out_size = PAGE_SIZE;
-		xz_ret = xz_dec_run(xz_dec, &xz_buf);
-		kunmap_local(xz_buf.out);
-		fw_priv->size += xz_buf.out_pos;
-		/* partial decompression means either end or error */
-		if (xz_buf.out_pos != PAGE_SIZE)
-			break;
-	} while (xz_ret == XZ_OK);
-
-	err = fw_decompress_xz_error(dev, xz_ret);
-	if (!err)
-		err = fw_map_paged_buf(fw_priv);
-
- out:
-	xz_dec_end(xz_dec);
-	return err;
-}
-
-static int fw_decompress_xz(struct device *dev, struct fw_priv *fw_priv,
-			    size_t in_size, const void *in_buffer)
-{
-	/* if the buffer is pre-allocated, we can perform in single-shot mode */
-	if (fw_priv->data)
-		return fw_decompress_xz_single(dev, fw_priv, in_size, in_buffer);
-	else
-		return fw_decompress_xz_pages(dev, fw_priv, in_size, in_buffer);
-}
-#endif /* CONFIG_FW_LOADER_COMPRESS_XZ */
-
-/* direct firmware loading support */
-static char fw_path_para[256];
-static const char * const fw_path[] = {
-	fw_path_para,
-	"/lib/firmware/updates/" UTS_RELEASE,
-	"/lib/firmware/updates",
-	"/lib/firmware/" UTS_RELEASE,
-	"/lib/firmware"
-};
-
-/*
- * Typical usage is that passing 'firmware_class.path=$CUSTOMIZED_PATH'
- * from kernel command line because firmware_class is generally built in
- * kernel instead of module.
- */
-module_param_string(path, fw_path_para, sizeof(fw_path_para), 0644);
-MODULE_PARM_DESC(path, "customized firmware image search path with a higher priority than default path");
-
-static int
-fw_get_filesystem_firmware(struct device *device, struct fw_priv *fw_priv,
-			   const char *suffix,
-			   int (*decompress)(struct device *dev,
-					     struct fw_priv *fw_priv,
-					     size_t in_size,
-					     const void *in_buffer))
-{
-	size_t size;
-	int i, len, maxlen = 0;
-	int rc = -ENOENT;
-	char *path, *nt = NULL;
-	size_t msize = INT_MAX;
-	void *buffer = NULL;
-
-	/* Already populated data member means we're loading into a buffer */
-	if (!decompress && fw_priv->data) {
-		buffer = fw_priv->data;
-		msize = fw_priv->allocated_size;
-	}
-
-	path = __getname();
-	if (!path)
-		return -ENOMEM;
-
-	wait_for_initramfs();
-	for (i = 0; i < ARRAY_SIZE(fw_path); i++) {
-		size_t file_size = 0;
-		size_t *file_size_ptr = NULL;
-
-		/* skip the unset customized path */
-		if (!fw_path[i][0])
-			continue;
-
-		/* strip off \n from customized path */
-		maxlen = strlen(fw_path[i]);
-		if (i == 0) {
-			nt = strchr(fw_path[i], '\n');
-			if (nt)
-				maxlen = nt - fw_path[i];
-		}
-
-		len = snprintf(path, PATH_MAX, "%.*s/%s%s",
-			       maxlen, fw_path[i],
-			       fw_priv->fw_name, suffix);
-		if (len >= PATH_MAX) {
-			rc = -ENAMETOOLONG;
-			break;
-		}
-
-		fw_priv->size = 0;
-
-		/*
-		 * The total file size is only examined when doing a partial
-		 * read; the "full read" case needs to fail if the whole
-		 * firmware was not completely loaded.
-		 */
-		if ((fw_priv->opt_flags & FW_OPT_PARTIAL) && buffer)
-			file_size_ptr = &file_size;
-
-		/* load firmware files from the mount namespace of init */
-		rc = kernel_read_file_from_path_initns(path, fw_priv->offset,
-						       &buffer, msize,
-						       file_size_ptr,
-						       READING_FIRMWARE);
-		if (rc < 0) {
-			if (!(fw_priv->opt_flags & FW_OPT_NO_WARN)) {
-				if (rc != -ENOENT)
-					dev_warn(device,
-						 "loading %s failed with error %d\n",
-						 path, rc);
-				else
-					dev_dbg(device,
-						"loading %s failed for no such file or directory.\n",
-						path);
-			}
-			continue;
-		}
-		size = rc;
-		rc = 0;
-
-		dev_dbg(device, "Loading firmware from %s\n", path);
-		if (decompress) {
-			dev_dbg(device, "f/w decompressing %s\n",
-				fw_priv->fw_name);
-			rc = decompress(device, fw_priv, size, buffer);
-			/* discard the superfluous original content */
-			vfree(buffer);
-			buffer = NULL;
-			if (rc) {
-				fw_free_paged_buf(fw_priv);
-				continue;
-			}
-		} else {
-			dev_dbg(device, "direct-loading %s\n",
-				fw_priv->fw_name);
-			if (!fw_priv->data)
-				fw_priv->data = buffer;
-			fw_priv->size = size;
-		}
-		fw_state_done(fw_priv);
-		break;
-	}
-	__putname(path);
-
-	return rc;
-}
-
-/* firmware holds the ownership of pages */
-static void firmware_free_data(const struct firmware *fw)
-{
-	/* Loaded directly? */
-	if (!fw->priv) {
-		vfree(fw->data);
-		return;
-	}
-	free_fw_priv(fw->priv);
-}
-
-/* store the pages buffer info firmware from buf */
-static void fw_set_page_data(struct fw_priv *fw_priv, struct firmware *fw)
-{
-	fw->priv = fw_priv;
-	fw->size = fw_priv->size;
-	fw->data = fw_priv->data;
-
-	pr_debug("%s: fw-%s fw_priv=%p data=%p size=%u\n",
-		 __func__, fw_priv->fw_name, fw_priv, fw_priv->data,
-		 (unsigned int)fw_priv->size);
-}
-
-#ifdef CONFIG_FW_CACHE
-static void fw_name_devm_release(struct device *dev, void *res)
-{
-	struct fw_name_devm *fwn = res;
-
-	if (fwn->magic == (unsigned long)&fw_cache)
-		pr_debug("%s: fw_name-%s devm-%p released\n",
-				__func__, fwn->name, res);
-	kfree_const(fwn->name);
-}
-
-static int fw_devm_match(struct device *dev, void *res,
-		void *match_data)
-{
-	struct fw_name_devm *fwn = res;
-
-	return (fwn->magic == (unsigned long)&fw_cache) &&
-		!strcmp(fwn->name, match_data);
-}
-
-static struct fw_name_devm *fw_find_devm_name(struct device *dev,
-		const char *name)
-{
-	struct fw_name_devm *fwn;
-
-	fwn = devres_find(dev, fw_name_devm_release,
-			  fw_devm_match, (void *)name);
-	return fwn;
-}
-
-static bool fw_cache_is_setup(struct device *dev, const char *name)
-{
-	struct fw_name_devm *fwn;
-
-	fwn = fw_find_devm_name(dev, name);
-	if (fwn)
-		return true;
-
-	return false;
-}
-
-/* add firmware name into devres list */
-static int fw_add_devm_name(struct device *dev, const char *name)
-{
-	struct fw_name_devm *fwn;
-
-	if (fw_cache_is_setup(dev, name))
-		return 0;
-
-	fwn = devres_alloc(fw_name_devm_release, sizeof(struct fw_name_devm),
-			   GFP_KERNEL);
-	if (!fwn)
-		return -ENOMEM;
-	fwn->name = kstrdup_const(name, GFP_KERNEL);
-	if (!fwn->name) {
-		devres_free(fwn);
-		return -ENOMEM;
-	}
-
-	fwn->magic = (unsigned long)&fw_cache;
-	devres_add(dev, fwn);
-
-	return 0;
-}
-#else
-static bool fw_cache_is_setup(struct device *dev, const char *name)
-{
-	return false;
-}
-
-static int fw_add_devm_name(struct device *dev, const char *name)
-{
-	return 0;
-}
-#endif
-
-int assign_fw(struct firmware *fw, struct device *device)
-{
-	struct fw_priv *fw_priv = fw->priv;
-	int ret;
-
-	mutex_lock(&fw_lock);
-	if (!fw_priv->size || fw_state_is_aborted(fw_priv)) {
-		mutex_unlock(&fw_lock);
-		return -ENOENT;
-	}
-
-	/*
-	 * add firmware name into devres list so that we can auto cache
-	 * and uncache firmware for device.
-	 *
-	 * device may has been deleted already, but the problem
-	 * should be fixed in devres or driver core.
-	 */
-	/* don't cache firmware handled without uevent */
-	if (device && (fw_priv->opt_flags & FW_OPT_UEVENT) &&
-	    !(fw_priv->opt_flags & FW_OPT_NOCACHE)) {
-		ret = fw_add_devm_name(device, fw_priv->fw_name);
-		if (ret) {
-			mutex_unlock(&fw_lock);
-			return ret;
-		}
-	}
-
-	/*
-	 * After caching firmware image is started, let it piggyback
-	 * on request firmware.
-	 */
-	if (!(fw_priv->opt_flags & FW_OPT_NOCACHE) &&
-	    fw_priv->fwc->state == FW_LOADER_START_CACHE)
-		fw_cache_piggyback_on_request(fw_priv);
-
-	/* pass the pages buffer to driver at the last minute */
-	fw_set_page_data(fw_priv, fw);
-	mutex_unlock(&fw_lock);
-	return 0;
-}
-
-/* prepare firmware and firmware_buf structs;
- * return 0 if a firmware is already assigned, 1 if need to load one,
- * or a negative error code
- */
-static int
-_request_firmware_prepare(struct firmware **firmware_p, const char *name,
-			  struct device *device, void *dbuf, size_t size,
-			  size_t offset, u32 opt_flags)
-{
-	struct firmware *firmware;
-	struct fw_priv *fw_priv;
-	int ret;
-
-	*firmware_p = firmware = kzalloc(sizeof(*firmware), GFP_KERNEL);
-	if (!firmware) {
-		dev_err(device, "%s: kmalloc(struct firmware) failed\n",
-			__func__);
-		return -ENOMEM;
-	}
-
-	if (firmware_request_builtin_buf(firmware, name, dbuf, size)) {
-		dev_dbg(device, "using built-in %s\n", name);
-		return 0; /* assigned */
-	}
-
-	ret = alloc_lookup_fw_priv(name, &fw_cache, &fw_priv, dbuf, size,
-				   offset, opt_flags);
-
-	/*
-	 * bind with 'priv' now to avoid warning in failure path
-	 * of requesting firmware.
-	 */
-	firmware->priv = fw_priv;
-
-	if (ret > 0) {
-		ret = fw_state_wait(fw_priv);
-		if (!ret) {
-			fw_set_page_data(fw_priv, firmware);
-			return 0; /* assigned */
-		}
-	}
-
-	if (ret < 0)
-		return ret;
-	return 1; /* need to load */
-}
-
-/*
- * Batched requests need only one wake, we need to do this step last due to the
- * fallback mechanism. The buf is protected with kref_get(), and it won't be
- * released until the last user calls release_firmware().
- *
- * Failed batched requests are possible as well, in such cases we just share
- * the struct fw_priv and won't release it until all requests are woken
- * and have gone through this same path.
- */
-static void fw_abort_batch_reqs(struct firmware *fw)
-{
-	struct fw_priv *fw_priv;
-
-	/* Loaded directly? */
-	if (!fw || !fw->priv)
-		return;
-
-	fw_priv = fw->priv;
-	mutex_lock(&fw_lock);
-	if (!fw_state_is_aborted(fw_priv))
-		fw_state_aborted(fw_priv);
-	mutex_unlock(&fw_lock);
-}
-
-#if defined(CONFIG_FW_LOADER_DEBUG)
-#include <crypto/sha2.h>
-
-static void fw_log_firmware_info(const struct firmware *fw, const char *name, struct device *device)
-{
-	u8 digest[SHA256_DIGEST_SIZE];
-
-	sha256(fw->data, fw->size, digest);
-	dev_dbg(device, "Loaded FW: %s, sha256: %*phN\n",
-		name, SHA256_DIGEST_SIZE, digest);
-}
-#else
-static void fw_log_firmware_info(const struct firmware *fw, const char *name,
-				 struct device *device)
-{}
-#endif
-
-/*
- * Reject firmware file names with ".." path components.
- * There are drivers that construct firmware file names from device-supplied
- * strings, and we don't want some device to be able to tell us "I would like to
- * be sent my firmware from ../../../etc/shadow, please".
- *
- * Search for ".." surrounded by either '/' or start/end of string.
- *
- * This intentionally only looks at the firmware name, not at the firmware base
- * directory or at symlink contents.
- */
-static bool name_contains_dotdot(const char *name)
-{
-	size_t name_len = strlen(name);
-
-	return strcmp(name, "..") == 0 || strncmp(name, "../", 3) == 0 ||
-	       strstr(name, "/../") != NULL ||
-	       (name_len >= 3 && strcmp(name+name_len-3, "/..") == 0);
-}
-
-/* called from request_firmware() and request_firmware_work_func() */
-static int
-_request_firmware(const struct firmware **firmware_p, const char *name,
-		  struct device *device, void *buf, size_t size,
-		  size_t offset, u32 opt_flags)
-{
-	struct firmware *fw = NULL;
-	struct cred *kern_cred = NULL;
-	const struct cred *old_cred;
-	bool nondirect = false;
-	int ret;
-
-	if (!firmware_p)
-		return -EINVAL;
-
-	if (!name || name[0] == '\0') {
-		ret = -EINVAL;
-		goto out;
-	}
-
-	if (name_contains_dotdot(name)) {
-		dev_warn(device,
-			 "Firmware load for '%s' refused, path contains '..' component\n",
-			 name);
-		ret = -EINVAL;
-		goto out;
-	}
-
-	ret = _request_firmware_prepare(&fw, name, device, buf, size,
-					offset, opt_flags);
-	if (ret <= 0) /* error or already assigned */
-		goto out;
-
-	/*
-	 * We are about to try to access the firmware file. Because we may have been
-	 * called by a driver when serving an unrelated request from userland, we use
-	 * the kernel credentials to read the file.
-	 */
-	kern_cred = prepare_kernel_cred(&init_task);
-	if (!kern_cred) {
-		ret = -ENOMEM;
-		goto out;
-	}
-	old_cred = override_creds(kern_cred);
-
-	ret = fw_get_filesystem_firmware(device, fw->priv, "", NULL);
-
-	/* Only full reads can support decompression, platform, and sysfs. */
-	if (!(opt_flags & FW_OPT_PARTIAL))
-		nondirect = true;
-
-#ifdef CONFIG_FW_LOADER_COMPRESS_ZSTD
-	if (ret == -ENOENT && nondirect)
-		ret = fw_get_filesystem_firmware(device, fw->priv, ".zst",
-						 fw_decompress_zstd);
-#endif
-#ifdef CONFIG_FW_LOADER_COMPRESS_XZ
-	if (ret == -ENOENT && nondirect)
-		ret = fw_get_filesystem_firmware(device, fw->priv, ".xz",
-						 fw_decompress_xz);
-#endif
-	if (ret == -ENOENT && nondirect)
-		ret = firmware_fallback_platform(fw->priv);
-
-	if (ret) {
-		if (!(opt_flags & FW_OPT_NO_WARN))
-			dev_warn(device,
-				 "Direct firmware load for %s failed with error %d\n",
-				 name, ret);
-		if (nondirect)
-			ret = firmware_fallback_sysfs(fw, name, device,
-						      opt_flags, ret);
-	} else
-		ret = assign_fw(fw, device);
-
-	revert_creds(old_cred);
-	put_cred(kern_cred);
-
-out:
-	if (ret < 0) {
-		fw_abort_batch_reqs(fw);
-		release_firmware(fw);
-		fw = NULL;
-	} else {
-		fw_log_firmware_info(fw, name, device);
-	}
-
-	*firmware_p = fw;
-	return ret;
-}
-
-/**
- * request_firmware() - send firmware request and wait for it
- * @firmware_p: pointer to firmware image
- * @name: name of firmware file
- * @device: device for which firmware is being loaded
- *
- *      @firmware_p will be used to return a firmware image by the name
- *      of @name for device @device.
- *
- *      Should be called from user context where sleeping is allowed.
- *
- *      @name will be used as $FIRMWARE in the uevent environment and
- *      should be distinctive enough not to be confused with any other
- *      firmware image for this or any other device.
- *	It must not contain any ".." path components - "foo/bar..bin" is
- *	allowed, but "foo/../bar.bin" is not.
- *
- *	Caller must hold the reference count of @device.
- *
- *	The function can be called safely inside device's suspend and
- *	resume callback.
- **/
-int
-request_firmware(const struct firmware **firmware_p, const char *name,
-		 struct device *device)
-{
-	int ret;
-
-	/* Need to pin this module until return */
-	__module_get(THIS_MODULE);
-	ret = _request_firmware(firmware_p, name, device, NULL, 0, 0,
-				FW_OPT_UEVENT);
-	module_put(THIS_MODULE);
-	return ret;
-}
-EXPORT_SYMBOL(request_firmware);
-
-/**
- * firmware_request_nowarn() - request for an optional fw module
- * @firmware: pointer to firmware image
- * @name: name of firmware file
- * @device: device for which firmware is being loaded
- *
- * This function is similar in behaviour to request_firmware(), except it
- * doesn't produce warning messages when the file is not found. The sysfs
- * fallback mechanism is enabled if direct filesystem lookup fails. However,
- * failures to find the firmware file with it are still suppressed. It is
- * therefore up to the driver to check for the return value of this call and to
- * decide when to inform the users of errors.
- **/
-int firmware_request_nowarn(const struct firmware **firmware, const char *name,
-			    struct device *device)
-{
-	int ret;
-
-	/* Need to pin this module until return */
-	__module_get(THIS_MODULE);
-	ret = _request_firmware(firmware, name, device, NULL, 0, 0,
-				FW_OPT_UEVENT | FW_OPT_NO_WARN);
-	module_put(THIS_MODULE);
-	return ret;
-}
-EXPORT_SYMBOL_GPL(firmware_request_nowarn);
-
-/**
- * request_firmware_direct() - load firmware directly without usermode helper
- * @firmware_p: pointer to firmware image
- * @name: name of firmware file
- * @device: device for which firmware is being loaded
- *
- * This function works pretty much like request_firmware(), but this doesn't
- * fall back to usermode helper even if the firmware couldn't be loaded
- * directly from fs.  Hence it's useful for loading optional firmwares, which
- * aren't always present, without extra long timeouts of udev.
- **/
-int request_firmware_direct(const struct firmware **firmware_p,
-			    const char *name, struct device *device)
-{
-	int ret;
-
-	__module_get(THIS_MODULE);
-	ret = _request_firmware(firmware_p, name, device, NULL, 0, 0,
-				FW_OPT_UEVENT | FW_OPT_NO_WARN |
-				FW_OPT_NOFALLBACK_SYSFS);
-	module_put(THIS_MODULE);
-	return ret;
-}
-EXPORT_SYMBOL_GPL(request_firmware_direct);
-
-/**
- * firmware_request_platform() - request firmware with platform-fw fallback
- * @firmware: pointer to firmware image
- * @name: name of firmware file
- * @device: device for which firmware is being loaded
- *
- * This function is similar in behaviour to request_firmware, except that if
- * direct filesystem lookup fails, it will fallback to looking for a copy of the
- * requested firmware embedded in the platform's main (e.g. UEFI) firmware.
- **/
-int firmware_request_platform(const struct firmware **firmware,
-			      const char *name, struct device *device)
-{
-	int ret;
-
-	/* Need to pin this module until return */
-	__module_get(THIS_MODULE);
-	ret = _request_firmware(firmware, name, device, NULL, 0, 0,
-				FW_OPT_UEVENT | FW_OPT_FALLBACK_PLATFORM);
-	module_put(THIS_MODULE);
-	return ret;
-}
-EXPORT_SYMBOL_GPL(firmware_request_platform);
-
-/**
- * firmware_request_cache() - cache firmware for suspend so resume can use it
- * @device: device for which firmware should be cached for
- * @name: name of firmware file
- *
- * There are some devices with an optimization that enables the device to not
- * require loading firmware on system reboot. This optimization may still
- * require the firmware present on resume from suspend. This routine can be
- * used to ensure the firmware is present on resume from suspend in these
- * situations. This helper is not compatible with drivers which use
- * request_firmware_into_buf() or request_firmware_nowait() with no uevent set.
- **/
-int firmware_request_cache(struct device *device, const char *name)
-{
-	int ret;
-
-	mutex_lock(&fw_lock);
-	ret = fw_add_devm_name(device, name);
-	mutex_unlock(&fw_lock);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(firmware_request_cache);
-
-/**
- * request_firmware_into_buf() - load firmware into a previously allocated buffer
- * @firmware_p: pointer to firmware image
- * @name: name of firmware file
- * @device: device for which firmware is being loaded and DMA region allocated
- * @buf: address of buffer to load firmware into
- * @size: size of buffer
- *
- * This function works pretty much like request_firmware(), but it doesn't
- * allocate a buffer to hold the firmware data. Instead, the firmware
- * is loaded directly into the buffer pointed to by @buf and the @firmware_p
- * data member is pointed at @buf.
- *
- * This function doesn't cache firmware either.
- */
-int
-request_firmware_into_buf(const struct firmware **firmware_p, const char *name,
-			  struct device *device, void *buf, size_t size)
-{
-	int ret;
-
-	if (fw_cache_is_setup(device, name))
-		return -EOPNOTSUPP;
-
-	__module_get(THIS_MODULE);
-	ret = _request_firmware(firmware_p, name, device, buf, size, 0,
-				FW_OPT_UEVENT | FW_OPT_NOCACHE);
-	module_put(THIS_MODULE);
-	return ret;
-}
-EXPORT_SYMBOL(request_firmware_into_buf);
-
-/**
- * request_partial_firmware_into_buf() - load partial firmware into a previously allocated buffer
- * @firmware_p: pointer to firmware image
- * @name: name of firmware file
- * @device: device for which firmware is being loaded and DMA region allocated
- * @buf: address of buffer to load firmware into
- * @size: size of buffer
- * @offset: offset into file to read
- *
- * This function works pretty much like request_firmware_into_buf except
- * it allows a partial read of the file.
- */
-int
-request_partial_firmware_into_buf(const struct firmware **firmware_p,
-				  const char *name, struct device *device,
-				  void *buf, size_t size, size_t offset)
-{
-	int ret;
-
-	if (fw_cache_is_setup(device, name))
-		return -EOPNOTSUPP;
-
-	__module_get(THIS_MODULE);
-	ret = _request_firmware(firmware_p, name, device, buf, size, offset,
-				FW_OPT_UEVENT | FW_OPT_NOCACHE |
-				FW_OPT_PARTIAL);
-	module_put(THIS_MODULE);
-	return ret;
-}
-EXPORT_SYMBOL(request_partial_firmware_into_buf);
-
-/**
- * release_firmware() - release the resource associated with a firmware image
- * @fw: firmware resource to release
- **/
-void release_firmware(const struct firmware *fw)
-{
-	if (fw) {
-		if (!firmware_is_builtin(fw))
-			firmware_free_data(fw);
-		kfree(fw);
-	}
-}
-EXPORT_SYMBOL(release_firmware);
-
-/* Async support */
-struct firmware_work {
-	struct work_struct work;
-	struct module *module;
-	const char *name;
-	struct device *device;
-	void *context;
-	void (*cont)(const struct firmware *fw, void *context);
-	u32 opt_flags;
-};
-
-static void request_firmware_work_func(struct work_struct *work)
-{
-	struct firmware_work *fw_work;
-	const struct firmware *fw;
-
-	fw_work = container_of(work, struct firmware_work, work);
-
-	_request_firmware(&fw, fw_work->name, fw_work->device, NULL, 0, 0,
-			  fw_work->opt_flags);
-	fw_work->cont(fw, fw_work->context);
-	put_device(fw_work->device); /* taken in request_firmware_nowait() */
-
-	module_put(fw_work->module);
-	kfree_const(fw_work->name);
-	kfree(fw_work);
-}
-
-
-static int _request_firmware_nowait(
-	struct module *module, bool uevent,
-	const char *name, struct device *device, gfp_t gfp, void *context,
-	void (*cont)(const struct firmware *fw, void *context), bool nowarn)
-{
-	struct firmware_work *fw_work;
-
-	fw_work = kzalloc(sizeof(struct firmware_work), gfp);
-	if (!fw_work)
-		return -ENOMEM;
-
-	fw_work->module = module;
-	fw_work->name = kstrdup_const(name, gfp);
-	if (!fw_work->name) {
-		kfree(fw_work);
-		return -ENOMEM;
-	}
-	fw_work->device = device;
-	fw_work->context = context;
-	fw_work->cont = cont;
-	fw_work->opt_flags = FW_OPT_NOWAIT |
-		(uevent ? FW_OPT_UEVENT : FW_OPT_USERHELPER) |
-		(nowarn ? FW_OPT_NO_WARN : 0);
-
-	if (!uevent && fw_cache_is_setup(device, name)) {
-		kfree_const(fw_work->name);
-		kfree(fw_work);
-		return -EOPNOTSUPP;
-	}
-
-	if (!try_module_get(module)) {
-		kfree_const(fw_work->name);
-		kfree(fw_work);
-		return -EFAULT;
-	}
-
-	get_device(fw_work->device);
-	INIT_WORK(&fw_work->work, request_firmware_work_func);
-	schedule_work(&fw_work->work);
-	return 0;
-}
-
-/**
- * request_firmware_nowait() - asynchronous version of request_firmware
- * @module: module requesting the firmware
- * @uevent: sends uevent to copy the firmware image if this flag
- *	is non-zero else the firmware copy must be done manually.
- * @name: name of firmware file
- * @device: device for which firmware is being loaded
- * @gfp: allocation flags
- * @context: will be passed over to @cont, and
- *	@fw may be %NULL if firmware request fails.
- * @cont: function will be called asynchronously when the firmware
- *	request is over.
- *
- *	Caller must hold the reference count of @device.
- *
- *	Asynchronous variant of request_firmware() for user contexts:
- *		- sleep for as small periods as possible since it may
- *		  increase kernel boot time of built-in device drivers
- *		  requesting firmware in their ->probe() methods, if
- *		  @gfp is GFP_KERNEL.
- *
- *		- can't sleep at all if @gfp is GFP_ATOMIC.
- **/
-int request_firmware_nowait(
-	struct module *module, bool uevent,
-	const char *name, struct device *device, gfp_t gfp, void *context,
-	void (*cont)(const struct firmware *fw, void *context))
-{
-	return _request_firmware_nowait(module, uevent, name, device, gfp,
-					context, cont, false);
-
-}
-EXPORT_SYMBOL(request_firmware_nowait);
-
-/**
- * firmware_request_nowait_nowarn() - async version of request_firmware_nowarn
- * @module: module requesting the firmware
- * @name: name of firmware file
- * @device: device for which firmware is being loaded
- * @gfp: allocation flags
- * @context: will be passed over to @cont, and
- *	@fw may be %NULL if firmware request fails.
- * @cont: function will be called asynchronously when the firmware
- *	request is over.
- *
- * Similar in function to request_firmware_nowait(), but doesn't print a warning
- * when the firmware file could not be found and always sends a uevent to copy
- * the firmware image.
- */
-int firmware_request_nowait_nowarn(
-	struct module *module, const char *name,
-	struct device *device, gfp_t gfp, void *context,
-	void (*cont)(const struct firmware *fw, void *context))
-{
-	return _request_firmware_nowait(module, FW_ACTION_UEVENT, name, device,
-					gfp, context, cont, true);
-}
-EXPORT_SYMBOL_GPL(firmware_request_nowait_nowarn);
-
-#ifdef CONFIG_FW_CACHE
-static ASYNC_DOMAIN_EXCLUSIVE(fw_cache_domain);
-
-/**
- * cache_firmware() - cache one firmware image in kernel memory space
- * @fw_name: the firmware image name
- *
- * Cache firmware in kernel memory so that drivers can use it when
- * system isn't ready for them to request firmware image from userspace.
- * Once it returns successfully, driver can use request_firmware or its
- * nowait version to get the cached firmware without any interacting
- * with userspace
- *
- * Return 0 if the firmware image has been cached successfully
- * Return !0 otherwise
- *
- */
-static int cache_firmware(const char *fw_name)
-{
-	int ret;
-	const struct firmware *fw;
-
-	pr_debug("%s: %s\n", __func__, fw_name);
-
-	ret = request_firmware(&fw, fw_name, NULL);
-	if (!ret)
-		kfree(fw);
-
-	pr_debug("%s: %s ret=%d\n", __func__, fw_name, ret);
-
-	return ret;
-}
-
-static struct fw_priv *lookup_fw_priv(const char *fw_name)
-{
-	struct fw_priv *tmp;
-	struct firmware_cache *fwc = &fw_cache;
-
-	spin_lock(&fwc->lock);
-	tmp = __lookup_fw_priv(fw_name);
-	spin_unlock(&fwc->lock);
-
-	return tmp;
-}
-
-/**
- * uncache_firmware() - remove one cached firmware image
- * @fw_name: the firmware image name
- *
- * Uncache one firmware image which has been cached successfully
- * before.
- *
- * Return 0 if the firmware cache has been removed successfully
- * Return !0 otherwise
- *
- */
-static int uncache_firmware(const char *fw_name)
-{
-	struct fw_priv *fw_priv;
-	struct firmware fw;
-
-	pr_debug("%s: %s\n", __func__, fw_name);
-
-	if (firmware_request_builtin(&fw, fw_name))
-		return 0;
-
-	fw_priv = lookup_fw_priv(fw_name);
-	if (fw_priv) {
-		free_fw_priv(fw_priv);
-		return 0;
-	}
-
-	return -EINVAL;
-}
-
-static struct fw_cache_entry *alloc_fw_cache_entry(const char *name)
-{
-	struct fw_cache_entry *fce;
-
-	fce = kzalloc(sizeof(*fce), GFP_ATOMIC);
-	if (!fce)
-		goto exit;
-
-	fce->name = kstrdup_const(name, GFP_ATOMIC);
-	if (!fce->name) {
-		kfree(fce);
-		fce = NULL;
-		goto exit;
-	}
-exit:
-	return fce;
-}
-
-static int __fw_entry_found(const char *name)
-{
-	struct firmware_cache *fwc = &fw_cache;
-	struct fw_cache_entry *fce;
-
-	list_for_each_entry(fce, &fwc->fw_names, list) {
-		if (!strcmp(fce->name, name))
-			return 1;
-	}
-	return 0;
-}
-
-static void fw_cache_piggyback_on_request(struct fw_priv *fw_priv)
-{
-	const char *name = fw_priv->fw_name;
-	struct firmware_cache *fwc = fw_priv->fwc;
-	struct fw_cache_entry *fce;
-
-	spin_lock(&fwc->name_lock);
-	if (__fw_entry_found(name))
-		goto found;
-
-	fce = alloc_fw_cache_entry(name);
-	if (fce) {
-		list_add(&fce->list, &fwc->fw_names);
-		kref_get(&fw_priv->ref);
-		pr_debug("%s: fw: %s\n", __func__, name);
-	}
-found:
-	spin_unlock(&fwc->name_lock);
-}
-
-static void free_fw_cache_entry(struct fw_cache_entry *fce)
-{
-	kfree_const(fce->name);
-	kfree(fce);
-}
-
-static void __async_dev_cache_fw_image(void *fw_entry,
-				       async_cookie_t cookie)
-{
-	struct fw_cache_entry *fce = fw_entry;
-	struct firmware_cache *fwc = &fw_cache;
-	int ret;
-
-	ret = cache_firmware(fce->name);
-	if (ret) {
-		spin_lock(&fwc->name_lock);
-		list_del(&fce->list);
-		spin_unlock(&fwc->name_lock);
-
-		free_fw_cache_entry(fce);
-	}
-}
-
-/* called with dev->devres_lock held */
-static void dev_create_fw_entry(struct device *dev, void *res,
-				void *data)
-{
-	struct fw_name_devm *fwn = res;
-	const char *fw_name = fwn->name;
-	struct list_head *head = data;
-	struct fw_cache_entry *fce;
-
-	fce = alloc_fw_cache_entry(fw_name);
-	if (fce)
-		list_add(&fce->list, head);
-}
-
-static int devm_name_match(struct device *dev, void *res,
-			   void *match_data)
-{
-	struct fw_name_devm *fwn = res;
-	return (fwn->magic == (unsigned long)match_data);
-}
-
-static void dev_cache_fw_image(struct device *dev, void *data)
-{
-	LIST_HEAD(todo);
-	struct fw_cache_entry *fce;
-	struct fw_cache_entry *fce_next;
-	struct firmware_cache *fwc = &fw_cache;
-
-	devres_for_each_res(dev, fw_name_devm_release,
-			    devm_name_match, &fw_cache,
-			    dev_create_fw_entry, &todo);
-
-	list_for_each_entry_safe(fce, fce_next, &todo, list) {
-		list_del(&fce->list);
-
-		spin_lock(&fwc->name_lock);
-		/* only one cache entry for one firmware */
-		if (!__fw_entry_found(fce->name)) {
-			list_add(&fce->list, &fwc->fw_names);
-		} else {
-			free_fw_cache_entry(fce);
-			fce = NULL;
-		}
-		spin_unlock(&fwc->name_lock);
-
-		if (fce)
-			async_schedule_domain(__async_dev_cache_fw_image,
-					      (void *)fce,
-					      &fw_cache_domain);
-	}
-}
-
-static void __device_uncache_fw_images(void)
-{
-	struct firmware_cache *fwc = &fw_cache;
-	struct fw_cache_entry *fce;
-
-	spin_lock(&fwc->name_lock);
-	while (!list_empty(&fwc->fw_names)) {
-		fce = list_entry(fwc->fw_names.next,
-				struct fw_cache_entry, list);
-		list_del(&fce->list);
-		spin_unlock(&fwc->name_lock);
-
-		uncache_firmware(fce->name);
-		free_fw_cache_entry(fce);
-
-		spin_lock(&fwc->name_lock);
-	}
-	spin_unlock(&fwc->name_lock);
-}
-
-/**
- * device_cache_fw_images() - cache devices' firmware
- *
- * If one device called request_firmware or its nowait version
- * successfully before, the firmware names are recored into the
- * device's devres link list, so device_cache_fw_images can call
- * cache_firmware() to cache these firmwares for the device,
- * then the device driver can load its firmwares easily at
- * time when system is not ready to complete loading firmware.
- */
-static void device_cache_fw_images(void)
-{
-	struct firmware_cache *fwc = &fw_cache;
-	DEFINE_WAIT(wait);
-
-	pr_debug("%s\n", __func__);
-
-	/* cancel uncache work */
-	cancel_delayed_work_sync(&fwc->work);
-
-	fw_fallback_set_cache_timeout();
-
-	mutex_lock(&fw_lock);
-	fwc->state = FW_LOADER_START_CACHE;
-	dpm_for_each_dev(NULL, dev_cache_fw_image);
-	mutex_unlock(&fw_lock);
-
-	/* wait for completion of caching firmware for all devices */
-	async_synchronize_full_domain(&fw_cache_domain);
-
-	fw_fallback_set_default_timeout();
-}
-
-/**
- * device_uncache_fw_images() - uncache devices' firmware
- *
- * uncache all firmwares which have been cached successfully
- * by device_uncache_fw_images earlier
- */
-static void device_uncache_fw_images(void)
-{
-	pr_debug("%s\n", __func__);
-	__device_uncache_fw_images();
-}
-
-static void device_uncache_fw_images_work(struct work_struct *work)
-{
-	device_uncache_fw_images();
-}
-
-/**
- * device_uncache_fw_images_delay() - uncache devices firmwares
- * @delay: number of milliseconds to delay uncache device firmwares
- *
- * uncache all devices's firmwares which has been cached successfully
- * by device_cache_fw_images after @delay milliseconds.
- */
-static void device_uncache_fw_images_delay(unsigned long delay)
-{
-	queue_delayed_work(system_power_efficient_wq, &fw_cache.work,
-			   msecs_to_jiffies(delay));
-}
-
-static int fw_pm_notify(struct notifier_block *notify_block,
-			unsigned long mode, void *unused)
-{
-	switch (mode) {
-	case PM_HIBERNATION_PREPARE:
-	case PM_SUSPEND_PREPARE:
-	case PM_RESTORE_PREPARE:
-		/*
-		 * Here, kill pending fallback requests will only kill
-		 * non-uevent firmware request to avoid stalling suspend.
-		 */
-		kill_pending_fw_fallback_reqs(false);
-		device_cache_fw_images();
-		break;
-
-	case PM_POST_SUSPEND:
-	case PM_POST_HIBERNATION:
-	case PM_POST_RESTORE:
-		/*
-		 * In case that system sleep failed and syscore_suspend is
-		 * not called.
-		 */
-		mutex_lock(&fw_lock);
-		fw_cache.state = FW_LOADER_NO_CACHE;
-		mutex_unlock(&fw_lock);
-
-		device_uncache_fw_images_delay(10 * MSEC_PER_SEC);
-		break;
-	}
-
-	return 0;
-}
-
-/* stop caching firmware once syscore_suspend is reached */
-static int fw_suspend(void)
-{
-	fw_cache.state = FW_LOADER_NO_CACHE;
-	return 0;
-}
-
-static struct syscore_ops fw_syscore_ops = {
-	.suspend = fw_suspend,
-};
-
-static int __init register_fw_pm_ops(void)
-{
-	int ret;
-
-	spin_lock_init(&fw_cache.name_lock);
-	INIT_LIST_HEAD(&fw_cache.fw_names);
-
-	INIT_DELAYED_WORK(&fw_cache.work,
-			  device_uncache_fw_images_work);
-
-	fw_cache.pm_notify.notifier_call = fw_pm_notify;
-	ret = register_pm_notifier(&fw_cache.pm_notify);
-	if (ret)
-		return ret;
-
-	register_syscore_ops(&fw_syscore_ops);
-
-	return ret;
-}
-
-static inline void unregister_fw_pm_ops(void)
-{
-	unregister_syscore_ops(&fw_syscore_ops);
-	unregister_pm_notifier(&fw_cache.pm_notify);
-}
-#else
-static void fw_cache_piggyback_on_request(struct fw_priv *fw_priv)
-{
-}
-static inline int register_fw_pm_ops(void)
-{
-	return 0;
-}
-static inline void unregister_fw_pm_ops(void)
-{
-}
-#endif
-
-static void __init fw_cache_init(void)
-{
-	spin_lock_init(&fw_cache.lock);
-	INIT_LIST_HEAD(&fw_cache.head);
-	fw_cache.state = FW_LOADER_NO_CACHE;
-}
-
-static int fw_shutdown_notify(struct notifier_block *unused1,
-			      unsigned long unused2, void *unused3)
-{
-	/*
-	 * Kill all pending fallback requests to avoid both stalling shutdown,
-	 * and avoid a deadlock with the usermode_lock.
-	 */
-	kill_pending_fw_fallback_reqs(true);
-
-	return NOTIFY_DONE;
-}
-
-static struct notifier_block fw_shutdown_nb = {
-	.notifier_call = fw_shutdown_notify,
-};
-
-static int __init firmware_class_init(void)
-{
-	int ret;
-
-	/* No need to unfold these on exit */
-	fw_cache_init();
-
-	ret = register_fw_pm_ops();
-	if (ret)
-		return ret;
-
-	ret = register_reboot_notifier(&fw_shutdown_nb);
-	if (ret)
-		goto out;
-
-	return register_sysfs_loader();
-
-out:
-	unregister_fw_pm_ops();
-	return ret;
-}
-
-static void __exit firmware_class_exit(void)
-{
-	unregister_fw_pm_ops();
-	unregister_reboot_notifier(&fw_shutdown_nb);
-	unregister_sysfs_loader();
-}
-
-fs_initcall(firmware_class_init);
-module_exit(firmware_class_exit);
diff -Nrup linux-6.16.7/drivers/bluetooth/hci_qca.c linux-lenovo-x13s-linux-6.16.y/drivers/bluetooth/hci_qca.c
--- linux-6.16.7/drivers/bluetooth/hci_qca.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/bluetooth/hci_qca.c	2025-09-11 09:47:42.000000000 -0600
@@ -1220,7 +1220,14 @@ static int qca_recv_event(struct hci_dev
 		 * vendor command).
 		 */
 
-		if (hdr->evt == HCI_EV_VENDOR)
+		/* For the WCN6750/WCN6855/WCN7850, like the WCN3990, the
+		 * vendor command for a baudrate change command isn't sent as
+		 * synchronous HCI command, the controller sends the corresponding
+		 * command complete event with the new baudrate. The event is
+		 * received and properly decoded after changing the baudrate of
+		 * the host port. It needs to be dropped.
+		 */
+		if (hdr->evt == HCI_EV_VENDOR || hdr->evt == HCI_EV_CMD_COMPLETE)
 			complete(&qca->drop_ev_comp);
 
 		kfree_skb(skb);
@@ -1514,6 +1521,9 @@ static int qca_set_speed(struct hci_uart
 
 		switch (soc_type) {
 		case QCA_WCN3990:
+		case QCA_WCN6750:
+		case QCA_WCN6855:
+		case QCA_WCN7850:
 			reinit_completion(&qca->drop_ev_comp);
 			set_bit(QCA_DROP_VENDOR_EVENT, &qca->flags);
 			break;
@@ -1549,6 +1559,9 @@ error:
 
 		switch (soc_type) {
 		case QCA_WCN3990:
+		case QCA_WCN6750:
+		case QCA_WCN6855:
+		case QCA_WCN7850:
 			/* Wait for the controller to send the vendor event
 			 * for the baudrate change command.
 			 */
diff -Nrup linux-6.16.7/drivers/cpuidle/cpuidle-qcom-spm.c linux-lenovo-x13s-linux-6.16.y/drivers/cpuidle/cpuidle-qcom-spm.c
--- linux-6.16.7/drivers/cpuidle/cpuidle-qcom-spm.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/cpuidle/cpuidle-qcom-spm.c	2025-09-11 09:47:42.000000000 -0600
@@ -86,9 +86,9 @@ static const struct of_device_id qcom_id
 
 static int spm_cpuidle_register(struct device *cpuidle_dev, int cpu)
 {
-	struct platform_device *pdev = NULL;
+	struct platform_device *pdev;
 	struct device_node *cpu_node, *saw_node;
-	struct cpuidle_qcom_spm_data *data = NULL;
+	struct cpuidle_qcom_spm_data *data;
 	int ret;
 
 	cpu_node = of_cpu_device_node_get(cpu);
@@ -96,20 +96,23 @@ static int spm_cpuidle_register(struct d
 		return -ENODEV;
 
 	saw_node = of_parse_phandle(cpu_node, "qcom,saw", 0);
+	of_node_put(cpu_node);
 	if (!saw_node)
 		return -ENODEV;
 
 	pdev = of_find_device_by_node(saw_node);
 	of_node_put(saw_node);
-	of_node_put(cpu_node);
 	if (!pdev)
 		return -ENODEV;
 
 	data = devm_kzalloc(cpuidle_dev, sizeof(*data), GFP_KERNEL);
-	if (!data)
+	if (!data) {
+		put_device(&pdev->dev);
 		return -ENOMEM;
+	}
 
 	data->spm = dev_get_drvdata(&pdev->dev);
+	put_device(&pdev->dev);
 	if (!data->spm)
 		return -EINVAL;
 
diff -Nrup linux-6.16.7/drivers/firmware/efi/libstub/efistub.h linux-lenovo-x13s-linux-6.16.y/drivers/firmware/efi/libstub/efistub.h
--- linux-6.16.7/drivers/firmware/efi/libstub/efistub.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/firmware/efi/libstub/efistub.h	2025-09-11 09:47:42.000000000 -0600
@@ -272,7 +272,7 @@ union efi_boot_services {
 		efi_status_t (__efiapi *wait_for_event)(unsigned long,
 							efi_event_t *,
 							unsigned long *);
-		void *signal_event;
+		efi_status_t (__efiapi *signal_event)(efi_event_t);
 		efi_status_t (__efiapi *close_event)(efi_event_t);
 		void *check_event;
 		void *install_protocol_interface;
@@ -324,7 +324,7 @@ union efi_boot_services {
 		void *calculate_crc32;
 		void (__efiapi *copy_mem)(void *, const void *, unsigned long);
 		void (__efiapi *set_mem)(void *, unsigned long, unsigned char);
-		void *create_event_ex;
+		efi_status_t (__efiapi *create_event_ex)(u32, int, void *, void *, void *, efi_event_t *);
 	};
 	struct {
 		efi_table_hdr_t hdr;
diff -Nrup linux-6.16.7/drivers/firmware/efi/libstub/efi-stub-helper.c linux-lenovo-x13s-linux-6.16.y/drivers/firmware/efi/libstub/efi-stub-helper.c
--- linux-6.16.7/drivers/firmware/efi/libstub/efi-stub-helper.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/firmware/efi/libstub/efi-stub-helper.c	2025-09-11 09:47:42.000000000 -0600
@@ -407,6 +407,13 @@ char *efi_convert_cmdline(efi_loaded_ima
 	return (char *)cmdline_addr;
 }
 
+#define EFI_EVENT_GROUP_BEFORE_EXIT_BOOT_SERVICES \
+	EFI_GUID(0x8be0e274, 0x3970, 0x4b44,  0x80, 0xc5, 0x1a, 0xb9, 0x50, 0x2f, 0x3b, 0xfc)
+
+static void efi_before_ebs_notify(efi_event_t event, void *context)
+{
+}
+
 /**
  * efi_exit_boot_services() - Exit boot services
  * @handle:	handle of the exiting image
@@ -427,10 +434,27 @@ efi_status_t efi_exit_boot_services(void
 {
 	struct efi_boot_memmap *map;
 	efi_status_t status;
+	efi_guid_t guid = EFI_EVENT_GROUP_BEFORE_EXIT_BOOT_SERVICES;
+	efi_event_t event;
 
 	if (efi_disable_pci_dma)
 		efi_pci_disable_bridge_busmaster();
 
+	status = efi_bs_call(create_event_ex, EFI_EVT_NOTIFY_SIGNAL,
+			     EFI_TPL_CALLBACK, efi_before_ebs_notify, NULL,
+			     &guid, &event);
+	if (status == EFI_SUCCESS) {
+		status = efi_bs_call(signal_event, event);
+		if (status != EFI_SUCCESS)
+			efi_err("%s - signal event failed: %02lx\n", __func__, status);
+
+		status = efi_bs_call(close_event, event);
+		if (status != EFI_SUCCESS)
+			efi_err("%s - close event failed: %02lx\n", __func__, status);
+	} else {
+		efi_err("%s - create event ex failed: %02lx\n", __func__, status);
+	}
+
 	status = efi_get_memory_map(&map, true);
 	if (status != EFI_SUCCESS)
 		return status;
diff -Nrup linux-6.16.7/drivers/firmware/psci/psci.c linux-lenovo-x13s-linux-6.16.y/drivers/firmware/psci/psci.c
--- linux-6.16.7/drivers/firmware/psci/psci.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/firmware/psci/psci.c	2025-09-11 09:47:42.000000000 -0600
@@ -79,6 +79,7 @@ struct psci_0_1_function_ids get_psci_0_
 static u32 psci_cpu_suspend_feature;
 static bool psci_system_reset2_supported;
 static bool psci_system_off2_hibernate_supported;
+static u32 psci_s2ram_suspend_param;
 
 static inline bool psci_has_ext_power_state(void)
 {
@@ -539,12 +540,22 @@ static int psci_system_suspend(unsigned
 
 static int psci_system_suspend_enter(suspend_state_t state)
 {
+	pm_set_resume_via_firmware();
+
 	return cpu_suspend(0, psci_system_suspend);
 }
 
-static const struct platform_suspend_ops psci_suspend_ops = {
-	.valid          = suspend_valid_only_mem,
-	.enter          = psci_system_suspend_enter,
+static int psci_system_suspend_begin(suspend_state_t state)
+{
+	pm_set_suspend_via_firmware();
+
+	return 0;
+}
+
+static const struct platform_suspend_ops psci_system_suspend_ops = {
+	.valid = suspend_valid_only_mem,
+	.enter = psci_system_suspend_enter,
+	.begin = psci_system_suspend_begin,
 };
 
 static void __init psci_init_system_reset2(void)
@@ -579,7 +590,7 @@ static void __init psci_init_system_susp
 	ret = psci_features(PSCI_FN_NATIVE(1_0, SYSTEM_SUSPEND));
 
 	if (ret != PSCI_RET_NOT_SUPPORTED)
-		suspend_set_ops(&psci_suspend_ops);
+		suspend_set_ops(&psci_system_suspend_ops);
 }
 
 static void __init psci_init_cpu_suspend(void)
@@ -708,6 +719,17 @@ static int __init psci_probe(void)
 
 typedef int (*psci_initcall_t)(const struct device_node *);
 
+static int psci_cpu_suspend_s2ram_enter(suspend_state_t state)
+{
+	return psci_cpu_suspend_enter(psci_s2ram_suspend_param);
+}
+
+static const struct platform_suspend_ops psci_cpu_suspend_s2ram_ops = {
+	.valid = suspend_valid_only_mem,
+	.enter = psci_cpu_suspend_s2ram_enter,
+	.begin = psci_system_suspend_begin,
+};
+
 /*
  * PSCI init function for PSCI versions >=0.2
  *
@@ -722,6 +744,20 @@ static int __init psci_0_2_init(const st
 		return err;
 
 	/*
+	 * Some firmwares expose S2RAM entry through a custom suspend param.
+	 *
+	 * If found, register a suspend handler instead of registering the
+	 * idle state with cpuidle.
+	 */
+	err = of_property_read_u32(np, "arm,psci-s2ram-param", &psci_s2ram_suspend_param);
+	if (!err) {
+		suspend_set_ops(&psci_cpu_suspend_s2ram_ops);
+	} else if (err != -EINVAL) {
+		pr_err("Couldn't read the S2RAM PSCI suspend param: %d\n",
+		       psci_s2ram_suspend_param);
+	}
+
+	/*
 	 * Starting with v0.2, the PSCI specification introduced a call
 	 * (PSCI_VERSION) that allows probing the firmware version, so
 	 * that PSCI function IDs and version specific initialization
diff -Nrup linux-6.16.7/drivers/gpu/drm/display/drm_dp_helper.c linux-lenovo-x13s-linux-6.16.y/drivers/gpu/drm/display/drm_dp_helper.c
--- linux-6.16.7/drivers/gpu/drm/display/drm_dp_helper.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/gpu/drm/display/drm_dp_helper.c	2025-09-11 09:47:42.000000000 -0600
@@ -28,6 +28,7 @@
 #include <linux/init.h>
 #include <linux/iopoll.h>
 #include <linux/kernel.h>
+#include <linux/minmax.h>
 #include <linux/module.h>
 #include <linux/sched.h>
 #include <linux/seq_file.h>
@@ -4111,6 +4112,32 @@ drm_edp_backlight_probe_max(struct drm_d
 	}
 
 	pn &= DP_EDP_PWMGEN_BIT_COUNT_MASK;
+
+	ret = drm_dp_dpcd_read_byte(aux, DP_EDP_PWMGEN_BIT_COUNT_CAP_MIN, &pn_min);
+	if (ret < 0) {
+		drm_dbg_kms(aux->drm_dev, "%s: Failed to read pwmgen bit count cap min: %d\n",
+			    aux->name, ret);
+		return -ENODEV;
+	}
+	pn_min &= DP_EDP_PWMGEN_BIT_COUNT_MASK;
+
+	ret = drm_dp_dpcd_read_byte(aux, DP_EDP_PWMGEN_BIT_COUNT_CAP_MAX, &pn_max);
+	if (ret < 0) {
+		drm_dbg_kms(aux->drm_dev, "%s: Failed to read pwmgen bit count cap max: %d\n",
+			    aux->name, ret);
+		return -ENODEV;
+	}
+	pn_max &= DP_EDP_PWMGEN_BIT_COUNT_MASK;
+
+	/*
+	 * Per VESA eDP Spec v1.4b, section 3.3.10.2:
+	 * If DP_EDP_PWMGEN_BIT_COUNT is less than DP_EDP_PWMGEN_BIT_COUNT_CAP_MIN,
+	 * the sink must use the MIN value as the effective PWM bit count.
+	 * Clamp the reported value to the [MIN, MAX] capability range to ensure
+	 * correct brightness scaling on compliant eDP panels.
+	 */
+	pn = clamp(pn, pn_min, pn_max);
+
 	bl->max = (1 << pn) - 1;
 	if (!driver_pwm_freq_hz)
 		return 0;
@@ -4137,20 +4164,6 @@ drm_edp_backlight_probe_max(struct drm_d
 	 * - FxP is within 25% of desired value.
 	 *   Note: 25% is arbitrary value and may need some tweak.
 	 */
-	ret = drm_dp_dpcd_read_byte(aux, DP_EDP_PWMGEN_BIT_COUNT_CAP_MIN, &pn_min);
-	if (ret < 0) {
-		drm_dbg_kms(aux->drm_dev, "%s: Failed to read pwmgen bit count cap min: %d\n",
-			    aux->name, ret);
-		return 0;
-	}
-	ret = drm_dp_dpcd_read_byte(aux, DP_EDP_PWMGEN_BIT_COUNT_CAP_MAX, &pn_max);
-	if (ret < 0) {
-		drm_dbg_kms(aux->drm_dev, "%s: Failed to read pwmgen bit count cap max: %d\n",
-			    aux->name, ret);
-		return 0;
-	}
-	pn_min &= DP_EDP_PWMGEN_BIT_COUNT_MASK;
-	pn_max &= DP_EDP_PWMGEN_BIT_COUNT_MASK;
 
 	/* Ensure frequency is within 25% of desired value */
 	fxp_min = DIV_ROUND_CLOSEST(fxp * 3, 4);
diff -Nrup linux-6.16.7/drivers/gpu/drm/panel/panel-edp.c linux-lenovo-x13s-linux-6.16.y/drivers/gpu/drm/panel/panel-edp.c
--- linux-6.16.7/drivers/gpu/drm/panel/panel-edp.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/gpu/drm/panel/panel-edp.c	2025-09-11 09:47:42.000000000 -0600
@@ -1923,6 +1923,7 @@ static const struct edp_panel_entry edp_
 	EDP_PANEL_ENTRY('B', 'O', 'E', 0x094b, &delay_200_500_e50, "NT116WHM-N21"),
 	EDP_PANEL_ENTRY('B', 'O', 'E', 0x0951, &delay_200_500_e80, "NV116WHM-N47"),
 	EDP_PANEL_ENTRY('B', 'O', 'E', 0x095f, &delay_200_500_e50, "NE135FBM-N41 v8.1"),
+	EDP_PANEL_ENTRY('B', 'O', 'E', 0x0964, &delay_200_500_e50, "NV116WUM-N61"),
 	EDP_PANEL_ENTRY('B', 'O', 'E', 0x096e, &delay_200_500_e50_po2e200, "NV116WHM-T07 V8.0"),
 	EDP_PANEL_ENTRY('B', 'O', 'E', 0x0979, &delay_200_500_e50, "NV116WHM-N49 V8.0"),
 	EDP_PANEL_ENTRY('B', 'O', 'E', 0x098d, &boe_nv110wtm_n61.delay, "NV110WTM-N61"),
@@ -1935,6 +1936,7 @@ static const struct edp_panel_entry edp_
 	EDP_PANEL_ENTRY('B', 'O', 'E', 0x0a3e, &delay_200_500_e80, "NV116WHM-N49"),
 	EDP_PANEL_ENTRY('B', 'O', 'E', 0x0a5d, &delay_200_500_e50, "NV116WHM-N45"),
 	EDP_PANEL_ENTRY('B', 'O', 'E', 0x0ac5, &delay_200_500_e50, "NV116WHM-N4C"),
+	EDP_PANEL_ENTRY('B', 'O', 'E', 0x0a84, &delay_200_500_e50, "NV133WUM-T01"),
 	EDP_PANEL_ENTRY('B', 'O', 'E', 0x0ae8, &delay_200_500_e50_p2e80, "NV140WUM-N41"),
 	EDP_PANEL_ENTRY('B', 'O', 'E', 0x0b09, &delay_200_500_e50_po2e200, "NV140FHM-NZ"),
 	EDP_PANEL_ENTRY('B', 'O', 'E', 0x0b34, &delay_200_500_e80, "NV122WUM-N41"),
diff -Nrup linux-6.16.7/drivers/i2c/busses/i2c-qcom-cci.c linux-lenovo-x13s-linux-6.16.y/drivers/i2c/busses/i2c-qcom-cci.c
--- linux-6.16.7/drivers/i2c/busses/i2c-qcom-cci.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/i2c/busses/i2c-qcom-cci.c	2025-09-11 09:47:42.000000000 -0600
@@ -10,6 +10,7 @@
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/platform_device.h>
+#include <linux/pm_opp.h>
 #include <linux/pm_runtime.h>
 
 #define CCI_HW_VERSION				0x0
@@ -121,6 +122,7 @@ struct cci_data {
 	struct i2c_adapter_quirks quirks;
 	u16 queue_size[NUM_QUEUES];
 	struct hw_params params[3];
+	bool fast_mode_plus_supported;
 };
 
 struct cci {
@@ -466,21 +468,25 @@ static const struct i2c_algorithm cci_al
 	.functionality = cci_func,
 };
 
-static int cci_enable_clocks(struct cci *cci)
+static unsigned long cci_desired_clk_rate(struct cci *cci)
 {
-	return clk_bulk_prepare_enable(cci->nclocks, cci->clocks);
-}
+	if (cci->data->fast_mode_plus_supported)
+		return 37500000ULL;
 
-static void cci_disable_clocks(struct cci *cci)
-{
-	clk_bulk_disable_unprepare(cci->nclocks, cci->clocks);
+	return 19200000ULL;
 }
 
 static int __maybe_unused cci_suspend_runtime(struct device *dev)
 {
 	struct cci *cci = dev_get_drvdata(dev);
+	int ret;
+
+	ret = dev_pm_opp_set_rate(dev, 0);
+	if (ret)
+		return ret;
+
+	clk_bulk_disable_unprepare(cci->nclocks, cci->clocks);
 
-	cci_disable_clocks(cci);
 	return 0;
 }
 
@@ -489,11 +495,16 @@ static int __maybe_unused cci_resume_run
 	struct cci *cci = dev_get_drvdata(dev);
 	int ret;
 
-	ret = cci_enable_clocks(cci);
+	ret = clk_bulk_prepare_enable(cci->nclocks, cci->clocks);
+	if (ret)
+		return ret;
+
+	ret = dev_pm_opp_set_rate(dev, cci_desired_clk_rate(cci));
 	if (ret)
 		return ret;
 
 	cci_init(cci);
+
 	return 0;
 }
 
@@ -592,10 +603,23 @@ static int cci_probe(struct platform_dev
 		return dev_err_probe(dev, -EINVAL, "not enough clocks in DT\n");
 	cci->nclocks = ret;
 
-	ret = cci_enable_clocks(cci);
+	ret = clk_bulk_prepare_enable(cci->nclocks, cci->clocks);
 	if (ret < 0)
 		return ret;
 
+	ret = devm_pm_opp_set_clkname(dev, "cci");
+	if (ret)
+		return ret;
+
+	/* OPP table is optional */
+	ret = devm_pm_opp_of_add_table(dev);
+	if (ret && ret != -ENODEV)
+		return dev_err_probe(dev, ret, "invalid OPP table in device tree\n");
+
+	ret = dev_pm_opp_set_rate(dev, cci_desired_clk_rate(cci));
+	if (ret)
+		return ret;
+
 	/* Interrupt */
 
 	ret = platform_get_irq(pdev, 0);
@@ -651,7 +675,7 @@ error_i2c:
 error:
 	disable_irq(cci->irq);
 disable_clocks:
-	cci_disable_clocks(cci);
+	clk_bulk_disable_unprepare(cci->nclocks, cci->clocks);
 
 	return ret;
 }
@@ -783,6 +807,7 @@ static const struct cci_data cci_v2_data
 		.trdhld = 3,
 		.tsp = 3
 	},
+	.fast_mode_plus_supported = true,
 };
 
 static const struct of_device_id cci_dt_match[] = {
diff -Nrup linux-6.16.7/drivers/leds/led-class.c linux-lenovo-x13s-linux-6.16.y/drivers/leds/led-class.c
--- linux-6.16.7/drivers/leds/led-class.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/leds/led-class.c	2025-09-11 09:47:42.000000000 -0600
@@ -252,15 +252,23 @@ static const struct class leds_class = {
  * of_led_get() - request a LED device via the LED framework
  * @np: device node to get the LED device from
  * @index: the index of the LED
+ * @name: the name of the LED used to map it to its function, if present
  *
  * Returns the LED device parsed from the phandle specified in the "leds"
  * property of a device tree node or a negative error-code on failure.
  */
-struct led_classdev *of_led_get(struct device_node *np, int index)
+static struct led_classdev *of_led_get(struct device_node *np, int index,
+				       const char *name)
 {
 	struct device *led_dev;
 	struct device_node *led_node;
 
+	/*
+	 * For named LEDs, first look up the name in the "led-names" property.
+	 * If it cannot be found, then of_parse_phandle() will propagate the error.
+	 */
+	if (name)
+		index = of_property_match_string(np, "led-names", name);
 	led_node = of_parse_phandle(np, "leds", index);
 	if (!led_node)
 		return ERR_PTR(-ENOENT);
@@ -270,7 +278,6 @@ struct led_classdev *of_led_get(struct d
 
 	return led_module_get(led_dev);
 }
-EXPORT_SYMBOL_GPL(of_led_get);
 
 /**
  * led_put() - release a LED device
@@ -325,7 +332,7 @@ struct led_classdev *__must_check devm_o
 	if (!dev)
 		return ERR_PTR(-EINVAL);
 
-	led = of_led_get(dev->of_node, index);
+	led = of_led_get(dev->of_node, index, NULL);
 	if (IS_ERR(led))
 		return led;
 
@@ -343,9 +350,14 @@ EXPORT_SYMBOL_GPL(devm_of_led_get);
 struct led_classdev *led_get(struct device *dev, char *con_id)
 {
 	struct led_lookup_data *lookup;
+	struct led_classdev *led_cdev;
 	const char *provider = NULL;
 	struct device *led_dev;
 
+	led_cdev = of_led_get(dev->of_node, -1, con_id);
+	if (!IS_ERR(led_cdev) || PTR_ERR(led_cdev) != -ENOENT)
+		return led_cdev;
+
 	mutex_lock(&leds_lookup_lock);
 	list_for_each_entry(lookup, &leds_lookup_list, list) {
 		if (!strcmp(lookup->dev_id, dev_name(dev)) &&
diff -Nrup linux-6.16.7/drivers/media/platform/qcom/camss/camss.c linux-lenovo-x13s-linux-6.16.y/drivers/media/platform/qcom/camss/camss.c
--- linux-6.16.7/drivers/media/platform/qcom/camss/camss.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/media/platform/qcom/camss/camss.c	2025-09-11 09:47:42.000000000 -0600
@@ -2845,6 +2845,14 @@ struct media_pad *camss_find_sensor_pad(
 
 	while (1) {
 		pad = &entity->pads[0];
+
+		/*
+		 * Work around unresolved bug in camss (or v4l2) which can
+		 * result in pad being NULL here.
+		 */
+		if (WARN_ON(!pad))
+			return NULL;
+
 		if (!(pad->flags & MEDIA_PAD_FL_SINK))
 			return NULL;
 
diff -Nrup linux-6.16.7/drivers/media/platform/qcom/camss/camss-vfe.c linux-lenovo-x13s-linux-6.16.y/drivers/media/platform/qcom/camss/camss-vfe.c
--- linux-6.16.7/drivers/media/platform/qcom/camss/camss-vfe.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/media/platform/qcom/camss/camss-vfe.c	2025-09-11 09:47:42.000000000 -0600
@@ -871,7 +871,7 @@ void vfe_isr_reset_ack(struct vfe_device
  */
 void vfe_pm_domain_off(struct vfe_device *vfe)
 {
-	if (!vfe->genpd)
+	if (!vfe->genpd_link)
 		return;
 
 	device_link_del(vfe->genpd_link);
diff -Nrup linux-6.16.7/drivers/media/platform/qcom/camss/camss-video.c linux-lenovo-x13s-linux-6.16.y/drivers/media/platform/qcom/camss/camss-video.c
--- linux-6.16.7/drivers/media/platform/qcom/camss/camss-video.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/media/platform/qcom/camss/camss-video.c	2025-09-11 09:47:42.000000000 -0600
@@ -225,6 +225,21 @@ static int video_check_format(struct cam
 	return 0;
 }
 
+static int video_prepare_streaming(struct vb2_queue *q)
+{
+	struct camss_video *video = vb2_get_drv_priv(q);
+	struct video_device *vdev = &video->vdev;
+	int ret;
+
+	ret = v4l2_pipeline_pm_get(&vdev->entity);
+	if (ret < 0) {
+		dev_err(video->camss->dev, "Failed to power up pipeline: %d\n",
+			ret);
+	}
+
+	return ret;
+}
+
 static int video_start_streaming(struct vb2_queue *q, unsigned int count)
 {
 	struct camss_video *video = vb2_get_drv_priv(q);
@@ -308,13 +323,23 @@ static void video_stop_streaming(struct
 	video->ops->flush_buffers(video, VB2_BUF_STATE_ERROR);
 }
 
+static void video_unprepare_streaming(struct vb2_queue *q)
+{
+	struct camss_video *video = vb2_get_drv_priv(q);
+	struct video_device *vdev = &video->vdev;
+
+	v4l2_pipeline_pm_put(&vdev->entity);
+}
+
 static const struct vb2_ops msm_video_vb2_q_ops = {
 	.queue_setup     = video_queue_setup,
 	.buf_init        = video_buf_init,
 	.buf_prepare     = video_buf_prepare,
 	.buf_queue       = video_buf_queue,
+	.prepare_streaming = video_prepare_streaming,
 	.start_streaming = video_start_streaming,
 	.stop_streaming  = video_stop_streaming,
+	.unprepare_streaming = video_unprepare_streaming,
 };
 
 /* -----------------------------------------------------------------------------
@@ -599,20 +624,10 @@ static int video_open(struct file *file)
 
 	file->private_data = vfh;
 
-	ret = v4l2_pipeline_pm_get(&vdev->entity);
-	if (ret < 0) {
-		dev_err(video->camss->dev, "Failed to power up pipeline: %d\n",
-			ret);
-		goto error_pm_use;
-	}
-
 	mutex_unlock(&video->lock);
 
 	return 0;
 
-error_pm_use:
-	v4l2_fh_release(file);
-
 error_alloc:
 	mutex_unlock(&video->lock);
 
@@ -621,12 +636,8 @@ error_alloc:
 
 static int video_release(struct file *file)
 {
-	struct video_device *vdev = video_devdata(file);
-
 	vb2_fop_release(file);
 
-	v4l2_pipeline_pm_put(&vdev->entity);
-
 	file->private_data = NULL;
 
 	return 0;
diff -Nrup linux-6.16.7/drivers/media/platform/qcom/venus/core.c linux-lenovo-x13s-linux-6.16.y/drivers/media/platform/qcom/venus/core.c
--- linux-6.16.7/drivers/media/platform/qcom/venus/core.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/media/platform/qcom/venus/core.c	2025-09-11 09:47:42.000000000 -0600
@@ -393,6 +393,15 @@ static int venus_probe(struct platform_d
 	if (IS_ERR(core->cpucfg_path))
 		return PTR_ERR(core->cpucfg_path);
 
+	core->llcc_path = devm_of_icc_get(dev, "video-llcc");
+	if (IS_ERR(core->llcc_path)) {
+		/* LLCC path is optional */
+		if (PTR_ERR(core->llcc_path) == -ENODATA)
+			core->llcc_path = NULL;
+		else
+			return PTR_ERR(core->llcc_path);
+	}
+
 	core->irq = platform_get_irq(pdev, 0);
 	if (core->irq < 0)
 		return core->irq;
@@ -581,12 +590,18 @@ static __maybe_unused int venus_runtime_
 	if (ret)
 		goto err_cpucfg_path;
 
+	ret = icc_set_bw(core->llcc_path, 0, 0);
+	if (ret)
+		goto err_llcc_path;
+
 	ret = icc_set_bw(core->video_path, 0, 0);
 	if (ret)
 		goto err_video_path;
 
 	return ret;
 
+err_llcc_path:
+	icc_set_bw(core->video_path, kbps_to_icc(20000), 0);
 err_video_path:
 	icc_set_bw(core->cpucfg_path, kbps_to_icc(1000), 0);
 err_cpucfg_path:
@@ -626,6 +641,10 @@ static __maybe_unused int venus_runtime_
 	if (ret)
 		return ret;
 
+	ret = icc_set_bw(core->llcc_path, kbps_to_icc(20000), 0);
+	if (ret)
+		return ret;
+
 	ret = icc_set_bw(core->cpucfg_path, kbps_to_icc(1000), 0);
 	if (ret)
 		return ret;
@@ -993,6 +1012,46 @@ static const struct venus_resources sm82
 	.enc_nodename = "video-encoder",
 };
 
+static const struct reg_val sm8350_reg_preset[] = {
+	{ 0xb0088, 0, 0x11 },
+};
+
+static const struct venus_resources sm8350_res = {
+	.freq_tbl = sm8250_freq_table,
+	.freq_tbl_size = ARRAY_SIZE(sm8250_freq_table),
+	.reg_tbl = sm8350_reg_preset,
+	.reg_tbl_size = ARRAY_SIZE(sm8350_reg_preset),
+	.bw_tbl_enc = sm8250_bw_table_enc,
+	.bw_tbl_enc_size = ARRAY_SIZE(sm8250_bw_table_enc),
+	.bw_tbl_dec = sm8250_bw_table_dec,
+	.bw_tbl_dec_size = ARRAY_SIZE(sm8250_bw_table_dec),
+	.clks = { "core", "iface" },
+	.clks_num = 2,
+	.resets = { "core" },
+	.resets_num = 1,
+	.vcodec0_clks = { "vcodec0_core" },
+	.vcodec_clks_num = 1,
+	.vcodec_pmdomains = (const char *[]) { "venus", "vcodec0" },
+	.vcodec_pmdomains_num = 2,
+	.opp_pmdomain = (const char *[]) { "mx", NULL },
+	.vcodec_num = 1,
+	.max_load = 7833600, /* 7680x4320@60fps */
+	.hfi_version = HFI_VERSION_6XX,
+	.vpu_version = VPU_VERSION_IRIS2,
+	.num_vpp_pipes = 4,
+	.vmem_id = VIDC_RESOURCE_NONE,
+	.vmem_size = 0,
+	.vmem_addr = 0,
+	.dma_mask = GENMASK(31, 29) - 1,
+	.cp_start = 0,
+	.cp_size = 0x25800000,
+	.cp_nonpixel_start = 0x1000000,
+	.cp_nonpixel_size = 0x24800000,
+	.fwname = "qcom/vpu-2.0/venus.mbn",
+	.dec_nodename = "video-decoder",
+	.enc_nodename = "video-encoder",
+};
+
 static const struct freq_tbl sc7280_freq_table[] = {
 	{ 0, 460000000 },
 	{ 0, 424000000 },
@@ -1057,16 +1116,62 @@ static const struct venus_resources sc72
 	.enc_nodename = "video-encoder",
 };
 
+static const struct freq_tbl sc8280xp_freq_table[] = {
+	{ 0, 239999999 },
+	{ 0, 338000000 },
+	{ 0, 366000000 },
+	{ 0, 444000000 },
+	{ 0, 533000000 },
+	{ 0, 560000000 },
+};
+
+static const struct venus_resources sc8280xp_res = {
+	.freq_tbl = sc8280xp_freq_table,
+	.freq_tbl_size = ARRAY_SIZE(sc8280xp_freq_table),
+	.reg_tbl = sm8350_reg_preset,
+	.reg_tbl_size = ARRAY_SIZE(sm8350_reg_preset),
+	.bw_tbl_enc = sm8250_bw_table_enc,
+	.bw_tbl_enc_size = ARRAY_SIZE(sm8250_bw_table_enc),
+	.bw_tbl_dec = sm8250_bw_table_dec,
+	.bw_tbl_dec_size = ARRAY_SIZE(sm8250_bw_table_dec),
+	.clks = { "core", "iface" },
+	.clks_num = 2,
+	.resets = { "core" },
+	.resets_num = 1,
+	.vcodec0_clks = { "vcodec0_core" },
+	.vcodec_clks_num = 1,
+	.vcodec_pmdomains = (const char *[]) { "venus", "vcodec0" },
+	.vcodec_pmdomains_num = 2,
+	.opp_pmdomain = (const char *[]) { "mx", NULL },
+	.vcodec_num = 1,
+	.max_load = 7833600, /* 7680x4320@60fps */
+	.hfi_version = HFI_VERSION_6XX,
+	.vpu_version = VPU_VERSION_IRIS2,
+	.num_vpp_pipes = 4,
+	.vmem_id = VIDC_RESOURCE_NONE,
+	.vmem_size = 0,
+	.vmem_addr = 0,
+	.dma_mask = GENMASK(31, 29) - 1,
+	.cp_start = 0,
+	.cp_size = 0x25800000,
+	.cp_nonpixel_start = 0x1000000,
+	.cp_nonpixel_size = 0x24800000,
+	.fwname = "qcom/vpu-2.0/venus.mbn",
+};
+
+
 static const struct of_device_id venus_dt_match[] = {
-	{ .compatible = "qcom,msm8916-venus", .data = &msm8916_res, },
-	{ .compatible = "qcom,msm8996-venus", .data = &msm8996_res, },
-	{ .compatible = "qcom,msm8998-venus", .data = &msm8998_res, },
-	{ .compatible = "qcom,sdm660-venus", .data = &sdm660_res, },
-	{ .compatible = "qcom,sdm845-venus", .data = &sdm845_res, },
-	{ .compatible = "qcom,sdm845-venus-v2", .data = &sdm845_res_v2, },
-	{ .compatible = "qcom,sc7180-venus", .data = &sc7180_res, },
-	{ .compatible = "qcom,sc7280-venus", .data = &sc7280_res, },
-	{ .compatible = "qcom,sm8250-venus", .data = &sm8250_res, },
+	{ .compatible = "qcom,msm8916-venus", .data = &msm8916_res },
+	{ .compatible = "qcom,msm8996-venus", .data = &msm8996_res },
+	{ .compatible = "qcom,msm8998-venus", .data = &msm8998_res },
+	{ .compatible = "qcom,sdm660-venus", .data = &sdm660_res },
+	{ .compatible = "qcom,sdm845-venus", .data = &sdm845_res },
+	{ .compatible = "qcom,sdm845-venus-v2", .data = &sdm845_res_v2 },
+	{ .compatible = "qcom,sc7180-venus", .data = &sc7180_res },
+	{ .compatible = "qcom,sc7280-venus", .data = &sc7280_res },
+	{ .compatible = "qcom,sc8280xp-venus", .data = &sc8280xp_res },
+	{ .compatible = "qcom,sm8250-venus", .data = &sm8250_res },
+	{ .compatible = "qcom,sm8350-venus", .data = &sm8350_res },
 	{ }
 };
 MODULE_DEVICE_TABLE(of, venus_dt_match);
diff -Nrup linux-6.16.7/drivers/media/platform/qcom/venus/core.h linux-lenovo-x13s-linux-6.16.y/drivers/media/platform/qcom/venus/core.h
--- linux-6.16.7/drivers/media/platform/qcom/venus/core.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/media/platform/qcom/venus/core.h	2025-09-11 09:47:42.000000000 -0600
@@ -40,6 +40,7 @@ struct freq_tbl {
 struct reg_val {
 	u32 reg;
 	u32 value;
+	u32 mask;
 };
 
 struct bw_tbl {
@@ -66,6 +67,7 @@ struct venus_resources {
 	unsigned int bw_tbl_enc_size;
 	const struct bw_tbl *bw_tbl_dec;
 	unsigned int bw_tbl_dec_size;
+	bool has_llcc_path;
 	const struct reg_val *reg_tbl;
 	unsigned int reg_tbl_size;
 	const struct hfi_ubwc_config *ubwc_conf;
@@ -137,6 +139,7 @@ struct venus_format {
  * @vcodec1_clks: an array of vcodec1 struct clk pointers
  * @video_path: an interconnect handle to video to/from memory path
  * @cpucfg_path: an interconnect handle to cpu configuration path
+ * @llcc_path: an interconnect handle to video to/from llcc path
  * @pmdomains:	a pointer to a list of pmdomains
  * @opp_pmdomain: an OPP power-domain
  * @resets: an array of reset signals
@@ -191,6 +194,7 @@ struct venus_core {
 	struct clk *vcodec1_clks[VIDC_VCODEC_CLKS_NUM_MAX];
 	struct icc_path *video_path;
 	struct icc_path *cpucfg_path;
+	struct icc_path *llcc_path;
 	struct dev_pm_domain_list *pmdomains;
 	struct dev_pm_domain_list *opp_pmdomain;
 	struct reset_control *resets[VIDC_RESETS_NUM_MAX];
diff -Nrup linux-6.16.7/drivers/media/platform/qcom/venus/hfi_venus.c linux-lenovo-x13s-linux-6.16.y/drivers/media/platform/qcom/venus/hfi_venus.c
--- linux-6.16.7/drivers/media/platform/qcom/venus/hfi_venus.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/media/platform/qcom/venus/hfi_venus.c	2025-09-11 09:47:42.000000000 -0600
@@ -369,10 +369,19 @@ static void venus_set_registers(struct v
 	const struct venus_resources *res = hdev->core->res;
 	const struct reg_val *tbl = res->reg_tbl;
 	unsigned int count = res->reg_tbl_size;
-	unsigned int i;
+	unsigned int i, val;
 
-	for (i = 0; i < count; i++)
-		writel(tbl[i].value, hdev->core->base + tbl[i].reg);
+	for (i = 0; i < count; i++) {
+		val = tbl[i].value;
+
+		/* In some cases, we only want to update certain bits */
+		if (tbl[i].mask) {
+			val = readl(hdev->core->base + tbl[i].reg);
+			val = (val & ~tbl[i].mask) | (tbl[i].value & tbl[i].mask);
+		}
+
+		writel(val, hdev->core->base + tbl[i].reg);
+	}
 }
 
 static void venus_soft_int(struct venus_hfi_device *hdev)
diff -Nrup linux-6.16.7/drivers/media/platform/qcom/venus/pm_helpers.c linux-lenovo-x13s-linux-6.16.y/drivers/media/platform/qcom/venus/pm_helpers.c
--- linux-6.16.7/drivers/media/platform/qcom/venus/pm_helpers.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/media/platform/qcom/venus/pm_helpers.c	2025-09-11 09:47:42.000000000 -0600
@@ -237,6 +237,9 @@ static int load_scale_bw(struct venus_co
 	dev_dbg(core->dev, VDBGL "total: avg_bw: %u, peak_bw: %u\n",
 		total_avg, total_peak);
 
+	if (core->res->has_llcc_path)
+		icc_set_bw(core->llcc_path, total_avg, total_peak);
+
 	return icc_set_bw(core->video_path, total_avg, total_peak);
 }
 
diff -Nrup linux-6.16.7/drivers/media/v4l2-core/v4l2-subdev.c linux-lenovo-x13s-linux-6.16.y/drivers/media/v4l2-core/v4l2-subdev.c
--- linux-6.16.7/drivers/media/v4l2-core/v4l2-subdev.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/media/v4l2-core/v4l2-subdev.c	2025-09-11 09:47:42.000000000 -0600
@@ -2563,7 +2563,7 @@ EXPORT_SYMBOL_GPL(v4l2_subdev_is_streami
 int v4l2_subdev_get_privacy_led(struct v4l2_subdev *sd)
 {
 #if IS_REACHABLE(CONFIG_LEDS_CLASS)
-	sd->privacy_led = led_get(sd->dev, "privacy-led");
+	sd->privacy_led = led_get(sd->dev, "privacy");
 	if (IS_ERR(sd->privacy_led) && PTR_ERR(sd->privacy_led) != -ENOENT)
 		return dev_err_probe(sd->dev, PTR_ERR(sd->privacy_led),
 				     "getting privacy LED\n");
diff -Nrup linux-6.16.7/drivers/net/wireless/ath/ath11k/core.c linux-lenovo-x13s-linux-6.16.y/drivers/net/wireless/ath/ath11k/core.c
--- linux-6.16.7/drivers/net/wireless/ath/ath11k/core.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/net/wireless/ath/ath11k/core.c	2025-09-11 09:47:42.000000000 -0600
@@ -2581,10 +2581,15 @@ int ath11k_core_init(struct ath11k_base
 	ret = ath11k_core_soc_create(ab);
 	if (ret) {
 		ath11k_err(ab, "failed to create soc core: %d\n", ret);
-		return ret;
+		goto err_unregister_pm_notifier;
 	}
 
 	return 0;
+
+err_unregister_pm_notifier:
+	ath11k_core_pm_notifier_unregister(ab);
+
+	return ret;
 }
 EXPORT_SYMBOL(ath11k_core_init);
 
diff -Nrup linux-6.16.7/drivers/net/wireless/ath/ath11k/dp_rx.c linux-lenovo-x13s-linux-6.16.y/drivers/net/wireless/ath/ath11k/dp_rx.c
--- linux-6.16.7/drivers/net/wireless/ath/ath11k/dp_rx.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/net/wireless/ath/ath11k/dp_rx.c	2025-09-11 09:47:42.000000000 -0600
@@ -2537,7 +2537,7 @@ static int ath11k_dp_rx_process_msdu(str
 	lrx_desc = (struct hal_rx_desc *)last_buf->data;
 	rx_attention = ath11k_dp_rx_get_attention(ab, lrx_desc);
 	if (!ath11k_dp_rx_h_attn_msdu_done(rx_attention)) {
-		ath11k_warn(ab, "msdu_done bit in attention is not set\n");
+		/* ath11k_warn(ab, "msdu_done bit in attention is not set\n"); */
 		ret = -EIO;
 		goto free_out;
 	}
@@ -2637,7 +2637,7 @@ int ath11k_dp_process_rx(struct ath11k_b
 	struct ath11k *ar;
 	struct hal_reo_dest_ring *desc;
 	enum hal_reo_dest_ring_push_reason push_reason;
-	u32 cookie, info0, rx_msdu_info0, rx_mpdu_info0;
+	u32 cookie;
 	int i;
 
 	for (i = 0; i < MAX_RADIOS; i++)
@@ -2654,7 +2654,7 @@ try_again:
 	      (struct hal_reo_dest_ring *)ath11k_hal_srng_dst_get_next_entry(ab,
 									     srng))) {
 		cookie = FIELD_GET(BUFFER_ADDR_INFO1_SW_COOKIE,
-				   READ_ONCE(desc->buf_addr_info.info1));
+				   desc->buf_addr_info.info1);
 		buf_id = FIELD_GET(DP_RXDMA_BUF_COOKIE_BUF_ID,
 				   cookie);
 		mac_id = FIELD_GET(DP_RXDMA_BUF_COOKIE_PDEV_ID, cookie);
@@ -2683,9 +2683,8 @@ try_again:
 
 		num_buffs_reaped[mac_id]++;
 
-		info0 = READ_ONCE(desc->info0);
 		push_reason = FIELD_GET(HAL_REO_DEST_RING_INFO0_PUSH_REASON,
-					info0);
+					desc->info0);
 		if (unlikely(push_reason !=
 			     HAL_REO_DEST_RING_PUSH_REASON_ROUTING_INSTRUCTION)) {
 			dev_kfree_skb_any(msdu);
@@ -2693,21 +2692,18 @@ try_again:
 			continue;
 		}
 
-		rx_msdu_info0 = READ_ONCE(desc->rx_msdu_info.info0);
-		rx_mpdu_info0 = READ_ONCE(desc->rx_mpdu_info.info0);
-
-		rxcb->is_first_msdu = !!(rx_msdu_info0 &
+		rxcb->is_first_msdu = !!(desc->rx_msdu_info.info0 &
 					 RX_MSDU_DESC_INFO0_FIRST_MSDU_IN_MPDU);
-		rxcb->is_last_msdu = !!(rx_msdu_info0 &
+		rxcb->is_last_msdu = !!(desc->rx_msdu_info.info0 &
 					RX_MSDU_DESC_INFO0_LAST_MSDU_IN_MPDU);
-		rxcb->is_continuation = !!(rx_msdu_info0 &
+		rxcb->is_continuation = !!(desc->rx_msdu_info.info0 &
 					   RX_MSDU_DESC_INFO0_MSDU_CONTINUATION);
 		rxcb->peer_id = FIELD_GET(RX_MPDU_DESC_META_DATA_PEER_ID,
-					  READ_ONCE(desc->rx_mpdu_info.meta_data));
+					  desc->rx_mpdu_info.meta_data);
 		rxcb->seq_no = FIELD_GET(RX_MPDU_DESC_INFO0_SEQ_NUM,
-					 rx_mpdu_info0);
+					 desc->rx_mpdu_info.info0);
 		rxcb->tid = FIELD_GET(HAL_REO_DEST_RING_INFO0_RX_QUEUE_NUM,
-				      info0);
+				      desc->info0);
 
 		rxcb->mac_id = mac_id;
 		__skb_queue_tail(&msdu_list[mac_id], msdu);
diff -Nrup linux-6.16.7/drivers/net/wireless/ath/ath11k/hal.c linux-lenovo-x13s-linux-6.16.y/drivers/net/wireless/ath/ath11k/hal.c
--- linux-6.16.7/drivers/net/wireless/ath/ath11k/hal.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/net/wireless/ath/ath11k/hal.c	2025-09-11 09:47:42.000000000 -0600
@@ -599,7 +599,7 @@ u32 ath11k_hal_ce_dst_status_get_length(
 	struct hal_ce_srng_dst_status_desc *desc = buf;
 	u32 len;
 
-	len = FIELD_GET(HAL_CE_DST_STATUS_DESC_FLAGS_LEN, READ_ONCE(desc->flags));
+	len = FIELD_GET(HAL_CE_DST_STATUS_DESC_FLAGS_LEN, desc->flags);
 	desc->flags &= ~HAL_CE_DST_STATUS_DESC_FLAGS_LEN;
 
 	return len;
diff -Nrup linux-6.16.7/drivers/net/wireless/ath/ath12k/hal.c linux-lenovo-x13s-linux-6.16.y/drivers/net/wireless/ath/ath12k/hal.c
--- linux-6.16.7/drivers/net/wireless/ath/ath12k/hal.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/net/wireless/ath/ath12k/hal.c	2025-09-11 09:47:42.000000000 -0600
@@ -1950,7 +1950,7 @@ u32 ath12k_hal_ce_dst_status_get_length(
 {
 	u32 len;
 
-	len = le32_get_bits(READ_ONCE(desc->flags), HAL_CE_DST_STATUS_DESC_FLAGS_LEN);
+	len = le32_get_bits(desc->flags, HAL_CE_DST_STATUS_DESC_FLAGS_LEN);
 	desc->flags &= ~cpu_to_le32(HAL_CE_DST_STATUS_DESC_FLAGS_LEN);
 
 	return len;
diff -Nrup linux-6.16.7/drivers/net/wireless/ath/ath12k/mac.c linux-lenovo-x13s-linux-6.16.y/drivers/net/wireless/ath/ath12k/mac.c
--- linux-6.16.7/drivers/net/wireless/ath/ath12k/mac.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/net/wireless/ath/ath12k/mac.c	2025-09-11 09:47:42.000000000 -0600
@@ -4955,9 +4955,9 @@ static int ath12k_mac_set_key(struct ath
 	}
 
 	if (key->flags & IEEE80211_KEY_FLAG_PAIRWISE)
-		flags |= WMI_KEY_PAIRWISE;
+		flags = WMI_KEY_PAIRWISE;
 	else
-		flags |= WMI_KEY_GROUP;
+		flags = WMI_KEY_GROUP;
 
 	ret = ath12k_install_key(arvif, key, cmd, peer_addr, flags);
 	if (ret) {
diff -Nrup linux-6.16.7/drivers/pci/controller/dwc/Kconfig linux-lenovo-x13s-linux-6.16.y/drivers/pci/controller/dwc/Kconfig
--- linux-6.16.7/drivers/pci/controller/dwc/Kconfig	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/pci/controller/dwc/Kconfig	2025-09-11 09:47:42.000000000 -0600
@@ -290,7 +290,7 @@ config PCIE_QCOM_COMMON
 	bool
 
 config PCIE_QCOM
-	bool "Qualcomm PCIe controller (host mode)"
+	tristate "Qualcomm PCIe controller (host mode)"
 	depends on OF && (ARCH_QCOM || COMPILE_TEST)
 	depends on PCI_MSI
 	select PCIE_DW_HOST
diff -Nrup linux-6.16.7/drivers/pci/controller/dwc/pcie-qcom.c linux-lenovo-x13s-linux-6.16.y/drivers/pci/controller/dwc/pcie-qcom.c
--- linux-6.16.7/drivers/pci/controller/dwc/pcie-qcom.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/pci/controller/dwc/pcie-qcom.c	2025-09-11 09:47:42.000000000 -0600
@@ -20,6 +20,8 @@
 #include <linux/kernel.h>
 #include <linux/limits.h>
 #include <linux/init.h>
+#include <linux/module.h>
+#include <linux/notifier.h>
 #include <linux/of.h>
 #include <linux/pci.h>
 #include <linux/pm_opp.h>
@@ -244,7 +246,6 @@ struct qcom_pcie_ops {
 	int (*get_resources)(struct qcom_pcie *pcie);
 	int (*init)(struct qcom_pcie *pcie);
 	int (*post_init)(struct qcom_pcie *pcie);
-	void (*host_post_init)(struct qcom_pcie *pcie);
 	void (*deinit)(struct qcom_pcie *pcie);
 	void (*ltssm_enable)(struct qcom_pcie *pcie);
 	int (*config_sid)(struct qcom_pcie *pcie);
@@ -274,6 +275,7 @@ struct qcom_pcie {
 	struct icc_path *icc_cpu;
 	const struct qcom_pcie_cfg *cfg;
 	struct dentry *debugfs;
+	struct notifier_block nb;
 	bool suspended;
 	bool use_pm_opp;
 };
@@ -1016,25 +1018,6 @@ static int qcom_pcie_post_init_2_7_0(str
 	return 0;
 }
 
-static int qcom_pcie_enable_aspm(struct pci_dev *pdev, void *userdata)
-{
-	/*
-	 * Downstream devices need to be in D0 state before enabling PCI PM
-	 * substates.
-	 */
-	pci_set_power_state_locked(pdev, PCI_D0);
-	pci_enable_link_state_locked(pdev, PCIE_LINK_STATE_ALL);
-
-	return 0;
-}
-
-static void qcom_pcie_host_post_init_2_7_0(struct qcom_pcie *pcie)
-{
-	struct dw_pcie_rp *pp = &pcie->pci->pp;
-
-	pci_walk_bus(pp->bridge->bus, qcom_pcie_enable_aspm, NULL);
-}
-
 static void qcom_pcie_deinit_2_7_0(struct qcom_pcie *pcie)
 {
 	struct qcom_pcie_resources_2_7_0 *res = &pcie->res.v2_7_0;
@@ -1285,19 +1268,9 @@ static void qcom_pcie_host_deinit(struct
 	pcie->cfg->ops->deinit(pcie);
 }
 
-static void qcom_pcie_host_post_init(struct dw_pcie_rp *pp)
-{
-	struct dw_pcie *pci = to_dw_pcie_from_pp(pp);
-	struct qcom_pcie *pcie = to_qcom_pcie(pci);
-
-	if (pcie->cfg->ops->host_post_init)
-		pcie->cfg->ops->host_post_init(pcie);
-}
-
 static const struct dw_pcie_host_ops qcom_pcie_dw_ops = {
 	.init		= qcom_pcie_host_init,
 	.deinit		= qcom_pcie_host_deinit,
-	.post_init	= qcom_pcie_host_post_init,
 };
 
 /* Qcom IP rev.: 2.1.0	Synopsys IP rev.: 4.01a */
@@ -1359,7 +1332,6 @@ static const struct qcom_pcie_ops ops_1_
 	.get_resources = qcom_pcie_get_resources_2_7_0,
 	.init = qcom_pcie_init_2_7_0,
 	.post_init = qcom_pcie_post_init_2_7_0,
-	.host_post_init = qcom_pcie_host_post_init_2_7_0,
 	.deinit = qcom_pcie_deinit_2_7_0,
 	.ltssm_enable = qcom_pcie_2_3_2_ltssm_enable,
 	.config_sid = qcom_pcie_config_sid_1_9_0,
@@ -1370,7 +1342,6 @@ static const struct qcom_pcie_ops ops_1_
 	.get_resources = qcom_pcie_get_resources_2_7_0,
 	.init = qcom_pcie_init_2_7_0,
 	.post_init = qcom_pcie_post_init_2_7_0,
-	.host_post_init = qcom_pcie_host_post_init_2_7_0,
 	.deinit = qcom_pcie_deinit_2_7_0,
 	.ltssm_enable = qcom_pcie_2_3_2_ltssm_enable,
 };
@@ -1580,6 +1551,38 @@ static irqreturn_t qcom_pcie_global_irq_
 	return IRQ_HANDLED;
 }
 
+static int qcom_pcie_enable_aspm(struct pci_dev *pdev)
+{
+	/*
+	 * Downstream devices need to be in D0 state before enabling PCI PM
+	 * substates.
+	 */
+	pci_set_power_state(pdev, PCI_D0);
+	pci_enable_link_state(pdev, PCIE_LINK_STATE_ALL);
+
+	return 0;
+}
+
+static int pcie_qcom_notify(struct notifier_block *nb, unsigned long action,
+		void *data)
+{
+	struct device *dev = data;
+	struct pci_dev *pdev = to_pci_dev(dev);
+
+	switch (action) {
+	case BUS_NOTIFY_BIND_DRIVER:
+		qcom_pcie_enable_aspm(pdev);
+		break;
+	}
+
+	return NOTIFY_DONE;
+}
+
+static void qcom_pcie_deinit_debugfs(struct qcom_pcie *pcie)
+{
+	debugfs_remove(pcie->debugfs);
+}
+
 static int qcom_pcie_probe(struct platform_device *pdev)
 {
 	const struct qcom_pcie_cfg *pcie_cfg;
@@ -1710,10 +1713,15 @@ static int qcom_pcie_probe(struct platfo
 	if (irq > 0)
 		pp->use_linkup_irq = true;
 
+	pcie->nb.notifier_call = pcie_qcom_notify;
+	ret = bus_register_notifier(&pci_bus_type, &pcie->nb);
+	if (ret)
+		goto err_phy_exit;
+
 	ret = dw_pcie_host_init(pp);
 	if (ret) {
 		dev_err(dev, "cannot initialize host\n");
-		goto err_phy_exit;
+		goto err_unregister_notifier;
 	}
 
 	name = devm_kasprintf(dev, GFP_KERNEL, "qcom_pcie_global_irq%d",
@@ -1746,6 +1754,8 @@ static int qcom_pcie_probe(struct platfo
 
 err_host_deinit:
 	dw_pcie_host_deinit(pp);
+err_unregister_notifier:
+	bus_unregister_notifier(&pci_bus_type, &pcie->nb);
 err_phy_exit:
 	phy_exit(pcie->phy);
 err_pm_runtime_put:
@@ -1755,6 +1765,23 @@ err_pm_runtime_put:
 	return ret;
 }
 
+static void qcom_pcie_remove(struct platform_device *pdev)
+{
+	struct qcom_pcie *pcie = platform_get_drvdata(pdev);
+	struct device *dev = &pdev->dev;
+
+	qcom_pcie_deinit_debugfs(pcie);
+
+	dw_pcie_host_deinit(&pcie->pci->pp);
+
+	bus_unregister_notifier(&pci_bus_type, &pcie->nb);
+
+	phy_exit(pcie->phy);
+
+	pm_runtime_put_sync(dev);
+	pm_runtime_disable(dev);
+}
+
 static int qcom_pcie_suspend_noirq(struct device *dev)
 {
 	struct qcom_pcie *pcie = dev_get_drvdata(dev);
@@ -1866,6 +1893,7 @@ static const struct of_device_id qcom_pc
 	{ .compatible = "qcom,pcie-x1e80100", .data = &cfg_sc8280xp },
 	{ }
 };
+MODULE_DEVICE_TABLE(of, qcom_pcie_match);
 
 static void qcom_fixup_class(struct pci_dev *dev)
 {
@@ -1885,12 +1913,16 @@ static const struct dev_pm_ops qcom_pcie
 
 static struct platform_driver qcom_pcie_driver = {
 	.probe = qcom_pcie_probe,
+	.remove = qcom_pcie_remove,
 	.driver = {
 		.name = "qcom-pcie",
-		.suppress_bind_attrs = true,
 		.of_match_table = qcom_pcie_match,
 		.pm = &qcom_pcie_pm_ops,
 		.probe_type = PROBE_PREFER_ASYNCHRONOUS,
 	},
 };
-builtin_platform_driver(qcom_pcie_driver);
+module_platform_driver(qcom_pcie_driver);
+
+MODULE_AUTHOR("Stanimir Varbanov <svarbanov@mm-sol.com>");
+MODULE_DESCRIPTION("Qualcomm PCIe root complex driver");
+MODULE_LICENSE("GPL");
diff -Nrup linux-6.16.7/drivers/phy/broadcom/phy-bcm-ns2-pcie.c linux-lenovo-x13s-linux-6.16.y/drivers/phy/broadcom/phy-bcm-ns2-pcie.c
--- linux-6.16.7/drivers/phy/broadcom/phy-bcm-ns2-pcie.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/phy/broadcom/phy-bcm-ns2-pcie.c	2025-09-11 09:47:42.000000000 -0600
@@ -61,8 +61,6 @@ static int ns2_pci_phy_probe(struct mdio
 		return PTR_ERR(provider);
 	}
 
-	dev_info(dev, "%s PHY registered\n", dev_name(dev));
-
 	return 0;
 }
 
diff -Nrup linux-6.16.7/drivers/phy/broadcom/phy-bcm-ns2-usbdrd.c linux-lenovo-x13s-linux-6.16.y/drivers/phy/broadcom/phy-bcm-ns2-usbdrd.c
--- linux-6.16.7/drivers/phy/broadcom/phy-bcm-ns2-usbdrd.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/phy/broadcom/phy-bcm-ns2-usbdrd.c	2025-09-11 09:47:42.000000000 -0600
@@ -395,7 +395,6 @@ static int ns2_drd_phy_probe(struct plat
 
 	platform_set_drvdata(pdev, driver);
 
-	dev_info(dev, "Registered NS2 DRD Phy device\n");
 	queue_delayed_work(system_power_efficient_wq, &driver->wq_extcon,
 			   driver->debounce_jiffies);
 
diff -Nrup linux-6.16.7/drivers/phy/broadcom/phy-bcm-sr-pcie.c linux-lenovo-x13s-linux-6.16.y/drivers/phy/broadcom/phy-bcm-sr-pcie.c
--- linux-6.16.7/drivers/phy/broadcom/phy-bcm-sr-pcie.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/phy/broadcom/phy-bcm-sr-pcie.c	2025-09-11 09:47:42.000000000 -0600
@@ -277,8 +277,6 @@ static int sr_pcie_phy_probe(struct plat
 		return PTR_ERR(provider);
 	}
 
-	dev_info(dev, "Stingray PCIe PHY driver initialized\n");
-
 	return 0;
 }
 
diff -Nrup linux-6.16.7/drivers/phy/broadcom/phy-brcm-sata.c linux-lenovo-x13s-linux-6.16.y/drivers/phy/broadcom/phy-brcm-sata.c
--- linux-6.16.7/drivers/phy/broadcom/phy-brcm-sata.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/phy/broadcom/phy-brcm-sata.c	2025-09-11 09:47:42.000000000 -0600
@@ -832,7 +832,7 @@ static int brcm_sata_phy_probe(struct pl
 		return PTR_ERR(provider);
 	}
 
-	dev_info(dev, "registered %d port(s)\n", count);
+	dev_dbg(dev, "registered %d port(s)\n", count);
 
 	return 0;
 }
diff -Nrup linux-6.16.7/drivers/phy/marvell/phy-pxa-usb.c linux-lenovo-x13s-linux-6.16.y/drivers/phy/marvell/phy-pxa-usb.c
--- linux-6.16.7/drivers/phy/marvell/phy-pxa-usb.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/phy/marvell/phy-pxa-usb.c	2025-09-11 09:47:42.000000000 -0600
@@ -325,7 +325,6 @@ static int pxa_usb_phy_probe(struct plat
 		phy_create_lookup(pxa_usb_phy->phy, "usb", "mv-otg");
 	}
 
-	dev_info(dev, "Marvell PXA USB PHY");
 	return 0;
 }
 
diff -Nrup linux-6.16.7/drivers/phy/phy-snps-eusb2.c linux-lenovo-x13s-linux-6.16.y/drivers/phy/phy-snps-eusb2.c
--- linux-6.16.7/drivers/phy/phy-snps-eusb2.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/phy/phy-snps-eusb2.c	2025-09-11 09:47:42.000000000 -0600
@@ -256,7 +256,7 @@ static int exynos_eusb2_ref_clk_init(str
 	}
 
 	if (!config) {
-		dev_err(&phy->phy->dev, "unsupported ref_clk_freq:%lu\n", ref_clk_freq);
+		dev_err(&phy->phy->dev, "unsupported ref_clk_freq: %lu\n", ref_clk_freq);
 		return -EINVAL;
 	}
 
@@ -293,7 +293,7 @@ static int qcom_eusb2_ref_clk_init(struc
 	}
 
 	if (!config) {
-		dev_err(&phy->phy->dev, "unsupported ref_clk_freq:%lu\n", ref_clk_freq);
+		dev_err(&phy->phy->dev, "unsupported ref_clk_freq: %lu\n", ref_clk_freq);
 		return -EINVAL;
 	}
 
@@ -464,39 +464,40 @@ static int snps_eusb2_hsphy_init(struct
 
 	ret = phy_init(phy->repeater);
 	if (ret) {
-		dev_err(&p->dev, "repeater init failed. %d\n", ret);
+		dev_err(&p->dev, "repeater init failed: %d\n", ret);
 		goto disable_vreg;
 	}
 
 	ret = clk_bulk_prepare_enable(phy->data->num_clks, phy->clks);
 	if (ret) {
-		dev_err(&p->dev, "failed to enable ref clock, %d\n", ret);
-		goto disable_vreg;
+		dev_err(&p->dev, "failed to enable ref clock: %d\n", ret);
+		goto exit_repeater;
 	}
 
 	ret = reset_control_assert(phy->phy_reset);
 	if (ret) {
-		dev_err(&p->dev, "failed to assert phy_reset, %d\n", ret);
-		goto disable_ref_clk;
+		dev_err(&p->dev, "failed to assert phy_reset: %d\n", ret);
+		goto disable_clks;
 	}
 
 	usleep_range(100, 150);
 
 	ret = reset_control_deassert(phy->phy_reset);
 	if (ret) {
-		dev_err(&p->dev, "failed to de-assert phy_reset, %d\n", ret);
-		goto disable_ref_clk;
+		dev_err(&p->dev, "failed to de-assert phy_reset: %d\n", ret);
+		goto disable_clks;
 	}
 
 	ret = phy->data->phy_init(p);
 	if (ret)
-		goto disable_ref_clk;
+		goto disable_clks;
 
 	return 0;
 
-disable_ref_clk:
+disable_clks:
 	clk_bulk_disable_unprepare(phy->data->num_clks, phy->clks);
-
+exit_repeater:
+	phy_exit(phy->repeater);
 disable_vreg:
 	regulator_bulk_disable(ARRAY_SIZE(phy->vregs), phy->vregs);
 
@@ -507,7 +508,7 @@ static int snps_eusb2_hsphy_exit(struct
 {
 	struct snps_eusb2_hsphy *phy = phy_get_drvdata(p);
 
-	clk_disable_unprepare(phy->ref_clk);
+	clk_bulk_disable_unprepare(phy->data->num_clks, phy->clks);
 
 	regulator_bulk_disable(ARRAY_SIZE(phy->vregs), phy->vregs);
 
@@ -554,7 +555,7 @@ static int snps_eusb2_hsphy_probe(struct
 	if (!phy->clks)
 		return -ENOMEM;
 
-	for (int i = 0; i < phy->data->num_clks; ++i)
+	for (i = 0; i < phy->data->num_clks; ++i)
 		phy->clks[i].id = phy->data->clk_names[i];
 
 	ret = devm_clk_bulk_get(dev, phy->data->num_clks, phy->clks);
@@ -563,7 +564,7 @@ static int snps_eusb2_hsphy_probe(struct
 				     "failed to get phy clock(s)\n");
 
 	phy->ref_clk = NULL;
-	for (int i = 0; i < phy->data->num_clks; ++i) {
+	for (i = 0; i < phy->data->num_clks; ++i) {
 		if (!strcmp(phy->clks[i].id, "ref")) {
 			phy->ref_clk = phy->clks[i].clk;
 			break;
@@ -585,14 +586,14 @@ static int snps_eusb2_hsphy_probe(struct
 		return dev_err_probe(dev, ret,
 				     "failed to get regulator supplies\n");
 
-	phy->repeater = devm_of_phy_optional_get(dev, np, 0);
+	phy->repeater = devm_of_phy_optional_get(dev, np, NULL);
 	if (IS_ERR(phy->repeater))
 		return dev_err_probe(dev, PTR_ERR(phy->repeater),
 				     "failed to get repeater\n");
 
 	generic_phy = devm_phy_create(dev, NULL, &snps_eusb2_hsphy_ops);
 	if (IS_ERR(generic_phy)) {
-		dev_err(dev, "failed to create phy %d\n", ret);
+		dev_err(dev, "failed to create phy: %d\n", ret);
 		return PTR_ERR(generic_phy);
 	}
 
@@ -603,8 +604,6 @@ static int snps_eusb2_hsphy_probe(struct
 	if (IS_ERR(phy_provider))
 		return PTR_ERR(phy_provider);
 
-	dev_info(dev, "Registered Snps-eUSB2 phy\n");
-
 	return 0;
 }
 
@@ -615,7 +614,9 @@ static const struct of_device_id snps_eu
 	}, {
 		.compatible = "samsung,exynos2200-eusb2-phy",
 		.data = &exynos2200_snps_eusb2_phy,
-	}, { },
+	}, {
+		/* sentinel */
+	}
 };
 MODULE_DEVICE_TABLE(of, snps_eusb2_hsphy_of_match_table);
 
diff -Nrup linux-6.16.7/drivers/phy/qualcomm/phy-qcom-eusb2-repeater.c linux-lenovo-x13s-linux-6.16.y/drivers/phy/qualcomm/phy-qcom-eusb2-repeater.c
--- linux-6.16.7/drivers/phy/qualcomm/phy-qcom-eusb2-repeater.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/phy/qualcomm/phy-qcom-eusb2-repeater.c	2025-09-11 09:47:42.000000000 -0600
@@ -241,8 +241,6 @@ static int eusb2_repeater_probe(struct p
 	if (IS_ERR(phy_provider))
 		return PTR_ERR(phy_provider);
 
-	dev_info(dev, "Registered Qcom-eUSB2 repeater\n");
-
 	return 0;
 }
 
diff -Nrup linux-6.16.7/drivers/phy/qualcomm/phy-qcom-m31.c linux-lenovo-x13s-linux-6.16.y/drivers/phy/qualcomm/phy-qcom-m31.c
--- linux-6.16.7/drivers/phy/qualcomm/phy-qcom-m31.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/phy/qualcomm/phy-qcom-m31.c	2025-09-11 09:47:42.000000000 -0600
@@ -311,8 +311,6 @@ static int m31usb_phy_probe(struct platf
 	phy_set_drvdata(qphy->phy, qphy);
 
 	phy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);
-	if (!IS_ERR(phy_provider))
-		dev_info(dev, "Registered M31 USB phy\n");
 
 	return PTR_ERR_OR_ZERO(phy_provider);
 }
diff -Nrup linux-6.16.7/drivers/phy/qualcomm/phy-qcom-qmp-combo.c linux-lenovo-x13s-linux-6.16.y/drivers/phy/qualcomm/phy-qcom-qmp-combo.c
--- linux-6.16.7/drivers/phy/qualcomm/phy-qcom-qmp-combo.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/phy/qualcomm/phy-qcom-qmp-combo.c	2025-09-11 09:47:42.000000000 -0600
@@ -19,6 +19,7 @@
 #include <linux/reset.h>
 #include <linux/slab.h>
 #include <linux/usb/typec.h>
+#include <linux/usb/typec_dp.h>
 #include <linux/usb/typec_mux.h>
 
 #include <drm/bridge/aux-bridge.h>
@@ -61,6 +62,12 @@
 
 #define PHY_INIT_COMPLETE_TIMEOUT		10000
 
+enum qmpphy_mode {
+	QMPPHY_MODE_USB3DP = 0,
+	QMPPHY_MODE_DP_ONLY,
+	QMPPHY_MODE_USB3_ONLY,
+};
+
 /* set of registers with offsets different per-PHY */
 enum qphy_reg_layout {
 	/* PCS registers */
@@ -1685,15 +1692,17 @@ struct qmp_combo {
 
 	struct mutex phy_mutex;
 	int init_count;
+	enum qmpphy_mode qmpphy_mode;
 
 	struct phy *usb_phy;
-	enum phy_mode mode;
+	enum phy_mode phy_mode;
 	unsigned int usb_init_count;
 
 	struct phy *dp_phy;
 	unsigned int dp_aux_cfg;
 	struct phy_configure_opts_dp dp_opts;
 	unsigned int dp_init_count;
+	bool dp_powered_on;
 
 	struct clk_fixed_rate pipe_clk_fixed;
 	struct clk_hw dp_link_hw;
@@ -1701,6 +1710,8 @@ struct qmp_combo {
 
 	struct typec_switch_dev *sw;
 	enum typec_orientation orientation;
+
+	struct typec_mux_dev *mux;
 };
 
 static void qmp_v3_dp_aux_init(struct qmp_combo *qmp);
@@ -2816,12 +2827,33 @@ static int qmp_combo_com_init(struct qmp
 	if (qmp->orientation == TYPEC_ORIENTATION_REVERSE)
 		val |= SW_PORTSELECT_VAL;
 	writel(val, com + QPHY_V3_DP_COM_TYPEC_CTRL);
-	writel(USB3_MODE | DP_MODE, com + QPHY_V3_DP_COM_PHY_MODE_CTRL);
 
-	/* bring both QMP USB and QMP DP PHYs PCS block out of reset */
-	qphy_clrbits(com, QPHY_V3_DP_COM_RESET_OVRD_CTRL,
-			SW_DPPHY_RESET_MUX | SW_DPPHY_RESET |
-			SW_USB3PHY_RESET_MUX | SW_USB3PHY_RESET);
+	switch (qmp->qmpphy_mode) {
+	case QMPPHY_MODE_USB3DP:
+		writel(USB3_MODE | DP_MODE, com + QPHY_V3_DP_COM_PHY_MODE_CTRL);
+
+		/* bring both QMP USB and QMP DP PHYs PCS block out of reset */
+		qphy_clrbits(com, QPHY_V3_DP_COM_RESET_OVRD_CTRL,
+				SW_DPPHY_RESET_MUX | SW_DPPHY_RESET |
+				SW_USB3PHY_RESET_MUX | SW_USB3PHY_RESET);
+		break;
+
+	case QMPPHY_MODE_DP_ONLY:
+		writel(DP_MODE, com + QPHY_V3_DP_COM_PHY_MODE_CTRL);
+
+		/* bring QMP DP PHY PCS block out of reset */
+		qphy_clrbits(com, QPHY_V3_DP_COM_RESET_OVRD_CTRL,
+				SW_DPPHY_RESET_MUX | SW_DPPHY_RESET);
+		break;
+
+	case QMPPHY_MODE_USB3_ONLY:
+		writel(USB3_MODE, com + QPHY_V3_DP_COM_PHY_MODE_CTRL);
+
+		/* bring QMP USB PHY PCS block out of reset */
+		qphy_clrbits(com, QPHY_V3_DP_COM_RESET_OVRD_CTRL,
+				SW_USB3PHY_RESET_MUX | SW_USB3PHY_RESET);
+		break;
+	}
 
 	qphy_clrbits(com, QPHY_V3_DP_COM_SWI_CTRL, 0x03);
 	qphy_clrbits(com, QPHY_V3_DP_COM_SW_RESET, SW_RESET);
@@ -2913,6 +2945,8 @@ static int qmp_combo_dp_power_on(struct
 	/* Configure link rate, swing, etc. */
 	cfg->configure_dp_phy(qmp);
 
+	qmp->dp_powered_on = true;
+
 	mutex_unlock(&qmp->phy_mutex);
 
 	return 0;
@@ -2927,6 +2961,8 @@ static int qmp_combo_dp_power_off(struct
 	/* Assert DP PHY power down */
 	writel(DP_PHY_PD_CTL_PSR_PWRDN, qmp->dp_dp_phy + QSERDES_DP_PHY_PD_CTL);
 
+	qmp->dp_powered_on = false;
+
 	mutex_unlock(&qmp->phy_mutex);
 
 	return 0;
@@ -3062,7 +3098,7 @@ static int qmp_combo_usb_set_mode(struct
 {
 	struct qmp_combo *qmp = phy_get_drvdata(phy);
 
-	qmp->mode = mode;
+	qmp->phy_mode = mode;
 
 	return 0;
 }
@@ -3091,8 +3127,8 @@ static void qmp_combo_enable_autonomous_
 	void __iomem *pcs_misc = qmp->pcs_misc;
 	u32 intr_mask;
 
-	if (qmp->mode == PHY_MODE_USB_HOST_SS ||
-	    qmp->mode == PHY_MODE_USB_DEVICE_SS)
+	if (qmp->phy_mode == PHY_MODE_USB_HOST_SS ||
+	    qmp->phy_mode == PHY_MODE_USB_DEVICE_SS)
 		intr_mask = ARCVR_DTCT_EN | ALFPS_DTCT_EN;
 	else
 		intr_mask = ARCVR_DTCT_EN | ARCVR_DTCT_EVENT_SEL;
@@ -3135,7 +3171,7 @@ static int __maybe_unused qmp_combo_runt
 {
 	struct qmp_combo *qmp = dev_get_drvdata(dev);
 
-	dev_vdbg(dev, "Suspending QMP phy, mode:%d\n", qmp->mode);
+	dev_vdbg(dev, "Suspending QMP phy, mode:%d\n", qmp->phy_mode);
 
 	if (!qmp->init_count) {
 		dev_vdbg(dev, "PHY not initialized, bailing out\n");
@@ -3155,7 +3191,7 @@ static int __maybe_unused qmp_combo_runt
 	struct qmp_combo *qmp = dev_get_drvdata(dev);
 	int ret = 0;
 
-	dev_vdbg(dev, "Resuming QMP phy, mode:%d\n", qmp->mode);
+	dev_vdbg(dev, "Resuming QMP phy, mode:%d\n", qmp->phy_mode);
 
 	if (!qmp->init_count) {
 		dev_vdbg(dev, "PHY not initialized, bailing out\n");
@@ -3549,17 +3585,109 @@ static int qmp_combo_typec_switch_set(st
 	return 0;
 }
 
-static void qmp_combo_typec_unregister(void *data)
+static int qmp_combo_typec_mux_set(struct typec_mux_dev *mux, struct typec_mux_state *state)
+{
+	struct qmp_combo *qmp = typec_mux_get_drvdata(mux);
+	const struct qmp_phy_cfg *cfg = qmp->cfg;
+	enum qmpphy_mode new_mode;
+	unsigned int svid;
+
+	guard(mutex)(&qmp->phy_mutex);
+
+	if (state->alt)
+		svid = state->alt->svid;
+	else
+		svid = 0;
+
+	if (svid == USB_TYPEC_DP_SID) {
+		switch (state->mode) {
+		/* DP Only */
+		case TYPEC_DP_STATE_C:
+		case TYPEC_DP_STATE_E:
+			new_mode = QMPPHY_MODE_DP_ONLY;
+			break;
+
+		/* DP + USB */
+		case TYPEC_DP_STATE_D:
+		case TYPEC_DP_STATE_F:
+
+		/* Safe fallback...*/
+		default:
+			new_mode = QMPPHY_MODE_USB3DP;
+			break;
+		}
+	} else {
+		/* No DP SVID => don't care, assume it's just USB3 */
+		new_mode = QMPPHY_MODE_USB3_ONLY;
+	}
+
+	if (new_mode == qmp->qmpphy_mode) {
+		dev_dbg(qmp->dev, "typec_mux_set: same qmpphy mode, bail out\n");
+		return 0;
+	}
+
+	if (qmp->qmpphy_mode != QMPPHY_MODE_USB3_ONLY && qmp->dp_powered_on) {
+		dev_dbg(qmp->dev, "typec_mux_set: DP PHY is still in use, delaying switch\n");
+		return 0;
+	}
+
+	dev_dbg(qmp->dev, "typec_mux_set: switching from qmpphy mode %d to %d\n",
+		qmp->qmpphy_mode, new_mode);
+
+	qmp->qmpphy_mode = new_mode;
+
+	if (qmp->init_count) {
+		if (qmp->usb_init_count)
+			qmp_combo_usb_power_off(qmp->usb_phy);
+
+		if (qmp->dp_init_count)
+			writel(DP_PHY_PD_CTL_PSR_PWRDN, qmp->dp_dp_phy + QSERDES_DP_PHY_PD_CTL);
+
+		qmp_combo_com_exit(qmp, true);
+
+		/* Now everything's powered down, power up the right PHYs */
+		qmp_combo_com_init(qmp, true);
+
+		if (new_mode == QMPPHY_MODE_DP_ONLY) {
+			if (qmp->usb_init_count)
+				qmp->usb_init_count--;
+		}
+
+		if (new_mode == QMPPHY_MODE_USB3DP || new_mode == QMPPHY_MODE_USB3_ONLY) {
+			qmp_combo_usb_power_on(qmp->usb_phy);
+			if (!qmp->usb_init_count)
+				qmp->usb_init_count++;
+		}
+
+		if (new_mode == QMPPHY_MODE_DP_ONLY || new_mode == QMPPHY_MODE_USB3DP) {
+			if (qmp->dp_init_count)
+				cfg->dp_aux_init(qmp);
+		}
+	}
+
+	return 0;
+}
+
+static void qmp_combo_typec_switch_unregister(void *data)
 {
 	struct qmp_combo *qmp = data;
 
 	typec_switch_unregister(qmp->sw);
 }
 
-static int qmp_combo_typec_switch_register(struct qmp_combo *qmp)
+static void qmp_combo_typec_mux_unregister(void *data)
+{
+	struct qmp_combo *qmp = data;
+
+	typec_mux_unregister(qmp->mux);
+}
+
+static int qmp_combo_typec_register(struct qmp_combo *qmp)
 {
 	struct typec_switch_desc sw_desc = {};
+	struct typec_mux_desc mux_desc = { };
 	struct device *dev = qmp->dev;
+	int ret;
 
 	sw_desc.drvdata = qmp;
 	sw_desc.fwnode = dev->fwnode;
@@ -3570,10 +3698,23 @@ static int qmp_combo_typec_switch_regist
 		return PTR_ERR(qmp->sw);
 	}
 
-	return devm_add_action_or_reset(dev, qmp_combo_typec_unregister, qmp);
+	ret = devm_add_action_or_reset(dev, qmp_combo_typec_switch_unregister, qmp);
+	if (ret)
+		return ret;
+
+	mux_desc.drvdata = qmp;
+	mux_desc.fwnode = dev->fwnode;
+	mux_desc.set = qmp_combo_typec_mux_set;
+	qmp->mux = typec_mux_register(dev, &mux_desc);
+	if (IS_ERR(qmp->mux)) {
+		dev_err(dev, "Unable to register typec mux: %pe\n", qmp->mux);
+		return PTR_ERR(qmp->mux);
+	}
+
+	return devm_add_action_or_reset(dev, qmp_combo_typec_mux_unregister, qmp);
 }
 #else
-static int qmp_combo_typec_switch_register(struct qmp_combo *qmp)
+static int qmp_combo_typec_register(struct qmp_combo *qmp)
 {
 	return 0;
 }
@@ -3806,7 +3947,7 @@ static int qmp_combo_probe(struct platfo
 	if (ret)
 		goto err_node_put;
 
-	ret = qmp_combo_typec_switch_register(qmp);
+	ret = qmp_combo_typec_register(qmp);
 	if (ret)
 		goto err_node_put;
 
@@ -3828,6 +3969,12 @@ static int qmp_combo_probe(struct platfo
 	if (ret)
 		goto err_node_put;
 
+	/*
+	 * The hw default is USB3_ONLY, but USB3+DP mode lets us more easily
+	 * check both sub-blocks' init tables for blunders at probe time.
+	 */
+	qmp->qmpphy_mode = QMPPHY_MODE_USB3DP;
+
 	qmp->usb_phy = devm_phy_create(dev, usb_np, &qmp_combo_usb_phy_ops);
 	if (IS_ERR(qmp->usb_phy)) {
 		ret = PTR_ERR(qmp->usb_phy);
diff -Nrup linux-6.16.7/drivers/phy/qualcomm/phy-qcom-qusb2.c linux-lenovo-x13s-linux-6.16.y/drivers/phy/qualcomm/phy-qcom-qusb2.c
--- linux-6.16.7/drivers/phy/qualcomm/phy-qcom-qusb2.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/phy/qualcomm/phy-qcom-qusb2.c	2025-09-11 09:47:42.000000000 -0600
@@ -1114,9 +1114,7 @@ static int qusb2_phy_probe(struct platfo
 	phy_set_drvdata(generic_phy, qphy);
 
 	phy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);
-	if (!IS_ERR(phy_provider))
-		dev_info(dev, "Registered Qcom-QUSB2 phy\n");
-	else
+	if (IS_ERR(phy_provider))
 		pm_runtime_disable(dev);
 
 	return PTR_ERR_OR_ZERO(phy_provider);
diff -Nrup linux-6.16.7/drivers/phy/st/phy-stih407-usb.c linux-lenovo-x13s-linux-6.16.y/drivers/phy/st/phy-stih407-usb.c
--- linux-6.16.7/drivers/phy/st/phy-stih407-usb.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/phy/st/phy-stih407-usb.c	2025-09-11 09:47:42.000000000 -0600
@@ -139,8 +139,6 @@ static int stih407_usb2_picophy_probe(st
 	if (IS_ERR(phy_provider))
 		return PTR_ERR(phy_provider);
 
-	dev_info(dev, "STiH407 USB Generic picoPHY driver probed!");
-
 	return 0;
 }
 
diff -Nrup linux-6.16.7/drivers/phy/st/phy-stm32-usbphyc.c linux-lenovo-x13s-linux-6.16.y/drivers/phy/st/phy-stm32-usbphyc.c
--- linux-6.16.7/drivers/phy/st/phy-stm32-usbphyc.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/phy/st/phy-stm32-usbphyc.c	2025-09-11 09:47:42.000000000 -0600
@@ -757,8 +757,8 @@ static int stm32_usbphyc_probe(struct pl
 	}
 
 	version = readl_relaxed(usbphyc->base + STM32_USBPHYC_VERSION);
-	dev_info(dev, "registered rev:%lu.%lu\n",
-		 FIELD_GET(MAJREV, version), FIELD_GET(MINREV, version));
+	dev_dbg(dev, "registered rev: %lu.%lu\n",
+		FIELD_GET(MAJREV, version), FIELD_GET(MINREV, version));
 
 	return 0;
 
diff -Nrup linux-6.16.7/drivers/phy/ti/phy-twl4030-usb.c linux-lenovo-x13s-linux-6.16.y/drivers/phy/ti/phy-twl4030-usb.c
--- linux-6.16.7/drivers/phy/ti/phy-twl4030-usb.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/phy/ti/phy-twl4030-usb.c	2025-09-11 09:47:42.000000000 -0600
@@ -784,7 +784,6 @@ static int twl4030_usb_probe(struct plat
 	pm_runtime_mark_last_busy(&pdev->dev);
 	pm_runtime_put_autosuspend(twl->dev);
 
-	dev_info(&pdev->dev, "Initialized TWL4030 USB module\n");
 	return 0;
 }
 
diff -Nrup linux-6.16.7/drivers/platform/x86/asus-wmi.c.rej linux-lenovo-x13s-linux-6.16.y/drivers/platform/x86/asus-wmi.c.rej
--- linux-6.16.7/drivers/platform/x86/asus-wmi.c.rej	2025-09-13 16:15:46.038293399 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/platform/x86/asus-wmi.c.rej	1969-12-31 17:00:00.000000000 -0700
@@ -1,34 +0,0 @@
---- drivers/platform/x86/asus-wmi.c
-+++ drivers/platform/x86/asus-wmi.c
-@@ -5088,16 +5088,22 @@ static int asus_wmi_probe(struct platform_device *pdev)
- 
- 	asus_s2idle_check_register();
- 
--	return asus_wmi_add(pdev);
-+	ret = asus_wmi_add(pdev);
-+	if (ret)
-+		asus_s2idle_check_unregister();
-+
-+	return ret;
- }
- 
- static bool used;
-+static DEFINE_MUTEX(register_mutex);
- 
- int __init_or_module asus_wmi_register_driver(struct asus_wmi_driver *driver)
- {
- 	struct platform_driver *platform_driver;
- 	struct platform_device *platform_device;
- 
-+	guard(mutex)(&register_mutex);
- 	if (used)
- 		return -EBUSY;
- 
-@@ -5120,6 +5126,7 @@ EXPORT_SYMBOL_GPL(asus_wmi_register_driver);
- 
- void asus_wmi_unregister_driver(struct asus_wmi_driver *driver)
- {
-+	guard(mutex)(&register_mutex);
- 	asus_s2idle_check_unregister();
- 
- 	platform_device_unregister(driver->platform_device);
diff -Nrup linux-6.16.7/drivers/platform/x86/intel/int3472/led.c linux-lenovo-x13s-linux-6.16.y/drivers/platform/x86/intel/int3472/led.c
--- linux-6.16.7/drivers/platform/x86/intel/int3472/led.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/platform/x86/intel/int3472/led.c	2025-09-11 09:47:42.000000000 -0600
@@ -43,7 +43,7 @@ int skl_int3472_register_pled(struct int
 
 	int3472->pled.lookup.provider = int3472->pled.name;
 	int3472->pled.lookup.dev_id = int3472->sensor_name;
-	int3472->pled.lookup.con_id = "privacy-led";
+	int3472->pled.lookup.con_id = "privacy";
 	led_add_lookup(&int3472->pled.lookup);
 
 	return 0;
diff -Nrup linux-6.16.7/drivers/power/supply/qcom_battmgr.c linux-lenovo-x13s-linux-6.16.y/drivers/power/supply/qcom_battmgr.c
--- linux-6.16.7/drivers/power/supply/qcom_battmgr.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/power/supply/qcom_battmgr.c	2025-09-11 09:47:42.000000000 -0600
@@ -577,6 +577,8 @@ static int qcom_battmgr_bat_get_property
 		val->intval = battmgr->status.capacity;
 		break;
 	case POWER_SUPPLY_PROP_CAPACITY:
+		if (battmgr->status.percent == (unsigned int)-1)
+			return -ENODATA;
 		val->intval = battmgr->status.percent;
 		break;
 	case POWER_SUPPLY_PROP_TEMP:
@@ -617,6 +619,7 @@ static const enum power_supply_property
 	POWER_SUPPLY_PROP_STATUS,
 	POWER_SUPPLY_PROP_PRESENT,
 	POWER_SUPPLY_PROP_TECHNOLOGY,
+	POWER_SUPPLY_PROP_CAPACITY,
 	POWER_SUPPLY_PROP_CYCLE_COUNT,
 	POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN,
 	POWER_SUPPLY_PROP_VOLTAGE_NOW,
@@ -1065,6 +1068,21 @@ static void qcom_battmgr_sc8280xp_callba
 		battmgr->ac.online = source == BATTMGR_CHARGING_SOURCE_AC;
 		battmgr->usb.online = source == BATTMGR_CHARGING_SOURCE_USB;
 		battmgr->wireless.online = source == BATTMGR_CHARGING_SOURCE_WIRELESS;
+		if (battmgr->info.last_full_capacity != 0) {
+			/*
+			 * 100 * battmgr->status.capacity can overflow a 32bit
+			 * unsigned integer. Do a temporary cast to avoid that.
+			 */
+			battmgr->status.percent =
+				(uint64_t)100 * battmgr->status.capacity /
+				battmgr->info.last_full_capacity;
+		} else {
+			/*
+			 * Let the sysfs handler know no data is available at
+			 * this time.
+			 */
+			battmgr->status.percent = (unsigned int)-1;
+		}
 		break;
 	case BATTMGR_BAT_DISCHARGE_TIME:
 		battmgr->status.discharge_time = le32_to_cpu(resp->time);
diff -Nrup linux-6.16.7/drivers/soc/qcom/icc-bwmon.c linux-lenovo-x13s-linux-6.16.y/drivers/soc/qcom/icc-bwmon.c
--- linux-6.16.7/drivers/soc/qcom/icc-bwmon.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/soc/qcom/icc-bwmon.c	2025-09-11 09:47:42.000000000 -0600
@@ -827,7 +827,7 @@ static const struct icc_bwmon_data msm89
 static const struct icc_bwmon_data sdm845_cpu_bwmon_data = {
 	.sample_ms = 4,
 	.count_unit_kb = 64,
-	.zone1_thres_count = 16,
+	.zone1_thres_count = 3,
 	.zone3_thres_count = 1,
 	.quirks = BWMON_HAS_GLOBAL_IRQ,
 	.regmap_fields = sdm845_cpu_bwmon_reg_fields,
@@ -846,7 +846,7 @@ static const struct icc_bwmon_data sdm84
 static const struct icc_bwmon_data sc7280_llcc_bwmon_data = {
 	.sample_ms = 4,
 	.count_unit_kb = 64,
-	.zone1_thres_count = 16,
+	.zone1_thres_count = 3,
 	.zone3_thres_count = 1,
 	.quirks = BWMON_NEEDS_FORCE_CLEAR,
 	.regmap_fields = sdm845_llcc_bwmon_reg_fields,
diff -Nrup linux-6.16.7/drivers/soundwire/bus.c linux-lenovo-x13s-linux-6.16.y/drivers/soundwire/bus.c
--- linux-6.16.7/drivers/soundwire/bus.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/soundwire/bus.c	2025-09-11 09:47:42.000000000 -0600
@@ -1360,6 +1360,18 @@ int sdw_slave_get_scale_index(struct sdw
 }
 EXPORT_SYMBOL(sdw_slave_get_scale_index);
 
+int sdw_slave_get_current_bank(struct sdw_slave *slave)
+{
+	int tmp;
+
+	tmp = sdw_read(slave, SDW_SCP_CTRL);
+	if (tmp < 0)
+		return tmp;
+
+	return FIELD_GET(SDW_SCP_STAT_CURR_BANK, tmp);
+}
+EXPORT_SYMBOL_GPL(sdw_slave_get_current_bank);
+
 static int sdw_slave_set_frequency(struct sdw_slave *slave)
 {
 	int scale_index;
diff -Nrup linux-6.16.7/drivers/soundwire/qcom.c linux-lenovo-x13s-linux-6.16.y/drivers/soundwire/qcom.c
--- linux-6.16.7/drivers/soundwire/qcom.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/soundwire/qcom.c	2025-09-11 09:47:42.000000000 -0600
@@ -1622,9 +1622,9 @@ static int qcom_swrm_probe(struct platfo
 	if (ret)
 		goto err_master_add;
 
-	dev_info(dev, "Qualcomm Soundwire controller v%x.%x.%x Registered\n",
-		 (ctrl->version >> 24) & 0xff, (ctrl->version >> 16) & 0xff,
-		 ctrl->version & 0xffff);
+	dev_dbg(dev, "Qualcomm Soundwire controller v%x.%x.%x registered\n",
+		(ctrl->version >> 24) & 0xff, (ctrl->version >> 16) & 0xff,
+		ctrl->version & 0xffff);
 
 	pm_runtime_set_autosuspend_delay(dev, 3000);
 	pm_runtime_use_autosuspend(dev);
diff -Nrup linux-6.16.7/drivers/soundwire/slave.c linux-lenovo-x13s-linux-6.16.y/drivers/soundwire/slave.c
--- linux-6.16.7/drivers/soundwire/slave.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/soundwire/slave.c	2025-09-11 09:47:42.000000000 -0600
@@ -273,4 +273,10 @@ int sdw_of_find_slaves(struct sdw_bus *b
 	return 0;
 }
 
+struct device *of_sdw_find_device_by_node(struct device_node *np)
+{
+	return bus_find_device_by_of_node(&sdw_bus_type, np);
+}
+EXPORT_SYMBOL_GPL(of_sdw_find_device_by_node);
+
 MODULE_IMPORT_NS("SND_SOC_SDCA");
diff -Nrup linux-6.16.7/fs/namei.c linux-lenovo-x13s-linux-6.16.y/fs/namei.c
--- linux-6.16.7/fs/namei.c	2025-09-13 16:15:37.954860024 -0600
+++ linux-lenovo-x13s-linux-6.16.y/fs/namei.c	2025-09-11 09:47:42.000000000 -0600
@@ -1095,10 +1095,10 @@ static inline void put_link(struct namei
 		path_put(&last->link);
 }
 
-static int sysctl_protected_symlinks __read_mostly = 1;
-static int sysctl_protected_hardlinks __read_mostly = 1;
-int sysctl_protected_fifos __read_mostly = 1;
-int sysctl_protected_regular __read_mostly = 1;
+static int sysctl_protected_symlinks __read_mostly;
+static int sysctl_protected_hardlinks __read_mostly;
+static int sysctl_protected_fifos __read_mostly;
+static int sysctl_protected_regular __read_mostly;
 
 #ifdef CONFIG_SYSCTL
 static const struct ctl_table namei_sysctls[] = {
diff -Nrup linux-6.16.7/fs/namei.c.orig linux-lenovo-x13s-linux-6.16.y/fs/namei.c.orig
--- linux-6.16.7/fs/namei.c.orig	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/fs/namei.c.orig	1969-12-31 17:00:00.000000000 -0700
@@ -1,5545 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- *  linux/fs/namei.c
- *
- *  Copyright (C) 1991, 1992  Linus Torvalds
- */
-
-/*
- * Some corrections by tytso.
- */
-
-/* [Feb 1997 T. Schoebel-Theuer] Complete rewrite of the pathname
- * lookup logic.
- */
-/* [Feb-Apr 2000, AV] Rewrite to the new namespace architecture.
- */
-
-#include <linux/init.h>
-#include <linux/export.h>
-#include <linux/slab.h>
-#include <linux/wordpart.h>
-#include <linux/fs.h>
-#include <linux/filelock.h>
-#include <linux/namei.h>
-#include <linux/pagemap.h>
-#include <linux/sched/mm.h>
-#include <linux/fsnotify.h>
-#include <linux/personality.h>
-#include <linux/security.h>
-#include <linux/syscalls.h>
-#include <linux/mount.h>
-#include <linux/audit.h>
-#include <linux/capability.h>
-#include <linux/file.h>
-#include <linux/fcntl.h>
-#include <linux/device_cgroup.h>
-#include <linux/fs_struct.h>
-#include <linux/posix_acl.h>
-#include <linux/hash.h>
-#include <linux/bitops.h>
-#include <linux/init_task.h>
-#include <linux/uaccess.h>
-
-#include "internal.h"
-#include "mount.h"
-
-/* [Feb-1997 T. Schoebel-Theuer]
- * Fundamental changes in the pathname lookup mechanisms (namei)
- * were necessary because of omirr.  The reason is that omirr needs
- * to know the _real_ pathname, not the user-supplied one, in case
- * of symlinks (and also when transname replacements occur).
- *
- * The new code replaces the old recursive symlink resolution with
- * an iterative one (in case of non-nested symlink chains).  It does
- * this with calls to <fs>_follow_link().
- * As a side effect, dir_namei(), _namei() and follow_link() are now 
- * replaced with a single function lookup_dentry() that can handle all 
- * the special cases of the former code.
- *
- * With the new dcache, the pathname is stored at each inode, at least as
- * long as the refcount of the inode is positive.  As a side effect, the
- * size of the dcache depends on the inode cache and thus is dynamic.
- *
- * [29-Apr-1998 C. Scott Ananian] Updated above description of symlink
- * resolution to correspond with current state of the code.
- *
- * Note that the symlink resolution is not *completely* iterative.
- * There is still a significant amount of tail- and mid- recursion in
- * the algorithm.  Also, note that <fs>_readlink() is not used in
- * lookup_dentry(): lookup_dentry() on the result of <fs>_readlink()
- * may return different results than <fs>_follow_link().  Many virtual
- * filesystems (including /proc) exhibit this behavior.
- */
-
-/* [24-Feb-97 T. Schoebel-Theuer] Side effects caused by new implementation:
- * New symlink semantics: when open() is called with flags O_CREAT | O_EXCL
- * and the name already exists in form of a symlink, try to create the new
- * name indicated by the symlink. The old code always complained that the
- * name already exists, due to not following the symlink even if its target
- * is nonexistent.  The new semantics affects also mknod() and link() when
- * the name is a symlink pointing to a non-existent name.
- *
- * I don't know which semantics is the right one, since I have no access
- * to standards. But I found by trial that HP-UX 9.0 has the full "new"
- * semantics implemented, while SunOS 4.1.1 and Solaris (SunOS 5.4) have the
- * "old" one. Personally, I think the new semantics is much more logical.
- * Note that "ln old new" where "new" is a symlink pointing to a non-existing
- * file does succeed in both HP-UX and SunOs, but not in Solaris
- * and in the old Linux semantics.
- */
-
-/* [16-Dec-97 Kevin Buhr] For security reasons, we change some symlink
- * semantics.  See the comments in "open_namei" and "do_link" below.
- *
- * [10-Sep-98 Alan Modra] Another symlink change.
- */
-
-/* [Feb-Apr 2000 AV] Complete rewrite. Rules for symlinks:
- *	inside the path - always follow.
- *	in the last component in creation/removal/renaming - never follow.
- *	if LOOKUP_FOLLOW passed - follow.
- *	if the pathname has trailing slashes - follow.
- *	otherwise - don't follow.
- * (applied in that order).
- *
- * [Jun 2000 AV] Inconsistent behaviour of open() in case if flags==O_CREAT
- * restored for 2.4. This is the last surviving part of old 4.2BSD bug.
- * During the 2.4 we need to fix the userland stuff depending on it -
- * hopefully we will be able to get rid of that wart in 2.5. So far only
- * XEmacs seems to be relying on it...
- */
-/*
- * [Sep 2001 AV] Single-semaphore locking scheme (kudos to David Holland)
- * implemented.  Let's see if raised priority of ->s_vfs_rename_mutex gives
- * any extra contention...
- */
-
-/* In order to reduce some races, while at the same time doing additional
- * checking and hopefully speeding things up, we copy filenames to the
- * kernel data space before using them..
- *
- * POSIX.1 2.4: an empty pathname is invalid (ENOENT).
- * PATH_MAX includes the nul terminator --RR.
- */
-
-#define EMBEDDED_NAME_MAX	(PATH_MAX - offsetof(struct filename, iname))
-
-static inline void initname(struct filename *name, const char __user *uptr)
-{
-	name->uptr = uptr;
-	name->aname = NULL;
-	atomic_set(&name->refcnt, 1);
-}
-
-struct filename *
-getname_flags(const char __user *filename, int flags)
-{
-	struct filename *result;
-	char *kname;
-	int len;
-
-	result = audit_reusename(filename);
-	if (result)
-		return result;
-
-	result = __getname();
-	if (unlikely(!result))
-		return ERR_PTR(-ENOMEM);
-
-	/*
-	 * First, try to embed the struct filename inside the names_cache
-	 * allocation
-	 */
-	kname = (char *)result->iname;
-	result->name = kname;
-
-	len = strncpy_from_user(kname, filename, EMBEDDED_NAME_MAX);
-	/*
-	 * Handle both empty path and copy failure in one go.
-	 */
-	if (unlikely(len <= 0)) {
-		if (unlikely(len < 0)) {
-			__putname(result);
-			return ERR_PTR(len);
-		}
-
-		/* The empty path is special. */
-		if (!(flags & LOOKUP_EMPTY)) {
-			__putname(result);
-			return ERR_PTR(-ENOENT);
-		}
-	}
-
-	/*
-	 * Uh-oh. We have a name that's approaching PATH_MAX. Allocate a
-	 * separate struct filename so we can dedicate the entire
-	 * names_cache allocation for the pathname, and re-do the copy from
-	 * userland.
-	 */
-	if (unlikely(len == EMBEDDED_NAME_MAX)) {
-		const size_t size = offsetof(struct filename, iname[1]);
-		kname = (char *)result;
-
-		/*
-		 * size is chosen that way we to guarantee that
-		 * result->iname[0] is within the same object and that
-		 * kname can't be equal to result->iname, no matter what.
-		 */
-		result = kzalloc(size, GFP_KERNEL);
-		if (unlikely(!result)) {
-			__putname(kname);
-			return ERR_PTR(-ENOMEM);
-		}
-		result->name = kname;
-		len = strncpy_from_user(kname, filename, PATH_MAX);
-		if (unlikely(len < 0)) {
-			__putname(kname);
-			kfree(result);
-			return ERR_PTR(len);
-		}
-		/* The empty path is special. */
-		if (unlikely(!len) && !(flags & LOOKUP_EMPTY)) {
-			__putname(kname);
-			kfree(result);
-			return ERR_PTR(-ENOENT);
-		}
-		if (unlikely(len == PATH_MAX)) {
-			__putname(kname);
-			kfree(result);
-			return ERR_PTR(-ENAMETOOLONG);
-		}
-	}
-	initname(result, filename);
-	audit_getname(result);
-	return result;
-}
-
-struct filename *getname_uflags(const char __user *filename, int uflags)
-{
-	int flags = (uflags & AT_EMPTY_PATH) ? LOOKUP_EMPTY : 0;
-
-	return getname_flags(filename, flags);
-}
-
-struct filename *__getname_maybe_null(const char __user *pathname)
-{
-	struct filename *name;
-	char c;
-
-	/* try to save on allocations; loss on um, though */
-	if (get_user(c, pathname))
-		return ERR_PTR(-EFAULT);
-	if (!c)
-		return NULL;
-
-	name = getname_flags(pathname, LOOKUP_EMPTY);
-	if (!IS_ERR(name) && !(name->name[0])) {
-		putname(name);
-		name = NULL;
-	}
-	return name;
-}
-
-struct filename *getname_kernel(const char * filename)
-{
-	struct filename *result;
-	int len = strlen(filename) + 1;
-
-	result = __getname();
-	if (unlikely(!result))
-		return ERR_PTR(-ENOMEM);
-
-	if (len <= EMBEDDED_NAME_MAX) {
-		result->name = (char *)result->iname;
-	} else if (len <= PATH_MAX) {
-		const size_t size = offsetof(struct filename, iname[1]);
-		struct filename *tmp;
-
-		tmp = kmalloc(size, GFP_KERNEL);
-		if (unlikely(!tmp)) {
-			__putname(result);
-			return ERR_PTR(-ENOMEM);
-		}
-		tmp->name = (char *)result;
-		result = tmp;
-	} else {
-		__putname(result);
-		return ERR_PTR(-ENAMETOOLONG);
-	}
-	memcpy((char *)result->name, filename, len);
-	initname(result, NULL);
-	audit_getname(result);
-	return result;
-}
-EXPORT_SYMBOL(getname_kernel);
-
-void putname(struct filename *name)
-{
-	int refcnt;
-
-	if (IS_ERR_OR_NULL(name))
-		return;
-
-	refcnt = atomic_read(&name->refcnt);
-	if (refcnt != 1) {
-		if (WARN_ON_ONCE(!refcnt))
-			return;
-
-		if (!atomic_dec_and_test(&name->refcnt))
-			return;
-	}
-
-	if (name->name != name->iname) {
-		__putname(name->name);
-		kfree(name);
-	} else
-		__putname(name);
-}
-EXPORT_SYMBOL(putname);
-
-/**
- * check_acl - perform ACL permission checking
- * @idmap:	idmap of the mount the inode was found from
- * @inode:	inode to check permissions on
- * @mask:	right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC ...)
- *
- * This function performs the ACL permission checking. Since this function
- * retrieve POSIX acls it needs to know whether it is called from a blocking or
- * non-blocking context and thus cares about the MAY_NOT_BLOCK bit.
- *
- * If the inode has been found through an idmapped mount the idmap of
- * the vfsmount must be passed through @idmap. This function will then take
- * care to map the inode according to @idmap before checking permissions.
- * On non-idmapped mounts or if permission checking is to be performed on the
- * raw inode simply pass @nop_mnt_idmap.
- */
-static int check_acl(struct mnt_idmap *idmap,
-		     struct inode *inode, int mask)
-{
-#ifdef CONFIG_FS_POSIX_ACL
-	struct posix_acl *acl;
-
-	if (mask & MAY_NOT_BLOCK) {
-		acl = get_cached_acl_rcu(inode, ACL_TYPE_ACCESS);
-	        if (!acl)
-	                return -EAGAIN;
-		/* no ->get_inode_acl() calls in RCU mode... */
-		if (is_uncached_acl(acl))
-			return -ECHILD;
-	        return posix_acl_permission(idmap, inode, acl, mask);
-	}
-
-	acl = get_inode_acl(inode, ACL_TYPE_ACCESS);
-	if (IS_ERR(acl))
-		return PTR_ERR(acl);
-	if (acl) {
-	        int error = posix_acl_permission(idmap, inode, acl, mask);
-	        posix_acl_release(acl);
-	        return error;
-	}
-#endif
-
-	return -EAGAIN;
-}
-
-/*
- * Very quick optimistic "we know we have no ACL's" check.
- *
- * Note that this is purely for ACL_TYPE_ACCESS, and purely
- * for the "we have cached that there are no ACLs" case.
- *
- * If this returns true, we know there are no ACLs. But if
- * it returns false, we might still not have ACLs (it could
- * be the is_uncached_acl() case).
- */
-static inline bool no_acl_inode(struct inode *inode)
-{
-#ifdef CONFIG_FS_POSIX_ACL
-	return likely(!READ_ONCE(inode->i_acl));
-#else
-	return true;
-#endif
-}
-
-/**
- * acl_permission_check - perform basic UNIX permission checking
- * @idmap:	idmap of the mount the inode was found from
- * @inode:	inode to check permissions on
- * @mask:	right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC ...)
- *
- * This function performs the basic UNIX permission checking. Since this
- * function may retrieve POSIX acls it needs to know whether it is called from a
- * blocking or non-blocking context and thus cares about the MAY_NOT_BLOCK bit.
- *
- * If the inode has been found through an idmapped mount the idmap of
- * the vfsmount must be passed through @idmap. This function will then take
- * care to map the inode according to @idmap before checking permissions.
- * On non-idmapped mounts or if permission checking is to be performed on the
- * raw inode simply pass @nop_mnt_idmap.
- */
-static int acl_permission_check(struct mnt_idmap *idmap,
-				struct inode *inode, int mask)
-{
-	unsigned int mode = inode->i_mode;
-	vfsuid_t vfsuid;
-
-	/*
-	 * Common cheap case: everybody has the requested
-	 * rights, and there are no ACLs to check. No need
-	 * to do any owner/group checks in that case.
-	 *
-	 *  - 'mask&7' is the requested permission bit set
-	 *  - multiplying by 0111 spreads them out to all of ugo
-	 *  - '& ~mode' looks for missing inode permission bits
-	 *  - the '!' is for "no missing permissions"
-	 *
-	 * After that, we just need to check that there are no
-	 * ACL's on the inode - do the 'IS_POSIXACL()' check last
-	 * because it will dereference the ->i_sb pointer and we
-	 * want to avoid that if at all possible.
-	 */
-	if (!((mask & 7) * 0111 & ~mode)) {
-		if (no_acl_inode(inode))
-			return 0;
-		if (!IS_POSIXACL(inode))
-			return 0;
-	}
-
-	/* Are we the owner? If so, ACL's don't matter */
-	vfsuid = i_uid_into_vfsuid(idmap, inode);
-	if (likely(vfsuid_eq_kuid(vfsuid, current_fsuid()))) {
-		mask &= 7;
-		mode >>= 6;
-		return (mask & ~mode) ? -EACCES : 0;
-	}
-
-	/* Do we have ACL's? */
-	if (IS_POSIXACL(inode) && (mode & S_IRWXG)) {
-		int error = check_acl(idmap, inode, mask);
-		if (error != -EAGAIN)
-			return error;
-	}
-
-	/* Only RWX matters for group/other mode bits */
-	mask &= 7;
-
-	/*
-	 * Are the group permissions different from
-	 * the other permissions in the bits we care
-	 * about? Need to check group ownership if so.
-	 */
-	if (mask & (mode ^ (mode >> 3))) {
-		vfsgid_t vfsgid = i_gid_into_vfsgid(idmap, inode);
-		if (vfsgid_in_group_p(vfsgid))
-			mode >>= 3;
-	}
-
-	/* Bits in 'mode' clear that we require? */
-	return (mask & ~mode) ? -EACCES : 0;
-}
-
-/**
- * generic_permission -  check for access rights on a Posix-like filesystem
- * @idmap:	idmap of the mount the inode was found from
- * @inode:	inode to check access rights for
- * @mask:	right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC,
- *		%MAY_NOT_BLOCK ...)
- *
- * Used to check for read/write/execute permissions on a file.
- * We use "fsuid" for this, letting us set arbitrary permissions
- * for filesystem access without changing the "normal" uids which
- * are used for other things.
- *
- * generic_permission is rcu-walk aware. It returns -ECHILD in case an rcu-walk
- * request cannot be satisfied (eg. requires blocking or too much complexity).
- * It would then be called again in ref-walk mode.
- *
- * If the inode has been found through an idmapped mount the idmap of
- * the vfsmount must be passed through @idmap. This function will then take
- * care to map the inode according to @idmap before checking permissions.
- * On non-idmapped mounts or if permission checking is to be performed on the
- * raw inode simply pass @nop_mnt_idmap.
- */
-int generic_permission(struct mnt_idmap *idmap, struct inode *inode,
-		       int mask)
-{
-	int ret;
-
-	/*
-	 * Do the basic permission checks.
-	 */
-	ret = acl_permission_check(idmap, inode, mask);
-	if (ret != -EACCES)
-		return ret;
-
-	if (S_ISDIR(inode->i_mode)) {
-		/* DACs are overridable for directories */
-		if (!(mask & MAY_WRITE))
-			if (capable_wrt_inode_uidgid(idmap, inode,
-						     CAP_DAC_READ_SEARCH))
-				return 0;
-		if (capable_wrt_inode_uidgid(idmap, inode,
-					     CAP_DAC_OVERRIDE))
-			return 0;
-		return -EACCES;
-	}
-
-	/*
-	 * Searching includes executable on directories, else just read.
-	 */
-	mask &= MAY_READ | MAY_WRITE | MAY_EXEC;
-	if (mask == MAY_READ)
-		if (capable_wrt_inode_uidgid(idmap, inode,
-					     CAP_DAC_READ_SEARCH))
-			return 0;
-	/*
-	 * Read/write DACs are always overridable.
-	 * Executable DACs are overridable when there is
-	 * at least one exec bit set.
-	 */
-	if (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))
-		if (capable_wrt_inode_uidgid(idmap, inode,
-					     CAP_DAC_OVERRIDE))
-			return 0;
-
-	return -EACCES;
-}
-EXPORT_SYMBOL(generic_permission);
-
-/**
- * do_inode_permission - UNIX permission checking
- * @idmap:	idmap of the mount the inode was found from
- * @inode:	inode to check permissions on
- * @mask:	right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC ...)
- *
- * We _really_ want to just do "generic_permission()" without
- * even looking at the inode->i_op values. So we keep a cache
- * flag in inode->i_opflags, that says "this has not special
- * permission function, use the fast case".
- */
-static inline int do_inode_permission(struct mnt_idmap *idmap,
-				      struct inode *inode, int mask)
-{
-	if (unlikely(!(inode->i_opflags & IOP_FASTPERM))) {
-		if (likely(inode->i_op->permission))
-			return inode->i_op->permission(idmap, inode, mask);
-
-		/* This gets set once for the inode lifetime */
-		spin_lock(&inode->i_lock);
-		inode->i_opflags |= IOP_FASTPERM;
-		spin_unlock(&inode->i_lock);
-	}
-	return generic_permission(idmap, inode, mask);
-}
-
-/**
- * sb_permission - Check superblock-level permissions
- * @sb: Superblock of inode to check permission on
- * @inode: Inode to check permission on
- * @mask: Right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC)
- *
- * Separate out file-system wide checks from inode-specific permission checks.
- */
-static int sb_permission(struct super_block *sb, struct inode *inode, int mask)
-{
-	if (unlikely(mask & MAY_WRITE)) {
-		umode_t mode = inode->i_mode;
-
-		/* Nobody gets write access to a read-only fs. */
-		if (sb_rdonly(sb) && (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)))
-			return -EROFS;
-	}
-	return 0;
-}
-
-/**
- * inode_permission - Check for access rights to a given inode
- * @idmap:	idmap of the mount the inode was found from
- * @inode:	Inode to check permission on
- * @mask:	Right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC)
- *
- * Check for read/write/execute permissions on an inode.  We use fs[ug]id for
- * this, letting us set arbitrary permissions for filesystem access without
- * changing the "normal" UIDs which are used for other things.
- *
- * When checking for MAY_APPEND, MAY_WRITE must also be set in @mask.
- */
-int inode_permission(struct mnt_idmap *idmap,
-		     struct inode *inode, int mask)
-{
-	int retval;
-
-	retval = sb_permission(inode->i_sb, inode, mask);
-	if (unlikely(retval))
-		return retval;
-
-	if (unlikely(mask & MAY_WRITE)) {
-		/*
-		 * Nobody gets write access to an immutable file.
-		 */
-		if (unlikely(IS_IMMUTABLE(inode)))
-			return -EPERM;
-
-		/*
-		 * Updating mtime will likely cause i_uid and i_gid to be
-		 * written back improperly if their true value is unknown
-		 * to the vfs.
-		 */
-		if (unlikely(HAS_UNMAPPED_ID(idmap, inode)))
-			return -EACCES;
-	}
-
-	retval = do_inode_permission(idmap, inode, mask);
-	if (unlikely(retval))
-		return retval;
-
-	retval = devcgroup_inode_permission(inode, mask);
-	if (unlikely(retval))
-		return retval;
-
-	return security_inode_permission(inode, mask);
-}
-EXPORT_SYMBOL(inode_permission);
-
-/**
- * path_get - get a reference to a path
- * @path: path to get the reference to
- *
- * Given a path increment the reference count to the dentry and the vfsmount.
- */
-void path_get(const struct path *path)
-{
-	mntget(path->mnt);
-	dget(path->dentry);
-}
-EXPORT_SYMBOL(path_get);
-
-/**
- * path_put - put a reference to a path
- * @path: path to put the reference to
- *
- * Given a path decrement the reference count to the dentry and the vfsmount.
- */
-void path_put(const struct path *path)
-{
-	dput(path->dentry);
-	mntput(path->mnt);
-}
-EXPORT_SYMBOL(path_put);
-
-#define EMBEDDED_LEVELS 2
-struct nameidata {
-	struct path	path;
-	struct qstr	last;
-	struct path	root;
-	struct inode	*inode; /* path.dentry.d_inode */
-	unsigned int	flags, state;
-	unsigned	seq, next_seq, m_seq, r_seq;
-	int		last_type;
-	unsigned	depth;
-	int		total_link_count;
-	struct saved {
-		struct path link;
-		struct delayed_call done;
-		const char *name;
-		unsigned seq;
-	} *stack, internal[EMBEDDED_LEVELS];
-	struct filename	*name;
-	const char *pathname;
-	struct nameidata *saved;
-	unsigned	root_seq;
-	int		dfd;
-	vfsuid_t	dir_vfsuid;
-	umode_t		dir_mode;
-} __randomize_layout;
-
-#define ND_ROOT_PRESET 1
-#define ND_ROOT_GRABBED 2
-#define ND_JUMPED 4
-
-static void __set_nameidata(struct nameidata *p, int dfd, struct filename *name)
-{
-	struct nameidata *old = current->nameidata;
-	p->stack = p->internal;
-	p->depth = 0;
-	p->dfd = dfd;
-	p->name = name;
-	p->pathname = likely(name) ? name->name : "";
-	p->path.mnt = NULL;
-	p->path.dentry = NULL;
-	p->total_link_count = old ? old->total_link_count : 0;
-	p->saved = old;
-	current->nameidata = p;
-}
-
-static inline void set_nameidata(struct nameidata *p, int dfd, struct filename *name,
-			  const struct path *root)
-{
-	__set_nameidata(p, dfd, name);
-	p->state = 0;
-	if (unlikely(root)) {
-		p->state = ND_ROOT_PRESET;
-		p->root = *root;
-	}
-}
-
-static void restore_nameidata(void)
-{
-	struct nameidata *now = current->nameidata, *old = now->saved;
-
-	current->nameidata = old;
-	if (old)
-		old->total_link_count = now->total_link_count;
-	if (now->stack != now->internal)
-		kfree(now->stack);
-}
-
-static bool nd_alloc_stack(struct nameidata *nd)
-{
-	struct saved *p;
-
-	p= kmalloc_array(MAXSYMLINKS, sizeof(struct saved),
-			 nd->flags & LOOKUP_RCU ? GFP_ATOMIC : GFP_KERNEL);
-	if (unlikely(!p))
-		return false;
-	memcpy(p, nd->internal, sizeof(nd->internal));
-	nd->stack = p;
-	return true;
-}
-
-/**
- * path_connected - Verify that a dentry is below mnt.mnt_root
- * @mnt: The mountpoint to check.
- * @dentry: The dentry to check.
- *
- * Rename can sometimes move a file or directory outside of a bind
- * mount, path_connected allows those cases to be detected.
- */
-static bool path_connected(struct vfsmount *mnt, struct dentry *dentry)
-{
-	struct super_block *sb = mnt->mnt_sb;
-
-	/* Bind mounts can have disconnected paths */
-	if (mnt->mnt_root == sb->s_root)
-		return true;
-
-	return is_subdir(dentry, mnt->mnt_root);
-}
-
-static void drop_links(struct nameidata *nd)
-{
-	int i = nd->depth;
-	while (i--) {
-		struct saved *last = nd->stack + i;
-		do_delayed_call(&last->done);
-		clear_delayed_call(&last->done);
-	}
-}
-
-static void leave_rcu(struct nameidata *nd)
-{
-	nd->flags &= ~LOOKUP_RCU;
-	nd->seq = nd->next_seq = 0;
-	rcu_read_unlock();
-}
-
-static void terminate_walk(struct nameidata *nd)
-{
-	drop_links(nd);
-	if (!(nd->flags & LOOKUP_RCU)) {
-		int i;
-		path_put(&nd->path);
-		for (i = 0; i < nd->depth; i++)
-			path_put(&nd->stack[i].link);
-		if (nd->state & ND_ROOT_GRABBED) {
-			path_put(&nd->root);
-			nd->state &= ~ND_ROOT_GRABBED;
-		}
-	} else {
-		leave_rcu(nd);
-	}
-	nd->depth = 0;
-	nd->path.mnt = NULL;
-	nd->path.dentry = NULL;
-}
-
-/* path_put is needed afterwards regardless of success or failure */
-static bool __legitimize_path(struct path *path, unsigned seq, unsigned mseq)
-{
-	int res = __legitimize_mnt(path->mnt, mseq);
-	if (unlikely(res)) {
-		if (res > 0)
-			path->mnt = NULL;
-		path->dentry = NULL;
-		return false;
-	}
-	if (unlikely(!lockref_get_not_dead(&path->dentry->d_lockref))) {
-		path->dentry = NULL;
-		return false;
-	}
-	return !read_seqcount_retry(&path->dentry->d_seq, seq);
-}
-
-static inline bool legitimize_path(struct nameidata *nd,
-			    struct path *path, unsigned seq)
-{
-	return __legitimize_path(path, seq, nd->m_seq);
-}
-
-static bool legitimize_links(struct nameidata *nd)
-{
-	int i;
-	if (unlikely(nd->flags & LOOKUP_CACHED)) {
-		drop_links(nd);
-		nd->depth = 0;
-		return false;
-	}
-	for (i = 0; i < nd->depth; i++) {
-		struct saved *last = nd->stack + i;
-		if (unlikely(!legitimize_path(nd, &last->link, last->seq))) {
-			drop_links(nd);
-			nd->depth = i + 1;
-			return false;
-		}
-	}
-	return true;
-}
-
-static bool legitimize_root(struct nameidata *nd)
-{
-	/* Nothing to do if nd->root is zero or is managed by the VFS user. */
-	if (!nd->root.mnt || (nd->state & ND_ROOT_PRESET))
-		return true;
-	nd->state |= ND_ROOT_GRABBED;
-	return legitimize_path(nd, &nd->root, nd->root_seq);
-}
-
-/*
- * Path walking has 2 modes, rcu-walk and ref-walk (see
- * Documentation/filesystems/path-lookup.txt).  In situations when we can't
- * continue in RCU mode, we attempt to drop out of rcu-walk mode and grab
- * normal reference counts on dentries and vfsmounts to transition to ref-walk
- * mode.  Refcounts are grabbed at the last known good point before rcu-walk
- * got stuck, so ref-walk may continue from there. If this is not successful
- * (eg. a seqcount has changed), then failure is returned and it's up to caller
- * to restart the path walk from the beginning in ref-walk mode.
- */
-
-/**
- * try_to_unlazy - try to switch to ref-walk mode.
- * @nd: nameidata pathwalk data
- * Returns: true on success, false on failure
- *
- * try_to_unlazy attempts to legitimize the current nd->path and nd->root
- * for ref-walk mode.
- * Must be called from rcu-walk context.
- * Nothing should touch nameidata between try_to_unlazy() failure and
- * terminate_walk().
- */
-static bool try_to_unlazy(struct nameidata *nd)
-{
-	struct dentry *parent = nd->path.dentry;
-
-	BUG_ON(!(nd->flags & LOOKUP_RCU));
-
-	if (unlikely(!legitimize_links(nd)))
-		goto out1;
-	if (unlikely(!legitimize_path(nd, &nd->path, nd->seq)))
-		goto out;
-	if (unlikely(!legitimize_root(nd)))
-		goto out;
-	leave_rcu(nd);
-	BUG_ON(nd->inode != parent->d_inode);
-	return true;
-
-out1:
-	nd->path.mnt = NULL;
-	nd->path.dentry = NULL;
-out:
-	leave_rcu(nd);
-	return false;
-}
-
-/**
- * try_to_unlazy_next - try to switch to ref-walk mode.
- * @nd: nameidata pathwalk data
- * @dentry: next dentry to step into
- * Returns: true on success, false on failure
- *
- * Similar to try_to_unlazy(), but here we have the next dentry already
- * picked by rcu-walk and want to legitimize that in addition to the current
- * nd->path and nd->root for ref-walk mode.  Must be called from rcu-walk context.
- * Nothing should touch nameidata between try_to_unlazy_next() failure and
- * terminate_walk().
- */
-static bool try_to_unlazy_next(struct nameidata *nd, struct dentry *dentry)
-{
-	int res;
-	BUG_ON(!(nd->flags & LOOKUP_RCU));
-
-	if (unlikely(!legitimize_links(nd)))
-		goto out2;
-	res = __legitimize_mnt(nd->path.mnt, nd->m_seq);
-	if (unlikely(res)) {
-		if (res > 0)
-			goto out2;
-		goto out1;
-	}
-	if (unlikely(!lockref_get_not_dead(&nd->path.dentry->d_lockref)))
-		goto out1;
-
-	/*
-	 * We need to move both the parent and the dentry from the RCU domain
-	 * to be properly refcounted. And the sequence number in the dentry
-	 * validates *both* dentry counters, since we checked the sequence
-	 * number of the parent after we got the child sequence number. So we
-	 * know the parent must still be valid if the child sequence number is
-	 */
-	if (unlikely(!lockref_get_not_dead(&dentry->d_lockref)))
-		goto out;
-	if (read_seqcount_retry(&dentry->d_seq, nd->next_seq))
-		goto out_dput;
-	/*
-	 * Sequence counts matched. Now make sure that the root is
-	 * still valid and get it if required.
-	 */
-	if (unlikely(!legitimize_root(nd)))
-		goto out_dput;
-	leave_rcu(nd);
-	return true;
-
-out2:
-	nd->path.mnt = NULL;
-out1:
-	nd->path.dentry = NULL;
-out:
-	leave_rcu(nd);
-	return false;
-out_dput:
-	leave_rcu(nd);
-	dput(dentry);
-	return false;
-}
-
-static inline int d_revalidate(struct inode *dir, const struct qstr *name,
-			       struct dentry *dentry, unsigned int flags)
-{
-	if (unlikely(dentry->d_flags & DCACHE_OP_REVALIDATE))
-		return dentry->d_op->d_revalidate(dir, name, dentry, flags);
-	else
-		return 1;
-}
-
-/**
- * complete_walk - successful completion of path walk
- * @nd:  pointer nameidata
- *
- * If we had been in RCU mode, drop out of it and legitimize nd->path.
- * Revalidate the final result, unless we'd already done that during
- * the path walk or the filesystem doesn't ask for it.  Return 0 on
- * success, -error on failure.  In case of failure caller does not
- * need to drop nd->path.
- */
-static int complete_walk(struct nameidata *nd)
-{
-	struct dentry *dentry = nd->path.dentry;
-	int status;
-
-	if (nd->flags & LOOKUP_RCU) {
-		/*
-		 * We don't want to zero nd->root for scoped-lookups or
-		 * externally-managed nd->root.
-		 */
-		if (!(nd->state & ND_ROOT_PRESET))
-			if (!(nd->flags & LOOKUP_IS_SCOPED))
-				nd->root.mnt = NULL;
-		nd->flags &= ~LOOKUP_CACHED;
-		if (!try_to_unlazy(nd))
-			return -ECHILD;
-	}
-
-	if (unlikely(nd->flags & LOOKUP_IS_SCOPED)) {
-		/*
-		 * While the guarantee of LOOKUP_IS_SCOPED is (roughly) "don't
-		 * ever step outside the root during lookup" and should already
-		 * be guaranteed by the rest of namei, we want to avoid a namei
-		 * BUG resulting in userspace being given a path that was not
-		 * scoped within the root at some point during the lookup.
-		 *
-		 * So, do a final sanity-check to make sure that in the
-		 * worst-case scenario (a complete bypass of LOOKUP_IS_SCOPED)
-		 * we won't silently return an fd completely outside of the
-		 * requested root to userspace.
-		 *
-		 * Userspace could move the path outside the root after this
-		 * check, but as discussed elsewhere this is not a concern (the
-		 * resolved file was inside the root at some point).
-		 */
-		if (!path_is_under(&nd->path, &nd->root))
-			return -EXDEV;
-	}
-
-	if (likely(!(nd->state & ND_JUMPED)))
-		return 0;
-
-	if (likely(!(dentry->d_flags & DCACHE_OP_WEAK_REVALIDATE)))
-		return 0;
-
-	status = dentry->d_op->d_weak_revalidate(dentry, nd->flags);
-	if (status > 0)
-		return 0;
-
-	if (!status)
-		status = -ESTALE;
-
-	return status;
-}
-
-static int set_root(struct nameidata *nd)
-{
-	struct fs_struct *fs = current->fs;
-
-	/*
-	 * Jumping to the real root in a scoped-lookup is a BUG in namei, but we
-	 * still have to ensure it doesn't happen because it will cause a breakout
-	 * from the dirfd.
-	 */
-	if (WARN_ON(nd->flags & LOOKUP_IS_SCOPED))
-		return -ENOTRECOVERABLE;
-
-	if (nd->flags & LOOKUP_RCU) {
-		unsigned seq;
-
-		do {
-			seq = read_seqcount_begin(&fs->seq);
-			nd->root = fs->root;
-			nd->root_seq = __read_seqcount_begin(&nd->root.dentry->d_seq);
-		} while (read_seqcount_retry(&fs->seq, seq));
-	} else {
-		get_fs_root(fs, &nd->root);
-		nd->state |= ND_ROOT_GRABBED;
-	}
-	return 0;
-}
-
-static int nd_jump_root(struct nameidata *nd)
-{
-	if (unlikely(nd->flags & LOOKUP_BENEATH))
-		return -EXDEV;
-	if (unlikely(nd->flags & LOOKUP_NO_XDEV)) {
-		/* Absolute path arguments to path_init() are allowed. */
-		if (nd->path.mnt != NULL && nd->path.mnt != nd->root.mnt)
-			return -EXDEV;
-	}
-	if (!nd->root.mnt) {
-		int error = set_root(nd);
-		if (error)
-			return error;
-	}
-	if (nd->flags & LOOKUP_RCU) {
-		struct dentry *d;
-		nd->path = nd->root;
-		d = nd->path.dentry;
-		nd->inode = d->d_inode;
-		nd->seq = nd->root_seq;
-		if (read_seqcount_retry(&d->d_seq, nd->seq))
-			return -ECHILD;
-	} else {
-		path_put(&nd->path);
-		nd->path = nd->root;
-		path_get(&nd->path);
-		nd->inode = nd->path.dentry->d_inode;
-	}
-	nd->state |= ND_JUMPED;
-	return 0;
-}
-
-/*
- * Helper to directly jump to a known parsed path from ->get_link,
- * caller must have taken a reference to path beforehand.
- */
-int nd_jump_link(const struct path *path)
-{
-	int error = -ELOOP;
-	struct nameidata *nd = current->nameidata;
-
-	if (unlikely(nd->flags & LOOKUP_NO_MAGICLINKS))
-		goto err;
-
-	error = -EXDEV;
-	if (unlikely(nd->flags & LOOKUP_NO_XDEV)) {
-		if (nd->path.mnt != path->mnt)
-			goto err;
-	}
-	/* Not currently safe for scoped-lookups. */
-	if (unlikely(nd->flags & LOOKUP_IS_SCOPED))
-		goto err;
-
-	path_put(&nd->path);
-	nd->path = *path;
-	nd->inode = nd->path.dentry->d_inode;
-	nd->state |= ND_JUMPED;
-	return 0;
-
-err:
-	path_put(path);
-	return error;
-}
-
-static inline void put_link(struct nameidata *nd)
-{
-	struct saved *last = nd->stack + --nd->depth;
-	do_delayed_call(&last->done);
-	if (!(nd->flags & LOOKUP_RCU))
-		path_put(&last->link);
-}
-
-static int sysctl_protected_symlinks __read_mostly;
-static int sysctl_protected_hardlinks __read_mostly;
-static int sysctl_protected_fifos __read_mostly;
-static int sysctl_protected_regular __read_mostly;
-
-#ifdef CONFIG_SYSCTL
-static const struct ctl_table namei_sysctls[] = {
-	{
-		.procname	= "protected_symlinks",
-		.data		= &sysctl_protected_symlinks,
-		.maxlen		= sizeof(int),
-		.mode		= 0644,
-		.proc_handler	= proc_dointvec_minmax,
-		.extra1		= SYSCTL_ZERO,
-		.extra2		= SYSCTL_ONE,
-	},
-	{
-		.procname	= "protected_hardlinks",
-		.data		= &sysctl_protected_hardlinks,
-		.maxlen		= sizeof(int),
-		.mode		= 0644,
-		.proc_handler	= proc_dointvec_minmax,
-		.extra1		= SYSCTL_ZERO,
-		.extra2		= SYSCTL_ONE,
-	},
-	{
-		.procname	= "protected_fifos",
-		.data		= &sysctl_protected_fifos,
-		.maxlen		= sizeof(int),
-		.mode		= 0644,
-		.proc_handler	= proc_dointvec_minmax,
-		.extra1		= SYSCTL_ZERO,
-		.extra2		= SYSCTL_TWO,
-	},
-	{
-		.procname	= "protected_regular",
-		.data		= &sysctl_protected_regular,
-		.maxlen		= sizeof(int),
-		.mode		= 0644,
-		.proc_handler	= proc_dointvec_minmax,
-		.extra1		= SYSCTL_ZERO,
-		.extra2		= SYSCTL_TWO,
-	},
-};
-
-static int __init init_fs_namei_sysctls(void)
-{
-	register_sysctl_init("fs", namei_sysctls);
-	return 0;
-}
-fs_initcall(init_fs_namei_sysctls);
-
-#endif /* CONFIG_SYSCTL */
-
-/**
- * may_follow_link - Check symlink following for unsafe situations
- * @nd: nameidata pathwalk data
- * @inode: Used for idmapping.
- *
- * In the case of the sysctl_protected_symlinks sysctl being enabled,
- * CAP_DAC_OVERRIDE needs to be specifically ignored if the symlink is
- * in a sticky world-writable directory. This is to protect privileged
- * processes from failing races against path names that may change out
- * from under them by way of other users creating malicious symlinks.
- * It will permit symlinks to be followed only when outside a sticky
- * world-writable directory, or when the uid of the symlink and follower
- * match, or when the directory owner matches the symlink's owner.
- *
- * Returns 0 if following the symlink is allowed, -ve on error.
- */
-static inline int may_follow_link(struct nameidata *nd, const struct inode *inode)
-{
-	struct mnt_idmap *idmap;
-	vfsuid_t vfsuid;
-
-	if (!sysctl_protected_symlinks)
-		return 0;
-
-	idmap = mnt_idmap(nd->path.mnt);
-	vfsuid = i_uid_into_vfsuid(idmap, inode);
-	/* Allowed if owner and follower match. */
-	if (vfsuid_eq_kuid(vfsuid, current_fsuid()))
-		return 0;
-
-	/* Allowed if parent directory not sticky and world-writable. */
-	if ((nd->dir_mode & (S_ISVTX|S_IWOTH)) != (S_ISVTX|S_IWOTH))
-		return 0;
-
-	/* Allowed if parent directory and link owner match. */
-	if (vfsuid_valid(nd->dir_vfsuid) && vfsuid_eq(nd->dir_vfsuid, vfsuid))
-		return 0;
-
-	if (nd->flags & LOOKUP_RCU)
-		return -ECHILD;
-
-	audit_inode(nd->name, nd->stack[0].link.dentry, 0);
-	audit_log_path_denied(AUDIT_ANOM_LINK, "follow_link");
-	return -EACCES;
-}
-
-/**
- * safe_hardlink_source - Check for safe hardlink conditions
- * @idmap: idmap of the mount the inode was found from
- * @inode: the source inode to hardlink from
- *
- * Return false if at least one of the following conditions:
- *    - inode is not a regular file
- *    - inode is setuid
- *    - inode is setgid and group-exec
- *    - access failure for read and write
- *
- * Otherwise returns true.
- */
-static bool safe_hardlink_source(struct mnt_idmap *idmap,
-				 struct inode *inode)
-{
-	umode_t mode = inode->i_mode;
-
-	/* Special files should not get pinned to the filesystem. */
-	if (!S_ISREG(mode))
-		return false;
-
-	/* Setuid files should not get pinned to the filesystem. */
-	if (mode & S_ISUID)
-		return false;
-
-	/* Executable setgid files should not get pinned to the filesystem. */
-	if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP))
-		return false;
-
-	/* Hardlinking to unreadable or unwritable sources is dangerous. */
-	if (inode_permission(idmap, inode, MAY_READ | MAY_WRITE))
-		return false;
-
-	return true;
-}
-
-/**
- * may_linkat - Check permissions for creating a hardlink
- * @idmap: idmap of the mount the inode was found from
- * @link:  the source to hardlink from
- *
- * Block hardlink when all of:
- *  - sysctl_protected_hardlinks enabled
- *  - fsuid does not match inode
- *  - hardlink source is unsafe (see safe_hardlink_source() above)
- *  - not CAP_FOWNER in a namespace with the inode owner uid mapped
- *
- * If the inode has been found through an idmapped mount the idmap of
- * the vfsmount must be passed through @idmap. This function will then take
- * care to map the inode according to @idmap before checking permissions.
- * On non-idmapped mounts or if permission checking is to be performed on the
- * raw inode simply pass @nop_mnt_idmap.
- *
- * Returns 0 if successful, -ve on error.
- */
-int may_linkat(struct mnt_idmap *idmap, const struct path *link)
-{
-	struct inode *inode = link->dentry->d_inode;
-
-	/* Inode writeback is not safe when the uid or gid are invalid. */
-	if (!vfsuid_valid(i_uid_into_vfsuid(idmap, inode)) ||
-	    !vfsgid_valid(i_gid_into_vfsgid(idmap, inode)))
-		return -EOVERFLOW;
-
-	if (!sysctl_protected_hardlinks)
-		return 0;
-
-	/* Source inode owner (or CAP_FOWNER) can hardlink all they like,
-	 * otherwise, it must be a safe source.
-	 */
-	if (safe_hardlink_source(idmap, inode) ||
-	    inode_owner_or_capable(idmap, inode))
-		return 0;
-
-	audit_log_path_denied(AUDIT_ANOM_LINK, "linkat");
-	return -EPERM;
-}
-
-/**
- * may_create_in_sticky - Check whether an O_CREAT open in a sticky directory
- *			  should be allowed, or not, on files that already
- *			  exist.
- * @idmap: idmap of the mount the inode was found from
- * @nd: nameidata pathwalk data
- * @inode: the inode of the file to open
- *
- * Block an O_CREAT open of a FIFO (or a regular file) when:
- *   - sysctl_protected_fifos (or sysctl_protected_regular) is enabled
- *   - the file already exists
- *   - we are in a sticky directory
- *   - we don't own the file
- *   - the owner of the directory doesn't own the file
- *   - the directory is world writable
- * If the sysctl_protected_fifos (or sysctl_protected_regular) is set to 2
- * the directory doesn't have to be world writable: being group writable will
- * be enough.
- *
- * If the inode has been found through an idmapped mount the idmap of
- * the vfsmount must be passed through @idmap. This function will then take
- * care to map the inode according to @idmap before checking permissions.
- * On non-idmapped mounts or if permission checking is to be performed on the
- * raw inode simply pass @nop_mnt_idmap.
- *
- * Returns 0 if the open is allowed, -ve on error.
- */
-static int may_create_in_sticky(struct mnt_idmap *idmap, struct nameidata *nd,
-				struct inode *const inode)
-{
-	umode_t dir_mode = nd->dir_mode;
-	vfsuid_t dir_vfsuid = nd->dir_vfsuid, i_vfsuid;
-
-	if (likely(!(dir_mode & S_ISVTX)))
-		return 0;
-
-	if (S_ISREG(inode->i_mode) && !sysctl_protected_regular)
-		return 0;
-
-	if (S_ISFIFO(inode->i_mode) && !sysctl_protected_fifos)
-		return 0;
-
-	i_vfsuid = i_uid_into_vfsuid(idmap, inode);
-
-	if (vfsuid_eq(i_vfsuid, dir_vfsuid))
-		return 0;
-
-	if (vfsuid_eq_kuid(i_vfsuid, current_fsuid()))
-		return 0;
-
-	if (likely(dir_mode & 0002)) {
-		audit_log_path_denied(AUDIT_ANOM_CREAT, "sticky_create");
-		return -EACCES;
-	}
-
-	if (dir_mode & 0020) {
-		if (sysctl_protected_fifos >= 2 && S_ISFIFO(inode->i_mode)) {
-			audit_log_path_denied(AUDIT_ANOM_CREAT,
-					      "sticky_create_fifo");
-			return -EACCES;
-		}
-
-		if (sysctl_protected_regular >= 2 && S_ISREG(inode->i_mode)) {
-			audit_log_path_denied(AUDIT_ANOM_CREAT,
-					      "sticky_create_regular");
-			return -EACCES;
-		}
-	}
-
-	return 0;
-}
-
-/*
- * follow_up - Find the mountpoint of path's vfsmount
- *
- * Given a path, find the mountpoint of its source file system.
- * Replace @path with the path of the mountpoint in the parent mount.
- * Up is towards /.
- *
- * Return 1 if we went up a level and 0 if we were already at the
- * root.
- */
-int follow_up(struct path *path)
-{
-	struct mount *mnt = real_mount(path->mnt);
-	struct mount *parent;
-	struct dentry *mountpoint;
-
-	read_seqlock_excl(&mount_lock);
-	parent = mnt->mnt_parent;
-	if (parent == mnt) {
-		read_sequnlock_excl(&mount_lock);
-		return 0;
-	}
-	mntget(&parent->mnt);
-	mountpoint = dget(mnt->mnt_mountpoint);
-	read_sequnlock_excl(&mount_lock);
-	dput(path->dentry);
-	path->dentry = mountpoint;
-	mntput(path->mnt);
-	path->mnt = &parent->mnt;
-	return 1;
-}
-EXPORT_SYMBOL(follow_up);
-
-static bool choose_mountpoint_rcu(struct mount *m, const struct path *root,
-				  struct path *path, unsigned *seqp)
-{
-	while (mnt_has_parent(m)) {
-		struct dentry *mountpoint = m->mnt_mountpoint;
-
-		m = m->mnt_parent;
-		if (unlikely(root->dentry == mountpoint &&
-			     root->mnt == &m->mnt))
-			break;
-		if (mountpoint != m->mnt.mnt_root) {
-			path->mnt = &m->mnt;
-			path->dentry = mountpoint;
-			*seqp = read_seqcount_begin(&mountpoint->d_seq);
-			return true;
-		}
-	}
-	return false;
-}
-
-static bool choose_mountpoint(struct mount *m, const struct path *root,
-			      struct path *path)
-{
-	bool found;
-
-	rcu_read_lock();
-	while (1) {
-		unsigned seq, mseq = read_seqbegin(&mount_lock);
-
-		found = choose_mountpoint_rcu(m, root, path, &seq);
-		if (unlikely(!found)) {
-			if (!read_seqretry(&mount_lock, mseq))
-				break;
-		} else {
-			if (likely(__legitimize_path(path, seq, mseq)))
-				break;
-			rcu_read_unlock();
-			path_put(path);
-			rcu_read_lock();
-		}
-	}
-	rcu_read_unlock();
-	return found;
-}
-
-/*
- * Perform an automount
- * - return -EISDIR to tell follow_managed() to stop and return the path we
- *   were called with.
- */
-static int follow_automount(struct path *path, int *count, unsigned lookup_flags)
-{
-	struct dentry *dentry = path->dentry;
-
-	/* We don't want to mount if someone's just doing a stat -
-	 * unless they're stat'ing a directory and appended a '/' to
-	 * the name.
-	 *
-	 * We do, however, want to mount if someone wants to open or
-	 * create a file of any type under the mountpoint, wants to
-	 * traverse through the mountpoint or wants to open the
-	 * mounted directory.  Also, autofs may mark negative dentries
-	 * as being automount points.  These will need the attentions
-	 * of the daemon to instantiate them before they can be used.
-	 */
-	if (!(lookup_flags & (LOOKUP_PARENT | LOOKUP_DIRECTORY |
-			   LOOKUP_OPEN | LOOKUP_CREATE | LOOKUP_AUTOMOUNT)) &&
-	    dentry->d_inode)
-		return -EISDIR;
-
-	if (count && (*count)++ >= MAXSYMLINKS)
-		return -ELOOP;
-
-	return finish_automount(dentry->d_op->d_automount(path), path);
-}
-
-/*
- * mount traversal - out-of-line part.  One note on ->d_flags accesses -
- * dentries are pinned but not locked here, so negative dentry can go
- * positive right under us.  Use of smp_load_acquire() provides a barrier
- * sufficient for ->d_inode and ->d_flags consistency.
- */
-static int __traverse_mounts(struct path *path, unsigned flags, bool *jumped,
-			     int *count, unsigned lookup_flags)
-{
-	struct vfsmount *mnt = path->mnt;
-	bool need_mntput = false;
-	int ret = 0;
-
-	while (flags & DCACHE_MANAGED_DENTRY) {
-		/* Allow the filesystem to manage the transit without i_mutex
-		 * being held. */
-		if (flags & DCACHE_MANAGE_TRANSIT) {
-			ret = path->dentry->d_op->d_manage(path, false);
-			flags = smp_load_acquire(&path->dentry->d_flags);
-			if (ret < 0)
-				break;
-		}
-
-		if (flags & DCACHE_MOUNTED) {	// something's mounted on it..
-			struct vfsmount *mounted = lookup_mnt(path);
-			if (mounted) {		// ... in our namespace
-				dput(path->dentry);
-				if (need_mntput)
-					mntput(path->mnt);
-				path->mnt = mounted;
-				path->dentry = dget(mounted->mnt_root);
-				// here we know it's positive
-				flags = path->dentry->d_flags;
-				need_mntput = true;
-				continue;
-			}
-		}
-
-		if (!(flags & DCACHE_NEED_AUTOMOUNT))
-			break;
-
-		// uncovered automount point
-		ret = follow_automount(path, count, lookup_flags);
-		flags = smp_load_acquire(&path->dentry->d_flags);
-		if (ret < 0)
-			break;
-	}
-
-	if (ret == -EISDIR)
-		ret = 0;
-	// possible if you race with several mount --move
-	if (need_mntput && path->mnt == mnt)
-		mntput(path->mnt);
-	if (!ret && unlikely(d_flags_negative(flags)))
-		ret = -ENOENT;
-	*jumped = need_mntput;
-	return ret;
-}
-
-static inline int traverse_mounts(struct path *path, bool *jumped,
-				  int *count, unsigned lookup_flags)
-{
-	unsigned flags = smp_load_acquire(&path->dentry->d_flags);
-
-	/* fastpath */
-	if (likely(!(flags & DCACHE_MANAGED_DENTRY))) {
-		*jumped = false;
-		if (unlikely(d_flags_negative(flags)))
-			return -ENOENT;
-		return 0;
-	}
-	return __traverse_mounts(path, flags, jumped, count, lookup_flags);
-}
-
-int follow_down_one(struct path *path)
-{
-	struct vfsmount *mounted;
-
-	mounted = lookup_mnt(path);
-	if (mounted) {
-		dput(path->dentry);
-		mntput(path->mnt);
-		path->mnt = mounted;
-		path->dentry = dget(mounted->mnt_root);
-		return 1;
-	}
-	return 0;
-}
-EXPORT_SYMBOL(follow_down_one);
-
-/*
- * Follow down to the covering mount currently visible to userspace.  At each
- * point, the filesystem owning that dentry may be queried as to whether the
- * caller is permitted to proceed or not.
- */
-int follow_down(struct path *path, unsigned int flags)
-{
-	struct vfsmount *mnt = path->mnt;
-	bool jumped;
-	int ret = traverse_mounts(path, &jumped, NULL, flags);
-
-	if (path->mnt != mnt)
-		mntput(mnt);
-	return ret;
-}
-EXPORT_SYMBOL(follow_down);
-
-/*
- * Try to skip to top of mountpoint pile in rcuwalk mode.  Fail if
- * we meet a managed dentry that would need blocking.
- */
-static bool __follow_mount_rcu(struct nameidata *nd, struct path *path)
-{
-	struct dentry *dentry = path->dentry;
-	unsigned int flags = dentry->d_flags;
-
-	if (likely(!(flags & DCACHE_MANAGED_DENTRY)))
-		return true;
-
-	if (unlikely(nd->flags & LOOKUP_NO_XDEV))
-		return false;
-
-	for (;;) {
-		/*
-		 * Don't forget we might have a non-mountpoint managed dentry
-		 * that wants to block transit.
-		 */
-		if (unlikely(flags & DCACHE_MANAGE_TRANSIT)) {
-			int res = dentry->d_op->d_manage(path, true);
-			if (res)
-				return res == -EISDIR;
-			flags = dentry->d_flags;
-		}
-
-		if (flags & DCACHE_MOUNTED) {
-			struct mount *mounted = __lookup_mnt(path->mnt, dentry);
-			if (mounted) {
-				path->mnt = &mounted->mnt;
-				dentry = path->dentry = mounted->mnt.mnt_root;
-				nd->state |= ND_JUMPED;
-				nd->next_seq = read_seqcount_begin(&dentry->d_seq);
-				flags = dentry->d_flags;
-				// makes sure that non-RCU pathwalk could reach
-				// this state.
-				if (read_seqretry(&mount_lock, nd->m_seq))
-					return false;
-				continue;
-			}
-			if (read_seqretry(&mount_lock, nd->m_seq))
-				return false;
-		}
-		return !(flags & DCACHE_NEED_AUTOMOUNT);
-	}
-}
-
-static inline int handle_mounts(struct nameidata *nd, struct dentry *dentry,
-			  struct path *path)
-{
-	bool jumped;
-	int ret;
-
-	path->mnt = nd->path.mnt;
-	path->dentry = dentry;
-	if (nd->flags & LOOKUP_RCU) {
-		unsigned int seq = nd->next_seq;
-		if (likely(__follow_mount_rcu(nd, path)))
-			return 0;
-		// *path and nd->next_seq might've been clobbered
-		path->mnt = nd->path.mnt;
-		path->dentry = dentry;
-		nd->next_seq = seq;
-		if (!try_to_unlazy_next(nd, dentry))
-			return -ECHILD;
-	}
-	ret = traverse_mounts(path, &jumped, &nd->total_link_count, nd->flags);
-	if (jumped) {
-		if (unlikely(nd->flags & LOOKUP_NO_XDEV))
-			ret = -EXDEV;
-		else
-			nd->state |= ND_JUMPED;
-	}
-	if (unlikely(ret)) {
-		dput(path->dentry);
-		if (path->mnt != nd->path.mnt)
-			mntput(path->mnt);
-	}
-	return ret;
-}
-
-/*
- * This looks up the name in dcache and possibly revalidates the found dentry.
- * NULL is returned if the dentry does not exist in the cache.
- */
-static struct dentry *lookup_dcache(const struct qstr *name,
-				    struct dentry *dir,
-				    unsigned int flags)
-{
-	struct dentry *dentry = d_lookup(dir, name);
-	if (dentry) {
-		int error = d_revalidate(dir->d_inode, name, dentry, flags);
-		if (unlikely(error <= 0)) {
-			if (!error)
-				d_invalidate(dentry);
-			dput(dentry);
-			return ERR_PTR(error);
-		}
-	}
-	return dentry;
-}
-
-static struct dentry *lookup_one_qstr_excl_raw(const struct qstr *name,
-					       struct dentry *base,
-					       unsigned int flags)
-{
-	struct dentry *dentry;
-	struct dentry *old;
-	struct inode *dir;
-
-	dentry = lookup_dcache(name, base, flags);
-	if (dentry)
-		return dentry;
-
-	/* Don't create child dentry for a dead directory. */
-	dir = base->d_inode;
-	if (unlikely(IS_DEADDIR(dir)))
-		return ERR_PTR(-ENOENT);
-
-	dentry = d_alloc(base, name);
-	if (unlikely(!dentry))
-		return ERR_PTR(-ENOMEM);
-
-	old = dir->i_op->lookup(dir, dentry, flags);
-	if (unlikely(old)) {
-		dput(dentry);
-		dentry = old;
-	}
-	return dentry;
-}
-
-/*
- * Parent directory has inode locked exclusive.  This is one
- * and only case when ->lookup() gets called on non in-lookup
- * dentries - as the matter of fact, this only gets called
- * when directory is guaranteed to have no in-lookup children
- * at all.
- * Will return -ENOENT if name isn't found and LOOKUP_CREATE wasn't passed.
- * Will return -EEXIST if name is found and LOOKUP_EXCL was passed.
- */
-struct dentry *lookup_one_qstr_excl(const struct qstr *name,
-				    struct dentry *base, unsigned int flags)
-{
-	struct dentry *dentry;
-
-	dentry = lookup_one_qstr_excl_raw(name, base, flags);
-	if (IS_ERR(dentry))
-		return dentry;
-	if (d_is_negative(dentry) && !(flags & LOOKUP_CREATE)) {
-		dput(dentry);
-		return ERR_PTR(-ENOENT);
-	}
-	if (d_is_positive(dentry) && (flags & LOOKUP_EXCL)) {
-		dput(dentry);
-		return ERR_PTR(-EEXIST);
-	}
-	return dentry;
-}
-EXPORT_SYMBOL(lookup_one_qstr_excl);
-
-/**
- * lookup_fast - do fast lockless (but racy) lookup of a dentry
- * @nd: current nameidata
- *
- * Do a fast, but racy lookup in the dcache for the given dentry, and
- * revalidate it. Returns a valid dentry pointer or NULL if one wasn't
- * found. On error, an ERR_PTR will be returned.
- *
- * If this function returns a valid dentry and the walk is no longer
- * lazy, the dentry will carry a reference that must later be put. If
- * RCU mode is still in force, then this is not the case and the dentry
- * must be legitimized before use. If this returns NULL, then the walk
- * will no longer be in RCU mode.
- */
-static struct dentry *lookup_fast(struct nameidata *nd)
-{
-	struct dentry *dentry, *parent = nd->path.dentry;
-	int status = 1;
-
-	/*
-	 * Rename seqlock is not required here because in the off chance
-	 * of a false negative due to a concurrent rename, the caller is
-	 * going to fall back to non-racy lookup.
-	 */
-	if (nd->flags & LOOKUP_RCU) {
-		dentry = __d_lookup_rcu(parent, &nd->last, &nd->next_seq);
-		if (unlikely(!dentry)) {
-			if (!try_to_unlazy(nd))
-				return ERR_PTR(-ECHILD);
-			return NULL;
-		}
-
-		/*
-		 * This sequence count validates that the parent had no
-		 * changes while we did the lookup of the dentry above.
-		 */
-		if (read_seqcount_retry(&parent->d_seq, nd->seq))
-			return ERR_PTR(-ECHILD);
-
-		status = d_revalidate(nd->inode, &nd->last, dentry, nd->flags);
-		if (likely(status > 0))
-			return dentry;
-		if (!try_to_unlazy_next(nd, dentry))
-			return ERR_PTR(-ECHILD);
-		if (status == -ECHILD)
-			/* we'd been told to redo it in non-rcu mode */
-			status = d_revalidate(nd->inode, &nd->last,
-					      dentry, nd->flags);
-	} else {
-		dentry = __d_lookup(parent, &nd->last);
-		if (unlikely(!dentry))
-			return NULL;
-		status = d_revalidate(nd->inode, &nd->last, dentry, nd->flags);
-	}
-	if (unlikely(status <= 0)) {
-		if (!status)
-			d_invalidate(dentry);
-		dput(dentry);
-		return ERR_PTR(status);
-	}
-	return dentry;
-}
-
-/* Fast lookup failed, do it the slow way */
-static struct dentry *__lookup_slow(const struct qstr *name,
-				    struct dentry *dir,
-				    unsigned int flags)
-{
-	struct dentry *dentry, *old;
-	struct inode *inode = dir->d_inode;
-	DECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq);
-
-	/* Don't go there if it's already dead */
-	if (unlikely(IS_DEADDIR(inode)))
-		return ERR_PTR(-ENOENT);
-again:
-	dentry = d_alloc_parallel(dir, name, &wq);
-	if (IS_ERR(dentry))
-		return dentry;
-	if (unlikely(!d_in_lookup(dentry))) {
-		int error = d_revalidate(inode, name, dentry, flags);
-		if (unlikely(error <= 0)) {
-			if (!error) {
-				d_invalidate(dentry);
-				dput(dentry);
-				goto again;
-			}
-			dput(dentry);
-			dentry = ERR_PTR(error);
-		}
-	} else {
-		old = inode->i_op->lookup(inode, dentry, flags);
-		d_lookup_done(dentry);
-		if (unlikely(old)) {
-			dput(dentry);
-			dentry = old;
-		}
-	}
-	return dentry;
-}
-
-static struct dentry *lookup_slow(const struct qstr *name,
-				  struct dentry *dir,
-				  unsigned int flags)
-{
-	struct inode *inode = dir->d_inode;
-	struct dentry *res;
-	inode_lock_shared(inode);
-	res = __lookup_slow(name, dir, flags);
-	inode_unlock_shared(inode);
-	return res;
-}
-
-static inline int may_lookup(struct mnt_idmap *idmap,
-			     struct nameidata *restrict nd)
-{
-	int err, mask;
-
-	mask = nd->flags & LOOKUP_RCU ? MAY_NOT_BLOCK : 0;
-	err = inode_permission(idmap, nd->inode, mask | MAY_EXEC);
-	if (likely(!err))
-		return 0;
-
-	// If we failed, and we weren't in LOOKUP_RCU, it's final
-	if (!(nd->flags & LOOKUP_RCU))
-		return err;
-
-	// Drop out of RCU mode to make sure it wasn't transient
-	if (!try_to_unlazy(nd))
-		return -ECHILD;	// redo it all non-lazy
-
-	if (err != -ECHILD)	// hard error
-		return err;
-
-	return inode_permission(idmap, nd->inode, MAY_EXEC);
-}
-
-static int reserve_stack(struct nameidata *nd, struct path *link)
-{
-	if (unlikely(nd->total_link_count++ >= MAXSYMLINKS))
-		return -ELOOP;
-
-	if (likely(nd->depth != EMBEDDED_LEVELS))
-		return 0;
-	if (likely(nd->stack != nd->internal))
-		return 0;
-	if (likely(nd_alloc_stack(nd)))
-		return 0;
-
-	if (nd->flags & LOOKUP_RCU) {
-		// we need to grab link before we do unlazy.  And we can't skip
-		// unlazy even if we fail to grab the link - cleanup needs it
-		bool grabbed_link = legitimize_path(nd, link, nd->next_seq);
-
-		if (!try_to_unlazy(nd) || !grabbed_link)
-			return -ECHILD;
-
-		if (nd_alloc_stack(nd))
-			return 0;
-	}
-	return -ENOMEM;
-}
-
-enum {WALK_TRAILING = 1, WALK_MORE = 2, WALK_NOFOLLOW = 4};
-
-static const char *pick_link(struct nameidata *nd, struct path *link,
-		     struct inode *inode, int flags)
-{
-	struct saved *last;
-	const char *res;
-	int error = reserve_stack(nd, link);
-
-	if (unlikely(error)) {
-		if (!(nd->flags & LOOKUP_RCU))
-			path_put(link);
-		return ERR_PTR(error);
-	}
-	last = nd->stack + nd->depth++;
-	last->link = *link;
-	clear_delayed_call(&last->done);
-	last->seq = nd->next_seq;
-
-	if (flags & WALK_TRAILING) {
-		error = may_follow_link(nd, inode);
-		if (unlikely(error))
-			return ERR_PTR(error);
-	}
-
-	if (unlikely(nd->flags & LOOKUP_NO_SYMLINKS) ||
-			unlikely(link->mnt->mnt_flags & MNT_NOSYMFOLLOW))
-		return ERR_PTR(-ELOOP);
-
-	if (unlikely(atime_needs_update(&last->link, inode))) {
-		if (nd->flags & LOOKUP_RCU) {
-			if (!try_to_unlazy(nd))
-				return ERR_PTR(-ECHILD);
-		}
-		touch_atime(&last->link);
-		cond_resched();
-	}
-
-	error = security_inode_follow_link(link->dentry, inode,
-					   nd->flags & LOOKUP_RCU);
-	if (unlikely(error))
-		return ERR_PTR(error);
-
-	res = READ_ONCE(inode->i_link);
-	if (!res) {
-		const char * (*get)(struct dentry *, struct inode *,
-				struct delayed_call *);
-		get = inode->i_op->get_link;
-		if (nd->flags & LOOKUP_RCU) {
-			res = get(NULL, inode, &last->done);
-			if (res == ERR_PTR(-ECHILD) && try_to_unlazy(nd))
-				res = get(link->dentry, inode, &last->done);
-		} else {
-			res = get(link->dentry, inode, &last->done);
-		}
-		if (!res)
-			goto all_done;
-		if (IS_ERR(res))
-			return res;
-	}
-	if (*res == '/') {
-		error = nd_jump_root(nd);
-		if (unlikely(error))
-			return ERR_PTR(error);
-		while (unlikely(*++res == '/'))
-			;
-	}
-	if (*res)
-		return res;
-all_done: // pure jump
-	put_link(nd);
-	return NULL;
-}
-
-/*
- * Do we need to follow links? We _really_ want to be able
- * to do this check without having to look at inode->i_op,
- * so we keep a cache of "no, this doesn't need follow_link"
- * for the common case.
- *
- * NOTE: dentry must be what nd->next_seq had been sampled from.
- */
-static const char *step_into(struct nameidata *nd, int flags,
-		     struct dentry *dentry)
-{
-	struct path path;
-	struct inode *inode;
-	int err = handle_mounts(nd, dentry, &path);
-
-	if (err < 0)
-		return ERR_PTR(err);
-	inode = path.dentry->d_inode;
-	if (likely(!d_is_symlink(path.dentry)) ||
-	   ((flags & WALK_TRAILING) && !(nd->flags & LOOKUP_FOLLOW)) ||
-	   (flags & WALK_NOFOLLOW)) {
-		/* not a symlink or should not follow */
-		if (nd->flags & LOOKUP_RCU) {
-			if (read_seqcount_retry(&path.dentry->d_seq, nd->next_seq))
-				return ERR_PTR(-ECHILD);
-			if (unlikely(!inode))
-				return ERR_PTR(-ENOENT);
-		} else {
-			dput(nd->path.dentry);
-			if (nd->path.mnt != path.mnt)
-				mntput(nd->path.mnt);
-		}
-		nd->path = path;
-		nd->inode = inode;
-		nd->seq = nd->next_seq;
-		return NULL;
-	}
-	if (nd->flags & LOOKUP_RCU) {
-		/* make sure that d_is_symlink above matches inode */
-		if (read_seqcount_retry(&path.dentry->d_seq, nd->next_seq))
-			return ERR_PTR(-ECHILD);
-	} else {
-		if (path.mnt == nd->path.mnt)
-			mntget(path.mnt);
-	}
-	return pick_link(nd, &path, inode, flags);
-}
-
-static struct dentry *follow_dotdot_rcu(struct nameidata *nd)
-{
-	struct dentry *parent, *old;
-
-	if (path_equal(&nd->path, &nd->root))
-		goto in_root;
-	if (unlikely(nd->path.dentry == nd->path.mnt->mnt_root)) {
-		struct path path;
-		unsigned seq;
-		if (!choose_mountpoint_rcu(real_mount(nd->path.mnt),
-					   &nd->root, &path, &seq))
-			goto in_root;
-		if (unlikely(nd->flags & LOOKUP_NO_XDEV))
-			return ERR_PTR(-ECHILD);
-		nd->path = path;
-		nd->inode = path.dentry->d_inode;
-		nd->seq = seq;
-		// makes sure that non-RCU pathwalk could reach this state
-		if (read_seqretry(&mount_lock, nd->m_seq))
-			return ERR_PTR(-ECHILD);
-		/* we know that mountpoint was pinned */
-	}
-	old = nd->path.dentry;
-	parent = old->d_parent;
-	nd->next_seq = read_seqcount_begin(&parent->d_seq);
-	// makes sure that non-RCU pathwalk could reach this state
-	if (read_seqcount_retry(&old->d_seq, nd->seq))
-		return ERR_PTR(-ECHILD);
-	if (unlikely(!path_connected(nd->path.mnt, parent)))
-		return ERR_PTR(-ECHILD);
-	return parent;
-in_root:
-	if (read_seqretry(&mount_lock, nd->m_seq))
-		return ERR_PTR(-ECHILD);
-	if (unlikely(nd->flags & LOOKUP_BENEATH))
-		return ERR_PTR(-ECHILD);
-	nd->next_seq = nd->seq;
-	return nd->path.dentry;
-}
-
-static struct dentry *follow_dotdot(struct nameidata *nd)
-{
-	struct dentry *parent;
-
-	if (path_equal(&nd->path, &nd->root))
-		goto in_root;
-	if (unlikely(nd->path.dentry == nd->path.mnt->mnt_root)) {
-		struct path path;
-
-		if (!choose_mountpoint(real_mount(nd->path.mnt),
-				       &nd->root, &path))
-			goto in_root;
-		path_put(&nd->path);
-		nd->path = path;
-		nd->inode = path.dentry->d_inode;
-		if (unlikely(nd->flags & LOOKUP_NO_XDEV))
-			return ERR_PTR(-EXDEV);
-	}
-	/* rare case of legitimate dget_parent()... */
-	parent = dget_parent(nd->path.dentry);
-	if (unlikely(!path_connected(nd->path.mnt, parent))) {
-		dput(parent);
-		return ERR_PTR(-ENOENT);
-	}
-	return parent;
-
-in_root:
-	if (unlikely(nd->flags & LOOKUP_BENEATH))
-		return ERR_PTR(-EXDEV);
-	return dget(nd->path.dentry);
-}
-
-static const char *handle_dots(struct nameidata *nd, int type)
-{
-	if (type == LAST_DOTDOT) {
-		const char *error = NULL;
-		struct dentry *parent;
-
-		if (!nd->root.mnt) {
-			error = ERR_PTR(set_root(nd));
-			if (error)
-				return error;
-		}
-		if (nd->flags & LOOKUP_RCU)
-			parent = follow_dotdot_rcu(nd);
-		else
-			parent = follow_dotdot(nd);
-		if (IS_ERR(parent))
-			return ERR_CAST(parent);
-		error = step_into(nd, WALK_NOFOLLOW, parent);
-		if (unlikely(error))
-			return error;
-
-		if (unlikely(nd->flags & LOOKUP_IS_SCOPED)) {
-			/*
-			 * If there was a racing rename or mount along our
-			 * path, then we can't be sure that ".." hasn't jumped
-			 * above nd->root (and so userspace should retry or use
-			 * some fallback).
-			 */
-			smp_rmb();
-			if (__read_seqcount_retry(&mount_lock.seqcount, nd->m_seq))
-				return ERR_PTR(-EAGAIN);
-			if (__read_seqcount_retry(&rename_lock.seqcount, nd->r_seq))
-				return ERR_PTR(-EAGAIN);
-		}
-	}
-	return NULL;
-}
-
-static const char *walk_component(struct nameidata *nd, int flags)
-{
-	struct dentry *dentry;
-	/*
-	 * "." and ".." are special - ".." especially so because it has
-	 * to be able to know about the current root directory and
-	 * parent relationships.
-	 */
-	if (unlikely(nd->last_type != LAST_NORM)) {
-		if (!(flags & WALK_MORE) && nd->depth)
-			put_link(nd);
-		return handle_dots(nd, nd->last_type);
-	}
-	dentry = lookup_fast(nd);
-	if (IS_ERR(dentry))
-		return ERR_CAST(dentry);
-	if (unlikely(!dentry)) {
-		dentry = lookup_slow(&nd->last, nd->path.dentry, nd->flags);
-		if (IS_ERR(dentry))
-			return ERR_CAST(dentry);
-	}
-	if (!(flags & WALK_MORE) && nd->depth)
-		put_link(nd);
-	return step_into(nd, flags, dentry);
-}
-
-/*
- * We can do the critical dentry name comparison and hashing
- * operations one word at a time, but we are limited to:
- *
- * - Architectures with fast unaligned word accesses. We could
- *   do a "get_unaligned()" if this helps and is sufficiently
- *   fast.
- *
- * - non-CONFIG_DEBUG_PAGEALLOC configurations (so that we
- *   do not trap on the (extremely unlikely) case of a page
- *   crossing operation.
- *
- * - Furthermore, we need an efficient 64-bit compile for the
- *   64-bit case in order to generate the "number of bytes in
- *   the final mask". Again, that could be replaced with a
- *   efficient population count instruction or similar.
- */
-#ifdef CONFIG_DCACHE_WORD_ACCESS
-
-#include <asm/word-at-a-time.h>
-
-#ifdef HASH_MIX
-
-/* Architecture provides HASH_MIX and fold_hash() in <asm/hash.h> */
-
-#elif defined(CONFIG_64BIT)
-/*
- * Register pressure in the mixing function is an issue, particularly
- * on 32-bit x86, but almost any function requires one state value and
- * one temporary.  Instead, use a function designed for two state values
- * and no temporaries.
- *
- * This function cannot create a collision in only two iterations, so
- * we have two iterations to achieve avalanche.  In those two iterations,
- * we have six layers of mixing, which is enough to spread one bit's
- * influence out to 2^6 = 64 state bits.
- *
- * Rotate constants are scored by considering either 64 one-bit input
- * deltas or 64*63/2 = 2016 two-bit input deltas, and finding the
- * probability of that delta causing a change to each of the 128 output
- * bits, using a sample of random initial states.
- *
- * The Shannon entropy of the computed probabilities is then summed
- * to produce a score.  Ideally, any input change has a 50% chance of
- * toggling any given output bit.
- *
- * Mixing scores (in bits) for (12,45):
- * Input delta: 1-bit      2-bit
- * 1 round:     713.3    42542.6
- * 2 rounds:   2753.7   140389.8
- * 3 rounds:   5954.1   233458.2
- * 4 rounds:   7862.6   256672.2
- * Perfect:    8192     258048
- *            (64*128) (64*63/2 * 128)
- */
-#define HASH_MIX(x, y, a)	\
-	(	x ^= (a),	\
-	y ^= x,	x = rol64(x,12),\
-	x += y,	y = rol64(y,45),\
-	y *= 9			)
-
-/*
- * Fold two longs into one 32-bit hash value.  This must be fast, but
- * latency isn't quite as critical, as there is a fair bit of additional
- * work done before the hash value is used.
- */
-static inline unsigned int fold_hash(unsigned long x, unsigned long y)
-{
-	y ^= x * GOLDEN_RATIO_64;
-	y *= GOLDEN_RATIO_64;
-	return y >> 32;
-}
-
-#else	/* 32-bit case */
-
-/*
- * Mixing scores (in bits) for (7,20):
- * Input delta: 1-bit      2-bit
- * 1 round:     330.3     9201.6
- * 2 rounds:   1246.4    25475.4
- * 3 rounds:   1907.1    31295.1
- * 4 rounds:   2042.3    31718.6
- * Perfect:    2048      31744
- *            (32*64)   (32*31/2 * 64)
- */
-#define HASH_MIX(x, y, a)	\
-	(	x ^= (a),	\
-	y ^= x,	x = rol32(x, 7),\
-	x += y,	y = rol32(y,20),\
-	y *= 9			)
-
-static inline unsigned int fold_hash(unsigned long x, unsigned long y)
-{
-	/* Use arch-optimized multiply if one exists */
-	return __hash_32(y ^ __hash_32(x));
-}
-
-#endif
-
-/*
- * Return the hash of a string of known length.  This is carfully
- * designed to match hash_name(), which is the more critical function.
- * In particular, we must end by hashing a final word containing 0..7
- * payload bytes, to match the way that hash_name() iterates until it
- * finds the delimiter after the name.
- */
-unsigned int full_name_hash(const void *salt, const char *name, unsigned int len)
-{
-	unsigned long a, x = 0, y = (unsigned long)salt;
-
-	for (;;) {
-		if (!len)
-			goto done;
-		a = load_unaligned_zeropad(name);
-		if (len < sizeof(unsigned long))
-			break;
-		HASH_MIX(x, y, a);
-		name += sizeof(unsigned long);
-		len -= sizeof(unsigned long);
-	}
-	x ^= a & bytemask_from_count(len);
-done:
-	return fold_hash(x, y);
-}
-EXPORT_SYMBOL(full_name_hash);
-
-/* Return the "hash_len" (hash and length) of a null-terminated string */
-u64 hashlen_string(const void *salt, const char *name)
-{
-	unsigned long a = 0, x = 0, y = (unsigned long)salt;
-	unsigned long adata, mask, len;
-	const struct word_at_a_time constants = WORD_AT_A_TIME_CONSTANTS;
-
-	len = 0;
-	goto inside;
-
-	do {
-		HASH_MIX(x, y, a);
-		len += sizeof(unsigned long);
-inside:
-		a = load_unaligned_zeropad(name+len);
-	} while (!has_zero(a, &adata, &constants));
-
-	adata = prep_zero_mask(a, adata, &constants);
-	mask = create_zero_mask(adata);
-	x ^= a & zero_bytemask(mask);
-
-	return hashlen_create(fold_hash(x, y), len + find_zero(mask));
-}
-EXPORT_SYMBOL(hashlen_string);
-
-/*
- * Calculate the length and hash of the path component, and
- * return the length as the result.
- */
-static inline const char *hash_name(struct nameidata *nd,
-				    const char *name,
-				    unsigned long *lastword)
-{
-	unsigned long a, b, x, y = (unsigned long)nd->path.dentry;
-	unsigned long adata, bdata, mask, len;
-	const struct word_at_a_time constants = WORD_AT_A_TIME_CONSTANTS;
-
-	/*
-	 * The first iteration is special, because it can result in
-	 * '.' and '..' and has no mixing other than the final fold.
-	 */
-	a = load_unaligned_zeropad(name);
-	b = a ^ REPEAT_BYTE('/');
-	if (has_zero(a, &adata, &constants) | has_zero(b, &bdata, &constants)) {
-		adata = prep_zero_mask(a, adata, &constants);
-		bdata = prep_zero_mask(b, bdata, &constants);
-		mask = create_zero_mask(adata | bdata);
-		a &= zero_bytemask(mask);
-		*lastword = a;
-		len = find_zero(mask);
-		nd->last.hash = fold_hash(a, y);
-		nd->last.len = len;
-		return name + len;
-	}
-
-	len = 0;
-	x = 0;
-	do {
-		HASH_MIX(x, y, a);
-		len += sizeof(unsigned long);
-		a = load_unaligned_zeropad(name+len);
-		b = a ^ REPEAT_BYTE('/');
-	} while (!(has_zero(a, &adata, &constants) | has_zero(b, &bdata, &constants)));
-
-	adata = prep_zero_mask(a, adata, &constants);
-	bdata = prep_zero_mask(b, bdata, &constants);
-	mask = create_zero_mask(adata | bdata);
-	a &= zero_bytemask(mask);
-	x ^= a;
-	len += find_zero(mask);
-	*lastword = 0;		// Multi-word components cannot be DOT or DOTDOT
-
-	nd->last.hash = fold_hash(x, y);
-	nd->last.len = len;
-	return name + len;
-}
-
-/*
- * Note that the 'last' word is always zero-masked, but
- * was loaded as a possibly big-endian word.
- */
-#ifdef __BIG_ENDIAN
-  #define LAST_WORD_IS_DOT	(0x2eul << (BITS_PER_LONG-8))
-  #define LAST_WORD_IS_DOTDOT	(0x2e2eul << (BITS_PER_LONG-16))
-#endif
-
-#else	/* !CONFIG_DCACHE_WORD_ACCESS: Slow, byte-at-a-time version */
-
-/* Return the hash of a string of known length */
-unsigned int full_name_hash(const void *salt, const char *name, unsigned int len)
-{
-	unsigned long hash = init_name_hash(salt);
-	while (len--)
-		hash = partial_name_hash((unsigned char)*name++, hash);
-	return end_name_hash(hash);
-}
-EXPORT_SYMBOL(full_name_hash);
-
-/* Return the "hash_len" (hash and length) of a null-terminated string */
-u64 hashlen_string(const void *salt, const char *name)
-{
-	unsigned long hash = init_name_hash(salt);
-	unsigned long len = 0, c;
-
-	c = (unsigned char)*name;
-	while (c) {
-		len++;
-		hash = partial_name_hash(c, hash);
-		c = (unsigned char)name[len];
-	}
-	return hashlen_create(end_name_hash(hash), len);
-}
-EXPORT_SYMBOL(hashlen_string);
-
-/*
- * We know there's a real path component here of at least
- * one character.
- */
-static inline const char *hash_name(struct nameidata *nd, const char *name, unsigned long *lastword)
-{
-	unsigned long hash = init_name_hash(nd->path.dentry);
-	unsigned long len = 0, c, last = 0;
-
-	c = (unsigned char)*name;
-	do {
-		last = (last << 8) + c;
-		len++;
-		hash = partial_name_hash(c, hash);
-		c = (unsigned char)name[len];
-	} while (c && c != '/');
-
-	// This is reliable for DOT or DOTDOT, since the component
-	// cannot contain NUL characters - top bits being zero means
-	// we cannot have had any other pathnames.
-	*lastword = last;
-	nd->last.hash = end_name_hash(hash);
-	nd->last.len = len;
-	return name + len;
-}
-
-#endif
-
-#ifndef LAST_WORD_IS_DOT
-  #define LAST_WORD_IS_DOT	0x2e
-  #define LAST_WORD_IS_DOTDOT	0x2e2e
-#endif
-
-/*
- * Name resolution.
- * This is the basic name resolution function, turning a pathname into
- * the final dentry. We expect 'base' to be positive and a directory.
- *
- * Returns 0 and nd will have valid dentry and mnt on success.
- * Returns error and drops reference to input namei data on failure.
- */
-static int link_path_walk(const char *name, struct nameidata *nd)
-{
-	int depth = 0; // depth <= nd->depth
-	int err;
-
-	nd->last_type = LAST_ROOT;
-	nd->flags |= LOOKUP_PARENT;
-	if (IS_ERR(name))
-		return PTR_ERR(name);
-	if (*name == '/') {
-		do {
-			name++;
-		} while (unlikely(*name == '/'));
-	}
-	if (unlikely(!*name)) {
-		nd->dir_mode = 0; // short-circuit the 'hardening' idiocy
-		return 0;
-	}
-
-	/* At this point we know we have a real path component. */
-	for(;;) {
-		struct mnt_idmap *idmap;
-		const char *link;
-		unsigned long lastword;
-
-		idmap = mnt_idmap(nd->path.mnt);
-		err = may_lookup(idmap, nd);
-		if (unlikely(err))
-			return err;
-
-		nd->last.name = name;
-		name = hash_name(nd, name, &lastword);
-
-		switch(lastword) {
-		case LAST_WORD_IS_DOTDOT:
-			nd->last_type = LAST_DOTDOT;
-			nd->state |= ND_JUMPED;
-			break;
-
-		case LAST_WORD_IS_DOT:
-			nd->last_type = LAST_DOT;
-			break;
-
-		default:
-			nd->last_type = LAST_NORM;
-			nd->state &= ~ND_JUMPED;
-
-			struct dentry *parent = nd->path.dentry;
-			if (unlikely(parent->d_flags & DCACHE_OP_HASH)) {
-				err = parent->d_op->d_hash(parent, &nd->last);
-				if (err < 0)
-					return err;
-			}
-		}
-
-		if (!*name)
-			goto OK;
-		/*
-		 * If it wasn't NUL, we know it was '/'. Skip that
-		 * slash, and continue until no more slashes.
-		 */
-		do {
-			name++;
-		} while (unlikely(*name == '/'));
-		if (unlikely(!*name)) {
-OK:
-			/* pathname or trailing symlink, done */
-			if (!depth) {
-				nd->dir_vfsuid = i_uid_into_vfsuid(idmap, nd->inode);
-				nd->dir_mode = nd->inode->i_mode;
-				nd->flags &= ~LOOKUP_PARENT;
-				return 0;
-			}
-			/* last component of nested symlink */
-			name = nd->stack[--depth].name;
-			link = walk_component(nd, 0);
-		} else {
-			/* not the last component */
-			link = walk_component(nd, WALK_MORE);
-		}
-		if (unlikely(link)) {
-			if (IS_ERR(link))
-				return PTR_ERR(link);
-			/* a symlink to follow */
-			nd->stack[depth++].name = name;
-			name = link;
-			continue;
-		}
-		if (unlikely(!d_can_lookup(nd->path.dentry))) {
-			if (nd->flags & LOOKUP_RCU) {
-				if (!try_to_unlazy(nd))
-					return -ECHILD;
-			}
-			return -ENOTDIR;
-		}
-	}
-}
-
-/* must be paired with terminate_walk() */
-static const char *path_init(struct nameidata *nd, unsigned flags)
-{
-	int error;
-	const char *s = nd->pathname;
-
-	/* LOOKUP_CACHED requires RCU, ask caller to retry */
-	if ((flags & (LOOKUP_RCU | LOOKUP_CACHED)) == LOOKUP_CACHED)
-		return ERR_PTR(-EAGAIN);
-
-	if (!*s)
-		flags &= ~LOOKUP_RCU;
-	if (flags & LOOKUP_RCU)
-		rcu_read_lock();
-	else
-		nd->seq = nd->next_seq = 0;
-
-	nd->flags = flags;
-	nd->state |= ND_JUMPED;
-
-	nd->m_seq = __read_seqcount_begin(&mount_lock.seqcount);
-	nd->r_seq = __read_seqcount_begin(&rename_lock.seqcount);
-	smp_rmb();
-
-	if (nd->state & ND_ROOT_PRESET) {
-		struct dentry *root = nd->root.dentry;
-		struct inode *inode = root->d_inode;
-		if (*s && unlikely(!d_can_lookup(root)))
-			return ERR_PTR(-ENOTDIR);
-		nd->path = nd->root;
-		nd->inode = inode;
-		if (flags & LOOKUP_RCU) {
-			nd->seq = read_seqcount_begin(&nd->path.dentry->d_seq);
-			nd->root_seq = nd->seq;
-		} else {
-			path_get(&nd->path);
-		}
-		return s;
-	}
-
-	nd->root.mnt = NULL;
-
-	/* Absolute pathname -- fetch the root (LOOKUP_IN_ROOT uses nd->dfd). */
-	if (*s == '/' && !(flags & LOOKUP_IN_ROOT)) {
-		error = nd_jump_root(nd);
-		if (unlikely(error))
-			return ERR_PTR(error);
-		return s;
-	}
-
-	/* Relative pathname -- get the starting-point it is relative to. */
-	if (nd->dfd == AT_FDCWD) {
-		if (flags & LOOKUP_RCU) {
-			struct fs_struct *fs = current->fs;
-			unsigned seq;
-
-			do {
-				seq = read_seqcount_begin(&fs->seq);
-				nd->path = fs->pwd;
-				nd->inode = nd->path.dentry->d_inode;
-				nd->seq = __read_seqcount_begin(&nd->path.dentry->d_seq);
-			} while (read_seqcount_retry(&fs->seq, seq));
-		} else {
-			get_fs_pwd(current->fs, &nd->path);
-			nd->inode = nd->path.dentry->d_inode;
-		}
-	} else {
-		/* Caller must check execute permissions on the starting path component */
-		CLASS(fd_raw, f)(nd->dfd);
-		struct dentry *dentry;
-
-		if (fd_empty(f))
-			return ERR_PTR(-EBADF);
-
-		if (flags & LOOKUP_LINKAT_EMPTY) {
-			if (fd_file(f)->f_cred != current_cred() &&
-			    !ns_capable(fd_file(f)->f_cred->user_ns, CAP_DAC_READ_SEARCH))
-				return ERR_PTR(-ENOENT);
-		}
-
-		dentry = fd_file(f)->f_path.dentry;
-
-		if (*s && unlikely(!d_can_lookup(dentry)))
-			return ERR_PTR(-ENOTDIR);
-
-		nd->path = fd_file(f)->f_path;
-		if (flags & LOOKUP_RCU) {
-			nd->inode = nd->path.dentry->d_inode;
-			nd->seq = read_seqcount_begin(&nd->path.dentry->d_seq);
-		} else {
-			path_get(&nd->path);
-			nd->inode = nd->path.dentry->d_inode;
-		}
-	}
-
-	/* For scoped-lookups we need to set the root to the dirfd as well. */
-	if (flags & LOOKUP_IS_SCOPED) {
-		nd->root = nd->path;
-		if (flags & LOOKUP_RCU) {
-			nd->root_seq = nd->seq;
-		} else {
-			path_get(&nd->root);
-			nd->state |= ND_ROOT_GRABBED;
-		}
-	}
-	return s;
-}
-
-static inline const char *lookup_last(struct nameidata *nd)
-{
-	if (nd->last_type == LAST_NORM && nd->last.name[nd->last.len])
-		nd->flags |= LOOKUP_FOLLOW | LOOKUP_DIRECTORY;
-
-	return walk_component(nd, WALK_TRAILING);
-}
-
-static int handle_lookup_down(struct nameidata *nd)
-{
-	if (!(nd->flags & LOOKUP_RCU))
-		dget(nd->path.dentry);
-	nd->next_seq = nd->seq;
-	return PTR_ERR(step_into(nd, WALK_NOFOLLOW, nd->path.dentry));
-}
-
-/* Returns 0 and nd will be valid on success; Returns error, otherwise. */
-static int path_lookupat(struct nameidata *nd, unsigned flags, struct path *path)
-{
-	const char *s = path_init(nd, flags);
-	int err;
-
-	if (unlikely(flags & LOOKUP_DOWN) && !IS_ERR(s)) {
-		err = handle_lookup_down(nd);
-		if (unlikely(err < 0))
-			s = ERR_PTR(err);
-	}
-
-	while (!(err = link_path_walk(s, nd)) &&
-	       (s = lookup_last(nd)) != NULL)
-		;
-	if (!err && unlikely(nd->flags & LOOKUP_MOUNTPOINT)) {
-		err = handle_lookup_down(nd);
-		nd->state &= ~ND_JUMPED; // no d_weak_revalidate(), please...
-	}
-	if (!err)
-		err = complete_walk(nd);
-
-	if (!err && nd->flags & LOOKUP_DIRECTORY)
-		if (!d_can_lookup(nd->path.dentry))
-			err = -ENOTDIR;
-	if (!err) {
-		*path = nd->path;
-		nd->path.mnt = NULL;
-		nd->path.dentry = NULL;
-	}
-	terminate_walk(nd);
-	return err;
-}
-
-int filename_lookup(int dfd, struct filename *name, unsigned flags,
-		    struct path *path, struct path *root)
-{
-	int retval;
-	struct nameidata nd;
-	if (IS_ERR(name))
-		return PTR_ERR(name);
-	set_nameidata(&nd, dfd, name, root);
-	retval = path_lookupat(&nd, flags | LOOKUP_RCU, path);
-	if (unlikely(retval == -ECHILD))
-		retval = path_lookupat(&nd, flags, path);
-	if (unlikely(retval == -ESTALE))
-		retval = path_lookupat(&nd, flags | LOOKUP_REVAL, path);
-
-	if (likely(!retval))
-		audit_inode(name, path->dentry,
-			    flags & LOOKUP_MOUNTPOINT ? AUDIT_INODE_NOEVAL : 0);
-	restore_nameidata();
-	return retval;
-}
-
-/* Returns 0 and nd will be valid on success; Returns error, otherwise. */
-static int path_parentat(struct nameidata *nd, unsigned flags,
-				struct path *parent)
-{
-	const char *s = path_init(nd, flags);
-	int err = link_path_walk(s, nd);
-	if (!err)
-		err = complete_walk(nd);
-	if (!err) {
-		*parent = nd->path;
-		nd->path.mnt = NULL;
-		nd->path.dentry = NULL;
-	}
-	terminate_walk(nd);
-	return err;
-}
-
-/* Note: this does not consume "name" */
-static int __filename_parentat(int dfd, struct filename *name,
-			       unsigned int flags, struct path *parent,
-			       struct qstr *last, int *type,
-			       const struct path *root)
-{
-	int retval;
-	struct nameidata nd;
-
-	if (IS_ERR(name))
-		return PTR_ERR(name);
-	set_nameidata(&nd, dfd, name, root);
-	retval = path_parentat(&nd, flags | LOOKUP_RCU, parent);
-	if (unlikely(retval == -ECHILD))
-		retval = path_parentat(&nd, flags, parent);
-	if (unlikely(retval == -ESTALE))
-		retval = path_parentat(&nd, flags | LOOKUP_REVAL, parent);
-	if (likely(!retval)) {
-		*last = nd.last;
-		*type = nd.last_type;
-		audit_inode(name, parent->dentry, AUDIT_INODE_PARENT);
-	}
-	restore_nameidata();
-	return retval;
-}
-
-static int filename_parentat(int dfd, struct filename *name,
-			     unsigned int flags, struct path *parent,
-			     struct qstr *last, int *type)
-{
-	return __filename_parentat(dfd, name, flags, parent, last, type, NULL);
-}
-
-/* does lookup, returns the object with parent locked */
-static struct dentry *__kern_path_locked(int dfd, struct filename *name, struct path *path)
-{
-	struct path parent_path __free(path_put) = {};
-	struct dentry *d;
-	struct qstr last;
-	int type, error;
-
-	error = filename_parentat(dfd, name, 0, &parent_path, &last, &type);
-	if (error)
-		return ERR_PTR(error);
-	if (unlikely(type != LAST_NORM))
-		return ERR_PTR(-EINVAL);
-	inode_lock_nested(parent_path.dentry->d_inode, I_MUTEX_PARENT);
-	d = lookup_one_qstr_excl(&last, parent_path.dentry, 0);
-	if (IS_ERR(d)) {
-		inode_unlock(parent_path.dentry->d_inode);
-		return d;
-	}
-	path->dentry = no_free_ptr(parent_path.dentry);
-	path->mnt = no_free_ptr(parent_path.mnt);
-	return d;
-}
-
-struct dentry *kern_path_locked_negative(const char *name, struct path *path)
-{
-	struct path parent_path __free(path_put) = {};
-	struct filename *filename __free(putname) = getname_kernel(name);
-	struct dentry *d;
-	struct qstr last;
-	int type, error;
-
-	error = filename_parentat(AT_FDCWD, filename, 0, &parent_path, &last, &type);
-	if (error)
-		return ERR_PTR(error);
-	if (unlikely(type != LAST_NORM))
-		return ERR_PTR(-EINVAL);
-	inode_lock_nested(parent_path.dentry->d_inode, I_MUTEX_PARENT);
-	d = lookup_one_qstr_excl_raw(&last, parent_path.dentry, 0);
-	if (IS_ERR(d)) {
-		inode_unlock(parent_path.dentry->d_inode);
-		return d;
-	}
-	path->dentry = no_free_ptr(parent_path.dentry);
-	path->mnt = no_free_ptr(parent_path.mnt);
-	return d;
-}
-
-struct dentry *kern_path_locked(const char *name, struct path *path)
-{
-	struct filename *filename = getname_kernel(name);
-	struct dentry *res = __kern_path_locked(AT_FDCWD, filename, path);
-
-	putname(filename);
-	return res;
-}
-
-struct dentry *user_path_locked_at(int dfd, const char __user *name, struct path *path)
-{
-	struct filename *filename = getname(name);
-	struct dentry *res = __kern_path_locked(dfd, filename, path);
-
-	putname(filename);
-	return res;
-}
-EXPORT_SYMBOL(user_path_locked_at);
-
-int kern_path(const char *name, unsigned int flags, struct path *path)
-{
-	struct filename *filename = getname_kernel(name);
-	int ret = filename_lookup(AT_FDCWD, filename, flags, path, NULL);
-
-	putname(filename);
-	return ret;
-
-}
-EXPORT_SYMBOL(kern_path);
-
-/**
- * vfs_path_parent_lookup - lookup a parent path relative to a dentry-vfsmount pair
- * @filename: filename structure
- * @flags: lookup flags
- * @parent: pointer to struct path to fill
- * @last: last component
- * @type: type of the last component
- * @root: pointer to struct path of the base directory
- */
-int vfs_path_parent_lookup(struct filename *filename, unsigned int flags,
-			   struct path *parent, struct qstr *last, int *type,
-			   const struct path *root)
-{
-	return  __filename_parentat(AT_FDCWD, filename, flags, parent, last,
-				    type, root);
-}
-EXPORT_SYMBOL(vfs_path_parent_lookup);
-
-/**
- * vfs_path_lookup - lookup a file path relative to a dentry-vfsmount pair
- * @dentry:  pointer to dentry of the base directory
- * @mnt: pointer to vfs mount of the base directory
- * @name: pointer to file name
- * @flags: lookup flags
- * @path: pointer to struct path to fill
- */
-int vfs_path_lookup(struct dentry *dentry, struct vfsmount *mnt,
-		    const char *name, unsigned int flags,
-		    struct path *path)
-{
-	struct filename *filename;
-	struct path root = {.mnt = mnt, .dentry = dentry};
-	int ret;
-
-	filename = getname_kernel(name);
-	/* the first argument of filename_lookup() is ignored with root */
-	ret = filename_lookup(AT_FDCWD, filename, flags, path, &root);
-	putname(filename);
-	return ret;
-}
-EXPORT_SYMBOL(vfs_path_lookup);
-
-static int lookup_noperm_common(struct qstr *qname, struct dentry *base)
-{
-	const char *name = qname->name;
-	u32 len = qname->len;
-
-	qname->hash = full_name_hash(base, name, len);
-	if (!len)
-		return -EACCES;
-
-	if (is_dot_dotdot(name, len))
-		return -EACCES;
-
-	while (len--) {
-		unsigned int c = *(const unsigned char *)name++;
-		if (c == '/' || c == '\0')
-			return -EACCES;
-	}
-	/*
-	 * See if the low-level filesystem might want
-	 * to use its own hash..
-	 */
-	if (base->d_flags & DCACHE_OP_HASH) {
-		int err = base->d_op->d_hash(base, qname);
-		if (err < 0)
-			return err;
-	}
-	return 0;
-}
-
-static int lookup_one_common(struct mnt_idmap *idmap,
-			     struct qstr *qname, struct dentry *base)
-{
-	int err;
-	err = lookup_noperm_common(qname, base);
-	if (err < 0)
-		return err;
-	return inode_permission(idmap, base->d_inode, MAY_EXEC);
-}
-
-/**
- * try_lookup_noperm - filesystem helper to lookup single pathname component
- * @name:	qstr storing pathname component to lookup
- * @base:	base directory to lookup from
- *
- * Look up a dentry by name in the dcache, returning NULL if it does not
- * currently exist.  The function does not try to create a dentry and if one
- * is found it doesn't try to revalidate it.
- *
- * Note that this routine is purely a helper for filesystem usage and should
- * not be called by generic code.  It does no permission checking.
- *
- * No locks need be held - only a counted reference to @base is needed.
- *
- */
-struct dentry *try_lookup_noperm(struct qstr *name, struct dentry *base)
-{
-	int err;
-
-	err = lookup_noperm_common(name, base);
-	if (err)
-		return ERR_PTR(err);
-
-	return d_lookup(base, name);
-}
-EXPORT_SYMBOL(try_lookup_noperm);
-
-/**
- * lookup_noperm - filesystem helper to lookup single pathname component
- * @name:	qstr storing pathname component to lookup
- * @base:	base directory to lookup from
- *
- * Note that this routine is purely a helper for filesystem usage and should
- * not be called by generic code.  It does no permission checking.
- *
- * The caller must hold base->i_mutex.
- */
-struct dentry *lookup_noperm(struct qstr *name, struct dentry *base)
-{
-	struct dentry *dentry;
-	int err;
-
-	WARN_ON_ONCE(!inode_is_locked(base->d_inode));
-
-	err = lookup_noperm_common(name, base);
-	if (err)
-		return ERR_PTR(err);
-
-	dentry = lookup_dcache(name, base, 0);
-	return dentry ? dentry : __lookup_slow(name, base, 0);
-}
-EXPORT_SYMBOL(lookup_noperm);
-
-/**
- * lookup_one - lookup single pathname component
- * @idmap:	idmap of the mount the lookup is performed from
- * @name:	qstr holding pathname component to lookup
- * @base:	base directory to lookup from
- *
- * This can be used for in-kernel filesystem clients such as file servers.
- *
- * The caller must hold base->i_mutex.
- */
-struct dentry *lookup_one(struct mnt_idmap *idmap, struct qstr *name,
-			  struct dentry *base)
-{
-	struct dentry *dentry;
-	int err;
-
-	WARN_ON_ONCE(!inode_is_locked(base->d_inode));
-
-	err = lookup_one_common(idmap, name, base);
-	if (err)
-		return ERR_PTR(err);
-
-	dentry = lookup_dcache(name, base, 0);
-	return dentry ? dentry : __lookup_slow(name, base, 0);
-}
-EXPORT_SYMBOL(lookup_one);
-
-/**
- * lookup_one_unlocked - lookup single pathname component
- * @idmap:	idmap of the mount the lookup is performed from
- * @name:	qstr olding pathname component to lookup
- * @base:	base directory to lookup from
- *
- * This can be used for in-kernel filesystem clients such as file servers.
- *
- * Unlike lookup_one, it should be called without the parent
- * i_rwsem held, and will take the i_rwsem itself if necessary.
- */
-struct dentry *lookup_one_unlocked(struct mnt_idmap *idmap, struct qstr *name,
-				   struct dentry *base)
-{
-	int err;
-	struct dentry *ret;
-
-	err = lookup_one_common(idmap, name, base);
-	if (err)
-		return ERR_PTR(err);
-
-	ret = lookup_dcache(name, base, 0);
-	if (!ret)
-		ret = lookup_slow(name, base, 0);
-	return ret;
-}
-EXPORT_SYMBOL(lookup_one_unlocked);
-
-/**
- * lookup_one_positive_unlocked - lookup single pathname component
- * @idmap:	idmap of the mount the lookup is performed from
- * @name:	qstr holding pathname component to lookup
- * @base:	base directory to lookup from
- *
- * This helper will yield ERR_PTR(-ENOENT) on negatives. The helper returns
- * known positive or ERR_PTR(). This is what most of the users want.
- *
- * Note that pinned negative with unlocked parent _can_ become positive at any
- * time, so callers of lookup_one_unlocked() need to be very careful; pinned
- * positives have >d_inode stable, so this one avoids such problems.
- *
- * This can be used for in-kernel filesystem clients such as file servers.
- *
- * The helper should be called without i_rwsem held.
- */
-struct dentry *lookup_one_positive_unlocked(struct mnt_idmap *idmap,
-					    struct qstr *name,
-					    struct dentry *base)
-{
-	struct dentry *ret = lookup_one_unlocked(idmap, name, base);
-
-	if (!IS_ERR(ret) && d_flags_negative(smp_load_acquire(&ret->d_flags))) {
-		dput(ret);
-		ret = ERR_PTR(-ENOENT);
-	}
-	return ret;
-}
-EXPORT_SYMBOL(lookup_one_positive_unlocked);
-
-/**
- * lookup_noperm_unlocked - filesystem helper to lookup single pathname component
- * @name:	pathname component to lookup
- * @base:	base directory to lookup from
- *
- * Note that this routine is purely a helper for filesystem usage and should
- * not be called by generic code. It does no permission checking.
- *
- * Unlike lookup_noperm(), it should be called without the parent
- * i_rwsem held, and will take the i_rwsem itself if necessary.
- *
- * Unlike try_lookup_noperm() it *does* revalidate the dentry if it already
- * existed.
- */
-struct dentry *lookup_noperm_unlocked(struct qstr *name, struct dentry *base)
-{
-	struct dentry *ret;
-	int err;
-
-	err = lookup_noperm_common(name, base);
-	if (err)
-		return ERR_PTR(err);
-
-	ret = lookup_dcache(name, base, 0);
-	if (!ret)
-		ret = lookup_slow(name, base, 0);
-	return ret;
-}
-EXPORT_SYMBOL(lookup_noperm_unlocked);
-
-/*
- * Like lookup_noperm_unlocked(), except that it yields ERR_PTR(-ENOENT)
- * on negatives.  Returns known positive or ERR_PTR(); that's what
- * most of the users want.  Note that pinned negative with unlocked parent
- * _can_ become positive at any time, so callers of lookup_noperm_unlocked()
- * need to be very careful; pinned positives have ->d_inode stable, so
- * this one avoids such problems.
- */
-struct dentry *lookup_noperm_positive_unlocked(struct qstr *name,
-					       struct dentry *base)
-{
-	struct dentry *ret;
-
-	ret = lookup_noperm_unlocked(name, base);
-	if (!IS_ERR(ret) && d_flags_negative(smp_load_acquire(&ret->d_flags))) {
-		dput(ret);
-		ret = ERR_PTR(-ENOENT);
-	}
-	return ret;
-}
-EXPORT_SYMBOL(lookup_noperm_positive_unlocked);
-
-#ifdef CONFIG_UNIX98_PTYS
-int path_pts(struct path *path)
-{
-	/* Find something mounted on "pts" in the same directory as
-	 * the input path.
-	 */
-	struct dentry *parent = dget_parent(path->dentry);
-	struct dentry *child;
-	struct qstr this = QSTR_INIT("pts", 3);
-
-	if (unlikely(!path_connected(path->mnt, parent))) {
-		dput(parent);
-		return -ENOENT;
-	}
-	dput(path->dentry);
-	path->dentry = parent;
-	child = d_hash_and_lookup(parent, &this);
-	if (IS_ERR_OR_NULL(child))
-		return -ENOENT;
-
-	path->dentry = child;
-	dput(parent);
-	follow_down(path, 0);
-	return 0;
-}
-#endif
-
-int user_path_at(int dfd, const char __user *name, unsigned flags,
-		 struct path *path)
-{
-	struct filename *filename = getname_flags(name, flags);
-	int ret = filename_lookup(dfd, filename, flags, path, NULL);
-
-	putname(filename);
-	return ret;
-}
-EXPORT_SYMBOL(user_path_at);
-
-int __check_sticky(struct mnt_idmap *idmap, struct inode *dir,
-		   struct inode *inode)
-{
-	kuid_t fsuid = current_fsuid();
-
-	if (vfsuid_eq_kuid(i_uid_into_vfsuid(idmap, inode), fsuid))
-		return 0;
-	if (vfsuid_eq_kuid(i_uid_into_vfsuid(idmap, dir), fsuid))
-		return 0;
-	return !capable_wrt_inode_uidgid(idmap, inode, CAP_FOWNER);
-}
-EXPORT_SYMBOL(__check_sticky);
-
-/*
- *	Check whether we can remove a link victim from directory dir, check
- *  whether the type of victim is right.
- *  1. We can't do it if dir is read-only (done in permission())
- *  2. We should have write and exec permissions on dir
- *  3. We can't remove anything from append-only dir
- *  4. We can't do anything with immutable dir (done in permission())
- *  5. If the sticky bit on dir is set we should either
- *	a. be owner of dir, or
- *	b. be owner of victim, or
- *	c. have CAP_FOWNER capability
- *  6. If the victim is append-only or immutable we can't do antyhing with
- *     links pointing to it.
- *  7. If the victim has an unknown uid or gid we can't change the inode.
- *  8. If we were asked to remove a directory and victim isn't one - ENOTDIR.
- *  9. If we were asked to remove a non-directory and victim isn't one - EISDIR.
- * 10. We can't remove a root or mountpoint.
- * 11. We don't allow removal of NFS sillyrenamed files; it's handled by
- *     nfs_async_unlink().
- */
-static int may_delete(struct mnt_idmap *idmap, struct inode *dir,
-		      struct dentry *victim, bool isdir)
-{
-	struct inode *inode = d_backing_inode(victim);
-	int error;
-
-	if (d_is_negative(victim))
-		return -ENOENT;
-	BUG_ON(!inode);
-
-	BUG_ON(victim->d_parent->d_inode != dir);
-
-	/* Inode writeback is not safe when the uid or gid are invalid. */
-	if (!vfsuid_valid(i_uid_into_vfsuid(idmap, inode)) ||
-	    !vfsgid_valid(i_gid_into_vfsgid(idmap, inode)))
-		return -EOVERFLOW;
-
-	audit_inode_child(dir, victim, AUDIT_TYPE_CHILD_DELETE);
-
-	error = inode_permission(idmap, dir, MAY_WRITE | MAY_EXEC);
-	if (error)
-		return error;
-	if (IS_APPEND(dir))
-		return -EPERM;
-
-	if (check_sticky(idmap, dir, inode) || IS_APPEND(inode) ||
-	    IS_IMMUTABLE(inode) || IS_SWAPFILE(inode) ||
-	    HAS_UNMAPPED_ID(idmap, inode))
-		return -EPERM;
-	if (isdir) {
-		if (!d_is_dir(victim))
-			return -ENOTDIR;
-		if (IS_ROOT(victim))
-			return -EBUSY;
-	} else if (d_is_dir(victim))
-		return -EISDIR;
-	if (IS_DEADDIR(dir))
-		return -ENOENT;
-	if (victim->d_flags & DCACHE_NFSFS_RENAMED)
-		return -EBUSY;
-	return 0;
-}
-
-/*	Check whether we can create an object with dentry child in directory
- *  dir.
- *  1. We can't do it if child already exists (open has special treatment for
- *     this case, but since we are inlined it's OK)
- *  2. We can't do it if dir is read-only (done in permission())
- *  3. We can't do it if the fs can't represent the fsuid or fsgid.
- *  4. We should have write and exec permissions on dir
- *  5. We can't do it if dir is immutable (done in permission())
- */
-static inline int may_create(struct mnt_idmap *idmap,
-			     struct inode *dir, struct dentry *child)
-{
-	audit_inode_child(dir, child, AUDIT_TYPE_CHILD_CREATE);
-	if (child->d_inode)
-		return -EEXIST;
-	if (IS_DEADDIR(dir))
-		return -ENOENT;
-	if (!fsuidgid_has_mapping(dir->i_sb, idmap))
-		return -EOVERFLOW;
-
-	return inode_permission(idmap, dir, MAY_WRITE | MAY_EXEC);
-}
-
-// p1 != p2, both are on the same filesystem, ->s_vfs_rename_mutex is held
-static struct dentry *lock_two_directories(struct dentry *p1, struct dentry *p2)
-{
-	struct dentry *p = p1, *q = p2, *r;
-
-	while ((r = p->d_parent) != p2 && r != p)
-		p = r;
-	if (r == p2) {
-		// p is a child of p2 and an ancestor of p1 or p1 itself
-		inode_lock_nested(p2->d_inode, I_MUTEX_PARENT);
-		inode_lock_nested(p1->d_inode, I_MUTEX_PARENT2);
-		return p;
-	}
-	// p is the root of connected component that contains p1
-	// p2 does not occur on the path from p to p1
-	while ((r = q->d_parent) != p1 && r != p && r != q)
-		q = r;
-	if (r == p1) {
-		// q is a child of p1 and an ancestor of p2 or p2 itself
-		inode_lock_nested(p1->d_inode, I_MUTEX_PARENT);
-		inode_lock_nested(p2->d_inode, I_MUTEX_PARENT2);
-		return q;
-	} else if (likely(r == p)) {
-		// both p2 and p1 are descendents of p
-		inode_lock_nested(p1->d_inode, I_MUTEX_PARENT);
-		inode_lock_nested(p2->d_inode, I_MUTEX_PARENT2);
-		return NULL;
-	} else { // no common ancestor at the time we'd been called
-		mutex_unlock(&p1->d_sb->s_vfs_rename_mutex);
-		return ERR_PTR(-EXDEV);
-	}
-}
-
-/*
- * p1 and p2 should be directories on the same fs.
- */
-struct dentry *lock_rename(struct dentry *p1, struct dentry *p2)
-{
-	if (p1 == p2) {
-		inode_lock_nested(p1->d_inode, I_MUTEX_PARENT);
-		return NULL;
-	}
-
-	mutex_lock(&p1->d_sb->s_vfs_rename_mutex);
-	return lock_two_directories(p1, p2);
-}
-EXPORT_SYMBOL(lock_rename);
-
-/*
- * c1 and p2 should be on the same fs.
- */
-struct dentry *lock_rename_child(struct dentry *c1, struct dentry *p2)
-{
-	if (READ_ONCE(c1->d_parent) == p2) {
-		/*
-		 * hopefully won't need to touch ->s_vfs_rename_mutex at all.
-		 */
-		inode_lock_nested(p2->d_inode, I_MUTEX_PARENT);
-		/*
-		 * now that p2 is locked, nobody can move in or out of it,
-		 * so the test below is safe.
-		 */
-		if (likely(c1->d_parent == p2))
-			return NULL;
-
-		/*
-		 * c1 got moved out of p2 while we'd been taking locks;
-		 * unlock and fall back to slow case.
-		 */
-		inode_unlock(p2->d_inode);
-	}
-
-	mutex_lock(&c1->d_sb->s_vfs_rename_mutex);
-	/*
-	 * nobody can move out of any directories on this fs.
-	 */
-	if (likely(c1->d_parent != p2))
-		return lock_two_directories(c1->d_parent, p2);
-
-	/*
-	 * c1 got moved into p2 while we were taking locks;
-	 * we need p2 locked and ->s_vfs_rename_mutex unlocked,
-	 * for consistency with lock_rename().
-	 */
-	inode_lock_nested(p2->d_inode, I_MUTEX_PARENT);
-	mutex_unlock(&c1->d_sb->s_vfs_rename_mutex);
-	return NULL;
-}
-EXPORT_SYMBOL(lock_rename_child);
-
-void unlock_rename(struct dentry *p1, struct dentry *p2)
-{
-	inode_unlock(p1->d_inode);
-	if (p1 != p2) {
-		inode_unlock(p2->d_inode);
-		mutex_unlock(&p1->d_sb->s_vfs_rename_mutex);
-	}
-}
-EXPORT_SYMBOL(unlock_rename);
-
-/**
- * vfs_prepare_mode - prepare the mode to be used for a new inode
- * @idmap:	idmap of the mount the inode was found from
- * @dir:	parent directory of the new inode
- * @mode:	mode of the new inode
- * @mask_perms:	allowed permission by the vfs
- * @type:	type of file to be created
- *
- * This helper consolidates and enforces vfs restrictions on the @mode of a new
- * object to be created.
- *
- * Umask stripping depends on whether the filesystem supports POSIX ACLs (see
- * the kernel documentation for mode_strip_umask()). Moving umask stripping
- * after setgid stripping allows the same ordering for both non-POSIX ACL and
- * POSIX ACL supporting filesystems.
- *
- * Note that it's currently valid for @type to be 0 if a directory is created.
- * Filesystems raise that flag individually and we need to check whether each
- * filesystem can deal with receiving S_IFDIR from the vfs before we enforce a
- * non-zero type.
- *
- * Returns: mode to be passed to the filesystem
- */
-static inline umode_t vfs_prepare_mode(struct mnt_idmap *idmap,
-				       const struct inode *dir, umode_t mode,
-				       umode_t mask_perms, umode_t type)
-{
-	mode = mode_strip_sgid(idmap, dir, mode);
-	mode = mode_strip_umask(dir, mode);
-
-	/*
-	 * Apply the vfs mandated allowed permission mask and set the type of
-	 * file to be created before we call into the filesystem.
-	 */
-	mode &= (mask_perms & ~S_IFMT);
-	mode |= (type & S_IFMT);
-
-	return mode;
-}
-
-/**
- * vfs_create - create new file
- * @idmap:	idmap of the mount the inode was found from
- * @dir:	inode of the parent directory
- * @dentry:	dentry of the child file
- * @mode:	mode of the child file
- * @want_excl:	whether the file must not yet exist
- *
- * Create a new file.
- *
- * If the inode has been found through an idmapped mount the idmap of
- * the vfsmount must be passed through @idmap. This function will then take
- * care to map the inode according to @idmap before checking permissions.
- * On non-idmapped mounts or if permission checking is to be performed on the
- * raw inode simply pass @nop_mnt_idmap.
- */
-int vfs_create(struct mnt_idmap *idmap, struct inode *dir,
-	       struct dentry *dentry, umode_t mode, bool want_excl)
-{
-	int error;
-
-	error = may_create(idmap, dir, dentry);
-	if (error)
-		return error;
-
-	if (!dir->i_op->create)
-		return -EACCES;	/* shouldn't it be ENOSYS? */
-
-	mode = vfs_prepare_mode(idmap, dir, mode, S_IALLUGO, S_IFREG);
-	error = security_inode_create(dir, dentry, mode);
-	if (error)
-		return error;
-	error = dir->i_op->create(idmap, dir, dentry, mode, want_excl);
-	if (!error)
-		fsnotify_create(dir, dentry);
-	return error;
-}
-EXPORT_SYMBOL(vfs_create);
-
-int vfs_mkobj(struct dentry *dentry, umode_t mode,
-		int (*f)(struct dentry *, umode_t, void *),
-		void *arg)
-{
-	struct inode *dir = dentry->d_parent->d_inode;
-	int error = may_create(&nop_mnt_idmap, dir, dentry);
-	if (error)
-		return error;
-
-	mode &= S_IALLUGO;
-	mode |= S_IFREG;
-	error = security_inode_create(dir, dentry, mode);
-	if (error)
-		return error;
-	error = f(dentry, mode, arg);
-	if (!error)
-		fsnotify_create(dir, dentry);
-	return error;
-}
-EXPORT_SYMBOL(vfs_mkobj);
-
-bool may_open_dev(const struct path *path)
-{
-	return !(path->mnt->mnt_flags & MNT_NODEV) &&
-		!(path->mnt->mnt_sb->s_iflags & SB_I_NODEV);
-}
-
-static int may_open(struct mnt_idmap *idmap, const struct path *path,
-		    int acc_mode, int flag)
-{
-	struct dentry *dentry = path->dentry;
-	struct inode *inode = dentry->d_inode;
-	int error;
-
-	if (!inode)
-		return -ENOENT;
-
-	switch (inode->i_mode & S_IFMT) {
-	case S_IFLNK:
-		return -ELOOP;
-	case S_IFDIR:
-		if (acc_mode & MAY_WRITE)
-			return -EISDIR;
-		if (acc_mode & MAY_EXEC)
-			return -EACCES;
-		break;
-	case S_IFBLK:
-	case S_IFCHR:
-		if (!may_open_dev(path))
-			return -EACCES;
-		fallthrough;
-	case S_IFIFO:
-	case S_IFSOCK:
-		if (acc_mode & MAY_EXEC)
-			return -EACCES;
-		flag &= ~O_TRUNC;
-		break;
-	case S_IFREG:
-		if ((acc_mode & MAY_EXEC) && path_noexec(path))
-			return -EACCES;
-		break;
-	default:
-		VFS_BUG_ON_INODE(!IS_ANON_FILE(inode), inode);
-	}
-
-	error = inode_permission(idmap, inode, MAY_OPEN | acc_mode);
-	if (error)
-		return error;
-
-	/*
-	 * An append-only file must be opened in append mode for writing.
-	 */
-	if (IS_APPEND(inode)) {
-		if  ((flag & O_ACCMODE) != O_RDONLY && !(flag & O_APPEND))
-			return -EPERM;
-		if (flag & O_TRUNC)
-			return -EPERM;
-	}
-
-	/* O_NOATIME can only be set by the owner or superuser */
-	if (flag & O_NOATIME && !inode_owner_or_capable(idmap, inode))
-		return -EPERM;
-
-	return 0;
-}
-
-static int handle_truncate(struct mnt_idmap *idmap, struct file *filp)
-{
-	const struct path *path = &filp->f_path;
-	struct inode *inode = path->dentry->d_inode;
-	int error = get_write_access(inode);
-	if (error)
-		return error;
-
-	error = security_file_truncate(filp);
-	if (!error) {
-		error = do_truncate(idmap, path->dentry, 0,
-				    ATTR_MTIME|ATTR_CTIME|ATTR_OPEN,
-				    filp);
-	}
-	put_write_access(inode);
-	return error;
-}
-
-static inline int open_to_namei_flags(int flag)
-{
-	if ((flag & O_ACCMODE) == 3)
-		flag--;
-	return flag;
-}
-
-static int may_o_create(struct mnt_idmap *idmap,
-			const struct path *dir, struct dentry *dentry,
-			umode_t mode)
-{
-	int error = security_path_mknod(dir, dentry, mode, 0);
-	if (error)
-		return error;
-
-	if (!fsuidgid_has_mapping(dir->dentry->d_sb, idmap))
-		return -EOVERFLOW;
-
-	error = inode_permission(idmap, dir->dentry->d_inode,
-				 MAY_WRITE | MAY_EXEC);
-	if (error)
-		return error;
-
-	return security_inode_create(dir->dentry->d_inode, dentry, mode);
-}
-
-/*
- * Attempt to atomically look up, create and open a file from a negative
- * dentry.
- *
- * Returns 0 if successful.  The file will have been created and attached to
- * @file by the filesystem calling finish_open().
- *
- * If the file was looked up only or didn't need creating, FMODE_OPENED won't
- * be set.  The caller will need to perform the open themselves.  @path will
- * have been updated to point to the new dentry.  This may be negative.
- *
- * Returns an error code otherwise.
- */
-static struct dentry *atomic_open(struct nameidata *nd, struct dentry *dentry,
-				  struct file *file,
-				  int open_flag, umode_t mode)
-{
-	struct dentry *const DENTRY_NOT_SET = (void *) -1UL;
-	struct inode *dir =  nd->path.dentry->d_inode;
-	int error;
-
-	if (nd->flags & LOOKUP_DIRECTORY)
-		open_flag |= O_DIRECTORY;
-
-	file->f_path.dentry = DENTRY_NOT_SET;
-	file->f_path.mnt = nd->path.mnt;
-	error = dir->i_op->atomic_open(dir, dentry, file,
-				       open_to_namei_flags(open_flag), mode);
-	d_lookup_done(dentry);
-	if (!error) {
-		if (file->f_mode & FMODE_OPENED) {
-			if (unlikely(dentry != file->f_path.dentry)) {
-				dput(dentry);
-				dentry = dget(file->f_path.dentry);
-			}
-		} else if (WARN_ON(file->f_path.dentry == DENTRY_NOT_SET)) {
-			error = -EIO;
-		} else {
-			if (file->f_path.dentry) {
-				dput(dentry);
-				dentry = file->f_path.dentry;
-			}
-			if (unlikely(d_is_negative(dentry)))
-				error = -ENOENT;
-		}
-	}
-	if (error) {
-		dput(dentry);
-		dentry = ERR_PTR(error);
-	}
-	return dentry;
-}
-
-/*
- * Look up and maybe create and open the last component.
- *
- * Must be called with parent locked (exclusive in O_CREAT case).
- *
- * Returns 0 on success, that is, if
- *  the file was successfully atomically created (if necessary) and opened, or
- *  the file was not completely opened at this time, though lookups and
- *  creations were performed.
- * These case are distinguished by presence of FMODE_OPENED on file->f_mode.
- * In the latter case dentry returned in @path might be negative if O_CREAT
- * hadn't been specified.
- *
- * An error code is returned on failure.
- */
-static struct dentry *lookup_open(struct nameidata *nd, struct file *file,
-				  const struct open_flags *op,
-				  bool got_write)
-{
-	struct mnt_idmap *idmap;
-	struct dentry *dir = nd->path.dentry;
-	struct inode *dir_inode = dir->d_inode;
-	int open_flag = op->open_flag;
-	struct dentry *dentry;
-	int error, create_error = 0;
-	umode_t mode = op->mode;
-	DECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq);
-
-	if (unlikely(IS_DEADDIR(dir_inode)))
-		return ERR_PTR(-ENOENT);
-
-	file->f_mode &= ~FMODE_CREATED;
-	dentry = d_lookup(dir, &nd->last);
-	for (;;) {
-		if (!dentry) {
-			dentry = d_alloc_parallel(dir, &nd->last, &wq);
-			if (IS_ERR(dentry))
-				return dentry;
-		}
-		if (d_in_lookup(dentry))
-			break;
-
-		error = d_revalidate(dir_inode, &nd->last, dentry, nd->flags);
-		if (likely(error > 0))
-			break;
-		if (error)
-			goto out_dput;
-		d_invalidate(dentry);
-		dput(dentry);
-		dentry = NULL;
-	}
-	if (dentry->d_inode) {
-		/* Cached positive dentry: will open in f_op->open */
-		return dentry;
-	}
-
-	if (open_flag & O_CREAT)
-		audit_inode(nd->name, dir, AUDIT_INODE_PARENT);
-
-	/*
-	 * Checking write permission is tricky, bacuse we don't know if we are
-	 * going to actually need it: O_CREAT opens should work as long as the
-	 * file exists.  But checking existence breaks atomicity.  The trick is
-	 * to check access and if not granted clear O_CREAT from the flags.
-	 *
-	 * Another problem is returing the "right" error value (e.g. for an
-	 * O_EXCL open we want to return EEXIST not EROFS).
-	 */
-	if (unlikely(!got_write))
-		open_flag &= ~O_TRUNC;
-	idmap = mnt_idmap(nd->path.mnt);
-	if (open_flag & O_CREAT) {
-		if (open_flag & O_EXCL)
-			open_flag &= ~O_TRUNC;
-		mode = vfs_prepare_mode(idmap, dir->d_inode, mode, mode, mode);
-		if (likely(got_write))
-			create_error = may_o_create(idmap, &nd->path,
-						    dentry, mode);
-		else
-			create_error = -EROFS;
-	}
-	if (create_error)
-		open_flag &= ~O_CREAT;
-	if (dir_inode->i_op->atomic_open) {
-		dentry = atomic_open(nd, dentry, file, open_flag, mode);
-		if (unlikely(create_error) && dentry == ERR_PTR(-ENOENT))
-			dentry = ERR_PTR(create_error);
-		return dentry;
-	}
-
-	if (d_in_lookup(dentry)) {
-		struct dentry *res = dir_inode->i_op->lookup(dir_inode, dentry,
-							     nd->flags);
-		d_lookup_done(dentry);
-		if (unlikely(res)) {
-			if (IS_ERR(res)) {
-				error = PTR_ERR(res);
-				goto out_dput;
-			}
-			dput(dentry);
-			dentry = res;
-		}
-	}
-
-	/* Negative dentry, just create the file */
-	if (!dentry->d_inode && (open_flag & O_CREAT)) {
-		file->f_mode |= FMODE_CREATED;
-		audit_inode_child(dir_inode, dentry, AUDIT_TYPE_CHILD_CREATE);
-		if (!dir_inode->i_op->create) {
-			error = -EACCES;
-			goto out_dput;
-		}
-
-		error = dir_inode->i_op->create(idmap, dir_inode, dentry,
-						mode, open_flag & O_EXCL);
-		if (error)
-			goto out_dput;
-	}
-	if (unlikely(create_error) && !dentry->d_inode) {
-		error = create_error;
-		goto out_dput;
-	}
-	return dentry;
-
-out_dput:
-	dput(dentry);
-	return ERR_PTR(error);
-}
-
-static inline bool trailing_slashes(struct nameidata *nd)
-{
-	return (bool)nd->last.name[nd->last.len];
-}
-
-static struct dentry *lookup_fast_for_open(struct nameidata *nd, int open_flag)
-{
-	struct dentry *dentry;
-
-	if (open_flag & O_CREAT) {
-		if (trailing_slashes(nd))
-			return ERR_PTR(-EISDIR);
-
-		/* Don't bother on an O_EXCL create */
-		if (open_flag & O_EXCL)
-			return NULL;
-	}
-
-	if (trailing_slashes(nd))
-		nd->flags |= LOOKUP_FOLLOW | LOOKUP_DIRECTORY;
-
-	dentry = lookup_fast(nd);
-	if (IS_ERR_OR_NULL(dentry))
-		return dentry;
-
-	if (open_flag & O_CREAT) {
-		/* Discard negative dentries. Need inode_lock to do the create */
-		if (!dentry->d_inode) {
-			if (!(nd->flags & LOOKUP_RCU))
-				dput(dentry);
-			dentry = NULL;
-		}
-	}
-	return dentry;
-}
-
-static const char *open_last_lookups(struct nameidata *nd,
-		   struct file *file, const struct open_flags *op)
-{
-	struct dentry *dir = nd->path.dentry;
-	int open_flag = op->open_flag;
-	bool got_write = false;
-	struct dentry *dentry;
-	const char *res;
-
-	nd->flags |= op->intent;
-
-	if (nd->last_type != LAST_NORM) {
-		if (nd->depth)
-			put_link(nd);
-		return handle_dots(nd, nd->last_type);
-	}
-
-	/* We _can_ be in RCU mode here */
-	dentry = lookup_fast_for_open(nd, open_flag);
-	if (IS_ERR(dentry))
-		return ERR_CAST(dentry);
-
-	if (likely(dentry))
-		goto finish_lookup;
-
-	if (!(open_flag & O_CREAT)) {
-		if (WARN_ON_ONCE(nd->flags & LOOKUP_RCU))
-			return ERR_PTR(-ECHILD);
-	} else {
-		if (nd->flags & LOOKUP_RCU) {
-			if (!try_to_unlazy(nd))
-				return ERR_PTR(-ECHILD);
-		}
-	}
-
-	if (open_flag & (O_CREAT | O_TRUNC | O_WRONLY | O_RDWR)) {
-		got_write = !mnt_want_write(nd->path.mnt);
-		/*
-		 * do _not_ fail yet - we might not need that or fail with
-		 * a different error; let lookup_open() decide; we'll be
-		 * dropping this one anyway.
-		 */
-	}
-	if (open_flag & O_CREAT)
-		inode_lock(dir->d_inode);
-	else
-		inode_lock_shared(dir->d_inode);
-	dentry = lookup_open(nd, file, op, got_write);
-	if (!IS_ERR(dentry)) {
-		if (file->f_mode & FMODE_CREATED)
-			fsnotify_create(dir->d_inode, dentry);
-		if (file->f_mode & FMODE_OPENED)
-			fsnotify_open(file);
-	}
-	if (open_flag & O_CREAT)
-		inode_unlock(dir->d_inode);
-	else
-		inode_unlock_shared(dir->d_inode);
-
-	if (got_write)
-		mnt_drop_write(nd->path.mnt);
-
-	if (IS_ERR(dentry))
-		return ERR_CAST(dentry);
-
-	if (file->f_mode & (FMODE_OPENED | FMODE_CREATED)) {
-		dput(nd->path.dentry);
-		nd->path.dentry = dentry;
-		return NULL;
-	}
-
-finish_lookup:
-	if (nd->depth)
-		put_link(nd);
-	res = step_into(nd, WALK_TRAILING, dentry);
-	if (unlikely(res))
-		nd->flags &= ~(LOOKUP_OPEN|LOOKUP_CREATE|LOOKUP_EXCL);
-	return res;
-}
-
-/*
- * Handle the last step of open()
- */
-static int do_open(struct nameidata *nd,
-		   struct file *file, const struct open_flags *op)
-{
-	struct mnt_idmap *idmap;
-	int open_flag = op->open_flag;
-	bool do_truncate;
-	int acc_mode;
-	int error;
-
-	if (!(file->f_mode & (FMODE_OPENED | FMODE_CREATED))) {
-		error = complete_walk(nd);
-		if (error)
-			return error;
-	}
-	if (!(file->f_mode & FMODE_CREATED))
-		audit_inode(nd->name, nd->path.dentry, 0);
-	idmap = mnt_idmap(nd->path.mnt);
-	if (open_flag & O_CREAT) {
-		if ((open_flag & O_EXCL) && !(file->f_mode & FMODE_CREATED))
-			return -EEXIST;
-		if (d_is_dir(nd->path.dentry))
-			return -EISDIR;
-		error = may_create_in_sticky(idmap, nd,
-					     d_backing_inode(nd->path.dentry));
-		if (unlikely(error))
-			return error;
-	}
-	if ((nd->flags & LOOKUP_DIRECTORY) && !d_can_lookup(nd->path.dentry))
-		return -ENOTDIR;
-
-	do_truncate = false;
-	acc_mode = op->acc_mode;
-	if (file->f_mode & FMODE_CREATED) {
-		/* Don't check for write permission, don't truncate */
-		open_flag &= ~O_TRUNC;
-		acc_mode = 0;
-	} else if (d_is_reg(nd->path.dentry) && open_flag & O_TRUNC) {
-		error = mnt_want_write(nd->path.mnt);
-		if (error)
-			return error;
-		do_truncate = true;
-	}
-	error = may_open(idmap, &nd->path, acc_mode, open_flag);
-	if (!error && !(file->f_mode & FMODE_OPENED))
-		error = vfs_open(&nd->path, file);
-	if (!error)
-		error = security_file_post_open(file, op->acc_mode);
-	if (!error && do_truncate)
-		error = handle_truncate(idmap, file);
-	if (unlikely(error > 0)) {
-		WARN_ON(1);
-		error = -EINVAL;
-	}
-	if (do_truncate)
-		mnt_drop_write(nd->path.mnt);
-	return error;
-}
-
-/**
- * vfs_tmpfile - create tmpfile
- * @idmap:	idmap of the mount the inode was found from
- * @parentpath:	pointer to the path of the base directory
- * @file:	file descriptor of the new tmpfile
- * @mode:	mode of the new tmpfile
- *
- * Create a temporary file.
- *
- * If the inode has been found through an idmapped mount the idmap of
- * the vfsmount must be passed through @idmap. This function will then take
- * care to map the inode according to @idmap before checking permissions.
- * On non-idmapped mounts or if permission checking is to be performed on the
- * raw inode simply pass @nop_mnt_idmap.
- */
-int vfs_tmpfile(struct mnt_idmap *idmap,
-		const struct path *parentpath,
-		struct file *file, umode_t mode)
-{
-	struct dentry *child;
-	struct inode *dir = d_inode(parentpath->dentry);
-	struct inode *inode;
-	int error;
-	int open_flag = file->f_flags;
-
-	/* we want directory to be writable */
-	error = inode_permission(idmap, dir, MAY_WRITE | MAY_EXEC);
-	if (error)
-		return error;
-	if (!dir->i_op->tmpfile)
-		return -EOPNOTSUPP;
-	child = d_alloc(parentpath->dentry, &slash_name);
-	if (unlikely(!child))
-		return -ENOMEM;
-	file->f_path.mnt = parentpath->mnt;
-	file->f_path.dentry = child;
-	mode = vfs_prepare_mode(idmap, dir, mode, mode, mode);
-	error = dir->i_op->tmpfile(idmap, dir, file, mode);
-	dput(child);
-	if (file->f_mode & FMODE_OPENED)
-		fsnotify_open(file);
-	if (error)
-		return error;
-	/* Don't check for other permissions, the inode was just created */
-	error = may_open(idmap, &file->f_path, 0, file->f_flags);
-	if (error)
-		return error;
-	inode = file_inode(file);
-	if (!(open_flag & O_EXCL)) {
-		spin_lock(&inode->i_lock);
-		inode->i_state |= I_LINKABLE;
-		spin_unlock(&inode->i_lock);
-	}
-	security_inode_post_create_tmpfile(idmap, inode);
-	return 0;
-}
-
-/**
- * kernel_tmpfile_open - open a tmpfile for kernel internal use
- * @idmap:	idmap of the mount the inode was found from
- * @parentpath:	path of the base directory
- * @mode:	mode of the new tmpfile
- * @open_flag:	flags
- * @cred:	credentials for open
- *
- * Create and open a temporary file.  The file is not accounted in nr_files,
- * hence this is only for kernel internal use, and must not be installed into
- * file tables or such.
- */
-struct file *kernel_tmpfile_open(struct mnt_idmap *idmap,
-				 const struct path *parentpath,
-				 umode_t mode, int open_flag,
-				 const struct cred *cred)
-{
-	struct file *file;
-	int error;
-
-	file = alloc_empty_file_noaccount(open_flag, cred);
-	if (IS_ERR(file))
-		return file;
-
-	error = vfs_tmpfile(idmap, parentpath, file, mode);
-	if (error) {
-		fput(file);
-		file = ERR_PTR(error);
-	}
-	return file;
-}
-EXPORT_SYMBOL(kernel_tmpfile_open);
-
-static int do_tmpfile(struct nameidata *nd, unsigned flags,
-		const struct open_flags *op,
-		struct file *file)
-{
-	struct path path;
-	int error = path_lookupat(nd, flags | LOOKUP_DIRECTORY, &path);
-
-	if (unlikely(error))
-		return error;
-	error = mnt_want_write(path.mnt);
-	if (unlikely(error))
-		goto out;
-	error = vfs_tmpfile(mnt_idmap(path.mnt), &path, file, op->mode);
-	if (error)
-		goto out2;
-	audit_inode(nd->name, file->f_path.dentry, 0);
-out2:
-	mnt_drop_write(path.mnt);
-out:
-	path_put(&path);
-	return error;
-}
-
-static int do_o_path(struct nameidata *nd, unsigned flags, struct file *file)
-{
-	struct path path;
-	int error = path_lookupat(nd, flags, &path);
-	if (!error) {
-		audit_inode(nd->name, path.dentry, 0);
-		error = vfs_open(&path, file);
-		path_put(&path);
-	}
-	return error;
-}
-
-static struct file *path_openat(struct nameidata *nd,
-			const struct open_flags *op, unsigned flags)
-{
-	struct file *file;
-	int error;
-
-	file = alloc_empty_file(op->open_flag, current_cred());
-	if (IS_ERR(file))
-		return file;
-
-	if (unlikely(file->f_flags & __O_TMPFILE)) {
-		error = do_tmpfile(nd, flags, op, file);
-	} else if (unlikely(file->f_flags & O_PATH)) {
-		error = do_o_path(nd, flags, file);
-	} else {
-		const char *s = path_init(nd, flags);
-		while (!(error = link_path_walk(s, nd)) &&
-		       (s = open_last_lookups(nd, file, op)) != NULL)
-			;
-		if (!error)
-			error = do_open(nd, file, op);
-		terminate_walk(nd);
-	}
-	if (likely(!error)) {
-		if (likely(file->f_mode & FMODE_OPENED))
-			return file;
-		WARN_ON(1);
-		error = -EINVAL;
-	}
-	fput_close(file);
-	if (error == -EOPENSTALE) {
-		if (flags & LOOKUP_RCU)
-			error = -ECHILD;
-		else
-			error = -ESTALE;
-	}
-	return ERR_PTR(error);
-}
-
-struct file *do_filp_open(int dfd, struct filename *pathname,
-		const struct open_flags *op)
-{
-	struct nameidata nd;
-	int flags = op->lookup_flags;
-	struct file *filp;
-
-	set_nameidata(&nd, dfd, pathname, NULL);
-	filp = path_openat(&nd, op, flags | LOOKUP_RCU);
-	if (unlikely(filp == ERR_PTR(-ECHILD)))
-		filp = path_openat(&nd, op, flags);
-	if (unlikely(filp == ERR_PTR(-ESTALE)))
-		filp = path_openat(&nd, op, flags | LOOKUP_REVAL);
-	restore_nameidata();
-	return filp;
-}
-
-struct file *do_file_open_root(const struct path *root,
-		const char *name, const struct open_flags *op)
-{
-	struct nameidata nd;
-	struct file *file;
-	struct filename *filename;
-	int flags = op->lookup_flags;
-
-	if (d_is_symlink(root->dentry) && op->intent & LOOKUP_OPEN)
-		return ERR_PTR(-ELOOP);
-
-	filename = getname_kernel(name);
-	if (IS_ERR(filename))
-		return ERR_CAST(filename);
-
-	set_nameidata(&nd, -1, filename, root);
-	file = path_openat(&nd, op, flags | LOOKUP_RCU);
-	if (unlikely(file == ERR_PTR(-ECHILD)))
-		file = path_openat(&nd, op, flags);
-	if (unlikely(file == ERR_PTR(-ESTALE)))
-		file = path_openat(&nd, op, flags | LOOKUP_REVAL);
-	restore_nameidata();
-	putname(filename);
-	return file;
-}
-
-static struct dentry *filename_create(int dfd, struct filename *name,
-				      struct path *path, unsigned int lookup_flags)
-{
-	struct dentry *dentry = ERR_PTR(-EEXIST);
-	struct qstr last;
-	bool want_dir = lookup_flags & LOOKUP_DIRECTORY;
-	unsigned int reval_flag = lookup_flags & LOOKUP_REVAL;
-	unsigned int create_flags = LOOKUP_CREATE | LOOKUP_EXCL;
-	int type;
-	int err2;
-	int error;
-
-	error = filename_parentat(dfd, name, reval_flag, path, &last, &type);
-	if (error)
-		return ERR_PTR(error);
-
-	/*
-	 * Yucky last component or no last component at all?
-	 * (foo/., foo/.., /////)
-	 */
-	if (unlikely(type != LAST_NORM))
-		goto out;
-
-	/* don't fail immediately if it's r/o, at least try to report other errors */
-	err2 = mnt_want_write(path->mnt);
-	/*
-	 * Do the final lookup.  Suppress 'create' if there is a trailing
-	 * '/', and a directory wasn't requested.
-	 */
-	if (last.name[last.len] && !want_dir)
-		create_flags &= ~LOOKUP_CREATE;
-	inode_lock_nested(path->dentry->d_inode, I_MUTEX_PARENT);
-	dentry = lookup_one_qstr_excl(&last, path->dentry,
-				      reval_flag | create_flags);
-	if (IS_ERR(dentry))
-		goto unlock;
-
-	if (unlikely(err2)) {
-		error = err2;
-		goto fail;
-	}
-	return dentry;
-fail:
-	dput(dentry);
-	dentry = ERR_PTR(error);
-unlock:
-	inode_unlock(path->dentry->d_inode);
-	if (!err2)
-		mnt_drop_write(path->mnt);
-out:
-	path_put(path);
-	return dentry;
-}
-
-struct dentry *kern_path_create(int dfd, const char *pathname,
-				struct path *path, unsigned int lookup_flags)
-{
-	struct filename *filename = getname_kernel(pathname);
-	struct dentry *res = filename_create(dfd, filename, path, lookup_flags);
-
-	putname(filename);
-	return res;
-}
-EXPORT_SYMBOL(kern_path_create);
-
-void done_path_create(struct path *path, struct dentry *dentry)
-{
-	if (!IS_ERR(dentry))
-		dput(dentry);
-	inode_unlock(path->dentry->d_inode);
-	mnt_drop_write(path->mnt);
-	path_put(path);
-}
-EXPORT_SYMBOL(done_path_create);
-
-inline struct dentry *user_path_create(int dfd, const char __user *pathname,
-				struct path *path, unsigned int lookup_flags)
-{
-	struct filename *filename = getname(pathname);
-	struct dentry *res = filename_create(dfd, filename, path, lookup_flags);
-
-	putname(filename);
-	return res;
-}
-EXPORT_SYMBOL(user_path_create);
-
-/**
- * vfs_mknod - create device node or file
- * @idmap:	idmap of the mount the inode was found from
- * @dir:	inode of the parent directory
- * @dentry:	dentry of the child device node
- * @mode:	mode of the child device node
- * @dev:	device number of device to create
- *
- * Create a device node or file.
- *
- * If the inode has been found through an idmapped mount the idmap of
- * the vfsmount must be passed through @idmap. This function will then take
- * care to map the inode according to @idmap before checking permissions.
- * On non-idmapped mounts or if permission checking is to be performed on the
- * raw inode simply pass @nop_mnt_idmap.
- */
-int vfs_mknod(struct mnt_idmap *idmap, struct inode *dir,
-	      struct dentry *dentry, umode_t mode, dev_t dev)
-{
-	bool is_whiteout = S_ISCHR(mode) && dev == WHITEOUT_DEV;
-	int error = may_create(idmap, dir, dentry);
-
-	if (error)
-		return error;
-
-	if ((S_ISCHR(mode) || S_ISBLK(mode)) && !is_whiteout &&
-	    !capable(CAP_MKNOD))
-		return -EPERM;
-
-	if (!dir->i_op->mknod)
-		return -EPERM;
-
-	mode = vfs_prepare_mode(idmap, dir, mode, mode, mode);
-	error = devcgroup_inode_mknod(mode, dev);
-	if (error)
-		return error;
-
-	error = security_inode_mknod(dir, dentry, mode, dev);
-	if (error)
-		return error;
-
-	error = dir->i_op->mknod(idmap, dir, dentry, mode, dev);
-	if (!error)
-		fsnotify_create(dir, dentry);
-	return error;
-}
-EXPORT_SYMBOL(vfs_mknod);
-
-static int may_mknod(umode_t mode)
-{
-	switch (mode & S_IFMT) {
-	case S_IFREG:
-	case S_IFCHR:
-	case S_IFBLK:
-	case S_IFIFO:
-	case S_IFSOCK:
-	case 0: /* zero mode translates to S_IFREG */
-		return 0;
-	case S_IFDIR:
-		return -EPERM;
-	default:
-		return -EINVAL;
-	}
-}
-
-static int do_mknodat(int dfd, struct filename *name, umode_t mode,
-		unsigned int dev)
-{
-	struct mnt_idmap *idmap;
-	struct dentry *dentry;
-	struct path path;
-	int error;
-	unsigned int lookup_flags = 0;
-
-	error = may_mknod(mode);
-	if (error)
-		goto out1;
-retry:
-	dentry = filename_create(dfd, name, &path, lookup_flags);
-	error = PTR_ERR(dentry);
-	if (IS_ERR(dentry))
-		goto out1;
-
-	error = security_path_mknod(&path, dentry,
-			mode_strip_umask(path.dentry->d_inode, mode), dev);
-	if (error)
-		goto out2;
-
-	idmap = mnt_idmap(path.mnt);
-	switch (mode & S_IFMT) {
-		case 0: case S_IFREG:
-			error = vfs_create(idmap, path.dentry->d_inode,
-					   dentry, mode, true);
-			if (!error)
-				security_path_post_mknod(idmap, dentry);
-			break;
-		case S_IFCHR: case S_IFBLK:
-			error = vfs_mknod(idmap, path.dentry->d_inode,
-					  dentry, mode, new_decode_dev(dev));
-			break;
-		case S_IFIFO: case S_IFSOCK:
-			error = vfs_mknod(idmap, path.dentry->d_inode,
-					  dentry, mode, 0);
-			break;
-	}
-out2:
-	done_path_create(&path, dentry);
-	if (retry_estale(error, lookup_flags)) {
-		lookup_flags |= LOOKUP_REVAL;
-		goto retry;
-	}
-out1:
-	putname(name);
-	return error;
-}
-
-SYSCALL_DEFINE4(mknodat, int, dfd, const char __user *, filename, umode_t, mode,
-		unsigned int, dev)
-{
-	return do_mknodat(dfd, getname(filename), mode, dev);
-}
-
-SYSCALL_DEFINE3(mknod, const char __user *, filename, umode_t, mode, unsigned, dev)
-{
-	return do_mknodat(AT_FDCWD, getname(filename), mode, dev);
-}
-
-/**
- * vfs_mkdir - create directory returning correct dentry if possible
- * @idmap:	idmap of the mount the inode was found from
- * @dir:	inode of the parent directory
- * @dentry:	dentry of the child directory
- * @mode:	mode of the child directory
- *
- * Create a directory.
- *
- * If the inode has been found through an idmapped mount the idmap of
- * the vfsmount must be passed through @idmap. This function will then take
- * care to map the inode according to @idmap before checking permissions.
- * On non-idmapped mounts or if permission checking is to be performed on the
- * raw inode simply pass @nop_mnt_idmap.
- *
- * In the event that the filesystem does not use the *@dentry but leaves it
- * negative or unhashes it and possibly splices a different one returning it,
- * the original dentry is dput() and the alternate is returned.
- *
- * In case of an error the dentry is dput() and an ERR_PTR() is returned.
- */
-struct dentry *vfs_mkdir(struct mnt_idmap *idmap, struct inode *dir,
-			 struct dentry *dentry, umode_t mode)
-{
-	int error;
-	unsigned max_links = dir->i_sb->s_max_links;
-	struct dentry *de;
-
-	error = may_create(idmap, dir, dentry);
-	if (error)
-		goto err;
-
-	error = -EPERM;
-	if (!dir->i_op->mkdir)
-		goto err;
-
-	mode = vfs_prepare_mode(idmap, dir, mode, S_IRWXUGO | S_ISVTX, 0);
-	error = security_inode_mkdir(dir, dentry, mode);
-	if (error)
-		goto err;
-
-	error = -EMLINK;
-	if (max_links && dir->i_nlink >= max_links)
-		goto err;
-
-	de = dir->i_op->mkdir(idmap, dir, dentry, mode);
-	error = PTR_ERR(de);
-	if (IS_ERR(de))
-		goto err;
-	if (de) {
-		dput(dentry);
-		dentry = de;
-	}
-	fsnotify_mkdir(dir, dentry);
-	return dentry;
-
-err:
-	dput(dentry);
-	return ERR_PTR(error);
-}
-EXPORT_SYMBOL(vfs_mkdir);
-
-int do_mkdirat(int dfd, struct filename *name, umode_t mode)
-{
-	struct dentry *dentry;
-	struct path path;
-	int error;
-	unsigned int lookup_flags = LOOKUP_DIRECTORY;
-
-retry:
-	dentry = filename_create(dfd, name, &path, lookup_flags);
-	error = PTR_ERR(dentry);
-	if (IS_ERR(dentry))
-		goto out_putname;
-
-	error = security_path_mkdir(&path, dentry,
-			mode_strip_umask(path.dentry->d_inode, mode));
-	if (!error) {
-		dentry = vfs_mkdir(mnt_idmap(path.mnt), path.dentry->d_inode,
-				  dentry, mode);
-		if (IS_ERR(dentry))
-			error = PTR_ERR(dentry);
-	}
-	done_path_create(&path, dentry);
-	if (retry_estale(error, lookup_flags)) {
-		lookup_flags |= LOOKUP_REVAL;
-		goto retry;
-	}
-out_putname:
-	putname(name);
-	return error;
-}
-
-SYSCALL_DEFINE3(mkdirat, int, dfd, const char __user *, pathname, umode_t, mode)
-{
-	return do_mkdirat(dfd, getname(pathname), mode);
-}
-
-SYSCALL_DEFINE2(mkdir, const char __user *, pathname, umode_t, mode)
-{
-	return do_mkdirat(AT_FDCWD, getname(pathname), mode);
-}
-
-/**
- * vfs_rmdir - remove directory
- * @idmap:	idmap of the mount the inode was found from
- * @dir:	inode of the parent directory
- * @dentry:	dentry of the child directory
- *
- * Remove a directory.
- *
- * If the inode has been found through an idmapped mount the idmap of
- * the vfsmount must be passed through @idmap. This function will then take
- * care to map the inode according to @idmap before checking permissions.
- * On non-idmapped mounts or if permission checking is to be performed on the
- * raw inode simply pass @nop_mnt_idmap.
- */
-int vfs_rmdir(struct mnt_idmap *idmap, struct inode *dir,
-		     struct dentry *dentry)
-{
-	int error = may_delete(idmap, dir, dentry, 1);
-
-	if (error)
-		return error;
-
-	if (!dir->i_op->rmdir)
-		return -EPERM;
-
-	dget(dentry);
-	inode_lock(dentry->d_inode);
-
-	error = -EBUSY;
-	if (is_local_mountpoint(dentry) ||
-	    (dentry->d_inode->i_flags & S_KERNEL_FILE))
-		goto out;
-
-	error = security_inode_rmdir(dir, dentry);
-	if (error)
-		goto out;
-
-	error = dir->i_op->rmdir(dir, dentry);
-	if (error)
-		goto out;
-
-	shrink_dcache_parent(dentry);
-	dentry->d_inode->i_flags |= S_DEAD;
-	dont_mount(dentry);
-	detach_mounts(dentry);
-
-out:
-	inode_unlock(dentry->d_inode);
-	dput(dentry);
-	if (!error)
-		d_delete_notify(dir, dentry);
-	return error;
-}
-EXPORT_SYMBOL(vfs_rmdir);
-
-int do_rmdir(int dfd, struct filename *name)
-{
-	int error;
-	struct dentry *dentry;
-	struct path path;
-	struct qstr last;
-	int type;
-	unsigned int lookup_flags = 0;
-retry:
-	error = filename_parentat(dfd, name, lookup_flags, &path, &last, &type);
-	if (error)
-		goto exit1;
-
-	switch (type) {
-	case LAST_DOTDOT:
-		error = -ENOTEMPTY;
-		goto exit2;
-	case LAST_DOT:
-		error = -EINVAL;
-		goto exit2;
-	case LAST_ROOT:
-		error = -EBUSY;
-		goto exit2;
-	}
-
-	error = mnt_want_write(path.mnt);
-	if (error)
-		goto exit2;
-
-	inode_lock_nested(path.dentry->d_inode, I_MUTEX_PARENT);
-	dentry = lookup_one_qstr_excl(&last, path.dentry, lookup_flags);
-	error = PTR_ERR(dentry);
-	if (IS_ERR(dentry))
-		goto exit3;
-	error = security_path_rmdir(&path, dentry);
-	if (error)
-		goto exit4;
-	error = vfs_rmdir(mnt_idmap(path.mnt), path.dentry->d_inode, dentry);
-exit4:
-	dput(dentry);
-exit3:
-	inode_unlock(path.dentry->d_inode);
-	mnt_drop_write(path.mnt);
-exit2:
-	path_put(&path);
-	if (retry_estale(error, lookup_flags)) {
-		lookup_flags |= LOOKUP_REVAL;
-		goto retry;
-	}
-exit1:
-	putname(name);
-	return error;
-}
-
-SYSCALL_DEFINE1(rmdir, const char __user *, pathname)
-{
-	return do_rmdir(AT_FDCWD, getname(pathname));
-}
-
-/**
- * vfs_unlink - unlink a filesystem object
- * @idmap:	idmap of the mount the inode was found from
- * @dir:	parent directory
- * @dentry:	victim
- * @delegated_inode: returns victim inode, if the inode is delegated.
- *
- * The caller must hold dir->i_mutex.
- *
- * If vfs_unlink discovers a delegation, it will return -EWOULDBLOCK and
- * return a reference to the inode in delegated_inode.  The caller
- * should then break the delegation on that inode and retry.  Because
- * breaking a delegation may take a long time, the caller should drop
- * dir->i_mutex before doing so.
- *
- * Alternatively, a caller may pass NULL for delegated_inode.  This may
- * be appropriate for callers that expect the underlying filesystem not
- * to be NFS exported.
- *
- * If the inode has been found through an idmapped mount the idmap of
- * the vfsmount must be passed through @idmap. This function will then take
- * care to map the inode according to @idmap before checking permissions.
- * On non-idmapped mounts or if permission checking is to be performed on the
- * raw inode simply pass @nop_mnt_idmap.
- */
-int vfs_unlink(struct mnt_idmap *idmap, struct inode *dir,
-	       struct dentry *dentry, struct inode **delegated_inode)
-{
-	struct inode *target = dentry->d_inode;
-	int error = may_delete(idmap, dir, dentry, 0);
-
-	if (error)
-		return error;
-
-	if (!dir->i_op->unlink)
-		return -EPERM;
-
-	inode_lock(target);
-	if (IS_SWAPFILE(target))
-		error = -EPERM;
-	else if (is_local_mountpoint(dentry))
-		error = -EBUSY;
-	else {
-		error = security_inode_unlink(dir, dentry);
-		if (!error) {
-			error = try_break_deleg(target, delegated_inode);
-			if (error)
-				goto out;
-			error = dir->i_op->unlink(dir, dentry);
-			if (!error) {
-				dont_mount(dentry);
-				detach_mounts(dentry);
-			}
-		}
-	}
-out:
-	inode_unlock(target);
-
-	/* We don't d_delete() NFS sillyrenamed files--they still exist. */
-	if (!error && dentry->d_flags & DCACHE_NFSFS_RENAMED) {
-		fsnotify_unlink(dir, dentry);
-	} else if (!error) {
-		fsnotify_link_count(target);
-		d_delete_notify(dir, dentry);
-	}
-
-	return error;
-}
-EXPORT_SYMBOL(vfs_unlink);
-
-/*
- * Make sure that the actual truncation of the file will occur outside its
- * directory's i_mutex.  Truncate can take a long time if there is a lot of
- * writeout happening, and we don't want to prevent access to the directory
- * while waiting on the I/O.
- */
-int do_unlinkat(int dfd, struct filename *name)
-{
-	int error;
-	struct dentry *dentry;
-	struct path path;
-	struct qstr last;
-	int type;
-	struct inode *inode = NULL;
-	struct inode *delegated_inode = NULL;
-	unsigned int lookup_flags = 0;
-retry:
-	error = filename_parentat(dfd, name, lookup_flags, &path, &last, &type);
-	if (error)
-		goto exit1;
-
-	error = -EISDIR;
-	if (type != LAST_NORM)
-		goto exit2;
-
-	error = mnt_want_write(path.mnt);
-	if (error)
-		goto exit2;
-retry_deleg:
-	inode_lock_nested(path.dentry->d_inode, I_MUTEX_PARENT);
-	dentry = lookup_one_qstr_excl(&last, path.dentry, lookup_flags);
-	error = PTR_ERR(dentry);
-	if (!IS_ERR(dentry)) {
-
-		/* Why not before? Because we want correct error value */
-		if (last.name[last.len])
-			goto slashes;
-		inode = dentry->d_inode;
-		ihold(inode);
-		error = security_path_unlink(&path, dentry);
-		if (error)
-			goto exit3;
-		error = vfs_unlink(mnt_idmap(path.mnt), path.dentry->d_inode,
-				   dentry, &delegated_inode);
-exit3:
-		dput(dentry);
-	}
-	inode_unlock(path.dentry->d_inode);
-	if (inode)
-		iput(inode);	/* truncate the inode here */
-	inode = NULL;
-	if (delegated_inode) {
-		error = break_deleg_wait(&delegated_inode);
-		if (!error)
-			goto retry_deleg;
-	}
-	mnt_drop_write(path.mnt);
-exit2:
-	path_put(&path);
-	if (retry_estale(error, lookup_flags)) {
-		lookup_flags |= LOOKUP_REVAL;
-		inode = NULL;
-		goto retry;
-	}
-exit1:
-	putname(name);
-	return error;
-
-slashes:
-	if (d_is_dir(dentry))
-		error = -EISDIR;
-	else
-		error = -ENOTDIR;
-	goto exit3;
-}
-
-SYSCALL_DEFINE3(unlinkat, int, dfd, const char __user *, pathname, int, flag)
-{
-	if ((flag & ~AT_REMOVEDIR) != 0)
-		return -EINVAL;
-
-	if (flag & AT_REMOVEDIR)
-		return do_rmdir(dfd, getname(pathname));
-	return do_unlinkat(dfd, getname(pathname));
-}
-
-SYSCALL_DEFINE1(unlink, const char __user *, pathname)
-{
-	return do_unlinkat(AT_FDCWD, getname(pathname));
-}
-
-/**
- * vfs_symlink - create symlink
- * @idmap:	idmap of the mount the inode was found from
- * @dir:	inode of the parent directory
- * @dentry:	dentry of the child symlink file
- * @oldname:	name of the file to link to
- *
- * Create a symlink.
- *
- * If the inode has been found through an idmapped mount the idmap of
- * the vfsmount must be passed through @idmap. This function will then take
- * care to map the inode according to @idmap before checking permissions.
- * On non-idmapped mounts or if permission checking is to be performed on the
- * raw inode simply pass @nop_mnt_idmap.
- */
-int vfs_symlink(struct mnt_idmap *idmap, struct inode *dir,
-		struct dentry *dentry, const char *oldname)
-{
-	int error;
-
-	error = may_create(idmap, dir, dentry);
-	if (error)
-		return error;
-
-	if (!dir->i_op->symlink)
-		return -EPERM;
-
-	error = security_inode_symlink(dir, dentry, oldname);
-	if (error)
-		return error;
-
-	error = dir->i_op->symlink(idmap, dir, dentry, oldname);
-	if (!error)
-		fsnotify_create(dir, dentry);
-	return error;
-}
-EXPORT_SYMBOL(vfs_symlink);
-
-int do_symlinkat(struct filename *from, int newdfd, struct filename *to)
-{
-	int error;
-	struct dentry *dentry;
-	struct path path;
-	unsigned int lookup_flags = 0;
-
-	if (IS_ERR(from)) {
-		error = PTR_ERR(from);
-		goto out_putnames;
-	}
-retry:
-	dentry = filename_create(newdfd, to, &path, lookup_flags);
-	error = PTR_ERR(dentry);
-	if (IS_ERR(dentry))
-		goto out_putnames;
-
-	error = security_path_symlink(&path, dentry, from->name);
-	if (!error)
-		error = vfs_symlink(mnt_idmap(path.mnt), path.dentry->d_inode,
-				    dentry, from->name);
-	done_path_create(&path, dentry);
-	if (retry_estale(error, lookup_flags)) {
-		lookup_flags |= LOOKUP_REVAL;
-		goto retry;
-	}
-out_putnames:
-	putname(to);
-	putname(from);
-	return error;
-}
-
-SYSCALL_DEFINE3(symlinkat, const char __user *, oldname,
-		int, newdfd, const char __user *, newname)
-{
-	return do_symlinkat(getname(oldname), newdfd, getname(newname));
-}
-
-SYSCALL_DEFINE2(symlink, const char __user *, oldname, const char __user *, newname)
-{
-	return do_symlinkat(getname(oldname), AT_FDCWD, getname(newname));
-}
-
-/**
- * vfs_link - create a new link
- * @old_dentry:	object to be linked
- * @idmap:	idmap of the mount
- * @dir:	new parent
- * @new_dentry:	where to create the new link
- * @delegated_inode: returns inode needing a delegation break
- *
- * The caller must hold dir->i_mutex
- *
- * If vfs_link discovers a delegation on the to-be-linked file in need
- * of breaking, it will return -EWOULDBLOCK and return a reference to the
- * inode in delegated_inode.  The caller should then break the delegation
- * and retry.  Because breaking a delegation may take a long time, the
- * caller should drop the i_mutex before doing so.
- *
- * Alternatively, a caller may pass NULL for delegated_inode.  This may
- * be appropriate for callers that expect the underlying filesystem not
- * to be NFS exported.
- *
- * If the inode has been found through an idmapped mount the idmap of
- * the vfsmount must be passed through @idmap. This function will then take
- * care to map the inode according to @idmap before checking permissions.
- * On non-idmapped mounts or if permission checking is to be performed on the
- * raw inode simply pass @nop_mnt_idmap.
- */
-int vfs_link(struct dentry *old_dentry, struct mnt_idmap *idmap,
-	     struct inode *dir, struct dentry *new_dentry,
-	     struct inode **delegated_inode)
-{
-	struct inode *inode = old_dentry->d_inode;
-	unsigned max_links = dir->i_sb->s_max_links;
-	int error;
-
-	if (!inode)
-		return -ENOENT;
-
-	error = may_create(idmap, dir, new_dentry);
-	if (error)
-		return error;
-
-	if (dir->i_sb != inode->i_sb)
-		return -EXDEV;
-
-	/*
-	 * A link to an append-only or immutable file cannot be created.
-	 */
-	if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
-		return -EPERM;
-	/*
-	 * Updating the link count will likely cause i_uid and i_gid to
-	 * be writen back improperly if their true value is unknown to
-	 * the vfs.
-	 */
-	if (HAS_UNMAPPED_ID(idmap, inode))
-		return -EPERM;
-	if (!dir->i_op->link)
-		return -EPERM;
-	if (S_ISDIR(inode->i_mode))
-		return -EPERM;
-
-	error = security_inode_link(old_dentry, dir, new_dentry);
-	if (error)
-		return error;
-
-	inode_lock(inode);
-	/* Make sure we don't allow creating hardlink to an unlinked file */
-	if (inode->i_nlink == 0 && !(inode->i_state & I_LINKABLE))
-		error =  -ENOENT;
-	else if (max_links && inode->i_nlink >= max_links)
-		error = -EMLINK;
-	else {
-		error = try_break_deleg(inode, delegated_inode);
-		if (!error)
-			error = dir->i_op->link(old_dentry, dir, new_dentry);
-	}
-
-	if (!error && (inode->i_state & I_LINKABLE)) {
-		spin_lock(&inode->i_lock);
-		inode->i_state &= ~I_LINKABLE;
-		spin_unlock(&inode->i_lock);
-	}
-	inode_unlock(inode);
-	if (!error)
-		fsnotify_link(dir, inode, new_dentry);
-	return error;
-}
-EXPORT_SYMBOL(vfs_link);
-
-/*
- * Hardlinks are often used in delicate situations.  We avoid
- * security-related surprises by not following symlinks on the
- * newname.  --KAB
- *
- * We don't follow them on the oldname either to be compatible
- * with linux 2.0, and to avoid hard-linking to directories
- * and other special files.  --ADM
- */
-int do_linkat(int olddfd, struct filename *old, int newdfd,
-	      struct filename *new, int flags)
-{
-	struct mnt_idmap *idmap;
-	struct dentry *new_dentry;
-	struct path old_path, new_path;
-	struct inode *delegated_inode = NULL;
-	int how = 0;
-	int error;
-
-	if ((flags & ~(AT_SYMLINK_FOLLOW | AT_EMPTY_PATH)) != 0) {
-		error = -EINVAL;
-		goto out_putnames;
-	}
-	/*
-	 * To use null names we require CAP_DAC_READ_SEARCH or
-	 * that the open-time creds of the dfd matches current.
-	 * This ensures that not everyone will be able to create
-	 * a hardlink using the passed file descriptor.
-	 */
-	if (flags & AT_EMPTY_PATH)
-		how |= LOOKUP_LINKAT_EMPTY;
-
-	if (flags & AT_SYMLINK_FOLLOW)
-		how |= LOOKUP_FOLLOW;
-retry:
-	error = filename_lookup(olddfd, old, how, &old_path, NULL);
-	if (error)
-		goto out_putnames;
-
-	new_dentry = filename_create(newdfd, new, &new_path,
-					(how & LOOKUP_REVAL));
-	error = PTR_ERR(new_dentry);
-	if (IS_ERR(new_dentry))
-		goto out_putpath;
-
-	error = -EXDEV;
-	if (old_path.mnt != new_path.mnt)
-		goto out_dput;
-	idmap = mnt_idmap(new_path.mnt);
-	error = may_linkat(idmap, &old_path);
-	if (unlikely(error))
-		goto out_dput;
-	error = security_path_link(old_path.dentry, &new_path, new_dentry);
-	if (error)
-		goto out_dput;
-	error = vfs_link(old_path.dentry, idmap, new_path.dentry->d_inode,
-			 new_dentry, &delegated_inode);
-out_dput:
-	done_path_create(&new_path, new_dentry);
-	if (delegated_inode) {
-		error = break_deleg_wait(&delegated_inode);
-		if (!error) {
-			path_put(&old_path);
-			goto retry;
-		}
-	}
-	if (retry_estale(error, how)) {
-		path_put(&old_path);
-		how |= LOOKUP_REVAL;
-		goto retry;
-	}
-out_putpath:
-	path_put(&old_path);
-out_putnames:
-	putname(old);
-	putname(new);
-
-	return error;
-}
-
-SYSCALL_DEFINE5(linkat, int, olddfd, const char __user *, oldname,
-		int, newdfd, const char __user *, newname, int, flags)
-{
-	return do_linkat(olddfd, getname_uflags(oldname, flags),
-		newdfd, getname(newname), flags);
-}
-
-SYSCALL_DEFINE2(link, const char __user *, oldname, const char __user *, newname)
-{
-	return do_linkat(AT_FDCWD, getname(oldname), AT_FDCWD, getname(newname), 0);
-}
-
-/**
- * vfs_rename - rename a filesystem object
- * @rd:		pointer to &struct renamedata info
- *
- * The caller must hold multiple mutexes--see lock_rename()).
- *
- * If vfs_rename discovers a delegation in need of breaking at either
- * the source or destination, it will return -EWOULDBLOCK and return a
- * reference to the inode in delegated_inode.  The caller should then
- * break the delegation and retry.  Because breaking a delegation may
- * take a long time, the caller should drop all locks before doing
- * so.
- *
- * Alternatively, a caller may pass NULL for delegated_inode.  This may
- * be appropriate for callers that expect the underlying filesystem not
- * to be NFS exported.
- *
- * The worst of all namespace operations - renaming directory. "Perverted"
- * doesn't even start to describe it. Somebody in UCB had a heck of a trip...
- * Problems:
- *
- *	a) we can get into loop creation.
- *	b) race potential - two innocent renames can create a loop together.
- *	   That's where 4.4BSD screws up. Current fix: serialization on
- *	   sb->s_vfs_rename_mutex. We might be more accurate, but that's another
- *	   story.
- *	c) we may have to lock up to _four_ objects - parents and victim (if it exists),
- *	   and source (if it's a non-directory or a subdirectory that moves to
- *	   different parent).
- *	   And that - after we got ->i_mutex on parents (until then we don't know
- *	   whether the target exists).  Solution: try to be smart with locking
- *	   order for inodes.  We rely on the fact that tree topology may change
- *	   only under ->s_vfs_rename_mutex _and_ that parent of the object we
- *	   move will be locked.  Thus we can rank directories by the tree
- *	   (ancestors first) and rank all non-directories after them.
- *	   That works since everybody except rename does "lock parent, lookup,
- *	   lock child" and rename is under ->s_vfs_rename_mutex.
- *	   HOWEVER, it relies on the assumption that any object with ->lookup()
- *	   has no more than 1 dentry.  If "hybrid" objects will ever appear,
- *	   we'd better make sure that there's no link(2) for them.
- *	d) conversion from fhandle to dentry may come in the wrong moment - when
- *	   we are removing the target. Solution: we will have to grab ->i_mutex
- *	   in the fhandle_to_dentry code. [FIXME - current nfsfh.c relies on
- *	   ->i_mutex on parents, which works but leads to some truly excessive
- *	   locking].
- */
-int vfs_rename(struct renamedata *rd)
-{
-	int error;
-	struct inode *old_dir = rd->old_dir, *new_dir = rd->new_dir;
-	struct dentry *old_dentry = rd->old_dentry;
-	struct dentry *new_dentry = rd->new_dentry;
-	struct inode **delegated_inode = rd->delegated_inode;
-	unsigned int flags = rd->flags;
-	bool is_dir = d_is_dir(old_dentry);
-	struct inode *source = old_dentry->d_inode;
-	struct inode *target = new_dentry->d_inode;
-	bool new_is_dir = false;
-	unsigned max_links = new_dir->i_sb->s_max_links;
-	struct name_snapshot old_name;
-	bool lock_old_subdir, lock_new_subdir;
-
-	if (source == target)
-		return 0;
-
-	error = may_delete(rd->old_mnt_idmap, old_dir, old_dentry, is_dir);
-	if (error)
-		return error;
-
-	if (!target) {
-		error = may_create(rd->new_mnt_idmap, new_dir, new_dentry);
-	} else {
-		new_is_dir = d_is_dir(new_dentry);
-
-		if (!(flags & RENAME_EXCHANGE))
-			error = may_delete(rd->new_mnt_idmap, new_dir,
-					   new_dentry, is_dir);
-		else
-			error = may_delete(rd->new_mnt_idmap, new_dir,
-					   new_dentry, new_is_dir);
-	}
-	if (error)
-		return error;
-
-	if (!old_dir->i_op->rename)
-		return -EPERM;
-
-	/*
-	 * If we are going to change the parent - check write permissions,
-	 * we'll need to flip '..'.
-	 */
-	if (new_dir != old_dir) {
-		if (is_dir) {
-			error = inode_permission(rd->old_mnt_idmap, source,
-						 MAY_WRITE);
-			if (error)
-				return error;
-		}
-		if ((flags & RENAME_EXCHANGE) && new_is_dir) {
-			error = inode_permission(rd->new_mnt_idmap, target,
-						 MAY_WRITE);
-			if (error)
-				return error;
-		}
-	}
-
-	error = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry,
-				      flags);
-	if (error)
-		return error;
-
-	take_dentry_name_snapshot(&old_name, old_dentry);
-	dget(new_dentry);
-	/*
-	 * Lock children.
-	 * The source subdirectory needs to be locked on cross-directory
-	 * rename or cross-directory exchange since its parent changes.
-	 * The target subdirectory needs to be locked on cross-directory
-	 * exchange due to parent change and on any rename due to becoming
-	 * a victim.
-	 * Non-directories need locking in all cases (for NFS reasons);
-	 * they get locked after any subdirectories (in inode address order).
-	 *
-	 * NOTE: WE ONLY LOCK UNRELATED DIRECTORIES IN CROSS-DIRECTORY CASE.
-	 * NEVER, EVER DO THAT WITHOUT ->s_vfs_rename_mutex.
-	 */
-	lock_old_subdir = new_dir != old_dir;
-	lock_new_subdir = new_dir != old_dir || !(flags & RENAME_EXCHANGE);
-	if (is_dir) {
-		if (lock_old_subdir)
-			inode_lock_nested(source, I_MUTEX_CHILD);
-		if (target && (!new_is_dir || lock_new_subdir))
-			inode_lock(target);
-	} else if (new_is_dir) {
-		if (lock_new_subdir)
-			inode_lock_nested(target, I_MUTEX_CHILD);
-		inode_lock(source);
-	} else {
-		lock_two_nondirectories(source, target);
-	}
-
-	error = -EPERM;
-	if (IS_SWAPFILE(source) || (target && IS_SWAPFILE(target)))
-		goto out;
-
-	error = -EBUSY;
-	if (is_local_mountpoint(old_dentry) || is_local_mountpoint(new_dentry))
-		goto out;
-
-	if (max_links && new_dir != old_dir) {
-		error = -EMLINK;
-		if (is_dir && !new_is_dir && new_dir->i_nlink >= max_links)
-			goto out;
-		if ((flags & RENAME_EXCHANGE) && !is_dir && new_is_dir &&
-		    old_dir->i_nlink >= max_links)
-			goto out;
-	}
-	if (!is_dir) {
-		error = try_break_deleg(source, delegated_inode);
-		if (error)
-			goto out;
-	}
-	if (target && !new_is_dir) {
-		error = try_break_deleg(target, delegated_inode);
-		if (error)
-			goto out;
-	}
-	error = old_dir->i_op->rename(rd->new_mnt_idmap, old_dir, old_dentry,
-				      new_dir, new_dentry, flags);
-	if (error)
-		goto out;
-
-	if (!(flags & RENAME_EXCHANGE) && target) {
-		if (is_dir) {
-			shrink_dcache_parent(new_dentry);
-			target->i_flags |= S_DEAD;
-		}
-		dont_mount(new_dentry);
-		detach_mounts(new_dentry);
-	}
-	if (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE)) {
-		if (!(flags & RENAME_EXCHANGE))
-			d_move(old_dentry, new_dentry);
-		else
-			d_exchange(old_dentry, new_dentry);
-	}
-out:
-	if (!is_dir || lock_old_subdir)
-		inode_unlock(source);
-	if (target && (!new_is_dir || lock_new_subdir))
-		inode_unlock(target);
-	dput(new_dentry);
-	if (!error) {
-		fsnotify_move(old_dir, new_dir, &old_name.name, is_dir,
-			      !(flags & RENAME_EXCHANGE) ? target : NULL, old_dentry);
-		if (flags & RENAME_EXCHANGE) {
-			fsnotify_move(new_dir, old_dir, &old_dentry->d_name,
-				      new_is_dir, NULL, new_dentry);
-		}
-	}
-	release_dentry_name_snapshot(&old_name);
-
-	return error;
-}
-EXPORT_SYMBOL(vfs_rename);
-
-int do_renameat2(int olddfd, struct filename *from, int newdfd,
-		 struct filename *to, unsigned int flags)
-{
-	struct renamedata rd;
-	struct dentry *old_dentry, *new_dentry;
-	struct dentry *trap;
-	struct path old_path, new_path;
-	struct qstr old_last, new_last;
-	int old_type, new_type;
-	struct inode *delegated_inode = NULL;
-	unsigned int lookup_flags = 0, target_flags =
-		LOOKUP_RENAME_TARGET | LOOKUP_CREATE;
-	bool should_retry = false;
-	int error = -EINVAL;
-
-	if (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE | RENAME_WHITEOUT))
-		goto put_names;
-
-	if ((flags & (RENAME_NOREPLACE | RENAME_WHITEOUT)) &&
-	    (flags & RENAME_EXCHANGE))
-		goto put_names;
-
-	if (flags & RENAME_EXCHANGE)
-		target_flags = 0;
-	if (flags & RENAME_NOREPLACE)
-		target_flags |= LOOKUP_EXCL;
-
-retry:
-	error = filename_parentat(olddfd, from, lookup_flags, &old_path,
-				  &old_last, &old_type);
-	if (error)
-		goto put_names;
-
-	error = filename_parentat(newdfd, to, lookup_flags, &new_path, &new_last,
-				  &new_type);
-	if (error)
-		goto exit1;
-
-	error = -EXDEV;
-	if (old_path.mnt != new_path.mnt)
-		goto exit2;
-
-	error = -EBUSY;
-	if (old_type != LAST_NORM)
-		goto exit2;
-
-	if (flags & RENAME_NOREPLACE)
-		error = -EEXIST;
-	if (new_type != LAST_NORM)
-		goto exit2;
-
-	error = mnt_want_write(old_path.mnt);
-	if (error)
-		goto exit2;
-
-retry_deleg:
-	trap = lock_rename(new_path.dentry, old_path.dentry);
-	if (IS_ERR(trap)) {
-		error = PTR_ERR(trap);
-		goto exit_lock_rename;
-	}
-
-	old_dentry = lookup_one_qstr_excl(&old_last, old_path.dentry,
-					  lookup_flags);
-	error = PTR_ERR(old_dentry);
-	if (IS_ERR(old_dentry))
-		goto exit3;
-	new_dentry = lookup_one_qstr_excl(&new_last, new_path.dentry,
-					  lookup_flags | target_flags);
-	error = PTR_ERR(new_dentry);
-	if (IS_ERR(new_dentry))
-		goto exit4;
-	if (flags & RENAME_EXCHANGE) {
-		if (!d_is_dir(new_dentry)) {
-			error = -ENOTDIR;
-			if (new_last.name[new_last.len])
-				goto exit5;
-		}
-	}
-	/* unless the source is a directory trailing slashes give -ENOTDIR */
-	if (!d_is_dir(old_dentry)) {
-		error = -ENOTDIR;
-		if (old_last.name[old_last.len])
-			goto exit5;
-		if (!(flags & RENAME_EXCHANGE) && new_last.name[new_last.len])
-			goto exit5;
-	}
-	/* source should not be ancestor of target */
-	error = -EINVAL;
-	if (old_dentry == trap)
-		goto exit5;
-	/* target should not be an ancestor of source */
-	if (!(flags & RENAME_EXCHANGE))
-		error = -ENOTEMPTY;
-	if (new_dentry == trap)
-		goto exit5;
-
-	error = security_path_rename(&old_path, old_dentry,
-				     &new_path, new_dentry, flags);
-	if (error)
-		goto exit5;
-
-	rd.old_dir	   = old_path.dentry->d_inode;
-	rd.old_dentry	   = old_dentry;
-	rd.old_mnt_idmap   = mnt_idmap(old_path.mnt);
-	rd.new_dir	   = new_path.dentry->d_inode;
-	rd.new_dentry	   = new_dentry;
-	rd.new_mnt_idmap   = mnt_idmap(new_path.mnt);
-	rd.delegated_inode = &delegated_inode;
-	rd.flags	   = flags;
-	error = vfs_rename(&rd);
-exit5:
-	dput(new_dentry);
-exit4:
-	dput(old_dentry);
-exit3:
-	unlock_rename(new_path.dentry, old_path.dentry);
-exit_lock_rename:
-	if (delegated_inode) {
-		error = break_deleg_wait(&delegated_inode);
-		if (!error)
-			goto retry_deleg;
-	}
-	mnt_drop_write(old_path.mnt);
-exit2:
-	if (retry_estale(error, lookup_flags))
-		should_retry = true;
-	path_put(&new_path);
-exit1:
-	path_put(&old_path);
-	if (should_retry) {
-		should_retry = false;
-		lookup_flags |= LOOKUP_REVAL;
-		goto retry;
-	}
-put_names:
-	putname(from);
-	putname(to);
-	return error;
-}
-
-SYSCALL_DEFINE5(renameat2, int, olddfd, const char __user *, oldname,
-		int, newdfd, const char __user *, newname, unsigned int, flags)
-{
-	return do_renameat2(olddfd, getname(oldname), newdfd, getname(newname),
-				flags);
-}
-
-SYSCALL_DEFINE4(renameat, int, olddfd, const char __user *, oldname,
-		int, newdfd, const char __user *, newname)
-{
-	return do_renameat2(olddfd, getname(oldname), newdfd, getname(newname),
-				0);
-}
-
-SYSCALL_DEFINE2(rename, const char __user *, oldname, const char __user *, newname)
-{
-	return do_renameat2(AT_FDCWD, getname(oldname), AT_FDCWD,
-				getname(newname), 0);
-}
-
-int readlink_copy(char __user *buffer, int buflen, const char *link, int linklen)
-{
-	int copylen;
-
-	copylen = linklen;
-	if (unlikely(copylen > (unsigned) buflen))
-		copylen = buflen;
-	if (copy_to_user(buffer, link, copylen))
-		copylen = -EFAULT;
-	return copylen;
-}
-
-/**
- * vfs_readlink - copy symlink body into userspace buffer
- * @dentry: dentry on which to get symbolic link
- * @buffer: user memory pointer
- * @buflen: size of buffer
- *
- * Does not touch atime.  That's up to the caller if necessary
- *
- * Does not call security hook.
- */
-int vfs_readlink(struct dentry *dentry, char __user *buffer, int buflen)
-{
-	struct inode *inode = d_inode(dentry);
-	DEFINE_DELAYED_CALL(done);
-	const char *link;
-	int res;
-
-	if (inode->i_opflags & IOP_CACHED_LINK)
-		return readlink_copy(buffer, buflen, inode->i_link, inode->i_linklen);
-
-	if (unlikely(!(inode->i_opflags & IOP_DEFAULT_READLINK))) {
-		if (unlikely(inode->i_op->readlink))
-			return inode->i_op->readlink(dentry, buffer, buflen);
-
-		if (!d_is_symlink(dentry))
-			return -EINVAL;
-
-		spin_lock(&inode->i_lock);
-		inode->i_opflags |= IOP_DEFAULT_READLINK;
-		spin_unlock(&inode->i_lock);
-	}
-
-	link = READ_ONCE(inode->i_link);
-	if (!link) {
-		link = inode->i_op->get_link(dentry, inode, &done);
-		if (IS_ERR(link))
-			return PTR_ERR(link);
-	}
-	res = readlink_copy(buffer, buflen, link, strlen(link));
-	do_delayed_call(&done);
-	return res;
-}
-EXPORT_SYMBOL(vfs_readlink);
-
-/**
- * vfs_get_link - get symlink body
- * @dentry: dentry on which to get symbolic link
- * @done: caller needs to free returned data with this
- *
- * Calls security hook and i_op->get_link() on the supplied inode.
- *
- * It does not touch atime.  That's up to the caller if necessary.
- *
- * Does not work on "special" symlinks like /proc/$$/fd/N
- */
-const char *vfs_get_link(struct dentry *dentry, struct delayed_call *done)
-{
-	const char *res = ERR_PTR(-EINVAL);
-	struct inode *inode = d_inode(dentry);
-
-	if (d_is_symlink(dentry)) {
-		res = ERR_PTR(security_inode_readlink(dentry));
-		if (!res)
-			res = inode->i_op->get_link(dentry, inode, done);
-	}
-	return res;
-}
-EXPORT_SYMBOL(vfs_get_link);
-
-/* get the link contents into pagecache */
-static char *__page_get_link(struct dentry *dentry, struct inode *inode,
-			     struct delayed_call *callback)
-{
-	struct folio *folio;
-	struct address_space *mapping = inode->i_mapping;
-
-	if (!dentry) {
-		folio = filemap_get_folio(mapping, 0);
-		if (IS_ERR(folio))
-			return ERR_PTR(-ECHILD);
-		if (!folio_test_uptodate(folio)) {
-			folio_put(folio);
-			return ERR_PTR(-ECHILD);
-		}
-	} else {
-		folio = read_mapping_folio(mapping, 0, NULL);
-		if (IS_ERR(folio))
-			return ERR_CAST(folio);
-	}
-	set_delayed_call(callback, page_put_link, folio);
-	BUG_ON(mapping_gfp_mask(mapping) & __GFP_HIGHMEM);
-	return folio_address(folio);
-}
-
-const char *page_get_link_raw(struct dentry *dentry, struct inode *inode,
-			      struct delayed_call *callback)
-{
-	return __page_get_link(dentry, inode, callback);
-}
-EXPORT_SYMBOL_GPL(page_get_link_raw);
-
-/**
- * page_get_link() - An implementation of the get_link inode_operation.
- * @dentry: The directory entry which is the symlink.
- * @inode: The inode for the symlink.
- * @callback: Used to drop the reference to the symlink.
- *
- * Filesystems which store their symlinks in the page cache should use
- * this to implement the get_link() member of their inode_operations.
- *
- * Return: A pointer to the NUL-terminated symlink.
- */
-const char *page_get_link(struct dentry *dentry, struct inode *inode,
-					struct delayed_call *callback)
-{
-	char *kaddr = __page_get_link(dentry, inode, callback);
-
-	if (!IS_ERR(kaddr))
-		nd_terminate_link(kaddr, inode->i_size, PAGE_SIZE - 1);
-	return kaddr;
-}
-EXPORT_SYMBOL(page_get_link);
-
-/**
- * page_put_link() - Drop the reference to the symlink.
- * @arg: The folio which contains the symlink.
- *
- * This is used internally by page_get_link().  It is exported for use
- * by filesystems which need to implement a variant of page_get_link()
- * themselves.  Despite the apparent symmetry, filesystems which use
- * page_get_link() do not need to call page_put_link().
- *
- * The argument, while it has a void pointer type, must be a pointer to
- * the folio which was retrieved from the page cache.  The delayed_call
- * infrastructure is used to drop the reference count once the caller
- * is done with the symlink.
- */
-void page_put_link(void *arg)
-{
-	folio_put(arg);
-}
-EXPORT_SYMBOL(page_put_link);
-
-int page_readlink(struct dentry *dentry, char __user *buffer, int buflen)
-{
-	const char *link;
-	int res;
-
-	DEFINE_DELAYED_CALL(done);
-	link = page_get_link(dentry, d_inode(dentry), &done);
-	res = PTR_ERR(link);
-	if (!IS_ERR(link))
-		res = readlink_copy(buffer, buflen, link, strlen(link));
-	do_delayed_call(&done);
-	return res;
-}
-EXPORT_SYMBOL(page_readlink);
-
-int page_symlink(struct inode *inode, const char *symname, int len)
-{
-	struct address_space *mapping = inode->i_mapping;
-	const struct address_space_operations *aops = mapping->a_ops;
-	bool nofs = !mapping_gfp_constraint(mapping, __GFP_FS);
-	struct folio *folio;
-	void *fsdata = NULL;
-	int err;
-	unsigned int flags;
-
-retry:
-	if (nofs)
-		flags = memalloc_nofs_save();
-	err = aops->write_begin(NULL, mapping, 0, len-1, &folio, &fsdata);
-	if (nofs)
-		memalloc_nofs_restore(flags);
-	if (err)
-		goto fail;
-
-	memcpy(folio_address(folio), symname, len - 1);
-
-	err = aops->write_end(NULL, mapping, 0, len - 1, len - 1,
-						folio, fsdata);
-	if (err < 0)
-		goto fail;
-	if (err < len-1)
-		goto retry;
-
-	mark_inode_dirty(inode);
-	return 0;
-fail:
-	return err;
-}
-EXPORT_SYMBOL(page_symlink);
-
-const struct inode_operations page_symlink_inode_operations = {
-	.get_link	= page_get_link,
-};
-EXPORT_SYMBOL(page_symlink_inode_operations);
diff -Nrup linux-6.16.7/fs/proc/generic.c linux-lenovo-x13s-linux-6.16.y/fs/proc/generic.c
--- linux-6.16.7/fs/proc/generic.c	2025-09-13 16:15:43.482296968 -0600
+++ linux-lenovo-x13s-linux-6.16.y/fs/proc/generic.c	2025-09-11 09:47:42.000000000 -0600
@@ -390,8 +390,7 @@ struct proc_dir_entry *proc_register(str
 	if (proc_alloc_inum(&dp->low_ino))
 		goto out_free_entry;
 
-	if (!S_ISDIR(dp->mode))
-		pde_set_flags(dp);
+	pde_set_flags(dp);
 
 	write_lock(&proc_subdir_lock);
 	dp->parent = dir;
diff -Nrup linux-6.16.7/fs/proc/generic.c.orig linux-lenovo-x13s-linux-6.16.y/fs/proc/generic.c.orig
--- linux-6.16.7/fs/proc/generic.c.orig	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/fs/proc/generic.c.orig	1969-12-31 17:00:00.000000000 -0700
@@ -1,834 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * proc/fs/generic.c --- generic routines for the proc-fs
- *
- * This file contains generic proc-fs routines for handling
- * directories and files.
- * 
- * Copyright (C) 1991, 1992 Linus Torvalds.
- * Copyright (C) 1997 Theodore Ts'o
- */
-
-#include <linux/cache.h>
-#include <linux/errno.h>
-#include <linux/time.h>
-#include <linux/proc_fs.h>
-#include <linux/stat.h>
-#include <linux/mm.h>
-#include <linux/module.h>
-#include <linux/namei.h>
-#include <linux/slab.h>
-#include <linux/printk.h>
-#include <linux/mount.h>
-#include <linux/init.h>
-#include <linux/idr.h>
-#include <linux/bitops.h>
-#include <linux/spinlock.h>
-#include <linux/completion.h>
-#include <linux/uaccess.h>
-#include <linux/seq_file.h>
-
-#include "internal.h"
-
-static DEFINE_RWLOCK(proc_subdir_lock);
-
-struct kmem_cache *proc_dir_entry_cache __ro_after_init;
-
-void pde_free(struct proc_dir_entry *pde)
-{
-	if (S_ISLNK(pde->mode))
-		kfree(pde->data);
-	if (pde->name != pde->inline_name)
-		kfree(pde->name);
-	kmem_cache_free(proc_dir_entry_cache, pde);
-}
-
-static int proc_match(const char *name, struct proc_dir_entry *de, unsigned int len)
-{
-	if (len < de->namelen)
-		return -1;
-	if (len > de->namelen)
-		return 1;
-
-	return memcmp(name, de->name, len);
-}
-
-static struct proc_dir_entry *pde_subdir_first(struct proc_dir_entry *dir)
-{
-	return rb_entry_safe(rb_first(&dir->subdir), struct proc_dir_entry,
-			     subdir_node);
-}
-
-static struct proc_dir_entry *pde_subdir_next(struct proc_dir_entry *dir)
-{
-	return rb_entry_safe(rb_next(&dir->subdir_node), struct proc_dir_entry,
-			     subdir_node);
-}
-
-static struct proc_dir_entry *pde_subdir_find(struct proc_dir_entry *dir,
-					      const char *name,
-					      unsigned int len)
-{
-	struct rb_node *node = dir->subdir.rb_node;
-
-	while (node) {
-		struct proc_dir_entry *de = rb_entry(node,
-						     struct proc_dir_entry,
-						     subdir_node);
-		int result = proc_match(name, de, len);
-
-		if (result < 0)
-			node = node->rb_left;
-		else if (result > 0)
-			node = node->rb_right;
-		else
-			return de;
-	}
-	return NULL;
-}
-
-static bool pde_subdir_insert(struct proc_dir_entry *dir,
-			      struct proc_dir_entry *de)
-{
-	struct rb_root *root = &dir->subdir;
-	struct rb_node **new = &root->rb_node, *parent = NULL;
-
-	/* Figure out where to put new node */
-	while (*new) {
-		struct proc_dir_entry *this = rb_entry(*new,
-						       struct proc_dir_entry,
-						       subdir_node);
-		int result = proc_match(de->name, this, de->namelen);
-
-		parent = *new;
-		if (result < 0)
-			new = &(*new)->rb_left;
-		else if (result > 0)
-			new = &(*new)->rb_right;
-		else
-			return false;
-	}
-
-	/* Add new node and rebalance tree. */
-	rb_link_node(&de->subdir_node, parent, new);
-	rb_insert_color(&de->subdir_node, root);
-	return true;
-}
-
-static int proc_notify_change(struct mnt_idmap *idmap,
-			      struct dentry *dentry, struct iattr *iattr)
-{
-	struct inode *inode = d_inode(dentry);
-	struct proc_dir_entry *de = PDE(inode);
-	int error;
-
-	error = setattr_prepare(&nop_mnt_idmap, dentry, iattr);
-	if (error)
-		return error;
-
-	setattr_copy(&nop_mnt_idmap, inode, iattr);
-
-	proc_set_user(de, inode->i_uid, inode->i_gid);
-	de->mode = inode->i_mode;
-	return 0;
-}
-
-static int proc_getattr(struct mnt_idmap *idmap,
-			const struct path *path, struct kstat *stat,
-			u32 request_mask, unsigned int query_flags)
-{
-	struct inode *inode = d_inode(path->dentry);
-	struct proc_dir_entry *de = PDE(inode);
-	if (de) {
-		nlink_t nlink = READ_ONCE(de->nlink);
-		if (nlink > 0) {
-			set_nlink(inode, nlink);
-		}
-	}
-
-	generic_fillattr(&nop_mnt_idmap, request_mask, inode, stat);
-	return 0;
-}
-
-static const struct inode_operations proc_file_inode_operations = {
-	.setattr	= proc_notify_change,
-};
-
-/*
- * This function parses a name such as "tty/driver/serial", and
- * returns the struct proc_dir_entry for "/proc/tty/driver", and
- * returns "serial" in residual.
- */
-static int __xlate_proc_name(const char *name, struct proc_dir_entry **ret,
-			     const char **residual)
-{
-	const char     		*cp = name, *next;
-	struct proc_dir_entry	*de;
-
-	de = *ret ?: &proc_root;
-	while ((next = strchr(cp, '/')) != NULL) {
-		de = pde_subdir_find(de, cp, next - cp);
-		if (!de) {
-			WARN(1, "name '%s'\n", name);
-			return -ENOENT;
-		}
-		cp = next + 1;
-	}
-	*residual = cp;
-	*ret = de;
-	return 0;
-}
-
-static int xlate_proc_name(const char *name, struct proc_dir_entry **ret,
-			   const char **residual)
-{
-	int rv;
-
-	read_lock(&proc_subdir_lock);
-	rv = __xlate_proc_name(name, ret, residual);
-	read_unlock(&proc_subdir_lock);
-	return rv;
-}
-
-static DEFINE_IDA(proc_inum_ida);
-
-#define PROC_DYNAMIC_FIRST 0xF0000000U
-
-/*
- * Return an inode number between PROC_DYNAMIC_FIRST and
- * 0xffffffff, or zero on failure.
- */
-int proc_alloc_inum(unsigned int *inum)
-{
-	int i;
-
-	i = ida_alloc_max(&proc_inum_ida, UINT_MAX - PROC_DYNAMIC_FIRST,
-			  GFP_KERNEL);
-	if (i < 0)
-		return i;
-
-	*inum = PROC_DYNAMIC_FIRST + (unsigned int)i;
-	return 0;
-}
-
-void proc_free_inum(unsigned int inum)
-{
-	ida_free(&proc_inum_ida, inum - PROC_DYNAMIC_FIRST);
-}
-
-static int proc_misc_d_revalidate(struct inode *dir, const struct qstr *name,
-				  struct dentry *dentry, unsigned int flags)
-{
-	if (flags & LOOKUP_RCU)
-		return -ECHILD;
-
-	if (atomic_read(&PDE(d_inode(dentry))->in_use) < 0)
-		return 0; /* revalidate */
-	return 1;
-}
-
-static int proc_misc_d_delete(const struct dentry *dentry)
-{
-	return atomic_read(&PDE(d_inode(dentry))->in_use) < 0;
-}
-
-static const struct dentry_operations proc_misc_dentry_ops = {
-	.d_revalidate	= proc_misc_d_revalidate,
-	.d_delete	= proc_misc_d_delete,
-};
-
-/*
- * Don't create negative dentries here, return -ENOENT by hand
- * instead.
- */
-struct dentry *proc_lookup_de(struct inode *dir, struct dentry *dentry,
-			      struct proc_dir_entry *de)
-{
-	struct inode *inode;
-
-	read_lock(&proc_subdir_lock);
-	de = pde_subdir_find(de, dentry->d_name.name, dentry->d_name.len);
-	if (de) {
-		pde_get(de);
-		read_unlock(&proc_subdir_lock);
-		inode = proc_get_inode(dir->i_sb, de);
-		if (!inode)
-			return ERR_PTR(-ENOMEM);
-		d_set_d_op(dentry, de->proc_dops);
-		return d_splice_alias(inode, dentry);
-	}
-	read_unlock(&proc_subdir_lock);
-	return ERR_PTR(-ENOENT);
-}
-
-struct dentry *proc_lookup(struct inode *dir, struct dentry *dentry,
-		unsigned int flags)
-{
-	struct proc_fs_info *fs_info = proc_sb_info(dir->i_sb);
-
-	if (fs_info->pidonly == PROC_PIDONLY_ON)
-		return ERR_PTR(-ENOENT);
-
-	return proc_lookup_de(dir, dentry, PDE(dir));
-}
-
-/*
- * This returns non-zero if at EOF, so that the /proc
- * root directory can use this and check if it should
- * continue with the <pid> entries..
- *
- * Note that the VFS-layer doesn't care about the return
- * value of the readdir() call, as long as it's non-negative
- * for success..
- */
-int proc_readdir_de(struct file *file, struct dir_context *ctx,
-		    struct proc_dir_entry *de)
-{
-	int i;
-
-	if (!dir_emit_dots(file, ctx))
-		return 0;
-
-	i = ctx->pos - 2;
-	read_lock(&proc_subdir_lock);
-	de = pde_subdir_first(de);
-	for (;;) {
-		if (!de) {
-			read_unlock(&proc_subdir_lock);
-			return 0;
-		}
-		if (!i)
-			break;
-		de = pde_subdir_next(de);
-		i--;
-	}
-
-	do {
-		struct proc_dir_entry *next;
-		pde_get(de);
-		read_unlock(&proc_subdir_lock);
-		if (!dir_emit(ctx, de->name, de->namelen,
-			    de->low_ino, de->mode >> 12)) {
-			pde_put(de);
-			return 0;
-		}
-		ctx->pos++;
-		read_lock(&proc_subdir_lock);
-		next = pde_subdir_next(de);
-		pde_put(de);
-		de = next;
-	} while (de);
-	read_unlock(&proc_subdir_lock);
-	return 1;
-}
-
-int proc_readdir(struct file *file, struct dir_context *ctx)
-{
-	struct inode *inode = file_inode(file);
-	struct proc_fs_info *fs_info = proc_sb_info(inode->i_sb);
-
-	if (fs_info->pidonly == PROC_PIDONLY_ON)
-		return 1;
-
-	return proc_readdir_de(file, ctx, PDE(inode));
-}
-
-/*
- * These are the generic /proc directory operations. They
- * use the in-memory "struct proc_dir_entry" tree to parse
- * the /proc directory.
- */
-static const struct file_operations proc_dir_operations = {
-	.llseek			= generic_file_llseek,
-	.read			= generic_read_dir,
-	.iterate_shared		= proc_readdir,
-};
-
-static int proc_net_d_revalidate(struct inode *dir, const struct qstr *name,
-				 struct dentry *dentry, unsigned int flags)
-{
-	return 0;
-}
-
-const struct dentry_operations proc_net_dentry_ops = {
-	.d_revalidate	= proc_net_d_revalidate,
-	.d_delete	= always_delete_dentry,
-};
-
-/*
- * proc directories can do almost nothing..
- */
-static const struct inode_operations proc_dir_inode_operations = {
-	.lookup		= proc_lookup,
-	.getattr	= proc_getattr,
-	.setattr	= proc_notify_change,
-};
-
-static void pde_set_flags(struct proc_dir_entry *pde)
-{
-	const struct proc_ops *proc_ops = pde->proc_ops;
-
-	if (!proc_ops)
-		return;
-
-	if (proc_ops->proc_flags & PROC_ENTRY_PERMANENT)
-		pde->flags |= PROC_ENTRY_PERMANENT;
-	if (proc_ops->proc_read_iter)
-		pde->flags |= PROC_ENTRY_proc_read_iter;
-#ifdef CONFIG_COMPAT
-	if (proc_ops->proc_compat_ioctl)
-		pde->flags |= PROC_ENTRY_proc_compat_ioctl;
-#endif
-	if (proc_ops->proc_lseek)
-		pde->flags |= PROC_ENTRY_proc_lseek;
-}
-
-/* returns the registered entry, or frees dp and returns NULL on failure */
-struct proc_dir_entry *proc_register(struct proc_dir_entry *dir,
-		struct proc_dir_entry *dp)
-{
-	if (proc_alloc_inum(&dp->low_ino))
-		goto out_free_entry;
-
-	pde_set_flags(dp);
-
-	write_lock(&proc_subdir_lock);
-	dp->parent = dir;
-	if (pde_subdir_insert(dir, dp) == false) {
-		WARN(1, "proc_dir_entry '%s/%s' already registered\n",
-		     dir->name, dp->name);
-		write_unlock(&proc_subdir_lock);
-		goto out_free_inum;
-	}
-	dir->nlink++;
-	write_unlock(&proc_subdir_lock);
-
-	return dp;
-out_free_inum:
-	proc_free_inum(dp->low_ino);
-out_free_entry:
-	pde_free(dp);
-	return NULL;
-}
-
-static struct proc_dir_entry *__proc_create(struct proc_dir_entry **parent,
-					  const char *name,
-					  umode_t mode,
-					  nlink_t nlink)
-{
-	struct proc_dir_entry *ent = NULL;
-	const char *fn;
-	struct qstr qstr;
-
-	if (xlate_proc_name(name, parent, &fn) != 0)
-		goto out;
-	qstr.name = fn;
-	qstr.len = strlen(fn);
-	if (qstr.len == 0 || qstr.len >= 256) {
-		WARN(1, "name len %u\n", qstr.len);
-		return NULL;
-	}
-	if (qstr.len == 1 && fn[0] == '.') {
-		WARN(1, "name '.'\n");
-		return NULL;
-	}
-	if (qstr.len == 2 && fn[0] == '.' && fn[1] == '.') {
-		WARN(1, "name '..'\n");
-		return NULL;
-	}
-	if (*parent == &proc_root && name_to_int(&qstr) != ~0U) {
-		WARN(1, "create '/proc/%s' by hand\n", qstr.name);
-		return NULL;
-	}
-	if (is_empty_pde(*parent)) {
-		WARN(1, "attempt to add to permanently empty directory");
-		return NULL;
-	}
-
-	ent = kmem_cache_zalloc(proc_dir_entry_cache, GFP_KERNEL);
-	if (!ent)
-		goto out;
-
-	if (qstr.len + 1 <= SIZEOF_PDE_INLINE_NAME) {
-		ent->name = ent->inline_name;
-	} else {
-		ent->name = kmalloc(qstr.len + 1, GFP_KERNEL);
-		if (!ent->name) {
-			pde_free(ent);
-			return NULL;
-		}
-	}
-
-	memcpy(ent->name, fn, qstr.len + 1);
-	ent->namelen = qstr.len;
-	ent->mode = mode;
-	ent->nlink = nlink;
-	ent->subdir = RB_ROOT;
-	refcount_set(&ent->refcnt, 1);
-	spin_lock_init(&ent->pde_unload_lock);
-	INIT_LIST_HEAD(&ent->pde_openers);
-	proc_set_user(ent, (*parent)->uid, (*parent)->gid);
-
-	ent->proc_dops = &proc_misc_dentry_ops;
-	/* Revalidate everything under /proc/${pid}/net */
-	if ((*parent)->proc_dops == &proc_net_dentry_ops)
-		pde_force_lookup(ent);
-
-out:
-	return ent;
-}
-
-struct proc_dir_entry *proc_symlink(const char *name,
-		struct proc_dir_entry *parent, const char *dest)
-{
-	struct proc_dir_entry *ent;
-
-	ent = __proc_create(&parent, name,
-			  (S_IFLNK | S_IRUGO | S_IWUGO | S_IXUGO),1);
-
-	if (ent) {
-		ent->size = strlen(dest);
-		ent->data = kmemdup(dest, ent->size + 1, GFP_KERNEL);
-		if (ent->data) {
-			ent->proc_iops = &proc_link_inode_operations;
-			ent = proc_register(parent, ent);
-		} else {
-			pde_free(ent);
-			ent = NULL;
-		}
-	}
-	return ent;
-}
-EXPORT_SYMBOL(proc_symlink);
-
-struct proc_dir_entry *_proc_mkdir(const char *name, umode_t mode,
-		struct proc_dir_entry *parent, void *data, bool force_lookup)
-{
-	struct proc_dir_entry *ent;
-
-	if (mode == 0)
-		mode = S_IRUGO | S_IXUGO;
-
-	ent = __proc_create(&parent, name, S_IFDIR | mode, 2);
-	if (ent) {
-		ent->data = data;
-		ent->proc_dir_ops = &proc_dir_operations;
-		ent->proc_iops = &proc_dir_inode_operations;
-		if (force_lookup) {
-			pde_force_lookup(ent);
-		}
-		ent = proc_register(parent, ent);
-	}
-	return ent;
-}
-EXPORT_SYMBOL_GPL(_proc_mkdir);
-
-struct proc_dir_entry *proc_mkdir_data(const char *name, umode_t mode,
-		struct proc_dir_entry *parent, void *data)
-{
-	return _proc_mkdir(name, mode, parent, data, false);
-}
-EXPORT_SYMBOL_GPL(proc_mkdir_data);
-
-struct proc_dir_entry *proc_mkdir_mode(const char *name, umode_t mode,
-				       struct proc_dir_entry *parent)
-{
-	return proc_mkdir_data(name, mode, parent, NULL);
-}
-EXPORT_SYMBOL(proc_mkdir_mode);
-
-struct proc_dir_entry *proc_mkdir(const char *name,
-		struct proc_dir_entry *parent)
-{
-	return proc_mkdir_data(name, 0, parent, NULL);
-}
-EXPORT_SYMBOL(proc_mkdir);
-
-struct proc_dir_entry *proc_create_mount_point(const char *name)
-{
-	umode_t mode = S_IFDIR | S_IRUGO | S_IXUGO;
-	struct proc_dir_entry *ent, *parent = NULL;
-
-	ent = __proc_create(&parent, name, mode, 2);
-	if (ent) {
-		ent->data = NULL;
-		ent->proc_dir_ops = NULL;
-		ent->proc_iops = NULL;
-		ent = proc_register(parent, ent);
-	}
-	return ent;
-}
-EXPORT_SYMBOL(proc_create_mount_point);
-
-struct proc_dir_entry *proc_create_reg(const char *name, umode_t mode,
-		struct proc_dir_entry **parent, void *data)
-{
-	struct proc_dir_entry *p;
-
-	if ((mode & S_IFMT) == 0)
-		mode |= S_IFREG;
-	if ((mode & S_IALLUGO) == 0)
-		mode |= S_IRUGO;
-	if (WARN_ON_ONCE(!S_ISREG(mode)))
-		return NULL;
-
-	p = __proc_create(parent, name, mode, 1);
-	if (p) {
-		p->proc_iops = &proc_file_inode_operations;
-		p->data = data;
-	}
-	return p;
-}
-
-struct proc_dir_entry *proc_create_data(const char *name, umode_t mode,
-		struct proc_dir_entry *parent,
-		const struct proc_ops *proc_ops, void *data)
-{
-	struct proc_dir_entry *p;
-
-	p = proc_create_reg(name, mode, &parent, data);
-	if (!p)
-		return NULL;
-	p->proc_ops = proc_ops;
-	return proc_register(parent, p);
-}
-EXPORT_SYMBOL(proc_create_data);
- 
-struct proc_dir_entry *proc_create(const char *name, umode_t mode,
-				   struct proc_dir_entry *parent,
-				   const struct proc_ops *proc_ops)
-{
-	return proc_create_data(name, mode, parent, proc_ops, NULL);
-}
-EXPORT_SYMBOL(proc_create);
-
-static int proc_seq_open(struct inode *inode, struct file *file)
-{
-	struct proc_dir_entry *de = PDE(inode);
-
-	if (de->state_size)
-		return seq_open_private(file, de->seq_ops, de->state_size);
-	return seq_open(file, de->seq_ops);
-}
-
-static int proc_seq_release(struct inode *inode, struct file *file)
-{
-	struct proc_dir_entry *de = PDE(inode);
-
-	if (de->state_size)
-		return seq_release_private(inode, file);
-	return seq_release(inode, file);
-}
-
-static const struct proc_ops proc_seq_ops = {
-	/* not permanent -- can call into arbitrary seq_operations */
-	.proc_open	= proc_seq_open,
-	.proc_read_iter	= seq_read_iter,
-	.proc_lseek	= seq_lseek,
-	.proc_release	= proc_seq_release,
-};
-
-struct proc_dir_entry *proc_create_seq_private(const char *name, umode_t mode,
-		struct proc_dir_entry *parent, const struct seq_operations *ops,
-		unsigned int state_size, void *data)
-{
-	struct proc_dir_entry *p;
-
-	p = proc_create_reg(name, mode, &parent, data);
-	if (!p)
-		return NULL;
-	p->proc_ops = &proc_seq_ops;
-	p->seq_ops = ops;
-	p->state_size = state_size;
-	return proc_register(parent, p);
-}
-EXPORT_SYMBOL(proc_create_seq_private);
-
-static int proc_single_open(struct inode *inode, struct file *file)
-{
-	struct proc_dir_entry *de = PDE(inode);
-
-	return single_open(file, de->single_show, de->data);
-}
-
-static const struct proc_ops proc_single_ops = {
-	/* not permanent -- can call into arbitrary ->single_show */
-	.proc_open	= proc_single_open,
-	.proc_read_iter = seq_read_iter,
-	.proc_lseek	= seq_lseek,
-	.proc_release	= single_release,
-};
-
-struct proc_dir_entry *proc_create_single_data(const char *name, umode_t mode,
-		struct proc_dir_entry *parent,
-		int (*show)(struct seq_file *, void *), void *data)
-{
-	struct proc_dir_entry *p;
-
-	p = proc_create_reg(name, mode, &parent, data);
-	if (!p)
-		return NULL;
-	p->proc_ops = &proc_single_ops;
-	p->single_show = show;
-	return proc_register(parent, p);
-}
-EXPORT_SYMBOL(proc_create_single_data);
-
-void proc_set_size(struct proc_dir_entry *de, loff_t size)
-{
-	de->size = size;
-}
-EXPORT_SYMBOL(proc_set_size);
-
-void proc_set_user(struct proc_dir_entry *de, kuid_t uid, kgid_t gid)
-{
-	de->uid = uid;
-	de->gid = gid;
-}
-EXPORT_SYMBOL(proc_set_user);
-
-void pde_put(struct proc_dir_entry *pde)
-{
-	if (refcount_dec_and_test(&pde->refcnt)) {
-		proc_free_inum(pde->low_ino);
-		pde_free(pde);
-	}
-}
-
-/*
- * Remove a /proc entry and free it if it's not currently in use.
- */
-void remove_proc_entry(const char *name, struct proc_dir_entry *parent)
-{
-	struct proc_dir_entry *de = NULL;
-	const char *fn = name;
-	unsigned int len;
-
-	write_lock(&proc_subdir_lock);
-	if (__xlate_proc_name(name, &parent, &fn) != 0) {
-		write_unlock(&proc_subdir_lock);
-		return;
-	}
-	len = strlen(fn);
-
-	de = pde_subdir_find(parent, fn, len);
-	if (de) {
-		if (unlikely(pde_is_permanent(de))) {
-			WARN(1, "removing permanent /proc entry '%s'", de->name);
-			de = NULL;
-		} else {
-			rb_erase(&de->subdir_node, &parent->subdir);
-			if (S_ISDIR(de->mode))
-				parent->nlink--;
-		}
-	}
-	write_unlock(&proc_subdir_lock);
-	if (!de) {
-		WARN(1, "name '%s'\n", name);
-		return;
-	}
-
-	proc_entry_rundown(de);
-
-	WARN(pde_subdir_first(de),
-	     "%s: removing non-empty directory '%s/%s', leaking at least '%s'\n",
-	     __func__, de->parent->name, de->name, pde_subdir_first(de)->name);
-	pde_put(de);
-}
-EXPORT_SYMBOL(remove_proc_entry);
-
-int remove_proc_subtree(const char *name, struct proc_dir_entry *parent)
-{
-	struct proc_dir_entry *root = NULL, *de, *next;
-	const char *fn = name;
-	unsigned int len;
-
-	write_lock(&proc_subdir_lock);
-	if (__xlate_proc_name(name, &parent, &fn) != 0) {
-		write_unlock(&proc_subdir_lock);
-		return -ENOENT;
-	}
-	len = strlen(fn);
-
-	root = pde_subdir_find(parent, fn, len);
-	if (!root) {
-		write_unlock(&proc_subdir_lock);
-		return -ENOENT;
-	}
-	if (unlikely(pde_is_permanent(root))) {
-		write_unlock(&proc_subdir_lock);
-		WARN(1, "removing permanent /proc entry '%s/%s'",
-			root->parent->name, root->name);
-		return -EINVAL;
-	}
-	rb_erase(&root->subdir_node, &parent->subdir);
-
-	de = root;
-	while (1) {
-		next = pde_subdir_first(de);
-		if (next) {
-			if (unlikely(pde_is_permanent(next))) {
-				write_unlock(&proc_subdir_lock);
-				WARN(1, "removing permanent /proc entry '%s/%s'",
-					next->parent->name, next->name);
-				return -EINVAL;
-			}
-			rb_erase(&next->subdir_node, &de->subdir);
-			de = next;
-			continue;
-		}
-		next = de->parent;
-		if (S_ISDIR(de->mode))
-			next->nlink--;
-		write_unlock(&proc_subdir_lock);
-
-		proc_entry_rundown(de);
-		if (de == root)
-			break;
-		pde_put(de);
-
-		write_lock(&proc_subdir_lock);
-		de = next;
-	}
-	pde_put(root);
-	return 0;
-}
-EXPORT_SYMBOL(remove_proc_subtree);
-
-void *proc_get_parent_data(const struct inode *inode)
-{
-	struct proc_dir_entry *de = PDE(inode);
-	return de->parent->data;
-}
-EXPORT_SYMBOL_GPL(proc_get_parent_data);
-
-void proc_remove(struct proc_dir_entry *de)
-{
-	if (de)
-		remove_proc_subtree(de->name, de->parent);
-}
-EXPORT_SYMBOL(proc_remove);
-
-/*
- * Pull a user buffer into memory and pass it to the file's write handler if
- * one is supplied.  The ->write() method is permitted to modify the
- * kernel-side buffer.
- */
-ssize_t proc_simple_write(struct file *f, const char __user *ubuf, size_t size,
-			  loff_t *_pos)
-{
-	struct proc_dir_entry *pde = PDE(file_inode(f));
-	char *buf;
-	int ret;
-
-	if (!pde->write)
-		return -EACCES;
-	if (size == 0 || size > PAGE_SIZE - 1)
-		return -EINVAL;
-	buf = memdup_user_nul(ubuf, size);
-	if (IS_ERR(buf))
-		return PTR_ERR(buf);
-	ret = pde->write(f, buf, size);
-	kfree(buf);
-	return ret == 0 ? size : ret;
-}
diff -Nrup linux-6.16.7/fs/proc/generic.c.rej linux-lenovo-x13s-linux-6.16.y/fs/proc/generic.c.rej
--- linux-6.16.7/fs/proc/generic.c.rej	2025-09-13 16:15:43.479015562 -0600
+++ linux-lenovo-x13s-linux-6.16.y/fs/proc/generic.c.rej	1969-12-31 17:00:00.000000000 -0700
@@ -1,82 +0,0 @@
---- fs/proc/generic.c
-+++ fs/proc/generic.c
-@@ -367,6 +367,25 @@ static const struct inode_operations proc_dir_inode_operations = {
- 	.setattr	= proc_notify_change,
- };
- 
-+static void pde_set_flags(struct proc_dir_entry *pde)
-+{
-+	const struct proc_ops *proc_ops = pde->proc_ops;
-+
-+	if (!proc_ops)
-+		return;
-+
-+	if (proc_ops->proc_flags & PROC_ENTRY_PERMANENT)
-+		pde->flags |= PROC_ENTRY_PERMANENT;
-+	if (proc_ops->proc_read_iter)
-+		pde->flags |= PROC_ENTRY_proc_read_iter;
-+#ifdef CONFIG_COMPAT
-+	if (proc_ops->proc_compat_ioctl)
-+		pde->flags |= PROC_ENTRY_proc_compat_ioctl;
-+#endif
-+	if (proc_ops->proc_lseek)
-+		pde->flags |= PROC_ENTRY_proc_lseek;
-+}
-+
- /* returns the registered entry, or frees dp and returns NULL on failure */
- struct proc_dir_entry *proc_register(struct proc_dir_entry *dir,
- 		struct proc_dir_entry *dp)
-@@ -374,6 +393,8 @@ struct proc_dir_entry *proc_register(struct proc_dir_entry *dir,
- 	if (proc_alloc_inum(&dp->low_ino))
- 		goto out_free_entry;
- 
-+	pde_set_flags(dp);
-+
- 	write_lock(&proc_subdir_lock);
- 	dp->parent = dir;
- 	if (pde_subdir_insert(dir, dp) == false) {
-@@ -561,20 +582,6 @@ struct proc_dir_entry *proc_create_reg(const char *name, umode_t mode,
- 	return p;
- }
- 
--static void pde_set_flags(struct proc_dir_entry *pde)
--{
--	if (pde->proc_ops->proc_flags & PROC_ENTRY_PERMANENT)
--		pde->flags |= PROC_ENTRY_PERMANENT;
--	if (pde->proc_ops->proc_read_iter)
--		pde->flags |= PROC_ENTRY_proc_read_iter;
--#ifdef CONFIG_COMPAT
--	if (pde->proc_ops->proc_compat_ioctl)
--		pde->flags |= PROC_ENTRY_proc_compat_ioctl;
--#endif
--	if (pde->proc_ops->proc_lseek)
--		pde->flags |= PROC_ENTRY_proc_lseek;
--}
--
- struct proc_dir_entry *proc_create_data(const char *name, umode_t mode,
- 		struct proc_dir_entry *parent,
- 		const struct proc_ops *proc_ops, void *data)
-@@ -585,7 +592,6 @@ struct proc_dir_entry *proc_create_data(const char *name, umode_t mode,
- 	if (!p)
- 		return NULL;
- 	p->proc_ops = proc_ops;
--	pde_set_flags(p);
- 	return proc_register(parent, p);
- }
- EXPORT_SYMBOL(proc_create_data);
-@@ -636,7 +642,6 @@ struct proc_dir_entry *proc_create_seq_private(const char *name, umode_t mode,
- 	p->proc_ops = &proc_seq_ops;
- 	p->seq_ops = ops;
- 	p->state_size = state_size;
--	pde_set_flags(p);
- 	return proc_register(parent, p);
- }
- EXPORT_SYMBOL(proc_create_seq_private);
-@@ -667,7 +672,6 @@ struct proc_dir_entry *proc_create_single_data(const char *name, umode_t mode,
- 		return NULL;
- 	p->proc_ops = &proc_single_ops;
- 	p->single_show = show;
--	pde_set_flags(p);
- 	return proc_register(parent, p);
- }
- EXPORT_SYMBOL(proc_create_single_data);
diff -Nrup linux-6.16.7/include/dt-bindings/clock/qcom,dispcc-sm8150.h linux-lenovo-x13s-linux-6.16.y/include/dt-bindings/clock/qcom,dispcc-sm8150.h
--- linux-6.16.7/include/dt-bindings/clock/qcom,dispcc-sm8150.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/include/dt-bindings/clock/qcom,dispcc-sm8150.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,76 +1 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.
- */
-
-#ifndef _DT_BINDINGS_CLK_QCOM_DISP_CC_SM8250_H
-#define _DT_BINDINGS_CLK_QCOM_DISP_CC_SM8250_H
-
-/* DISP_CC clock registers */
-#define DISP_CC_MDSS_AHB_CLK			0
-#define DISP_CC_MDSS_AHB_CLK_SRC		1
-#define DISP_CC_MDSS_BYTE0_CLK			2
-#define DISP_CC_MDSS_BYTE0_CLK_SRC		3
-#define DISP_CC_MDSS_BYTE0_DIV_CLK_SRC		4
-#define DISP_CC_MDSS_BYTE0_INTF_CLK		5
-#define DISP_CC_MDSS_BYTE1_CLK			6
-#define DISP_CC_MDSS_BYTE1_CLK_SRC		7
-#define DISP_CC_MDSS_BYTE1_DIV_CLK_SRC		8
-#define DISP_CC_MDSS_BYTE1_INTF_CLK		9
-#define DISP_CC_MDSS_DP_AUX1_CLK		10
-#define DISP_CC_MDSS_DP_AUX1_CLK_SRC		11
-#define DISP_CC_MDSS_DP_AUX_CLK			12
-#define DISP_CC_MDSS_DP_AUX_CLK_SRC		13
-#define DISP_CC_MDSS_DP_LINK1_CLK		14
-#define DISP_CC_MDSS_DP_LINK1_CLK_SRC		15
-#define DISP_CC_MDSS_DP_LINK1_DIV_CLK_SRC	16
-#define DISP_CC_MDSS_DP_LINK1_INTF_CLK		17
-#define DISP_CC_MDSS_DP_LINK_CLK		18
-#define DISP_CC_MDSS_DP_LINK_CLK_SRC		19
-#define DISP_CC_MDSS_DP_LINK_DIV_CLK_SRC	20
-#define DISP_CC_MDSS_DP_LINK_INTF_CLK		21
-#define DISP_CC_MDSS_DP_PIXEL1_CLK		22
-#define DISP_CC_MDSS_DP_PIXEL1_CLK_SRC		23
-#define DISP_CC_MDSS_DP_PIXEL2_CLK		24
-#define DISP_CC_MDSS_DP_PIXEL2_CLK_SRC		25
-#define DISP_CC_MDSS_DP_PIXEL_CLK		26
-#define DISP_CC_MDSS_DP_PIXEL_CLK_SRC		27
-#define DISP_CC_MDSS_ESC0_CLK			28
-#define DISP_CC_MDSS_ESC0_CLK_SRC		29
-#define DISP_CC_MDSS_ESC1_CLK			30
-#define DISP_CC_MDSS_ESC1_CLK_SRC		31
-#define DISP_CC_MDSS_MDP_CLK			32
-#define DISP_CC_MDSS_MDP_CLK_SRC		33
-#define DISP_CC_MDSS_MDP_LUT_CLK		34
-#define DISP_CC_MDSS_NON_GDSC_AHB_CLK		35
-#define DISP_CC_MDSS_PCLK0_CLK			36
-#define DISP_CC_MDSS_PCLK0_CLK_SRC		37
-#define DISP_CC_MDSS_PCLK1_CLK			38
-#define DISP_CC_MDSS_PCLK1_CLK_SRC		39
-#define DISP_CC_MDSS_ROT_CLK			40
-#define DISP_CC_MDSS_ROT_CLK_SRC		41
-#define DISP_CC_MDSS_RSCC_AHB_CLK		42
-#define DISP_CC_MDSS_RSCC_VSYNC_CLK		43
-#define DISP_CC_MDSS_VSYNC_CLK			44
-#define DISP_CC_MDSS_VSYNC_CLK_SRC		45
-#define DISP_CC_PLL0				46
-#define DISP_CC_PLL1				47
-#define DISP_CC_MDSS_EDP_AUX_CLK		48
-#define DISP_CC_MDSS_EDP_AUX_CLK_SRC		49
-#define DISP_CC_MDSS_EDP_GTC_CLK		50
-#define DISP_CC_MDSS_EDP_GTC_CLK_SRC		51
-#define DISP_CC_MDSS_EDP_LINK_CLK		52
-#define DISP_CC_MDSS_EDP_LINK_CLK_SRC		53
-#define DISP_CC_MDSS_EDP_LINK_INTF_CLK		54
-#define DISP_CC_MDSS_EDP_PIXEL_CLK		55
-#define DISP_CC_MDSS_EDP_PIXEL_CLK_SRC		56
-#define DISP_CC_MDSS_EDP_LINK_DIV_CLK_SRC	57
-
-/* DISP_CC Reset */
-#define DISP_CC_MDSS_CORE_BCR			0
-#define DISP_CC_MDSS_RSCC_BCR			1
-
-/* DISP_CC GDSCR */
-#define MDSS_GDSC				0
-
-#endif
+qcom,dispcc-sm8250.h
\ No newline at end of file
diff -Nrup linux-6.16.7/include/dt-bindings/clock/qcom,dispcc-sm8350.h linux-lenovo-x13s-linux-6.16.y/include/dt-bindings/clock/qcom,dispcc-sm8350.h
--- linux-6.16.7/include/dt-bindings/clock/qcom,dispcc-sm8350.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/include/dt-bindings/clock/qcom,dispcc-sm8350.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,76 +1 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.
- */
-
-#ifndef _DT_BINDINGS_CLK_QCOM_DISP_CC_SM8250_H
-#define _DT_BINDINGS_CLK_QCOM_DISP_CC_SM8250_H
-
-/* DISP_CC clock registers */
-#define DISP_CC_MDSS_AHB_CLK			0
-#define DISP_CC_MDSS_AHB_CLK_SRC		1
-#define DISP_CC_MDSS_BYTE0_CLK			2
-#define DISP_CC_MDSS_BYTE0_CLK_SRC		3
-#define DISP_CC_MDSS_BYTE0_DIV_CLK_SRC		4
-#define DISP_CC_MDSS_BYTE0_INTF_CLK		5
-#define DISP_CC_MDSS_BYTE1_CLK			6
-#define DISP_CC_MDSS_BYTE1_CLK_SRC		7
-#define DISP_CC_MDSS_BYTE1_DIV_CLK_SRC		8
-#define DISP_CC_MDSS_BYTE1_INTF_CLK		9
-#define DISP_CC_MDSS_DP_AUX1_CLK		10
-#define DISP_CC_MDSS_DP_AUX1_CLK_SRC		11
-#define DISP_CC_MDSS_DP_AUX_CLK			12
-#define DISP_CC_MDSS_DP_AUX_CLK_SRC		13
-#define DISP_CC_MDSS_DP_LINK1_CLK		14
-#define DISP_CC_MDSS_DP_LINK1_CLK_SRC		15
-#define DISP_CC_MDSS_DP_LINK1_DIV_CLK_SRC	16
-#define DISP_CC_MDSS_DP_LINK1_INTF_CLK		17
-#define DISP_CC_MDSS_DP_LINK_CLK		18
-#define DISP_CC_MDSS_DP_LINK_CLK_SRC		19
-#define DISP_CC_MDSS_DP_LINK_DIV_CLK_SRC	20
-#define DISP_CC_MDSS_DP_LINK_INTF_CLK		21
-#define DISP_CC_MDSS_DP_PIXEL1_CLK		22
-#define DISP_CC_MDSS_DP_PIXEL1_CLK_SRC		23
-#define DISP_CC_MDSS_DP_PIXEL2_CLK		24
-#define DISP_CC_MDSS_DP_PIXEL2_CLK_SRC		25
-#define DISP_CC_MDSS_DP_PIXEL_CLK		26
-#define DISP_CC_MDSS_DP_PIXEL_CLK_SRC		27
-#define DISP_CC_MDSS_ESC0_CLK			28
-#define DISP_CC_MDSS_ESC0_CLK_SRC		29
-#define DISP_CC_MDSS_ESC1_CLK			30
-#define DISP_CC_MDSS_ESC1_CLK_SRC		31
-#define DISP_CC_MDSS_MDP_CLK			32
-#define DISP_CC_MDSS_MDP_CLK_SRC		33
-#define DISP_CC_MDSS_MDP_LUT_CLK		34
-#define DISP_CC_MDSS_NON_GDSC_AHB_CLK		35
-#define DISP_CC_MDSS_PCLK0_CLK			36
-#define DISP_CC_MDSS_PCLK0_CLK_SRC		37
-#define DISP_CC_MDSS_PCLK1_CLK			38
-#define DISP_CC_MDSS_PCLK1_CLK_SRC		39
-#define DISP_CC_MDSS_ROT_CLK			40
-#define DISP_CC_MDSS_ROT_CLK_SRC		41
-#define DISP_CC_MDSS_RSCC_AHB_CLK		42
-#define DISP_CC_MDSS_RSCC_VSYNC_CLK		43
-#define DISP_CC_MDSS_VSYNC_CLK			44
-#define DISP_CC_MDSS_VSYNC_CLK_SRC		45
-#define DISP_CC_PLL0				46
-#define DISP_CC_PLL1				47
-#define DISP_CC_MDSS_EDP_AUX_CLK		48
-#define DISP_CC_MDSS_EDP_AUX_CLK_SRC		49
-#define DISP_CC_MDSS_EDP_GTC_CLK		50
-#define DISP_CC_MDSS_EDP_GTC_CLK_SRC		51
-#define DISP_CC_MDSS_EDP_LINK_CLK		52
-#define DISP_CC_MDSS_EDP_LINK_CLK_SRC		53
-#define DISP_CC_MDSS_EDP_LINK_INTF_CLK		54
-#define DISP_CC_MDSS_EDP_PIXEL_CLK		55
-#define DISP_CC_MDSS_EDP_PIXEL_CLK_SRC		56
-#define DISP_CC_MDSS_EDP_LINK_DIV_CLK_SRC	57
-
-/* DISP_CC Reset */
-#define DISP_CC_MDSS_CORE_BCR			0
-#define DISP_CC_MDSS_RSCC_BCR			1
-
-/* DISP_CC GDSCR */
-#define MDSS_GDSC				0
-
-#endif
+qcom,dispcc-sm8250.h
\ No newline at end of file
diff -Nrup linux-6.16.7/include/dt-bindings/clock/qcom,sm8650-dispcc.h linux-lenovo-x13s-linux-6.16.y/include/dt-bindings/clock/qcom,sm8650-dispcc.h
--- linux-6.16.7/include/dt-bindings/clock/qcom,sm8650-dispcc.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/include/dt-bindings/clock/qcom,sm8650-dispcc.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,101 +1 @@
-/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */
-/*
- * Copyright (c) 2022, The Linux Foundation. All rights reserved.
- */
-
-#ifndef _DT_BINDINGS_CLK_QCOM_SM8550_DISP_CC_H
-#define _DT_BINDINGS_CLK_QCOM_SM8550_DISP_CC_H
-
-/* DISP_CC clocks */
-#define DISP_CC_MDSS_ACCU_CLK					0
-#define DISP_CC_MDSS_AHB1_CLK					1
-#define DISP_CC_MDSS_AHB_CLK					2
-#define DISP_CC_MDSS_AHB_CLK_SRC				3
-#define DISP_CC_MDSS_BYTE0_CLK					4
-#define DISP_CC_MDSS_BYTE0_CLK_SRC				5
-#define DISP_CC_MDSS_BYTE0_DIV_CLK_SRC				6
-#define DISP_CC_MDSS_BYTE0_INTF_CLK				7
-#define DISP_CC_MDSS_BYTE1_CLK					8
-#define DISP_CC_MDSS_BYTE1_CLK_SRC				9
-#define DISP_CC_MDSS_BYTE1_DIV_CLK_SRC				10
-#define DISP_CC_MDSS_BYTE1_INTF_CLK				11
-#define DISP_CC_MDSS_DPTX0_AUX_CLK				12
-#define DISP_CC_MDSS_DPTX0_AUX_CLK_SRC				13
-#define DISP_CC_MDSS_DPTX0_CRYPTO_CLK				14
-#define DISP_CC_MDSS_DPTX0_LINK_CLK				15
-#define DISP_CC_MDSS_DPTX0_LINK_CLK_SRC				16
-#define DISP_CC_MDSS_DPTX0_LINK_DIV_CLK_SRC			17
-#define DISP_CC_MDSS_DPTX0_LINK_INTF_CLK			18
-#define DISP_CC_MDSS_DPTX0_PIXEL0_CLK				19
-#define DISP_CC_MDSS_DPTX0_PIXEL0_CLK_SRC			20
-#define DISP_CC_MDSS_DPTX0_PIXEL1_CLK				21
-#define DISP_CC_MDSS_DPTX0_PIXEL1_CLK_SRC			22
-#define DISP_CC_MDSS_DPTX0_USB_ROUTER_LINK_INTF_CLK		23
-#define DISP_CC_MDSS_DPTX1_AUX_CLK				24
-#define DISP_CC_MDSS_DPTX1_AUX_CLK_SRC				25
-#define DISP_CC_MDSS_DPTX1_CRYPTO_CLK				26
-#define DISP_CC_MDSS_DPTX1_LINK_CLK				27
-#define DISP_CC_MDSS_DPTX1_LINK_CLK_SRC				28
-#define DISP_CC_MDSS_DPTX1_LINK_DIV_CLK_SRC			29
-#define DISP_CC_MDSS_DPTX1_LINK_INTF_CLK			30
-#define DISP_CC_MDSS_DPTX1_PIXEL0_CLK				31
-#define DISP_CC_MDSS_DPTX1_PIXEL0_CLK_SRC			32
-#define DISP_CC_MDSS_DPTX1_PIXEL1_CLK				33
-#define DISP_CC_MDSS_DPTX1_PIXEL1_CLK_SRC			34
-#define DISP_CC_MDSS_DPTX1_USB_ROUTER_LINK_INTF_CLK		35
-#define DISP_CC_MDSS_DPTX2_AUX_CLK				36
-#define DISP_CC_MDSS_DPTX2_AUX_CLK_SRC				37
-#define DISP_CC_MDSS_DPTX2_CRYPTO_CLK				38
-#define DISP_CC_MDSS_DPTX2_LINK_CLK				39
-#define DISP_CC_MDSS_DPTX2_LINK_CLK_SRC				40
-#define DISP_CC_MDSS_DPTX2_LINK_DIV_CLK_SRC			41
-#define DISP_CC_MDSS_DPTX2_LINK_INTF_CLK			42
-#define DISP_CC_MDSS_DPTX2_PIXEL0_CLK				43
-#define DISP_CC_MDSS_DPTX2_PIXEL0_CLK_SRC			44
-#define DISP_CC_MDSS_DPTX2_PIXEL1_CLK				45
-#define DISP_CC_MDSS_DPTX2_PIXEL1_CLK_SRC			46
-#define DISP_CC_MDSS_DPTX3_AUX_CLK				47
-#define DISP_CC_MDSS_DPTX3_AUX_CLK_SRC				48
-#define DISP_CC_MDSS_DPTX3_CRYPTO_CLK				49
-#define DISP_CC_MDSS_DPTX3_LINK_CLK				50
-#define DISP_CC_MDSS_DPTX3_LINK_CLK_SRC				51
-#define DISP_CC_MDSS_DPTX3_LINK_DIV_CLK_SRC			52
-#define DISP_CC_MDSS_DPTX3_LINK_INTF_CLK			53
-#define DISP_CC_MDSS_DPTX3_PIXEL0_CLK				54
-#define DISP_CC_MDSS_DPTX3_PIXEL0_CLK_SRC			55
-#define DISP_CC_MDSS_ESC0_CLK					56
-#define DISP_CC_MDSS_ESC0_CLK_SRC				57
-#define DISP_CC_MDSS_ESC1_CLK					58
-#define DISP_CC_MDSS_ESC1_CLK_SRC				59
-#define DISP_CC_MDSS_MDP1_CLK					60
-#define DISP_CC_MDSS_MDP_CLK					61
-#define DISP_CC_MDSS_MDP_CLK_SRC				62
-#define DISP_CC_MDSS_MDP_LUT1_CLK				63
-#define DISP_CC_MDSS_MDP_LUT_CLK				64
-#define DISP_CC_MDSS_NON_GDSC_AHB_CLK				65
-#define DISP_CC_MDSS_PCLK0_CLK					66
-#define DISP_CC_MDSS_PCLK0_CLK_SRC				67
-#define DISP_CC_MDSS_PCLK1_CLK					68
-#define DISP_CC_MDSS_PCLK1_CLK_SRC				69
-#define DISP_CC_MDSS_RSCC_AHB_CLK				70
-#define DISP_CC_MDSS_RSCC_VSYNC_CLK				71
-#define DISP_CC_MDSS_VSYNC1_CLK					72
-#define DISP_CC_MDSS_VSYNC_CLK					73
-#define DISP_CC_MDSS_VSYNC_CLK_SRC				74
-#define DISP_CC_PLL0						75
-#define DISP_CC_PLL1						76
-#define DISP_CC_SLEEP_CLK					77
-#define DISP_CC_SLEEP_CLK_SRC					78
-#define DISP_CC_XO_CLK						79
-#define DISP_CC_XO_CLK_SRC					80
-
-/* DISP_CC resets */
-#define DISP_CC_MDSS_CORE_BCR					0
-#define DISP_CC_MDSS_CORE_INT2_BCR				1
-#define DISP_CC_MDSS_RSCC_BCR					2
-
-/* DISP_CC GDSCR */
-#define MDSS_GDSC						0
-#define MDSS_INT2_GDSC						1
-
-#endif
+qcom,sm8550-dispcc.h
\ No newline at end of file
diff -Nrup linux-6.16.7/include/dt-bindings/input/linux-event-codes.h linux-lenovo-x13s-linux-6.16.y/include/dt-bindings/input/linux-event-codes.h
--- linux-6.16.7/include/dt-bindings/input/linux-event-codes.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/include/dt-bindings/input/linux-event-codes.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,982 +1 @@
-/* SPDX-License-Identifier: GPL-2.0-only WITH Linux-syscall-note */
-/*
- * Input event codes
- *
- *    *** IMPORTANT ***
- * This file is not only included from C-code but also from devicetree source
- * files. As such this file MUST only contain comments and defines.
- *
- * Copyright (c) 1999-2002 Vojtech Pavlik
- * Copyright (c) 2015 Hans de Goede <hdegoede@redhat.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published by
- * the Free Software Foundation.
- */
-#ifndef _UAPI_INPUT_EVENT_CODES_H
-#define _UAPI_INPUT_EVENT_CODES_H
-
-/*
- * Device properties and quirks
- */
-
-#define INPUT_PROP_POINTER		0x00	/* needs a pointer */
-#define INPUT_PROP_DIRECT		0x01	/* direct input devices */
-#define INPUT_PROP_BUTTONPAD		0x02	/* has button(s) under pad */
-#define INPUT_PROP_SEMI_MT		0x03	/* touch rectangle only */
-#define INPUT_PROP_TOPBUTTONPAD		0x04	/* softbuttons at top of pad */
-#define INPUT_PROP_POINTING_STICK	0x05	/* is a pointing stick */
-#define INPUT_PROP_ACCELEROMETER	0x06	/* has accelerometer */
-
-#define INPUT_PROP_MAX			0x1f
-#define INPUT_PROP_CNT			(INPUT_PROP_MAX + 1)
-
-/*
- * Event types
- */
-
-#define EV_SYN			0x00
-#define EV_KEY			0x01
-#define EV_REL			0x02
-#define EV_ABS			0x03
-#define EV_MSC			0x04
-#define EV_SW			0x05
-#define EV_LED			0x11
-#define EV_SND			0x12
-#define EV_REP			0x14
-#define EV_FF			0x15
-#define EV_PWR			0x16
-#define EV_FF_STATUS		0x17
-#define EV_MAX			0x1f
-#define EV_CNT			(EV_MAX+1)
-
-/*
- * Synchronization events.
- */
-
-#define SYN_REPORT		0
-#define SYN_CONFIG		1
-#define SYN_MT_REPORT		2
-#define SYN_DROPPED		3
-#define SYN_MAX			0xf
-#define SYN_CNT			(SYN_MAX+1)
-
-/*
- * Keys and buttons
- *
- * Most of the keys/buttons are modeled after USB HUT 1.12
- * (see http://www.usb.org/developers/hidpage).
- * Abbreviations in the comments:
- * AC - Application Control
- * AL - Application Launch Button
- * SC - System Control
- */
-
-#define KEY_RESERVED		0
-#define KEY_ESC			1
-#define KEY_1			2
-#define KEY_2			3
-#define KEY_3			4
-#define KEY_4			5
-#define KEY_5			6
-#define KEY_6			7
-#define KEY_7			8
-#define KEY_8			9
-#define KEY_9			10
-#define KEY_0			11
-#define KEY_MINUS		12
-#define KEY_EQUAL		13
-#define KEY_BACKSPACE		14
-#define KEY_TAB			15
-#define KEY_Q			16
-#define KEY_W			17
-#define KEY_E			18
-#define KEY_R			19
-#define KEY_T			20
-#define KEY_Y			21
-#define KEY_U			22
-#define KEY_I			23
-#define KEY_O			24
-#define KEY_P			25
-#define KEY_LEFTBRACE		26
-#define KEY_RIGHTBRACE		27
-#define KEY_ENTER		28
-#define KEY_LEFTCTRL		29
-#define KEY_A			30
-#define KEY_S			31
-#define KEY_D			32
-#define KEY_F			33
-#define KEY_G			34
-#define KEY_H			35
-#define KEY_J			36
-#define KEY_K			37
-#define KEY_L			38
-#define KEY_SEMICOLON		39
-#define KEY_APOSTROPHE		40
-#define KEY_GRAVE		41
-#define KEY_LEFTSHIFT		42
-#define KEY_BACKSLASH		43
-#define KEY_Z			44
-#define KEY_X			45
-#define KEY_C			46
-#define KEY_V			47
-#define KEY_B			48
-#define KEY_N			49
-#define KEY_M			50
-#define KEY_COMMA		51
-#define KEY_DOT			52
-#define KEY_SLASH		53
-#define KEY_RIGHTSHIFT		54
-#define KEY_KPASTERISK		55
-#define KEY_LEFTALT		56
-#define KEY_SPACE		57
-#define KEY_CAPSLOCK		58
-#define KEY_F1			59
-#define KEY_F2			60
-#define KEY_F3			61
-#define KEY_F4			62
-#define KEY_F5			63
-#define KEY_F6			64
-#define KEY_F7			65
-#define KEY_F8			66
-#define KEY_F9			67
-#define KEY_F10			68
-#define KEY_NUMLOCK		69
-#define KEY_SCROLLLOCK		70
-#define KEY_KP7			71
-#define KEY_KP8			72
-#define KEY_KP9			73
-#define KEY_KPMINUS		74
-#define KEY_KP4			75
-#define KEY_KP5			76
-#define KEY_KP6			77
-#define KEY_KPPLUS		78
-#define KEY_KP1			79
-#define KEY_KP2			80
-#define KEY_KP3			81
-#define KEY_KP0			82
-#define KEY_KPDOT		83
-
-#define KEY_ZENKAKUHANKAKU	85
-#define KEY_102ND		86
-#define KEY_F11			87
-#define KEY_F12			88
-#define KEY_RO			89
-#define KEY_KATAKANA		90
-#define KEY_HIRAGANA		91
-#define KEY_HENKAN		92
-#define KEY_KATAKANAHIRAGANA	93
-#define KEY_MUHENKAN		94
-#define KEY_KPJPCOMMA		95
-#define KEY_KPENTER		96
-#define KEY_RIGHTCTRL		97
-#define KEY_KPSLASH		98
-#define KEY_SYSRQ		99
-#define KEY_RIGHTALT		100
-#define KEY_LINEFEED		101
-#define KEY_HOME		102
-#define KEY_UP			103
-#define KEY_PAGEUP		104
-#define KEY_LEFT		105
-#define KEY_RIGHT		106
-#define KEY_END			107
-#define KEY_DOWN		108
-#define KEY_PAGEDOWN		109
-#define KEY_INSERT		110
-#define KEY_DELETE		111
-#define KEY_MACRO		112
-#define KEY_MUTE		113
-#define KEY_VOLUMEDOWN		114
-#define KEY_VOLUMEUP		115
-#define KEY_POWER		116	/* SC System Power Down */
-#define KEY_KPEQUAL		117
-#define KEY_KPPLUSMINUS		118
-#define KEY_PAUSE		119
-#define KEY_SCALE		120	/* AL Compiz Scale (Expose) */
-
-#define KEY_KPCOMMA		121
-#define KEY_HANGEUL		122
-#define KEY_HANGUEL		KEY_HANGEUL
-#define KEY_HANJA		123
-#define KEY_YEN			124
-#define KEY_LEFTMETA		125
-#define KEY_RIGHTMETA		126
-#define KEY_COMPOSE		127
-
-#define KEY_STOP		128	/* AC Stop */
-#define KEY_AGAIN		129
-#define KEY_PROPS		130	/* AC Properties */
-#define KEY_UNDO		131	/* AC Undo */
-#define KEY_FRONT		132
-#define KEY_COPY		133	/* AC Copy */
-#define KEY_OPEN		134	/* AC Open */
-#define KEY_PASTE		135	/* AC Paste */
-#define KEY_FIND		136	/* AC Search */
-#define KEY_CUT			137	/* AC Cut */
-#define KEY_HELP		138	/* AL Integrated Help Center */
-#define KEY_MENU		139	/* Menu (show menu) */
-#define KEY_CALC		140	/* AL Calculator */
-#define KEY_SETUP		141
-#define KEY_SLEEP		142	/* SC System Sleep */
-#define KEY_WAKEUP		143	/* System Wake Up */
-#define KEY_FILE		144	/* AL Local Machine Browser */
-#define KEY_SENDFILE		145
-#define KEY_DELETEFILE		146
-#define KEY_XFER		147
-#define KEY_PROG1		148
-#define KEY_PROG2		149
-#define KEY_WWW			150	/* AL Internet Browser */
-#define KEY_MSDOS		151
-#define KEY_COFFEE		152	/* AL Terminal Lock/Screensaver */
-#define KEY_SCREENLOCK		KEY_COFFEE
-#define KEY_ROTATE_DISPLAY	153	/* Display orientation for e.g. tablets */
-#define KEY_DIRECTION		KEY_ROTATE_DISPLAY
-#define KEY_CYCLEWINDOWS	154
-#define KEY_MAIL		155
-#define KEY_BOOKMARKS		156	/* AC Bookmarks */
-#define KEY_COMPUTER		157
-#define KEY_BACK		158	/* AC Back */
-#define KEY_FORWARD		159	/* AC Forward */
-#define KEY_CLOSECD		160
-#define KEY_EJECTCD		161
-#define KEY_EJECTCLOSECD	162
-#define KEY_NEXTSONG		163
-#define KEY_PLAYPAUSE		164
-#define KEY_PREVIOUSSONG	165
-#define KEY_STOPCD		166
-#define KEY_RECORD		167
-#define KEY_REWIND		168
-#define KEY_PHONE		169	/* Media Select Telephone */
-#define KEY_ISO			170
-#define KEY_CONFIG		171	/* AL Consumer Control Configuration */
-#define KEY_HOMEPAGE		172	/* AC Home */
-#define KEY_REFRESH		173	/* AC Refresh */
-#define KEY_EXIT		174	/* AC Exit */
-#define KEY_MOVE		175
-#define KEY_EDIT		176
-#define KEY_SCROLLUP		177
-#define KEY_SCROLLDOWN		178
-#define KEY_KPLEFTPAREN		179
-#define KEY_KPRIGHTPAREN	180
-#define KEY_NEW			181	/* AC New */
-#define KEY_REDO		182	/* AC Redo/Repeat */
-
-#define KEY_F13			183
-#define KEY_F14			184
-#define KEY_F15			185
-#define KEY_F16			186
-#define KEY_F17			187
-#define KEY_F18			188
-#define KEY_F19			189
-#define KEY_F20			190
-#define KEY_F21			191
-#define KEY_F22			192
-#define KEY_F23			193
-#define KEY_F24			194
-
-#define KEY_PLAYCD		200
-#define KEY_PAUSECD		201
-#define KEY_PROG3		202
-#define KEY_PROG4		203
-#define KEY_ALL_APPLICATIONS	204	/* AC Desktop Show All Applications */
-#define KEY_DASHBOARD		KEY_ALL_APPLICATIONS
-#define KEY_SUSPEND		205
-#define KEY_CLOSE		206	/* AC Close */
-#define KEY_PLAY		207
-#define KEY_FASTFORWARD		208
-#define KEY_BASSBOOST		209
-#define KEY_PRINT		210	/* AC Print */
-#define KEY_HP			211
-#define KEY_CAMERA		212
-#define KEY_SOUND		213
-#define KEY_QUESTION		214
-#define KEY_EMAIL		215
-#define KEY_CHAT		216
-#define KEY_SEARCH		217
-#define KEY_CONNECT		218
-#define KEY_FINANCE		219	/* AL Checkbook/Finance */
-#define KEY_SPORT		220
-#define KEY_SHOP		221
-#define KEY_ALTERASE		222
-#define KEY_CANCEL		223	/* AC Cancel */
-#define KEY_BRIGHTNESSDOWN	224
-#define KEY_BRIGHTNESSUP	225
-#define KEY_MEDIA		226
-
-#define KEY_SWITCHVIDEOMODE	227	/* Cycle between available video
-					   outputs (Monitor/LCD/TV-out/etc) */
-#define KEY_KBDILLUMTOGGLE	228
-#define KEY_KBDILLUMDOWN	229
-#define KEY_KBDILLUMUP		230
-
-#define KEY_SEND		231	/* AC Send */
-#define KEY_REPLY		232	/* AC Reply */
-#define KEY_FORWARDMAIL		233	/* AC Forward Msg */
-#define KEY_SAVE		234	/* AC Save */
-#define KEY_DOCUMENTS		235
-
-#define KEY_BATTERY		236
-
-#define KEY_BLUETOOTH		237
-#define KEY_WLAN		238
-#define KEY_UWB			239
-
-#define KEY_UNKNOWN		240
-
-#define KEY_VIDEO_NEXT		241	/* drive next video source */
-#define KEY_VIDEO_PREV		242	/* drive previous video source */
-#define KEY_BRIGHTNESS_CYCLE	243	/* brightness up, after max is min */
-#define KEY_BRIGHTNESS_AUTO	244	/* Set Auto Brightness: manual
-					  brightness control is off,
-					  rely on ambient */
-#define KEY_BRIGHTNESS_ZERO	KEY_BRIGHTNESS_AUTO
-#define KEY_DISPLAY_OFF		245	/* display device to off state */
-
-#define KEY_WWAN		246	/* Wireless WAN (LTE, UMTS, GSM, etc.) */
-#define KEY_WIMAX		KEY_WWAN
-#define KEY_RFKILL		247	/* Key that controls all radios */
-
-#define KEY_MICMUTE		248	/* Mute / unmute the microphone */
-
-/* Code 255 is reserved for special needs of AT keyboard driver */
-
-#define BTN_MISC		0x100
-#define BTN_0			0x100
-#define BTN_1			0x101
-#define BTN_2			0x102
-#define BTN_3			0x103
-#define BTN_4			0x104
-#define BTN_5			0x105
-#define BTN_6			0x106
-#define BTN_7			0x107
-#define BTN_8			0x108
-#define BTN_9			0x109
-
-#define BTN_MOUSE		0x110
-#define BTN_LEFT		0x110
-#define BTN_RIGHT		0x111
-#define BTN_MIDDLE		0x112
-#define BTN_SIDE		0x113
-#define BTN_EXTRA		0x114
-#define BTN_FORWARD		0x115
-#define BTN_BACK		0x116
-#define BTN_TASK		0x117
-
-#define BTN_JOYSTICK		0x120
-#define BTN_TRIGGER		0x120
-#define BTN_THUMB		0x121
-#define BTN_THUMB2		0x122
-#define BTN_TOP			0x123
-#define BTN_TOP2		0x124
-#define BTN_PINKIE		0x125
-#define BTN_BASE		0x126
-#define BTN_BASE2		0x127
-#define BTN_BASE3		0x128
-#define BTN_BASE4		0x129
-#define BTN_BASE5		0x12a
-#define BTN_BASE6		0x12b
-#define BTN_DEAD		0x12f
-
-#define BTN_GAMEPAD		0x130
-#define BTN_SOUTH		0x130
-#define BTN_A			BTN_SOUTH
-#define BTN_EAST		0x131
-#define BTN_B			BTN_EAST
-#define BTN_C			0x132
-#define BTN_NORTH		0x133
-#define BTN_X			BTN_NORTH
-#define BTN_WEST		0x134
-#define BTN_Y			BTN_WEST
-#define BTN_Z			0x135
-#define BTN_TL			0x136
-#define BTN_TR			0x137
-#define BTN_TL2			0x138
-#define BTN_TR2			0x139
-#define BTN_SELECT		0x13a
-#define BTN_START		0x13b
-#define BTN_MODE		0x13c
-#define BTN_THUMBL		0x13d
-#define BTN_THUMBR		0x13e
-
-#define BTN_DIGI		0x140
-#define BTN_TOOL_PEN		0x140
-#define BTN_TOOL_RUBBER		0x141
-#define BTN_TOOL_BRUSH		0x142
-#define BTN_TOOL_PENCIL		0x143
-#define BTN_TOOL_AIRBRUSH	0x144
-#define BTN_TOOL_FINGER		0x145
-#define BTN_TOOL_MOUSE		0x146
-#define BTN_TOOL_LENS		0x147
-#define BTN_TOOL_QUINTTAP	0x148	/* Five fingers on trackpad */
-#define BTN_STYLUS3		0x149
-#define BTN_TOUCH		0x14a
-#define BTN_STYLUS		0x14b
-#define BTN_STYLUS2		0x14c
-#define BTN_TOOL_DOUBLETAP	0x14d
-#define BTN_TOOL_TRIPLETAP	0x14e
-#define BTN_TOOL_QUADTAP	0x14f	/* Four fingers on trackpad */
-
-#define BTN_WHEEL		0x150
-#define BTN_GEAR_DOWN		0x150
-#define BTN_GEAR_UP		0x151
-
-#define KEY_OK			0x160
-#define KEY_SELECT		0x161
-#define KEY_GOTO		0x162
-#define KEY_CLEAR		0x163
-#define KEY_POWER2		0x164
-#define KEY_OPTION		0x165
-#define KEY_INFO		0x166	/* AL OEM Features/Tips/Tutorial */
-#define KEY_TIME		0x167
-#define KEY_VENDOR		0x168
-#define KEY_ARCHIVE		0x169
-#define KEY_PROGRAM		0x16a	/* Media Select Program Guide */
-#define KEY_CHANNEL		0x16b
-#define KEY_FAVORITES		0x16c
-#define KEY_EPG			0x16d
-#define KEY_PVR			0x16e	/* Media Select Home */
-#define KEY_MHP			0x16f
-#define KEY_LANGUAGE		0x170
-#define KEY_TITLE		0x171
-#define KEY_SUBTITLE		0x172
-#define KEY_ANGLE		0x173
-#define KEY_FULL_SCREEN		0x174	/* AC View Toggle */
-#define KEY_ZOOM		KEY_FULL_SCREEN
-#define KEY_MODE		0x175
-#define KEY_KEYBOARD		0x176
-#define KEY_ASPECT_RATIO	0x177	/* HUTRR37: Aspect */
-#define KEY_SCREEN		KEY_ASPECT_RATIO
-#define KEY_PC			0x178	/* Media Select Computer */
-#define KEY_TV			0x179	/* Media Select TV */
-#define KEY_TV2			0x17a	/* Media Select Cable */
-#define KEY_VCR			0x17b	/* Media Select VCR */
-#define KEY_VCR2		0x17c	/* VCR Plus */
-#define KEY_SAT			0x17d	/* Media Select Satellite */
-#define KEY_SAT2		0x17e
-#define KEY_CD			0x17f	/* Media Select CD */
-#define KEY_TAPE		0x180	/* Media Select Tape */
-#define KEY_RADIO		0x181
-#define KEY_TUNER		0x182	/* Media Select Tuner */
-#define KEY_PLAYER		0x183
-#define KEY_TEXT		0x184
-#define KEY_DVD			0x185	/* Media Select DVD */
-#define KEY_AUX			0x186
-#define KEY_MP3			0x187
-#define KEY_AUDIO		0x188	/* AL Audio Browser */
-#define KEY_VIDEO		0x189	/* AL Movie Browser */
-#define KEY_DIRECTORY		0x18a
-#define KEY_LIST		0x18b
-#define KEY_MEMO		0x18c	/* Media Select Messages */
-#define KEY_CALENDAR		0x18d
-#define KEY_RED			0x18e
-#define KEY_GREEN		0x18f
-#define KEY_YELLOW		0x190
-#define KEY_BLUE		0x191
-#define KEY_CHANNELUP		0x192	/* Channel Increment */
-#define KEY_CHANNELDOWN		0x193	/* Channel Decrement */
-#define KEY_FIRST		0x194
-#define KEY_LAST		0x195	/* Recall Last */
-#define KEY_AB			0x196
-#define KEY_NEXT		0x197
-#define KEY_RESTART		0x198
-#define KEY_SLOW		0x199
-#define KEY_SHUFFLE		0x19a
-#define KEY_BREAK		0x19b
-#define KEY_PREVIOUS		0x19c
-#define KEY_DIGITS		0x19d
-#define KEY_TEEN		0x19e
-#define KEY_TWEN		0x19f
-#define KEY_VIDEOPHONE		0x1a0	/* Media Select Video Phone */
-#define KEY_GAMES		0x1a1	/* Media Select Games */
-#define KEY_ZOOMIN		0x1a2	/* AC Zoom In */
-#define KEY_ZOOMOUT		0x1a3	/* AC Zoom Out */
-#define KEY_ZOOMRESET		0x1a4	/* AC Zoom */
-#define KEY_WORDPROCESSOR	0x1a5	/* AL Word Processor */
-#define KEY_EDITOR		0x1a6	/* AL Text Editor */
-#define KEY_SPREADSHEET		0x1a7	/* AL Spreadsheet */
-#define KEY_GRAPHICSEDITOR	0x1a8	/* AL Graphics Editor */
-#define KEY_PRESENTATION	0x1a9	/* AL Presentation App */
-#define KEY_DATABASE		0x1aa	/* AL Database App */
-#define KEY_NEWS		0x1ab	/* AL Newsreader */
-#define KEY_VOICEMAIL		0x1ac	/* AL Voicemail */
-#define KEY_ADDRESSBOOK		0x1ad	/* AL Contacts/Address Book */
-#define KEY_MESSENGER		0x1ae	/* AL Instant Messaging */
-#define KEY_DISPLAYTOGGLE	0x1af	/* Turn display (LCD) on and off */
-#define KEY_BRIGHTNESS_TOGGLE	KEY_DISPLAYTOGGLE
-#define KEY_SPELLCHECK		0x1b0   /* AL Spell Check */
-#define KEY_LOGOFF		0x1b1   /* AL Logoff */
-
-#define KEY_DOLLAR		0x1b2
-#define KEY_EURO		0x1b3
-
-#define KEY_FRAMEBACK		0x1b4	/* Consumer - transport controls */
-#define KEY_FRAMEFORWARD	0x1b5
-#define KEY_CONTEXT_MENU	0x1b6	/* GenDesc - system context menu */
-#define KEY_MEDIA_REPEAT	0x1b7	/* Consumer - transport control */
-#define KEY_10CHANNELSUP	0x1b8	/* 10 channels up (10+) */
-#define KEY_10CHANNELSDOWN	0x1b9	/* 10 channels down (10-) */
-#define KEY_IMAGES		0x1ba	/* AL Image Browser */
-#define KEY_NOTIFICATION_CENTER	0x1bc	/* Show/hide the notification center */
-#define KEY_PICKUP_PHONE	0x1bd	/* Answer incoming call */
-#define KEY_HANGUP_PHONE	0x1be	/* Decline incoming call */
-#define KEY_LINK_PHONE		0x1bf   /* AL Phone Syncing */
-
-#define KEY_DEL_EOL		0x1c0
-#define KEY_DEL_EOS		0x1c1
-#define KEY_INS_LINE		0x1c2
-#define KEY_DEL_LINE		0x1c3
-
-#define KEY_FN			0x1d0
-#define KEY_FN_ESC		0x1d1
-#define KEY_FN_F1		0x1d2
-#define KEY_FN_F2		0x1d3
-#define KEY_FN_F3		0x1d4
-#define KEY_FN_F4		0x1d5
-#define KEY_FN_F5		0x1d6
-#define KEY_FN_F6		0x1d7
-#define KEY_FN_F7		0x1d8
-#define KEY_FN_F8		0x1d9
-#define KEY_FN_F9		0x1da
-#define KEY_FN_F10		0x1db
-#define KEY_FN_F11		0x1dc
-#define KEY_FN_F12		0x1dd
-#define KEY_FN_1		0x1de
-#define KEY_FN_2		0x1df
-#define KEY_FN_D		0x1e0
-#define KEY_FN_E		0x1e1
-#define KEY_FN_F		0x1e2
-#define KEY_FN_S		0x1e3
-#define KEY_FN_B		0x1e4
-#define KEY_FN_RIGHT_SHIFT	0x1e5
-
-#define KEY_BRL_DOT1		0x1f1
-#define KEY_BRL_DOT2		0x1f2
-#define KEY_BRL_DOT3		0x1f3
-#define KEY_BRL_DOT4		0x1f4
-#define KEY_BRL_DOT5		0x1f5
-#define KEY_BRL_DOT6		0x1f6
-#define KEY_BRL_DOT7		0x1f7
-#define KEY_BRL_DOT8		0x1f8
-#define KEY_BRL_DOT9		0x1f9
-#define KEY_BRL_DOT10		0x1fa
-
-#define KEY_NUMERIC_0		0x200	/* used by phones, remote controls, */
-#define KEY_NUMERIC_1		0x201	/* and other keypads */
-#define KEY_NUMERIC_2		0x202
-#define KEY_NUMERIC_3		0x203
-#define KEY_NUMERIC_4		0x204
-#define KEY_NUMERIC_5		0x205
-#define KEY_NUMERIC_6		0x206
-#define KEY_NUMERIC_7		0x207
-#define KEY_NUMERIC_8		0x208
-#define KEY_NUMERIC_9		0x209
-#define KEY_NUMERIC_STAR	0x20a
-#define KEY_NUMERIC_POUND	0x20b
-#define KEY_NUMERIC_A		0x20c	/* Phone key A - HUT Telephony 0xb9 */
-#define KEY_NUMERIC_B		0x20d
-#define KEY_NUMERIC_C		0x20e
-#define KEY_NUMERIC_D		0x20f
-
-#define KEY_CAMERA_FOCUS	0x210
-#define KEY_WPS_BUTTON		0x211	/* WiFi Protected Setup key */
-
-#define KEY_TOUCHPAD_TOGGLE	0x212	/* Request switch touchpad on or off */
-#define KEY_TOUCHPAD_ON		0x213
-#define KEY_TOUCHPAD_OFF	0x214
-
-#define KEY_CAMERA_ZOOMIN	0x215
-#define KEY_CAMERA_ZOOMOUT	0x216
-#define KEY_CAMERA_UP		0x217
-#define KEY_CAMERA_DOWN		0x218
-#define KEY_CAMERA_LEFT		0x219
-#define KEY_CAMERA_RIGHT	0x21a
-
-#define KEY_ATTENDANT_ON	0x21b
-#define KEY_ATTENDANT_OFF	0x21c
-#define KEY_ATTENDANT_TOGGLE	0x21d	/* Attendant call on or off */
-#define KEY_LIGHTS_TOGGLE	0x21e	/* Reading light on or off */
-
-#define BTN_DPAD_UP		0x220
-#define BTN_DPAD_DOWN		0x221
-#define BTN_DPAD_LEFT		0x222
-#define BTN_DPAD_RIGHT		0x223
-
-#define KEY_ALS_TOGGLE		0x230	/* Ambient light sensor */
-#define KEY_ROTATE_LOCK_TOGGLE	0x231	/* Display rotation lock */
-#define KEY_REFRESH_RATE_TOGGLE	0x232	/* Display refresh rate toggle */
-
-#define KEY_BUTTONCONFIG		0x240	/* AL Button Configuration */
-#define KEY_TASKMANAGER		0x241	/* AL Task/Project Manager */
-#define KEY_JOURNAL		0x242	/* AL Log/Journal/Timecard */
-#define KEY_CONTROLPANEL		0x243	/* AL Control Panel */
-#define KEY_APPSELECT		0x244	/* AL Select Task/Application */
-#define KEY_SCREENSAVER		0x245	/* AL Screen Saver */
-#define KEY_VOICECOMMAND		0x246	/* Listening Voice Command */
-#define KEY_ASSISTANT		0x247	/* AL Context-aware desktop assistant */
-#define KEY_KBD_LAYOUT_NEXT	0x248	/* AC Next Keyboard Layout Select */
-#define KEY_EMOJI_PICKER	0x249	/* Show/hide emoji picker (HUTRR101) */
-#define KEY_DICTATE		0x24a	/* Start or Stop Voice Dictation Session (HUTRR99) */
-#define KEY_CAMERA_ACCESS_ENABLE	0x24b	/* Enables programmatic access to camera devices. (HUTRR72) */
-#define KEY_CAMERA_ACCESS_DISABLE	0x24c	/* Disables programmatic access to camera devices. (HUTRR72) */
-#define KEY_CAMERA_ACCESS_TOGGLE	0x24d	/* Toggles the current state of the camera access control. (HUTRR72) */
-#define KEY_ACCESSIBILITY		0x24e	/* Toggles the system bound accessibility UI/command (HUTRR116) */
-#define KEY_DO_NOT_DISTURB		0x24f	/* Toggles the system-wide "Do Not Disturb" control (HUTRR94)*/
-
-#define KEY_BRIGHTNESS_MIN		0x250	/* Set Brightness to Minimum */
-#define KEY_BRIGHTNESS_MAX		0x251	/* Set Brightness to Maximum */
-
-#define KEY_KBDINPUTASSIST_PREV		0x260
-#define KEY_KBDINPUTASSIST_NEXT		0x261
-#define KEY_KBDINPUTASSIST_PREVGROUP		0x262
-#define KEY_KBDINPUTASSIST_NEXTGROUP		0x263
-#define KEY_KBDINPUTASSIST_ACCEPT		0x264
-#define KEY_KBDINPUTASSIST_CANCEL		0x265
-
-/* Diagonal movement keys */
-#define KEY_RIGHT_UP			0x266
-#define KEY_RIGHT_DOWN			0x267
-#define KEY_LEFT_UP			0x268
-#define KEY_LEFT_DOWN			0x269
-
-#define KEY_ROOT_MENU			0x26a /* Show Device's Root Menu */
-/* Show Top Menu of the Media (e.g. DVD) */
-#define KEY_MEDIA_TOP_MENU		0x26b
-#define KEY_NUMERIC_11			0x26c
-#define KEY_NUMERIC_12			0x26d
-/*
- * Toggle Audio Description: refers to an audio service that helps blind and
- * visually impaired consumers understand the action in a program. Note: in
- * some countries this is referred to as "Video Description".
- */
-#define KEY_AUDIO_DESC			0x26e
-#define KEY_3D_MODE			0x26f
-#define KEY_NEXT_FAVORITE		0x270
-#define KEY_STOP_RECORD			0x271
-#define KEY_PAUSE_RECORD		0x272
-#define KEY_VOD				0x273 /* Video on Demand */
-#define KEY_UNMUTE			0x274
-#define KEY_FASTREVERSE			0x275
-#define KEY_SLOWREVERSE			0x276
-/*
- * Control a data application associated with the currently viewed channel,
- * e.g. teletext or data broadcast application (MHEG, MHP, HbbTV, etc.)
- */
-#define KEY_DATA			0x277
-#define KEY_ONSCREEN_KEYBOARD		0x278
-/* Electronic privacy screen control */
-#define KEY_PRIVACY_SCREEN_TOGGLE	0x279
-
-/* Select an area of screen to be copied */
-#define KEY_SELECTIVE_SCREENSHOT	0x27a
-
-/* Move the focus to the next or previous user controllable element within a UI container */
-#define KEY_NEXT_ELEMENT               0x27b
-#define KEY_PREVIOUS_ELEMENT           0x27c
-
-/* Toggle Autopilot engagement */
-#define KEY_AUTOPILOT_ENGAGE_TOGGLE    0x27d
-
-/* Shortcut Keys */
-#define KEY_MARK_WAYPOINT              0x27e
-#define KEY_SOS                                0x27f
-#define KEY_NAV_CHART                  0x280
-#define KEY_FISHING_CHART              0x281
-#define KEY_SINGLE_RANGE_RADAR         0x282
-#define KEY_DUAL_RANGE_RADAR           0x283
-#define KEY_RADAR_OVERLAY              0x284
-#define KEY_TRADITIONAL_SONAR          0x285
-#define KEY_CLEARVU_SONAR              0x286
-#define KEY_SIDEVU_SONAR               0x287
-#define KEY_NAV_INFO                   0x288
-#define KEY_BRIGHTNESS_MENU            0x289
-
-/*
- * Some keyboards have keys which do not have a defined meaning, these keys
- * are intended to be programmed / bound to macros by the user. For most
- * keyboards with these macro-keys the key-sequence to inject, or action to
- * take, is all handled by software on the host side. So from the kernel's
- * point of view these are just normal keys.
- *
- * The KEY_MACRO# codes below are intended for such keys, which may be labeled
- * e.g. G1-G18, or S1 - S30. The KEY_MACRO# codes MUST NOT be used for keys
- * where the marking on the key does indicate a defined meaning / purpose.
- *
- * The KEY_MACRO# codes MUST also NOT be used as fallback for when no existing
- * KEY_FOO define matches the marking / purpose. In this case a new KEY_FOO
- * define MUST be added.
- */
-#define KEY_MACRO1			0x290
-#define KEY_MACRO2			0x291
-#define KEY_MACRO3			0x292
-#define KEY_MACRO4			0x293
-#define KEY_MACRO5			0x294
-#define KEY_MACRO6			0x295
-#define KEY_MACRO7			0x296
-#define KEY_MACRO8			0x297
-#define KEY_MACRO9			0x298
-#define KEY_MACRO10			0x299
-#define KEY_MACRO11			0x29a
-#define KEY_MACRO12			0x29b
-#define KEY_MACRO13			0x29c
-#define KEY_MACRO14			0x29d
-#define KEY_MACRO15			0x29e
-#define KEY_MACRO16			0x29f
-#define KEY_MACRO17			0x2a0
-#define KEY_MACRO18			0x2a1
-#define KEY_MACRO19			0x2a2
-#define KEY_MACRO20			0x2a3
-#define KEY_MACRO21			0x2a4
-#define KEY_MACRO22			0x2a5
-#define KEY_MACRO23			0x2a6
-#define KEY_MACRO24			0x2a7
-#define KEY_MACRO25			0x2a8
-#define KEY_MACRO26			0x2a9
-#define KEY_MACRO27			0x2aa
-#define KEY_MACRO28			0x2ab
-#define KEY_MACRO29			0x2ac
-#define KEY_MACRO30			0x2ad
-
-/*
- * Some keyboards with the macro-keys described above have some extra keys
- * for controlling the host-side software responsible for the macro handling:
- * -A macro recording start/stop key. Note that not all keyboards which emit
- *  KEY_MACRO_RECORD_START will also emit KEY_MACRO_RECORD_STOP if
- *  KEY_MACRO_RECORD_STOP is not advertised, then KEY_MACRO_RECORD_START
- *  should be interpreted as a recording start/stop toggle;
- * -Keys for switching between different macro (pre)sets, either a key for
- *  cycling through the configured presets or keys to directly select a preset.
- */
-#define KEY_MACRO_RECORD_START		0x2b0
-#define KEY_MACRO_RECORD_STOP		0x2b1
-#define KEY_MACRO_PRESET_CYCLE		0x2b2
-#define KEY_MACRO_PRESET1		0x2b3
-#define KEY_MACRO_PRESET2		0x2b4
-#define KEY_MACRO_PRESET3		0x2b5
-
-/*
- * Some keyboards have a buildin LCD panel where the contents are controlled
- * by the host. Often these have a number of keys directly below the LCD
- * intended for controlling a menu shown on the LCD. These keys often don't
- * have any labeling so we just name them KEY_KBD_LCD_MENU#
- */
-#define KEY_KBD_LCD_MENU1		0x2b8
-#define KEY_KBD_LCD_MENU2		0x2b9
-#define KEY_KBD_LCD_MENU3		0x2ba
-#define KEY_KBD_LCD_MENU4		0x2bb
-#define KEY_KBD_LCD_MENU5		0x2bc
-
-#define BTN_TRIGGER_HAPPY		0x2c0
-#define BTN_TRIGGER_HAPPY1		0x2c0
-#define BTN_TRIGGER_HAPPY2		0x2c1
-#define BTN_TRIGGER_HAPPY3		0x2c2
-#define BTN_TRIGGER_HAPPY4		0x2c3
-#define BTN_TRIGGER_HAPPY5		0x2c4
-#define BTN_TRIGGER_HAPPY6		0x2c5
-#define BTN_TRIGGER_HAPPY7		0x2c6
-#define BTN_TRIGGER_HAPPY8		0x2c7
-#define BTN_TRIGGER_HAPPY9		0x2c8
-#define BTN_TRIGGER_HAPPY10		0x2c9
-#define BTN_TRIGGER_HAPPY11		0x2ca
-#define BTN_TRIGGER_HAPPY12		0x2cb
-#define BTN_TRIGGER_HAPPY13		0x2cc
-#define BTN_TRIGGER_HAPPY14		0x2cd
-#define BTN_TRIGGER_HAPPY15		0x2ce
-#define BTN_TRIGGER_HAPPY16		0x2cf
-#define BTN_TRIGGER_HAPPY17		0x2d0
-#define BTN_TRIGGER_HAPPY18		0x2d1
-#define BTN_TRIGGER_HAPPY19		0x2d2
-#define BTN_TRIGGER_HAPPY20		0x2d3
-#define BTN_TRIGGER_HAPPY21		0x2d4
-#define BTN_TRIGGER_HAPPY22		0x2d5
-#define BTN_TRIGGER_HAPPY23		0x2d6
-#define BTN_TRIGGER_HAPPY24		0x2d7
-#define BTN_TRIGGER_HAPPY25		0x2d8
-#define BTN_TRIGGER_HAPPY26		0x2d9
-#define BTN_TRIGGER_HAPPY27		0x2da
-#define BTN_TRIGGER_HAPPY28		0x2db
-#define BTN_TRIGGER_HAPPY29		0x2dc
-#define BTN_TRIGGER_HAPPY30		0x2dd
-#define BTN_TRIGGER_HAPPY31		0x2de
-#define BTN_TRIGGER_HAPPY32		0x2df
-#define BTN_TRIGGER_HAPPY33		0x2e0
-#define BTN_TRIGGER_HAPPY34		0x2e1
-#define BTN_TRIGGER_HAPPY35		0x2e2
-#define BTN_TRIGGER_HAPPY36		0x2e3
-#define BTN_TRIGGER_HAPPY37		0x2e4
-#define BTN_TRIGGER_HAPPY38		0x2e5
-#define BTN_TRIGGER_HAPPY39		0x2e6
-#define BTN_TRIGGER_HAPPY40		0x2e7
-
-/* We avoid low common keys in module aliases so they don't get huge. */
-#define KEY_MIN_INTERESTING	KEY_MUTE
-#define KEY_MAX			0x2ff
-#define KEY_CNT			(KEY_MAX+1)
-
-/*
- * Relative axes
- */
-
-#define REL_X			0x00
-#define REL_Y			0x01
-#define REL_Z			0x02
-#define REL_RX			0x03
-#define REL_RY			0x04
-#define REL_RZ			0x05
-#define REL_HWHEEL		0x06
-#define REL_DIAL		0x07
-#define REL_WHEEL		0x08
-#define REL_MISC		0x09
-/*
- * 0x0a is reserved and should not be used in input drivers.
- * It was used by HID as REL_MISC+1 and userspace needs to detect if
- * the next REL_* event is correct or is just REL_MISC + n.
- * We define here REL_RESERVED so userspace can rely on it and detect
- * the situation described above.
- */
-#define REL_RESERVED		0x0a
-#define REL_WHEEL_HI_RES	0x0b
-#define REL_HWHEEL_HI_RES	0x0c
-#define REL_MAX			0x0f
-#define REL_CNT			(REL_MAX+1)
-
-/*
- * Absolute axes
- */
-
-#define ABS_X			0x00
-#define ABS_Y			0x01
-#define ABS_Z			0x02
-#define ABS_RX			0x03
-#define ABS_RY			0x04
-#define ABS_RZ			0x05
-#define ABS_THROTTLE		0x06
-#define ABS_RUDDER		0x07
-#define ABS_WHEEL		0x08
-#define ABS_GAS			0x09
-#define ABS_BRAKE		0x0a
-#define ABS_HAT0X		0x10
-#define ABS_HAT0Y		0x11
-#define ABS_HAT1X		0x12
-#define ABS_HAT1Y		0x13
-#define ABS_HAT2X		0x14
-#define ABS_HAT2Y		0x15
-#define ABS_HAT3X		0x16
-#define ABS_HAT3Y		0x17
-#define ABS_PRESSURE		0x18
-#define ABS_DISTANCE		0x19
-#define ABS_TILT_X		0x1a
-#define ABS_TILT_Y		0x1b
-#define ABS_TOOL_WIDTH		0x1c
-
-#define ABS_VOLUME		0x20
-#define ABS_PROFILE		0x21
-
-#define ABS_MISC		0x28
-
-/*
- * 0x2e is reserved and should not be used in input drivers.
- * It was used by HID as ABS_MISC+6 and userspace needs to detect if
- * the next ABS_* event is correct or is just ABS_MISC + n.
- * We define here ABS_RESERVED so userspace can rely on it and detect
- * the situation described above.
- */
-#define ABS_RESERVED		0x2e
-
-#define ABS_MT_SLOT		0x2f	/* MT slot being modified */
-#define ABS_MT_TOUCH_MAJOR	0x30	/* Major axis of touching ellipse */
-#define ABS_MT_TOUCH_MINOR	0x31	/* Minor axis (omit if circular) */
-#define ABS_MT_WIDTH_MAJOR	0x32	/* Major axis of approaching ellipse */
-#define ABS_MT_WIDTH_MINOR	0x33	/* Minor axis (omit if circular) */
-#define ABS_MT_ORIENTATION	0x34	/* Ellipse orientation */
-#define ABS_MT_POSITION_X	0x35	/* Center X touch position */
-#define ABS_MT_POSITION_Y	0x36	/* Center Y touch position */
-#define ABS_MT_TOOL_TYPE	0x37	/* Type of touching device */
-#define ABS_MT_BLOB_ID		0x38	/* Group a set of packets as a blob */
-#define ABS_MT_TRACKING_ID	0x39	/* Unique ID of initiated contact */
-#define ABS_MT_PRESSURE		0x3a	/* Pressure on contact area */
-#define ABS_MT_DISTANCE		0x3b	/* Contact hover distance */
-#define ABS_MT_TOOL_X		0x3c	/* Center X tool position */
-#define ABS_MT_TOOL_Y		0x3d	/* Center Y tool position */
-
-
-#define ABS_MAX			0x3f
-#define ABS_CNT			(ABS_MAX+1)
-
-/*
- * Switch events
- */
-
-#define SW_LID			0x00  /* set = lid shut */
-#define SW_TABLET_MODE		0x01  /* set = tablet mode */
-#define SW_HEADPHONE_INSERT	0x02  /* set = inserted */
-#define SW_RFKILL_ALL		0x03  /* rfkill master switch, type "any"
-					 set = radio enabled */
-#define SW_RADIO		SW_RFKILL_ALL	/* deprecated */
-#define SW_MICROPHONE_INSERT	0x04  /* set = inserted */
-#define SW_DOCK			0x05  /* set = plugged into dock */
-#define SW_LINEOUT_INSERT	0x06  /* set = inserted */
-#define SW_JACK_PHYSICAL_INSERT 0x07  /* set = mechanical switch set */
-#define SW_VIDEOOUT_INSERT	0x08  /* set = inserted */
-#define SW_CAMERA_LENS_COVER	0x09  /* set = lens covered */
-#define SW_KEYPAD_SLIDE		0x0a  /* set = keypad slide out */
-#define SW_FRONT_PROXIMITY	0x0b  /* set = front proximity sensor active */
-#define SW_ROTATE_LOCK		0x0c  /* set = rotate locked/disabled */
-#define SW_LINEIN_INSERT	0x0d  /* set = inserted */
-#define SW_MUTE_DEVICE		0x0e  /* set = device disabled */
-#define SW_PEN_INSERTED		0x0f  /* set = pen inserted */
-#define SW_MACHINE_COVER	0x10  /* set = cover closed */
-#define SW_USB_INSERT		0x11  /* set = USB audio device connected */
-#define SW_MAX			0x11
-#define SW_CNT			(SW_MAX+1)
-
-/*
- * Misc events
- */
-
-#define MSC_SERIAL		0x00
-#define MSC_PULSELED		0x01
-#define MSC_GESTURE		0x02
-#define MSC_RAW			0x03
-#define MSC_SCAN		0x04
-#define MSC_TIMESTAMP		0x05
-#define MSC_MAX			0x07
-#define MSC_CNT			(MSC_MAX+1)
-
-/*
- * LEDs
- */
-
-#define LED_NUML		0x00
-#define LED_CAPSL		0x01
-#define LED_SCROLLL		0x02
-#define LED_COMPOSE		0x03
-#define LED_KANA		0x04
-#define LED_SLEEP		0x05
-#define LED_SUSPEND		0x06
-#define LED_MUTE		0x07
-#define LED_MISC		0x08
-#define LED_MAIL		0x09
-#define LED_CHARGING		0x0a
-#define LED_MAX			0x0f
-#define LED_CNT			(LED_MAX+1)
-
-/*
- * Autorepeat values
- */
-
-#define REP_DELAY		0x00
-#define REP_PERIOD		0x01
-#define REP_MAX			0x01
-#define REP_CNT			(REP_MAX+1)
-
-/*
- * Sounds
- */
-
-#define SND_CLICK		0x00
-#define SND_BELL		0x01
-#define SND_TONE		0x02
-#define SND_MAX			0x07
-#define SND_CNT			(SND_MAX+1)
-
-#endif
+../../uapi/linux/input-event-codes.h
\ No newline at end of file
diff -Nrup linux-6.16.7/include/linux/cpu.h linux-lenovo-x13s-linux-6.16.y/include/linux/cpu.h
--- linux-6.16.7/include/linux/cpu.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/include/linux/cpu.h	2025-09-11 09:47:42.000000000 -0600
@@ -83,7 +83,6 @@ extern ssize_t cpu_show_old_microcode(st
 extern ssize_t cpu_show_indirect_target_selection(struct device *dev,
 						  struct device_attribute *attr, char *buf);
 extern ssize_t cpu_show_tsa(struct device *dev, struct device_attribute *attr, char *buf);
-extern ssize_t cpu_show_vmscape(struct device *dev, struct device_attribute *attr, char *buf);
 
 extern __printf(4, 5)
 struct device *cpu_device_create(struct device *parent, void *drvdata,
diff -Nrup linux-6.16.7/include/linux/leds.h linux-lenovo-x13s-linux-6.16.y/include/linux/leds.h
--- linux-6.16.7/include/linux/leds.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/include/linux/leds.h	2025-09-11 09:47:42.000000000 -0600
@@ -294,7 +294,6 @@ void led_remove_lookup(struct led_lookup
 struct led_classdev *__must_check led_get(struct device *dev, char *con_id);
 struct led_classdev *__must_check devm_led_get(struct device *dev, char *con_id);
 
-extern struct led_classdev *of_led_get(struct device_node *np, int index);
 extern void led_put(struct led_classdev *led_cdev);
 struct led_classdev *__must_check devm_of_led_get(struct device *dev,
 						  int index);
diff -Nrup linux-6.16.7/include/linux/sched/bore.h linux-lenovo-x13s-linux-6.16.y/include/linux/sched/bore.h
--- linux-6.16.7/include/linux/sched/bore.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-lenovo-x13s-linux-6.16.y/include/linux/sched/bore.h	2025-09-11 09:47:42.000000000 -0600
@@ -0,0 +1,39 @@
+#ifndef _KERNEL_SCHED_BORE_H
+#define _KERNEL_SCHED_BORE_H
+
+#include <linux/sched.h>
+#include <linux/sched/cputime.h>
+#include <linux/atomic.h>
+#include <linux/list.h>
+#include <linux/rcupdate.h>
+
+#define SCHED_BORE_AUTHOR   "Masahito Suzuki"
+#define SCHED_BORE_PROGNAME "BORE CPU Scheduler modification"
+
+#define SCHED_BORE_VERSION  "6.5.2"
+
+extern u8   __read_mostly sched_bore;
+extern u8   __read_mostly sched_burst_inherit_type;
+extern u8   __read_mostly sched_burst_smoothness;
+extern u8   __read_mostly sched_burst_penalty_offset;
+extern uint __read_mostly sched_burst_penalty_scale;
+extern uint __read_mostly sched_burst_cache_lifetime;
+
+extern u8   effective_prio_bore(struct task_struct *p);
+extern void update_curr_bore(struct task_struct *p, u64 delta_exec);
+extern void restart_burst_bore(struct task_struct *p);
+extern void restart_burst_rescale_deadline_bore(struct task_struct *p);
+extern void task_fork_bore(struct task_struct *p, struct task_struct *parent,
+													u64 clone_flags, u64 now);
+extern void sched_init_bore(void);
+extern void reset_task_bore(struct task_struct *p);
+
+extern int  sched_bore_update_handler(const struct ctl_table *table,
+	int write, void __user *buffer, size_t *lenp, loff_t *ppos);
+extern int  sched_burst_inherit_type_update_handler(const struct ctl_table *table,
+	int write, void __user *buffer, size_t *lenp, loff_t *ppos);
+
+extern void reweight_entity(
+	struct cfs_rq *cfs_rq, struct sched_entity *se, unsigned long weight);
+
+#endif /* _KERNEL_SCHED_BORE_H */
diff -Nrup linux-6.16.7/include/linux/sched.h linux-lenovo-x13s-linux-6.16.y/include/linux/sched.h
--- linux-6.16.7/include/linux/sched.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/include/linux/sched.h	2025-09-11 09:47:42.000000000 -0600
@@ -809,6 +809,32 @@ struct kmap_ctrl {
 #endif
 };
 
+#ifdef CONFIG_SCHED_BORE
+#define BORE_BC_TIMESTAMP_SHIFT 16
+
+struct bore_bc {
+	u64				timestamp:	48;
+	u64				penalty:	16;
+};
+
+struct bore_ctx {
+	struct bore_bc	subtree;
+	struct bore_bc	group;
+	u64				burst_time;
+	u16				prev_penalty;
+	u16				curr_penalty;
+	union {
+		u16			penalty;
+		struct {
+			u8		_;
+			u8		score;
+		};
+	};
+	bool			stop_update;
+	bool			futex_waiting;
+};
+#endif /* CONFIG_SCHED_BORE */
+
 struct task_struct {
 #ifdef CONFIG_THREAD_INFO_IN_TASK
 	/*
@@ -869,6 +895,9 @@ struct task_struct {
 #ifdef CONFIG_SCHED_CLASS_EXT
 	struct sched_ext_entity		scx;
 #endif
+#ifdef CONFIG_SCHED_BORE
+	struct bore_ctx			bore;
+#endif /* CONFIG_SCHED_BORE */
 	const struct sched_class	*sched_class;
 
 #ifdef CONFIG_SCHED_CORE
diff -Nrup linux-6.16.7/include/linux/soundwire/sdw.h linux-lenovo-x13s-linux-6.16.y/include/linux/soundwire/sdw.h
--- linux-6.16.7/include/linux/soundwire/sdw.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/include/linux/soundwire/sdw.h	2025-09-11 09:47:42.000000000 -0600
@@ -19,6 +19,7 @@
 
 struct dentry;
 struct fwnode_handle;
+struct device_node;
 
 struct sdw_bus;
 struct sdw_slave;
@@ -1086,6 +1087,10 @@ int sdw_stream_add_slave(struct sdw_slav
 int sdw_stream_remove_slave(struct sdw_slave *slave,
 			    struct sdw_stream_runtime *stream);
 
+struct device *of_sdw_find_device_by_node(struct device_node *np);
+
+int sdw_slave_get_current_bank(struct sdw_slave *sdev);
+
 int sdw_slave_get_scale_index(struct sdw_slave *slave, u8 *base);
 
 /* messaging and data APIs */
@@ -1117,6 +1122,18 @@ static inline int sdw_stream_remove_slav
 {
 	WARN_ONCE(1, "SoundWire API is disabled");
 	return -EINVAL;
+}
+
+static inline struct device *of_sdw_find_device_by_node(struct device_node *np)
+{
+	WARN_ONCE(1, "SoundWire API is disabled");
+	return NULL;
+}
+
+static inline int sdw_slave_get_current_bank(struct sdw_slave *sdev)
+{
+	WARN_ONCE(1, "SoundWire API is disabled");
+	return -EINVAL;
 }
 
 /* messaging and data APIs */
diff -Nrup linux-6.16.7/include/uapi/sound/snd_ar_tokens.h linux-lenovo-x13s-linux-6.16.y/include/uapi/sound/snd_ar_tokens.h
--- linux-6.16.7/include/uapi/sound/snd_ar_tokens.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/include/uapi/sound/snd_ar_tokens.h	2025-09-11 09:47:42.000000000 -0600
@@ -118,6 +118,12 @@ enum ar_event_types {
  *						LPAIF_WSA = 2,
  *						LPAIF_VA = 3,
  *						LPAIF_AXI = 4
+ * Possible values for MI2S
+ *						I2S_INTF_TYPE_PRIMARY = 0,
+ *						I2S_INTF_TYPE_SECONDARY = 1,
+ *						I2S_INTF_TYPE_TERTIARY = 2,
+ *						I2S_INTF_TYPE_QUATERNARY = 3,
+ *						I2S_INTF_TYPE_QUINARY = 4,
  *
  * %AR_TKN_U32_MODULE_FMT_INTERLEAVE:		PCM Interleaving
  *						PCM_INTERLEAVED = 1,
@@ -184,8 +190,8 @@ enum ar_event_types {
 #define AR_TKN_U32_MODULE_INSTANCE_ID		201
 #define AR_TKN_U32_MODULE_MAX_IP_PORTS		202
 #define AR_TKN_U32_MODULE_MAX_OP_PORTS		203
-#define AR_TKN_U32_MODULE_IN_PORTS		204
-#define AR_TKN_U32_MODULE_OUT_PORTS		205
+#define AR_TKN_U32_MODULE_IN_PORTS		204 /* deprecated */
+#define AR_TKN_U32_MODULE_OUT_PORTS		205 /* deprecated */
 #define AR_TKN_U32_MODULE_SRC_OP_PORT_ID	206
 #define AR_TKN_U32_MODULE_DST_IN_PORT_ID	207
 #define AR_TKN_U32_MODULE_SRC_INSTANCE_ID	208
@@ -232,4 +238,12 @@ enum ar_event_types {
 #define AR_TKN_U32_MODULE_LOG_TAP_POINT_ID	260
 #define AR_TKN_U32_MODULE_LOG_MODE		261
 
+#define SND_SOC_AR_TPLG_MODULE_CFG_TYPE 0x01001006
+struct audioreach_module_priv_data {
+	__le32 size;	/* size in bytes of the array, including all elements */
+	__le32 type;	/* SND_SOC_AR_TPLG_MODULE_CFG_TYPE */
+	__le32 priv[2];	/* Private data for future expansion */
+	__le32 data[0];	/* config data */
+};
+
 #endif /* __SND_AR_TOKENS_H__ */
diff -Nrup linux-6.16.7/init/Kconfig linux-lenovo-x13s-linux-6.16.y/init/Kconfig
--- linux-6.16.7/init/Kconfig	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/init/Kconfig	2025-09-11 09:47:42.000000000 -0600
@@ -1381,6 +1381,23 @@ config CHECKPOINT_RESTORE
 
 	  If unsure, say N here.
 
+config SCHED_BORE
+	bool "Burst-Oriented Response Enhancer"
+	default y
+	help
+	  In Desktop and Mobile computing, one might prefer interactive
+	  tasks to keep responsive no matter what they run in the background.
+
+	  Enabling this kernel feature modifies the scheduler to discriminate
+	  tasks by their burst time (runtime since it last went sleeping or
+	  yielding state) and prioritize those that run less bursty.
+	  Such tasks usually include window compositor, widgets backend,
+	  terminal emulator, video playback, games and so on.
+	  With a little impact to scheduling fairness, it may improve
+	  responsiveness especially under heavy background workload.
+
+	  If unsure, say Y here.
+
 config SCHED_AUTOGROUP
 	bool "Automatic process group scheduling"
 	select CGROUPS
diff -Nrup linux-6.16.7/Kconfig linux-lenovo-x13s-linux-6.16.y/Kconfig
--- linux-6.16.7/Kconfig	2025-09-13 16:15:46.056700351 -0600
+++ linux-lenovo-x13s-linux-6.16.y/Kconfig	2025-09-11 09:47:42.000000000 -0600
@@ -32,5 +32,3 @@ source "lib/Kconfig.debug"
 source "Documentation/Kconfig"
 
 source "io_uring/Kconfig"
-
-source "distro/Kconfig"
diff -Nrup linux-6.16.7/kernel/fork.c linux-lenovo-x13s-linux-6.16.y/kernel/fork.c
--- linux-6.16.7/kernel/fork.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/kernel/fork.c	2025-09-11 09:47:42.000000000 -0600
@@ -115,6 +115,10 @@
 /* For dup_mmap(). */
 #include "../mm/internal.h"
 
+#ifdef CONFIG_SCHED_BORE
+#include <linux/sched/bore.h>
+#endif /* CONFIG_SCHED_BORE */
+
 #include <trace/events/sched.h>
 
 #define CREATE_TRACE_POINTS
@@ -2313,6 +2317,10 @@ __latent_entropy struct task_struct *cop
 	 * Need tasklist lock for parent etc handling!
 	 */
 	write_lock_irq(&tasklist_lock);
+#ifdef CONFIG_SCHED_BORE
+	if (likely(p->pid))
+		task_fork_bore(p, current, clone_flags, p->start_time);
+#endif /* CONFIG_SCHED_BORE */
 
 	/* CLONE_PARENT re-uses the old parent */
 	if (clone_flags & (CLONE_PARENT|CLONE_THREAD)) {
diff -Nrup linux-6.16.7/kernel/futex/waitwake.c linux-lenovo-x13s-linux-6.16.y/kernel/futex/waitwake.c
--- linux-6.16.7/kernel/futex/waitwake.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/kernel/futex/waitwake.c	2025-09-11 09:47:42.000000000 -0600
@@ -4,6 +4,9 @@
 #include <linux/sched/task.h>
 #include <linux/sched/signal.h>
 #include <linux/freezer.h>
+#ifdef CONFIG_SCHED_BORE
+#include <linux/sched/bore.h>
+#endif // CONFIG_SCHED_BORE
 
 #include "futex.h"
 
@@ -355,7 +358,15 @@ void futex_do_wait(struct futex_q *q, st
 		 * is no timeout, or if it has yet to expire.
 		 */
 		if (!timeout || timeout->task)
+#ifdef CONFIG_SCHED_BORE
+		{
+			current->bore.futex_waiting = true;
+#endif // CONFIG_SCHED_BORE
 			schedule();
+#ifdef CONFIG_SCHED_BORE
+			current->bore.futex_waiting = false;
+		}
+#endif // CONFIG_SCHED_BORE
 	}
 	__set_current_state(TASK_RUNNING);
 }
diff -Nrup linux-6.16.7/kernel/Kconfig.hz linux-lenovo-x13s-linux-6.16.y/kernel/Kconfig.hz
--- linux-6.16.7/kernel/Kconfig.hz	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/kernel/Kconfig.hz	2025-09-11 09:47:42.000000000 -0600
@@ -57,3 +57,20 @@ config HZ
 
 config SCHED_HRTICK
 	def_bool HIGH_RES_TIMERS
+
+config MIN_BASE_SLICE_NS
+	int "Default value for min_base_slice_ns"
+	default 2000000
+	help
+	 The BORE Scheduler automatically calculates the optimal base
+	 slice for the configured HZ using the following equation:
+	 
+	 base_slice_ns =
+	 	1000000000/HZ * DIV_ROUNDUP(min_base_slice_ns, 1000000000/HZ)
+	 
+	 This option sets the default lower bound limit of the base slice
+	 to prevent the loss of task throughput due to overscheduling.
+	 
+	 Setting this value too high can cause the system to boot with
+	 an unnecessarily large base slice, resulting in high scheduling
+	 latency and poor system responsiveness.
diff -Nrup linux-6.16.7/kernel/sched/bore.c linux-lenovo-x13s-linux-6.16.y/kernel/sched/bore.c
--- linux-6.16.7/kernel/sched/bore.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-lenovo-x13s-linux-6.16.y/kernel/sched/bore.c	2025-09-11 09:47:42.000000000 -0600
@@ -0,0 +1,393 @@
+/*
+ *  Burst-Oriented Response Enhancer (BORE) CPU Scheduler
+ *  Copyright (C) 2021-2025 Masahito Suzuki <firelzrd@gmail.com>
+ */
+#include <linux/cpuset.h>
+#include <linux/sched/task.h>
+#include <linux/sched/bore.h>
+#include "sched.h"
+
+#ifdef CONFIG_SCHED_BORE
+u8   __read_mostly sched_bore                   = 1;
+u8   __read_mostly sched_burst_inherit_type     = 2;
+u8   __read_mostly sched_burst_smoothness       = 1;
+u8   __read_mostly sched_burst_penalty_offset   = 24;
+uint __read_mostly sched_burst_penalty_scale    = 1536;
+uint __read_mostly sched_burst_cache_lifetime   = 75000000;
+static int __maybe_unused maxval_prio    =   39;
+static int __maybe_unused maxval_6_bits  =   63;
+static int __maybe_unused maxval_8_bits  =  255;
+static int __maybe_unused maxval_12_bits = 4095;
+
+#define MAX_BURST_PENALTY ((40U << 8) - 1)
+#define BURST_CACHE_STOP_COUNT 63
+
+static u32 (*inherit_penalty_fn)(struct task_struct *, u64, u64);
+
+static inline u32 log2p1_u64_u32fp(u64 v, u8 fp) {
+	if (!v) return 0;
+	u32 exponent = fls64(v),
+		mantissa = (u32)(v << (64 - exponent) << 1 >> (64 - fp));
+	return exponent << fp | mantissa;
+}
+
+static inline u32 calc_burst_penalty(u64 burst_time) {
+	u32 greed = log2p1_u64_u32fp(burst_time, 8),
+		tolerance = sched_burst_penalty_offset << 8,
+		penalty = max(0, (s32)(greed - tolerance)),
+		scaled_penalty = penalty * sched_burst_penalty_scale >> 10;
+	return min(MAX_BURST_PENALTY, scaled_penalty);
+}
+
+static inline u64 rescale_slice(u64 delta, u8 old_prio, u8 new_prio) {
+	u64 unscaled, rescaled;
+	unscaled = mul_u64_u32_shr(delta   , sched_prio_to_weight[old_prio], 10);
+	rescaled = mul_u64_u32_shr(unscaled, sched_prio_to_wmult [new_prio], 22);
+	return rescaled;
+}
+
+static inline u32 binary_smooth(u32 new, u32 old) {
+	if (new <= old) return new;
+
+	u32 increment = new - old,
+		shift = sched_burst_smoothness,
+		divisor = 1U << shift;
+
+	return old + ((increment + divisor - 1) >> shift);
+}
+
+static void reweight_task_by_prio(struct task_struct *p, int prio) {
+	if (task_has_idle_policy(p)) return;
+
+	struct sched_entity *se = &p->se;
+	unsigned long weight = scale_load(sched_prio_to_weight[prio]);
+
+	if (se->on_rq) {
+		p->bore.stop_update = true;
+		reweight_entity(cfs_rq_of(se), se, weight);
+		p->bore.stop_update = false;
+	} else
+		se->load.weight = weight;
+	se->load.inv_weight = sched_prio_to_wmult[prio];
+}
+
+u8 effective_prio_bore(struct task_struct *p) {
+	int prio = p->static_prio - MAX_RT_PRIO;
+	if (likely(sched_bore))
+		prio += p->bore.score;
+	return (u8)clamp(prio, 0, maxval_prio);
+}
+
+static void update_penalty(struct task_struct *p) {
+	struct bore_ctx *ctx = &p->bore;
+
+	u8  prev_prio = effective_prio_bore(p);
+	u32 penalty = 0;
+
+	if (!(p->flags & PF_KTHREAD)) {
+		u32 curr_penalty = ctx->curr_penalty;
+		penalty = ctx->prev_penalty;
+		if (penalty < curr_penalty)
+			penalty = curr_penalty;
+	}
+	ctx->penalty = penalty;
+
+	u8 new_prio = effective_prio_bore(p);
+	if (new_prio != prev_prio)
+		reweight_task_by_prio(p, new_prio);
+}
+
+void update_curr_bore(struct task_struct *p, u64 delta_exec) {
+	struct bore_ctx *ctx = &p->bore;
+	if (ctx->stop_update) return;
+
+	ctx->burst_time += delta_exec;
+	u32 curr_penalty = ctx->curr_penalty = calc_burst_penalty(ctx->burst_time);
+
+	if (curr_penalty <= ctx->prev_penalty) return;
+	update_penalty(p);
+}
+
+void restart_burst_bore(struct task_struct *p) {
+	struct bore_ctx *ctx = &p->bore;
+	u32 new_penalty = binary_smooth(ctx->curr_penalty, ctx->prev_penalty);
+	ctx->prev_penalty = new_penalty;
+	ctx->curr_penalty = 0;
+	ctx->burst_time = 0;
+	update_penalty(p);
+}
+
+void restart_burst_rescale_deadline_bore(struct task_struct *p) {
+	struct sched_entity *se = &p->se;
+	s64 vscaled, vremain = se->deadline - se->vruntime;
+
+	u8 old_prio = effective_prio_bore(p);
+	restart_burst_bore(p);
+	u8 new_prio = effective_prio_bore(p);
+
+	if (old_prio > new_prio) {
+		vscaled = rescale_slice(abs(vremain), old_prio, new_prio);
+		if (unlikely(vremain < 0))
+			vscaled = -vscaled;
+		se->deadline = se->vruntime + vscaled;
+	}
+}
+
+static inline bool task_is_bore_eligible(struct task_struct *p)
+{return p && p->sched_class == &fair_sched_class && !p->exit_state;}
+
+#ifndef for_each_child_task
+#define for_each_child_task(p, t) \
+	list_for_each_entry(t, &(p)->children, sibling)
+#endif
+
+static inline u32 count_children_upto2(struct task_struct *p) {
+	struct list_head *head = &p->children;
+	struct list_head *next = head->next;
+	return (next != head) + (next->next != head);
+}
+
+static inline bool burst_cache_expired(struct bore_bc *bc, u64 now) {
+	u64 timestamp = bc->timestamp << BORE_BC_TIMESTAMP_SHIFT;
+	return now - timestamp > sched_burst_cache_lifetime;
+}
+
+static void update_burst_cache(struct bore_bc *bc,
+		struct task_struct *p, u32 count, u32 total, u64 now) {
+	u32 average = count ? total / count : 0;
+	bc->penalty = max(average, p->bore.penalty);
+	bc->timestamp = now >> BORE_BC_TIMESTAMP_SHIFT;
+}
+
+static u32 inherit_none(struct task_struct *parent,
+									u64 clone_flags, u64 now)
+{ return 0; }
+
+static u32 inherit_from_parent(struct task_struct *parent,
+									u64 clone_flags, u64 now) {
+	if (clone_flags & CLONE_PARENT)
+		parent = parent->real_parent;
+
+	struct bore_bc *bc = &parent->bore.subtree;
+
+	if (burst_cache_expired(bc, now)) {
+		struct task_struct *child;
+		u32 count = 0, total = 0;
+		for_each_child_task(parent, child) {
+			if (count >= BURST_CACHE_STOP_COUNT) break;
+
+			if (!task_is_bore_eligible(child)) continue;
+			count++;
+			total += child->bore.penalty;
+		}
+
+		update_burst_cache(bc, parent, count, total, now);
+	}
+
+	return bc->penalty;
+}
+
+static u32 inherit_from_ancestor_hub(struct task_struct *parent,
+										u64 clone_flags, u64 now) {
+	struct task_struct *ancestor = parent;
+	u32 sole_child_count = 0;
+
+	if (clone_flags & CLONE_PARENT) {
+		ancestor = ancestor->real_parent;
+		sole_child_count = 1;
+	}
+
+	for (struct task_struct *next;
+			(next = ancestor->real_parent) != ancestor &&
+			count_children_upto2(ancestor) <= sole_child_count;
+			ancestor = next, sole_child_count = 1) {}
+
+	struct bore_bc *bc = &ancestor->bore.subtree;
+
+	if (burst_cache_expired(bc, now)) {
+		struct task_struct *direct_child;
+		u32 count = 0, total = 0;
+		for_each_child_task(ancestor, direct_child) {
+			if (count >= BURST_CACHE_STOP_COUNT) break;
+
+			struct task_struct *descendant = direct_child;
+			while (count_children_upto2(descendant) == 1)
+				descendant = list_first_entry(&descendant->children,
+												struct task_struct, sibling);
+
+			if (!task_is_bore_eligible(descendant)) continue;
+			count++;
+			total += descendant->bore.penalty;
+		}
+
+		update_burst_cache(bc, ancestor, count, total, now);
+	}
+
+	return bc->penalty;
+}
+
+static u32 inherit_from_thread_group(struct task_struct *p, u64 now) {
+	struct task_struct *leader = p->group_leader;
+	struct bore_bc *bc = &leader->bore.group;
+
+	if (burst_cache_expired(bc, now)) {
+		struct task_struct *sibling;
+		u32 count = 0, total = 0;
+
+		for_each_thread(leader, sibling) {
+			if (count >= BURST_CACHE_STOP_COUNT) break;
+
+			if (!task_is_bore_eligible(sibling)) continue;
+			count++;
+			total += sibling->bore.penalty;
+		}
+
+		update_burst_cache(bc, leader, count, total, now);
+	}
+
+	return bc->penalty;
+}
+
+void task_fork_bore(struct task_struct *p,
+	               struct task_struct *parent, u64 clone_flags, u64 now) {
+	if (!task_is_bore_eligible(p) || unlikely(!sched_bore)) return;
+
+	struct bore_ctx *ctx = &p->bore;
+	u32 inherited_penalty = (clone_flags & CLONE_THREAD)?
+		inherit_from_thread_group(parent, now):
+		inherit_penalty_fn(parent, clone_flags, now);
+
+	if (ctx->prev_penalty < inherited_penalty)
+		ctx->prev_penalty = inherited_penalty;
+	ctx->curr_penalty  = 0;
+	ctx->burst_time    = 0;
+	ctx->stop_update   = false;
+	ctx->futex_waiting = false;
+	update_penalty(p);
+}
+
+void reset_task_bore(struct task_struct *p)
+{ memset(&p->bore, 0, sizeof(struct bore_ctx)); }
+
+static void update_inherit_type(void) {
+	switch(sched_burst_inherit_type) {
+	case 1:
+		inherit_penalty_fn = inherit_from_parent;
+		break;
+	case 2:
+		inherit_penalty_fn = inherit_from_ancestor_hub;
+		break;
+	default:
+		inherit_penalty_fn = inherit_none;
+	}
+}
+
+void __init sched_init_bore(void) {
+	printk(KERN_INFO "%s %s by %s\n",
+		SCHED_BORE_PROGNAME, SCHED_BORE_VERSION, SCHED_BORE_AUTHOR);
+
+	reset_task_bore(&init_task);
+	update_inherit_type();
+}
+
+static void readjust_all_task_weights(void) {
+	struct task_struct *task;
+	struct rq *rq;
+	struct rq_flags rf;
+
+	scoped_guard(write_lock_irq, &tasklist_lock)
+	for_each_process(task) {
+		if (!task_is_bore_eligible(task)) continue;
+		rq = task_rq_lock(task, &rf);
+		update_rq_clock(rq);
+		reweight_task_by_prio(task, effective_prio_bore(task));
+		task_rq_unlock(rq, task, &rf);
+	}
+}
+
+int sched_bore_update_handler(const struct ctl_table *table,
+		int write, void __user *buffer, size_t *lenp, loff_t *ppos) {
+	int ret = proc_dou8vec_minmax(table, write, buffer, lenp, ppos);
+	if (ret || !write)
+		return ret;
+
+	readjust_all_task_weights();
+
+	return 0;
+}
+
+int sched_burst_inherit_type_update_handler(const struct ctl_table *table,
+		int write, void __user *buffer, size_t *lenp, loff_t *ppos) {
+	int ret = proc_dou8vec_minmax(table, write, buffer, lenp, ppos);
+	if (ret || !write)
+		return ret;
+
+	update_inherit_type();
+
+	return 0;
+}
+
+#ifdef CONFIG_SYSCTL
+static struct ctl_table sched_bore_sysctls[] = {
+	{
+		.procname	= "sched_bore",
+		.data		= &sched_bore,
+		.maxlen		= sizeof(u8),
+		.mode		= 0644,
+		.proc_handler = sched_bore_update_handler,
+		.extra1		= SYSCTL_ZERO,
+		.extra2		= SYSCTL_ONE,
+	},
+	{
+		.procname	= "sched_burst_inherit_type",
+		.data		= &sched_burst_inherit_type,
+		.maxlen		= sizeof(u8),
+		.mode		= 0644,
+		.proc_handler = sched_burst_inherit_type_update_handler,
+		.extra1		= SYSCTL_ZERO,
+		.extra2		= SYSCTL_TWO,
+	},
+	{
+		.procname	= "sched_burst_smoothness",
+		.data		= &sched_burst_smoothness,
+		.maxlen		= sizeof(u8),
+		.mode		= 0644,
+		.proc_handler = proc_dou8vec_minmax,
+		.extra1		= SYSCTL_ZERO,
+		.extra2		= SYSCTL_THREE,
+	},
+	{
+		.procname	= "sched_burst_penalty_offset",
+		.data		= &sched_burst_penalty_offset,
+		.maxlen		= sizeof(u8),
+		.mode		= 0644,
+		.proc_handler = proc_dou8vec_minmax,
+		.extra1		= SYSCTL_ZERO,
+		.extra2		= &maxval_6_bits,
+	},
+	{
+		.procname	= "sched_burst_penalty_scale",
+		.data		= &sched_burst_penalty_scale,
+		.maxlen		= sizeof(uint),
+		.mode		= 0644,
+		.proc_handler = proc_douintvec_minmax,
+		.extra1		= SYSCTL_ZERO,
+		.extra2		= &maxval_12_bits,
+	},
+	{
+		.procname	= "sched_burst_cache_lifetime",
+		.data		= &sched_burst_cache_lifetime,
+		.maxlen		= sizeof(uint),
+		.mode		= 0644,
+		.proc_handler = proc_douintvec,
+	},
+};
+
+static int __init sched_bore_sysctl_init(void) {
+	register_sysctl_init("kernel", sched_bore_sysctls);
+	return 0;
+}
+late_initcall(sched_bore_sysctl_init);
+
+#endif // CONFIG_SYSCTL
+#endif /* CONFIG_SCHED_BORE */
diff -Nrup linux-6.16.7/kernel/sched/core.c linux-lenovo-x13s-linux-6.16.y/kernel/sched/core.c
--- linux-6.16.7/kernel/sched/core.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/kernel/sched/core.c	2025-09-11 09:47:42.000000000 -0600
@@ -97,6 +97,10 @@
 #include "../../io_uring/io-wq.h"
 #include "../smpboot.h"
 
+#ifdef CONFIG_SCHED_BORE
+#include <linux/sched/bore.h>
+#endif /* CONFIG_SCHED_BORE */
+
 EXPORT_TRACEPOINT_SYMBOL_GPL(ipi_send_cpu);
 EXPORT_TRACEPOINT_SYMBOL_GPL(ipi_send_cpumask);
 
@@ -1423,7 +1427,11 @@ int tg_nop(struct task_group *tg, void *
 
 void set_load_weight(struct task_struct *p, bool update_load)
 {
+#ifdef CONFIG_SCHED_BORE
+	int prio = effective_prio_bore(p);
+#else /* !CONFIG_SCHED_BORE */
 	int prio = p->static_prio - MAX_RT_PRIO;
+#endif /* CONFIG_SCHED_BORE */
 	struct load_weight lw;
 
 	if (task_has_idle_policy(p)) {
@@ -8523,6 +8531,10 @@ void __init sched_init(void)
 	BUG_ON(!sched_class_above(&ext_sched_class, &idle_sched_class));
 #endif
 
+#ifdef CONFIG_SCHED_BORE
+	sched_init_bore();
+#endif /* CONFIG_SCHED_BORE */
+
 	wait_bit_init();
 
 #ifdef CONFIG_FAIR_GROUP_SCHED
diff -Nrup linux-6.16.7/kernel/sched/debug.c linux-lenovo-x13s-linux-6.16.y/kernel/sched/debug.c
--- linux-6.16.7/kernel/sched/debug.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/kernel/sched/debug.c	2025-09-11 09:47:42.000000000 -0600
@@ -167,7 +167,53 @@ static const struct file_operations sche
 };
 
 #ifdef CONFIG_SMP
+#ifdef CONFIG_SCHED_BORE
+#define DEFINE_SYSCTL_SCHED_FUNC(name, update_func) \
+static ssize_t sched_##name##_write(struct file *filp, const char __user *ubuf, size_t cnt, loff_t *ppos) \
+{ \
+	char buf[16]; \
+	unsigned int value; \
+\
+	if (cnt > 15) \
+		cnt = 15; \
+\
+	if (copy_from_user(&buf, ubuf, cnt)) \
+		return -EFAULT; \
+	buf[cnt] = '\0'; \
+\
+	if (kstrtouint(buf, 10, &value)) \
+		return -EINVAL; \
+\
+	sysctl_sched_##name = value; \
+	sched_update_##update_func(); \
+\
+	*ppos += cnt; \
+	return cnt; \
+} \
+\
+static int sched_##name##_show(struct seq_file *m, void *v) \
+{ \
+	seq_printf(m, "%d\n", sysctl_sched_##name); \
+	return 0; \
+} \
+\
+static int sched_##name##_open(struct inode *inode, struct file *filp) \
+{ \
+	return single_open(filp, sched_##name##_show, NULL); \
+} \
+\
+static const struct file_operations sched_##name##_fops = { \
+	.open		= sched_##name##_open, \
+	.write		= sched_##name##_write, \
+	.read		= seq_read, \
+	.llseek		= seq_lseek, \
+	.release	= single_release, \
+};
+
+DEFINE_SYSCTL_SCHED_FUNC(min_base_slice, min_base_slice)
 
+#undef DEFINE_SYSCTL_SCHED_FUNC
+#else /* !CONFIG_SCHED_BORE */
 static ssize_t sched_scaling_write(struct file *filp, const char __user *ubuf,
 				   size_t cnt, loff_t *ppos)
 {
@@ -213,7 +259,7 @@ static const struct file_operations sche
 	.llseek		= seq_lseek,
 	.release	= single_release,
 };
-
+#endif /* CONFIG_SCHED_BORE */
 #endif /* SMP */
 
 #ifdef CONFIG_PREEMPT_DYNAMIC
@@ -507,13 +553,20 @@ static __init int sched_init_debug(void)
 	debugfs_create_file("preempt", 0644, debugfs_sched, NULL, &sched_dynamic_fops);
 #endif
 
+#ifdef CONFIG_SCHED_BORE
+	debugfs_create_file("min_base_slice_ns", 0644, debugfs_sched, NULL, &sched_min_base_slice_fops);
+	debugfs_create_u32("base_slice_ns", 0444, debugfs_sched, &sysctl_sched_base_slice);
+#else /* !CONFIG_SCHED_BORE */
 	debugfs_create_u32("base_slice_ns", 0644, debugfs_sched, &sysctl_sched_base_slice);
+#endif /* CONFIG_SCHED_BORE */
 
 	debugfs_create_u32("latency_warn_ms", 0644, debugfs_sched, &sysctl_resched_latency_warn_ms);
 	debugfs_create_u32("latency_warn_once", 0644, debugfs_sched, &sysctl_resched_latency_warn_once);
 
 #ifdef CONFIG_SMP
+#if !defined(CONFIG_SCHED_BORE)
 	debugfs_create_file("tunable_scaling", 0644, debugfs_sched, NULL, &sched_scaling_fops);
+#endif /* CONFIG_SCHED_BORE */
 	debugfs_create_u32("migration_cost_ns", 0644, debugfs_sched, &sysctl_sched_migration_cost);
 	debugfs_create_u32("nr_migrate", 0644, debugfs_sched, &sysctl_sched_nr_migrate);
 
@@ -762,6 +815,9 @@ print_task(struct seq_file *m, struct rq
 		SPLIT_NS(schedstat_val_or_zero(p->stats.sum_sleep_runtime)),
 		SPLIT_NS(schedstat_val_or_zero(p->stats.sum_block_runtime)));
 
+#ifdef CONFIG_SCHED_BORE
+	SEQ_printf(m, " %2d", p->bore.score);
+#endif /* CONFIG_SCHED_BORE */
 #ifdef CONFIG_NUMA_BALANCING
 	SEQ_printf(m, "   %d      %d", task_node(p), task_numa_group_id(p));
 #endif
@@ -1248,6 +1304,9 @@ void proc_sched_show_task(struct task_st
 
 	P(se.load.weight);
 #ifdef CONFIG_SMP
+#ifdef CONFIG_SCHED_BORE
+	P(bore.score);
+#endif /* CONFIG_SCHED_BORE */
 	P(se.avg.load_sum);
 	P(se.avg.runnable_sum);
 	P(se.avg.util_sum);
diff -Nrup linux-6.16.7/kernel/sched/fair.c linux-lenovo-x13s-linux-6.16.y/kernel/sched/fair.c
--- linux-6.16.7/kernel/sched/fair.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/kernel/sched/fair.c	2025-09-11 09:47:42.000000000 -0600
@@ -58,6 +58,10 @@
 #include "stats.h"
 #include "autogroup.h"
 
+#ifdef CONFIG_SCHED_BORE
+#include <linux/sched/bore.h>
+#endif /* CONFIG_SCHED_BORE */
+
 /*
  * The initial- and re-scaling of tunables is configurable
  *
@@ -67,17 +71,30 @@
  *   SCHED_TUNABLESCALING_LOG - scaled logarithmically, *1+ilog(ncpus)
  *   SCHED_TUNABLESCALING_LINEAR - scaled linear, *ncpus
  *
- * (default SCHED_TUNABLESCALING_LOG = *(1+ilog(ncpus))
+ * BORE : default SCHED_TUNABLESCALING_NONE = *1 constant
+ * EEVDF: default SCHED_TUNABLESCALING_LOG  = *(1+ilog(ncpus))
  */
+#ifdef CONFIG_SCHED_BORE
+unsigned int sysctl_sched_tunable_scaling = SCHED_TUNABLESCALING_NONE;
+#else /* !CONFIG_SCHED_BORE */
 unsigned int sysctl_sched_tunable_scaling = SCHED_TUNABLESCALING_LOG;
+#endif /* CONFIG_SCHED_BORE */
 
 /*
  * Minimal preemption granularity for CPU-bound tasks:
  *
- * (default: 0.70 msec * (1 + ilog(ncpus)), units: nanoseconds)
- */
+ * BORE : base_slice = minimum multiple of nsecs_per_tick >= min_base_slice
+ * (default min_base_slice = 2000000 constant, units: nanoseconds)
+ * EEVDF: default 0.70 msec * (1 + ilog(ncpus)), units: nanoseconds
+ */
+#ifdef CONFIG_SCHED_BORE
+static const unsigned int nsecs_per_tick       = 1000000000ULL / HZ;
+unsigned int sysctl_sched_min_base_slice       = CONFIG_MIN_BASE_SLICE_NS;
+__read_mostly uint sysctl_sched_base_slice     = nsecs_per_tick;
+#else /* !CONFIG_SCHED_BORE */
 unsigned int sysctl_sched_base_slice			= 700000ULL;
 static unsigned int normalized_sysctl_sched_base_slice	= 700000ULL;
+#endif /* CONFIG_SCHED_BORE */
 
 __read_mostly unsigned int sysctl_sched_migration_cost	= 500000UL;
 
@@ -191,6 +208,13 @@ static inline void update_load_set(struc
  *
  * This idea comes from the SD scheduler of Con Kolivas:
  */
+#ifdef CONFIG_SCHED_BORE
+static void update_sysctl(void) {
+	sysctl_sched_base_slice = nsecs_per_tick *
+		max(1UL, DIV_ROUND_UP(sysctl_sched_min_base_slice, nsecs_per_tick));
+}
+void sched_update_min_base_slice(void) { update_sysctl(); }
+#else /* !CONFIG_SCHED_BORE */
 static unsigned int get_update_sysctl_factor(void)
 {
 	unsigned int cpus = min_t(unsigned int, num_online_cpus(), 8);
@@ -221,6 +245,7 @@ static void update_sysctl(void)
 	SET_SYSCTL(sched_base_slice);
 #undef SET_SYSCTL
 }
+#endif /* CONFIG_SCHED_BORE */
 
 void __init sched_init_granularity(void)
 {
@@ -700,6 +725,9 @@ static void update_entity_lag(struct cfs
 
 	vlag = avg_vruntime(cfs_rq) - se->vruntime;
 	limit = calc_delta_fair(max_t(u64, 2*se->slice, TICK_NSEC), se);
+#ifdef CONFIG_SCHED_BORE
+	limit >>= !!sched_bore;
+#endif /* CONFIG_SCHED_BORE */
 
 	se->vlag = clamp(vlag, -limit, limit);
 }
@@ -939,7 +967,16 @@ static struct sched_entity *pick_eevdf(s
 	if (curr && (!curr->on_rq || !entity_eligible(cfs_rq, curr)))
 		curr = NULL;
 
+#if !defined(CONFIG_SCHED_BORE)
 	if (sched_feat(RUN_TO_PARITY) && curr && protect_slice(curr))
+#else /* CONFIG_SCHED_BORE */
+	bool run_to_parity = likely(sched_bore) ?
+		sched_feat(RUN_TO_PARITY_BORE) : sched_feat(RUN_TO_PARITY);
+	if (run_to_parity && curr && protect_slice(curr) &&
+		(!entity_is_task(curr) ||
+		 !task_of(curr)->bore.futex_waiting ||
+		 unlikely(!sched_bore)))
+#endif /* CONFIG_SCHED_BORE */
 		return curr;
 
 	/* Pick the leftmost entity if it's eligible */
@@ -997,6 +1034,7 @@ struct sched_entity *__pick_last_entity(
  * Scheduling class statistics methods:
  */
 #ifdef CONFIG_SMP
+#if !defined(CONFIG_SCHED_BORE)
 int sched_update_scaling(void)
 {
 	unsigned int factor = get_update_sysctl_factor();
@@ -1008,6 +1046,7 @@ int sched_update_scaling(void)
 
 	return 0;
 }
+#endif /* CONFIG_SCHED_BORE */
 #endif
 
 static void clear_buddies(struct cfs_rq *cfs_rq, struct sched_entity *se);
@@ -1244,6 +1283,9 @@ static void update_curr(struct cfs_rq *c
 	if (entity_is_task(curr)) {
 		struct task_struct *p = task_of(curr);
 
+#ifdef CONFIG_SCHED_BORE
+		update_curr_bore(p, delta_exec);
+#endif /* CONFIG_SCHED_BORE */
 		update_curr_task(p, delta_exec);
 
 		/*
@@ -3794,7 +3836,7 @@ dequeue_load_avg(struct cfs_rq *cfs_rq,
 
 static void place_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int flags);
 
-static void reweight_entity(struct cfs_rq *cfs_rq, struct sched_entity *se,
+void reweight_entity(struct cfs_rq *cfs_rq, struct sched_entity *se,
 			    unsigned long weight)
 {
 	bool curr = cfs_rq->curr == se;
@@ -5205,12 +5247,11 @@ void __setparam_fair(struct task_struct
 static void
 place_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int flags)
 {
-	u64 vslice, vruntime = avg_vruntime(cfs_rq);
+	u64 vslice = 0, vruntime = avg_vruntime(cfs_rq);
 	s64 lag = 0;
 
 	if (!se->custom_slice)
 		se->slice = sysctl_sched_base_slice;
-	vslice = calc_delta_fair(se->slice, se);
 
 	/*
 	 * Due to how V is constructed as the weighted average of entities,
@@ -5295,7 +5336,18 @@ place_entity(struct cfs_rq *cfs_rq, stru
 		se->rel_deadline = 0;
 		return;
 	}
-
+#ifdef CONFIG_SCHED_BORE
+	if (entity_is_task(se) &&
+			likely(sched_bore) &&
+			task_of(se)->bore.futex_waiting)
+		goto vslice_found;
+#endif /* !CONFIG_SCHED_BORE */
+	vslice = calc_delta_fair(se->slice, se);
+#ifdef CONFIG_SCHED_BORE
+	if (likely(sched_bore))
+		vslice >>= !!(flags & (ENQUEUE_INITIAL | ENQUEUE_WAKEUP));
+	else
+#endif /* CONFIG_SCHED_BORE */
 	/*
 	 * When joining the competition; the existing tasks will be,
 	 * on average, halfway through their slice, as such start tasks
@@ -5304,6 +5356,9 @@ place_entity(struct cfs_rq *cfs_rq, stru
 	if (sched_feat(PLACE_DEADLINE_INITIAL) && (flags & ENQUEUE_INITIAL))
 		vslice /= 2;
 
+#ifdef CONFIG_SCHED_BORE
+vslice_found:
+#endif /* CONFIG_SCHED_BORE */
 	/*
 	 * EEVDF: vd_i = ve_i + r_i/w_i
 	 */
@@ -5314,7 +5369,7 @@ static void check_enqueue_throttle(struc
 static inline int cfs_rq_throttled(struct cfs_rq *cfs_rq);
 
 static void
-requeue_delayed_entity(struct sched_entity *se);
+requeue_delayed_entity(struct sched_entity *se, int flags);
 
 static void
 enqueue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int flags)
@@ -5478,6 +5533,10 @@ dequeue_entity(struct cfs_rq *cfs_rq, st
 		if (sched_feat(DELAY_DEQUEUE) && delay &&
 		    !entity_eligible(cfs_rq, se)) {
 			update_load_avg(cfs_rq, se, 0);
+#ifdef CONFIG_SCHED_BORE
+			if (sched_feat(DELAY_ZERO) && likely(sched_bore))
+				update_entity_lag(cfs_rq, se);
+#endif /* CONFIG_SCHED_BORE */
 			set_delayed(se);
 			return false;
 		}
@@ -6894,7 +6953,7 @@ static int sched_idle_cpu(int cpu)
 #endif
 
 static void
-requeue_delayed_entity(struct sched_entity *se)
+requeue_delayed_entity(struct sched_entity *se, int flags)
 {
 	struct cfs_rq *cfs_rq = cfs_rq_of(se);
 
@@ -6907,13 +6966,22 @@ requeue_delayed_entity(struct sched_enti
 	WARN_ON_ONCE(!se->on_rq);
 
 	if (sched_feat(DELAY_ZERO)) {
+#ifdef CONFIG_SCHED_BORE
+		if (likely(sched_bore))
+			flags |= ENQUEUE_WAKEUP;
+		else {
+#endif /* CONFIG_SCHED_BORE */
+		flags = 0;
 		update_entity_lag(cfs_rq, se);
+#ifdef CONFIG_SCHED_BORE
+		}
+#endif /* CONFIG_SCHED_BORE */
 		if (se->vlag > 0) {
 			cfs_rq->nr_queued--;
 			if (se != cfs_rq->curr)
 				__dequeue_entity(cfs_rq, se);
 			se->vlag = 0;
-			place_entity(cfs_rq, se, 0);
+			place_entity(cfs_rq, se, flags);
 			if (se != cfs_rq->curr)
 				__enqueue_entity(cfs_rq, se);
 			cfs_rq->nr_queued++;
@@ -6950,7 +7018,7 @@ enqueue_task_fair(struct rq *rq, struct
 		util_est_enqueue(&rq->cfs, p);
 
 	if (flags & ENQUEUE_DELAYED) {
-		requeue_delayed_entity(se);
+		requeue_delayed_entity(se, flags);
 		return;
 	}
 
@@ -6968,7 +7036,7 @@ enqueue_task_fair(struct rq *rq, struct
 	for_each_sched_entity(se) {
 		if (se->on_rq) {
 			if (se->sched_delayed)
-				requeue_delayed_entity(se);
+				requeue_delayed_entity(se, flags);
 			break;
 		}
 		cfs_rq = cfs_rq_of(se);
@@ -7190,6 +7258,15 @@ static bool dequeue_task_fair(struct rq
 		util_est_dequeue(&rq->cfs, p);
 
 	util_est_update(&rq->cfs, p, flags & DEQUEUE_SLEEP);
+#ifdef CONFIG_SCHED_BORE
+	struct cfs_rq *cfs_rq = &rq->cfs;
+	struct sched_entity *se = &p->se;
+	if ((flags & DEQUEUE_SLEEP) && entity_is_task(se)) {
+		if (cfs_rq->curr == se)
+			update_curr(cfs_rq_of(&p->se));
+		restart_burst_bore(p);
+	}
+#endif /* CONFIG_SCHED_BORE */
 	if (dequeue_entities(rq, &p->se, flags) < 0)
 		return false;
 
@@ -7559,9 +7636,14 @@ static inline int sched_balance_find_dst
 	return new_cpu;
 }
 
+static inline bool is_idle_cpu(int cpu)
+{
+	return available_idle_cpu(cpu) || sched_idle_cpu(cpu);
+}
+
 static inline int __select_idle_cpu(int cpu, struct task_struct *p)
 {
-	if ((available_idle_cpu(cpu) || sched_idle_cpu(cpu)) &&
+	if (is_idle_cpu(cpu) &&
 	    sched_cpu_cookie_match(cpu_rq(cpu), p))
 		return cpu;
 
@@ -7572,6 +7654,24 @@ static inline int __select_idle_cpu(int
 DEFINE_STATIC_KEY_FALSE(sched_smt_present);
 EXPORT_SYMBOL_GPL(sched_smt_present);
 
+/*
+ * Return true if all the CPUs in the SMT core where @cpu belongs are idle,
+ * false otherwise.
+ */
+static bool is_idle_core(int cpu)
+{
+	int sibling;
+
+	if (!sched_smt_active())
+		return is_idle_cpu(cpu);
+
+	for_each_cpu(sibling, cpu_smt_mask(cpu))
+		if (!is_idle_cpu(sibling))
+			return false;
+
+	return true;
+}
+
 static inline void set_idle_cores(int cpu, int val)
 {
 	struct sched_domain_shared *sds;
@@ -7654,29 +7754,6 @@ static int select_idle_core(struct task_
 	return -1;
 }
 
-/*
- * Scan the local SMT mask for idle CPUs.
- */
-static int select_idle_smt(struct task_struct *p, struct sched_domain *sd, int target)
-{
-	int cpu;
-
-	for_each_cpu_and(cpu, cpu_smt_mask(target), p->cpus_ptr) {
-		if (cpu == target)
-			continue;
-		/*
-		 * Check if the CPU is in the LLC scheduling domain of @target.
-		 * Due to isolcpus, there is no guarantee that all the siblings are in the domain.
-		 */
-		if (!cpumask_test_cpu(cpu, sched_domain_span(sd)))
-			continue;
-		if (available_idle_cpu(cpu) || sched_idle_cpu(cpu))
-			return cpu;
-	}
-
-	return -1;
-}
-
 #else /* CONFIG_SCHED_SMT */
 
 static inline void set_idle_cores(int cpu, int val)
@@ -7693,9 +7770,9 @@ static inline int select_idle_core(struc
 	return __select_idle_cpu(core, p);
 }
 
-static inline int select_idle_smt(struct task_struct *p, struct sched_domain *sd, int target)
+static inline bool is_idle_core(int cpu)
 {
-	return -1;
+	return is_idle_cpu(cpu);
 }
 
 #endif /* CONFIG_SCHED_SMT */
@@ -7792,7 +7869,7 @@ select_idle_capacity(struct task_struct
 	for_each_cpu_wrap(cpu, cpus, target) {
 		unsigned long cpu_cap = capacity_of(cpu);
 
-		if (!available_idle_cpu(cpu) && !sched_idle_cpu(cpu))
+		if (!is_idle_cpu(cpu))
 			continue;
 
 		fits = util_fits_cpu(task_util, util_min, util_max, cpu);
@@ -7863,7 +7940,7 @@ static int select_idle_sibling(struct ta
 	 */
 	lockdep_assert_irqs_disabled();
 
-	if ((available_idle_cpu(target) || sched_idle_cpu(target)) &&
+	if (is_idle_core(target) &&
 	    asym_fits_cpu(task_util, util_min, util_max, target))
 		return target;
 
@@ -7871,7 +7948,7 @@ static int select_idle_sibling(struct ta
 	 * If the previous CPU is cache affine and idle, don't be stupid:
 	 */
 	if (prev != target && cpus_share_cache(prev, target) &&
-	    (available_idle_cpu(prev) || sched_idle_cpu(prev)) &&
+	    is_idle_core(prev) &&
 	    asym_fits_cpu(task_util, util_min, util_max, prev)) {
 
 		if (!static_branch_unlikely(&sched_cluster_active) ||
@@ -7903,7 +7980,7 @@ static int select_idle_sibling(struct ta
 	if (recent_used_cpu != prev &&
 	    recent_used_cpu != target &&
 	    cpus_share_cache(recent_used_cpu, target) &&
-	    (available_idle_cpu(recent_used_cpu) || sched_idle_cpu(recent_used_cpu)) &&
+	    is_idle_core(recent_used_cpu) &&
 	    cpumask_test_cpu(recent_used_cpu, p->cpus_ptr) &&
 	    asym_fits_cpu(task_util, util_min, util_max, recent_used_cpu)) {
 
@@ -7939,16 +8016,9 @@ static int select_idle_sibling(struct ta
 	if (!sd)
 		return target;
 
-	if (sched_smt_active()) {
+	if (sched_smt_active())
 		has_idle_core = test_idle_cores(target);
 
-		if (!has_idle_core && cpus_share_cache(prev, target)) {
-			i = select_idle_smt(p, sd, prev);
-			if ((unsigned int)i < nr_cpumask_bits)
-				return i;
-		}
-	}
-
 	i = select_idle_cpu(p, sd, has_idle_core, target);
 	if ((unsigned)i < nr_cpumask_bits)
 		return i;
@@ -9019,16 +9089,25 @@ static void yield_task_fair(struct rq *r
 	/*
 	 * Are we the only task in the tree?
 	 */
+#if !defined(CONFIG_SCHED_BORE)
 	if (unlikely(rq->nr_running == 1))
 		return;
 
 	clear_buddies(cfs_rq, se);
+#endif /* CONFIG_SCHED_BORE */
 
 	update_rq_clock(rq);
 	/*
 	 * Update run-time statistics of the 'current'.
 	 */
 	update_curr(cfs_rq);
+#ifdef CONFIG_SCHED_BORE
+	restart_burst_rescale_deadline_bore(curr);
+	if (unlikely(rq->nr_running == 1))
+		return;
+
+	clear_buddies(cfs_rq, se);
+#endif /* CONFIG_SCHED_BORE */
 	/*
 	 * Tell update_rq_clock() that we've just updated,
 	 * so we don't do microscopic update in schedule()
@@ -13273,6 +13352,9 @@ static void switched_to_fair(struct rq *
 	WARN_ON_ONCE(p->se.sched_delayed);
 
 	attach_task_cfs_rq(p);
+#ifdef CONFIG_SCHED_BORE
+	reset_task_bore(p);
+#endif /* CONFIG_SCHED_BORE */
 
 	set_task_max_allowed_capacity(p);
 
diff -Nrup linux-6.16.7/kernel/sched/features.h linux-lenovo-x13s-linux-6.16.y/kernel/sched/features.h
--- linux-6.16.7/kernel/sched/features.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/kernel/sched/features.h	2025-09-11 09:47:42.000000000 -0600
@@ -18,6 +18,9 @@ SCHED_FEAT(PLACE_REL_DEADLINE, true)
  * 0-lag point or until is has exhausted it's slice.
  */
 SCHED_FEAT(RUN_TO_PARITY, true)
+#ifdef CONFIG_SCHED_BORE
+SCHED_FEAT(RUN_TO_PARITY_BORE, false)
+#endif /* CONFIG_SCHED_BORE */
 /*
  * Allow wakeup of tasks with a shorter slice to cancel RUN_TO_PARITY for
  * current.
diff -Nrup linux-6.16.7/kernel/sched/Makefile linux-lenovo-x13s-linux-6.16.y/kernel/sched/Makefile
--- linux-6.16.7/kernel/sched/Makefile	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/kernel/sched/Makefile	2025-09-11 09:47:42.000000000 -0600
@@ -37,3 +37,4 @@ obj-y += core.o
 obj-y += fair.o
 obj-y += build_policy.o
 obj-y += build_utility.o
+obj-$(CONFIG_SCHED_BORE) += bore.o
diff -Nrup linux-6.16.7/kernel/sched/sched.h linux-lenovo-x13s-linux-6.16.y/kernel/sched/sched.h
--- linux-6.16.7/kernel/sched/sched.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/kernel/sched/sched.h	2025-09-11 09:47:42.000000000 -0600
@@ -2119,7 +2119,11 @@ extern int group_balance_cpu(struct sche
 extern void update_sched_domain_debugfs(void);
 extern void dirty_sched_domain_sysctl(int cpu);
 
+#ifdef CONFIG_SCHED_BORE
+extern void sched_update_min_base_slice(void);
+#else /* !CONFIG_SCHED_BORE */
 extern int sched_update_scaling(void);
+#endif /* CONFIG_SCHED_BORE */
 
 static inline const struct cpumask *task_user_cpus(struct task_struct *p)
 {
@@ -2825,7 +2829,12 @@ extern void wakeup_preempt(struct rq *rq
 extern __read_mostly unsigned int sysctl_sched_nr_migrate;
 extern __read_mostly unsigned int sysctl_sched_migration_cost;
 
+#ifdef CONFIG_SCHED_BORE
+extern unsigned int sysctl_sched_min_base_slice;
+extern __read_mostly uint sysctl_sched_base_slice;
+#else /* !CONFIG_SCHED_BORE */
 extern unsigned int sysctl_sched_base_slice;
+#endif /* CONFIG_SCHED_BORE */
 
 extern int sysctl_resched_latency_warn_ms;
 extern int sysctl_resched_latency_warn_once;
diff -Nrup linux-6.16.7/kernel/sys.c linux-lenovo-x13s-linux-6.16.y/kernel/sys.c
--- linux-6.16.7/kernel/sys.c	2025-09-13 16:15:37.961397732 -0600
+++ linux-lenovo-x13s-linux-6.16.y/kernel/sys.c	2025-09-11 09:47:42.000000000 -0600
@@ -2749,16 +2749,10 @@ SYSCALL_DEFINE5(prctl, int, option, unsi
 		break;
 #endif
 	case PR_SET_MDWE:
-		if (IS_ENABLED(CONFIG_PARISC))
-			error = -EINVAL;
-		else
-			error = prctl_set_mdwe(arg2, arg3, arg4, arg5);
+		error = prctl_set_mdwe(arg2, arg3, arg4, arg5);
 		break;
 	case PR_GET_MDWE:
-		if (IS_ENABLED(CONFIG_PARISC))
-			error = -EINVAL;
-		else
-			error = prctl_get_mdwe(arg2, arg3, arg4, arg5);
+		error = prctl_get_mdwe(arg2, arg3, arg4, arg5);
 		break;
 	case PR_PPC_GET_DEXCR:
 		if (arg3 || arg4 || arg5)
diff -Nrup linux-6.16.7/kernel/sys.c.orig linux-lenovo-x13s-linux-6.16.y/kernel/sys.c.orig
--- linux-6.16.7/kernel/sys.c.orig	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/kernel/sys.c.orig	1969-12-31 17:00:00.000000000 -0700
@@ -1,2992 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- *  linux/kernel/sys.c
- *
- *  Copyright (C) 1991, 1992  Linus Torvalds
- */
-
-#include <linux/export.h>
-#include <linux/mm.h>
-#include <linux/mm_inline.h>
-#include <linux/utsname.h>
-#include <linux/mman.h>
-#include <linux/reboot.h>
-#include <linux/prctl.h>
-#include <linux/highuid.h>
-#include <linux/fs.h>
-#include <linux/kmod.h>
-#include <linux/ksm.h>
-#include <linux/perf_event.h>
-#include <linux/resource.h>
-#include <linux/kernel.h>
-#include <linux/workqueue.h>
-#include <linux/capability.h>
-#include <linux/device.h>
-#include <linux/key.h>
-#include <linux/times.h>
-#include <linux/posix-timers.h>
-#include <linux/security.h>
-#include <linux/random.h>
-#include <linux/suspend.h>
-#include <linux/tty.h>
-#include <linux/signal.h>
-#include <linux/cn_proc.h>
-#include <linux/getcpu.h>
-#include <linux/task_io_accounting_ops.h>
-#include <linux/seccomp.h>
-#include <linux/cpu.h>
-#include <linux/personality.h>
-#include <linux/ptrace.h>
-#include <linux/fs_struct.h>
-#include <linux/file.h>
-#include <linux/mount.h>
-#include <linux/gfp.h>
-#include <linux/syscore_ops.h>
-#include <linux/version.h>
-#include <linux/ctype.h>
-#include <linux/syscall_user_dispatch.h>
-
-#include <linux/compat.h>
-#include <linux/syscalls.h>
-#include <linux/kprobes.h>
-#include <linux/user_namespace.h>
-#include <linux/time_namespace.h>
-#include <linux/binfmts.h>
-#include <linux/futex.h>
-
-#include <linux/sched.h>
-#include <linux/sched/autogroup.h>
-#include <linux/sched/loadavg.h>
-#include <linux/sched/stat.h>
-#include <linux/sched/mm.h>
-#include <linux/sched/coredump.h>
-#include <linux/sched/task.h>
-#include <linux/sched/cputime.h>
-#include <linux/rcupdate.h>
-#include <linux/uidgid.h>
-#include <linux/cred.h>
-
-#include <linux/nospec.h>
-
-#include <linux/kmsg_dump.h>
-/* Move somewhere else to avoid recompiling? */
-#include <generated/utsrelease.h>
-
-#include <linux/uaccess.h>
-#include <asm/io.h>
-#include <asm/unistd.h>
-
-#include <trace/events/task.h>
-
-#include "uid16.h"
-
-#ifndef SET_UNALIGN_CTL
-# define SET_UNALIGN_CTL(a, b)	(-EINVAL)
-#endif
-#ifndef GET_UNALIGN_CTL
-# define GET_UNALIGN_CTL(a, b)	(-EINVAL)
-#endif
-#ifndef SET_FPEMU_CTL
-# define SET_FPEMU_CTL(a, b)	(-EINVAL)
-#endif
-#ifndef GET_FPEMU_CTL
-# define GET_FPEMU_CTL(a, b)	(-EINVAL)
-#endif
-#ifndef SET_FPEXC_CTL
-# define SET_FPEXC_CTL(a, b)	(-EINVAL)
-#endif
-#ifndef GET_FPEXC_CTL
-# define GET_FPEXC_CTL(a, b)	(-EINVAL)
-#endif
-#ifndef GET_ENDIAN
-# define GET_ENDIAN(a, b)	(-EINVAL)
-#endif
-#ifndef SET_ENDIAN
-# define SET_ENDIAN(a, b)	(-EINVAL)
-#endif
-#ifndef GET_TSC_CTL
-# define GET_TSC_CTL(a)		(-EINVAL)
-#endif
-#ifndef SET_TSC_CTL
-# define SET_TSC_CTL(a)		(-EINVAL)
-#endif
-#ifndef GET_FP_MODE
-# define GET_FP_MODE(a)		(-EINVAL)
-#endif
-#ifndef SET_FP_MODE
-# define SET_FP_MODE(a,b)	(-EINVAL)
-#endif
-#ifndef SVE_SET_VL
-# define SVE_SET_VL(a)		(-EINVAL)
-#endif
-#ifndef SVE_GET_VL
-# define SVE_GET_VL()		(-EINVAL)
-#endif
-#ifndef SME_SET_VL
-# define SME_SET_VL(a)		(-EINVAL)
-#endif
-#ifndef SME_GET_VL
-# define SME_GET_VL()		(-EINVAL)
-#endif
-#ifndef PAC_RESET_KEYS
-# define PAC_RESET_KEYS(a, b)	(-EINVAL)
-#endif
-#ifndef PAC_SET_ENABLED_KEYS
-# define PAC_SET_ENABLED_KEYS(a, b, c)	(-EINVAL)
-#endif
-#ifndef PAC_GET_ENABLED_KEYS
-# define PAC_GET_ENABLED_KEYS(a)	(-EINVAL)
-#endif
-#ifndef SET_TAGGED_ADDR_CTRL
-# define SET_TAGGED_ADDR_CTRL(a)	(-EINVAL)
-#endif
-#ifndef GET_TAGGED_ADDR_CTRL
-# define GET_TAGGED_ADDR_CTRL()		(-EINVAL)
-#endif
-#ifndef RISCV_V_SET_CONTROL
-# define RISCV_V_SET_CONTROL(a)		(-EINVAL)
-#endif
-#ifndef RISCV_V_GET_CONTROL
-# define RISCV_V_GET_CONTROL()		(-EINVAL)
-#endif
-#ifndef RISCV_SET_ICACHE_FLUSH_CTX
-# define RISCV_SET_ICACHE_FLUSH_CTX(a, b)	(-EINVAL)
-#endif
-#ifndef PPC_GET_DEXCR_ASPECT
-# define PPC_GET_DEXCR_ASPECT(a, b)	(-EINVAL)
-#endif
-#ifndef PPC_SET_DEXCR_ASPECT
-# define PPC_SET_DEXCR_ASPECT(a, b, c)	(-EINVAL)
-#endif
-
-/*
- * this is where the system-wide overflow UID and GID are defined, for
- * architectures that now have 32-bit UID/GID but didn't in the past
- */
-
-int overflowuid = DEFAULT_OVERFLOWUID;
-int overflowgid = DEFAULT_OVERFLOWGID;
-
-EXPORT_SYMBOL(overflowuid);
-EXPORT_SYMBOL(overflowgid);
-
-/*
- * the same as above, but for filesystems which can only store a 16-bit
- * UID and GID. as such, this is needed on all architectures
- */
-
-int fs_overflowuid = DEFAULT_FS_OVERFLOWUID;
-int fs_overflowgid = DEFAULT_FS_OVERFLOWGID;
-
-EXPORT_SYMBOL(fs_overflowuid);
-EXPORT_SYMBOL(fs_overflowgid);
-
-/*
- * Returns true if current's euid is same as p's uid or euid,
- * or has CAP_SYS_NICE to p's user_ns.
- *
- * Called with rcu_read_lock, creds are safe
- */
-static bool set_one_prio_perm(struct task_struct *p)
-{
-	const struct cred *cred = current_cred(), *pcred = __task_cred(p);
-
-	if (uid_eq(pcred->uid,  cred->euid) ||
-	    uid_eq(pcred->euid, cred->euid))
-		return true;
-	if (ns_capable(pcred->user_ns, CAP_SYS_NICE))
-		return true;
-	return false;
-}
-
-/*
- * set the priority of a task
- * - the caller must hold the RCU read lock
- */
-static int set_one_prio(struct task_struct *p, int niceval, int error)
-{
-	int no_nice;
-
-	if (!set_one_prio_perm(p)) {
-		error = -EPERM;
-		goto out;
-	}
-	if (niceval < task_nice(p) && !can_nice(p, niceval)) {
-		error = -EACCES;
-		goto out;
-	}
-	no_nice = security_task_setnice(p, niceval);
-	if (no_nice) {
-		error = no_nice;
-		goto out;
-	}
-	if (error == -ESRCH)
-		error = 0;
-	set_user_nice(p, niceval);
-out:
-	return error;
-}
-
-SYSCALL_DEFINE3(setpriority, int, which, int, who, int, niceval)
-{
-	struct task_struct *g, *p;
-	struct user_struct *user;
-	const struct cred *cred = current_cred();
-	int error = -EINVAL;
-	struct pid *pgrp;
-	kuid_t uid;
-
-	if (which > PRIO_USER || which < PRIO_PROCESS)
-		goto out;
-
-	/* normalize: avoid signed division (rounding problems) */
-	error = -ESRCH;
-	if (niceval < MIN_NICE)
-		niceval = MIN_NICE;
-	if (niceval > MAX_NICE)
-		niceval = MAX_NICE;
-
-	rcu_read_lock();
-	switch (which) {
-	case PRIO_PROCESS:
-		if (who)
-			p = find_task_by_vpid(who);
-		else
-			p = current;
-		if (p)
-			error = set_one_prio(p, niceval, error);
-		break;
-	case PRIO_PGRP:
-		if (who)
-			pgrp = find_vpid(who);
-		else
-			pgrp = task_pgrp(current);
-		read_lock(&tasklist_lock);
-		do_each_pid_thread(pgrp, PIDTYPE_PGID, p) {
-			error = set_one_prio(p, niceval, error);
-		} while_each_pid_thread(pgrp, PIDTYPE_PGID, p);
-		read_unlock(&tasklist_lock);
-		break;
-	case PRIO_USER:
-		uid = make_kuid(cred->user_ns, who);
-		user = cred->user;
-		if (!who)
-			uid = cred->uid;
-		else if (!uid_eq(uid, cred->uid)) {
-			user = find_user(uid);
-			if (!user)
-				goto out_unlock;	/* No processes for this user */
-		}
-		for_each_process_thread(g, p) {
-			if (uid_eq(task_uid(p), uid) && task_pid_vnr(p))
-				error = set_one_prio(p, niceval, error);
-		}
-		if (!uid_eq(uid, cred->uid))
-			free_uid(user);		/* For find_user() */
-		break;
-	}
-out_unlock:
-	rcu_read_unlock();
-out:
-	return error;
-}
-
-/*
- * Ugh. To avoid negative return values, "getpriority()" will
- * not return the normal nice-value, but a negated value that
- * has been offset by 20 (ie it returns 40..1 instead of -20..19)
- * to stay compatible.
- */
-SYSCALL_DEFINE2(getpriority, int, which, int, who)
-{
-	struct task_struct *g, *p;
-	struct user_struct *user;
-	const struct cred *cred = current_cred();
-	long niceval, retval = -ESRCH;
-	struct pid *pgrp;
-	kuid_t uid;
-
-	if (which > PRIO_USER || which < PRIO_PROCESS)
-		return -EINVAL;
-
-	rcu_read_lock();
-	switch (which) {
-	case PRIO_PROCESS:
-		if (who)
-			p = find_task_by_vpid(who);
-		else
-			p = current;
-		if (p) {
-			niceval = nice_to_rlimit(task_nice(p));
-			if (niceval > retval)
-				retval = niceval;
-		}
-		break;
-	case PRIO_PGRP:
-		if (who)
-			pgrp = find_vpid(who);
-		else
-			pgrp = task_pgrp(current);
-		read_lock(&tasklist_lock);
-		do_each_pid_thread(pgrp, PIDTYPE_PGID, p) {
-			niceval = nice_to_rlimit(task_nice(p));
-			if (niceval > retval)
-				retval = niceval;
-		} while_each_pid_thread(pgrp, PIDTYPE_PGID, p);
-		read_unlock(&tasklist_lock);
-		break;
-	case PRIO_USER:
-		uid = make_kuid(cred->user_ns, who);
-		user = cred->user;
-		if (!who)
-			uid = cred->uid;
-		else if (!uid_eq(uid, cred->uid)) {
-			user = find_user(uid);
-			if (!user)
-				goto out_unlock;	/* No processes for this user */
-		}
-		for_each_process_thread(g, p) {
-			if (uid_eq(task_uid(p), uid) && task_pid_vnr(p)) {
-				niceval = nice_to_rlimit(task_nice(p));
-				if (niceval > retval)
-					retval = niceval;
-			}
-		}
-		if (!uid_eq(uid, cred->uid))
-			free_uid(user);		/* for find_user() */
-		break;
-	}
-out_unlock:
-	rcu_read_unlock();
-
-	return retval;
-}
-
-/*
- * Unprivileged users may change the real gid to the effective gid
- * or vice versa.  (BSD-style)
- *
- * If you set the real gid at all, or set the effective gid to a value not
- * equal to the real gid, then the saved gid is set to the new effective gid.
- *
- * This makes it possible for a setgid program to completely drop its
- * privileges, which is often a useful assertion to make when you are doing
- * a security audit over a program.
- *
- * The general idea is that a program which uses just setregid() will be
- * 100% compatible with BSD.  A program which uses just setgid() will be
- * 100% compatible with POSIX with saved IDs.
- *
- * SMP: There are not races, the GIDs are checked only by filesystem
- *      operations (as far as semantic preservation is concerned).
- */
-#ifdef CONFIG_MULTIUSER
-long __sys_setregid(gid_t rgid, gid_t egid)
-{
-	struct user_namespace *ns = current_user_ns();
-	const struct cred *old;
-	struct cred *new;
-	int retval;
-	kgid_t krgid, kegid;
-
-	krgid = make_kgid(ns, rgid);
-	kegid = make_kgid(ns, egid);
-
-	if ((rgid != (gid_t) -1) && !gid_valid(krgid))
-		return -EINVAL;
-	if ((egid != (gid_t) -1) && !gid_valid(kegid))
-		return -EINVAL;
-
-	new = prepare_creds();
-	if (!new)
-		return -ENOMEM;
-	old = current_cred();
-
-	retval = -EPERM;
-	if (rgid != (gid_t) -1) {
-		if (gid_eq(old->gid, krgid) ||
-		    gid_eq(old->egid, krgid) ||
-		    ns_capable_setid(old->user_ns, CAP_SETGID))
-			new->gid = krgid;
-		else
-			goto error;
-	}
-	if (egid != (gid_t) -1) {
-		if (gid_eq(old->gid, kegid) ||
-		    gid_eq(old->egid, kegid) ||
-		    gid_eq(old->sgid, kegid) ||
-		    ns_capable_setid(old->user_ns, CAP_SETGID))
-			new->egid = kegid;
-		else
-			goto error;
-	}
-
-	if (rgid != (gid_t) -1 ||
-	    (egid != (gid_t) -1 && !gid_eq(kegid, old->gid)))
-		new->sgid = new->egid;
-	new->fsgid = new->egid;
-
-	retval = security_task_fix_setgid(new, old, LSM_SETID_RE);
-	if (retval < 0)
-		goto error;
-
-	return commit_creds(new);
-
-error:
-	abort_creds(new);
-	return retval;
-}
-
-SYSCALL_DEFINE2(setregid, gid_t, rgid, gid_t, egid)
-{
-	return __sys_setregid(rgid, egid);
-}
-
-/*
- * setgid() is implemented like SysV w/ SAVED_IDS
- *
- * SMP: Same implicit races as above.
- */
-long __sys_setgid(gid_t gid)
-{
-	struct user_namespace *ns = current_user_ns();
-	const struct cred *old;
-	struct cred *new;
-	int retval;
-	kgid_t kgid;
-
-	kgid = make_kgid(ns, gid);
-	if (!gid_valid(kgid))
-		return -EINVAL;
-
-	new = prepare_creds();
-	if (!new)
-		return -ENOMEM;
-	old = current_cred();
-
-	retval = -EPERM;
-	if (ns_capable_setid(old->user_ns, CAP_SETGID))
-		new->gid = new->egid = new->sgid = new->fsgid = kgid;
-	else if (gid_eq(kgid, old->gid) || gid_eq(kgid, old->sgid))
-		new->egid = new->fsgid = kgid;
-	else
-		goto error;
-
-	retval = security_task_fix_setgid(new, old, LSM_SETID_ID);
-	if (retval < 0)
-		goto error;
-
-	return commit_creds(new);
-
-error:
-	abort_creds(new);
-	return retval;
-}
-
-SYSCALL_DEFINE1(setgid, gid_t, gid)
-{
-	return __sys_setgid(gid);
-}
-
-/*
- * change the user struct in a credentials set to match the new UID
- */
-static int set_user(struct cred *new)
-{
-	struct user_struct *new_user;
-
-	new_user = alloc_uid(new->uid);
-	if (!new_user)
-		return -EAGAIN;
-
-	free_uid(new->user);
-	new->user = new_user;
-	return 0;
-}
-
-static void flag_nproc_exceeded(struct cred *new)
-{
-	if (new->ucounts == current_ucounts())
-		return;
-
-	/*
-	 * We don't fail in case of NPROC limit excess here because too many
-	 * poorly written programs don't check set*uid() return code, assuming
-	 * it never fails if called by root.  We may still enforce NPROC limit
-	 * for programs doing set*uid()+execve() by harmlessly deferring the
-	 * failure to the execve() stage.
-	 */
-	if (is_rlimit_overlimit(new->ucounts, UCOUNT_RLIMIT_NPROC, rlimit(RLIMIT_NPROC)) &&
-			new->user != INIT_USER)
-		current->flags |= PF_NPROC_EXCEEDED;
-	else
-		current->flags &= ~PF_NPROC_EXCEEDED;
-}
-
-/*
- * Unprivileged users may change the real uid to the effective uid
- * or vice versa.  (BSD-style)
- *
- * If you set the real uid at all, or set the effective uid to a value not
- * equal to the real uid, then the saved uid is set to the new effective uid.
- *
- * This makes it possible for a setuid program to completely drop its
- * privileges, which is often a useful assertion to make when you are doing
- * a security audit over a program.
- *
- * The general idea is that a program which uses just setreuid() will be
- * 100% compatible with BSD.  A program which uses just setuid() will be
- * 100% compatible with POSIX with saved IDs.
- */
-long __sys_setreuid(uid_t ruid, uid_t euid)
-{
-	struct user_namespace *ns = current_user_ns();
-	const struct cred *old;
-	struct cred *new;
-	int retval;
-	kuid_t kruid, keuid;
-
-	kruid = make_kuid(ns, ruid);
-	keuid = make_kuid(ns, euid);
-
-	if ((ruid != (uid_t) -1) && !uid_valid(kruid))
-		return -EINVAL;
-	if ((euid != (uid_t) -1) && !uid_valid(keuid))
-		return -EINVAL;
-
-	new = prepare_creds();
-	if (!new)
-		return -ENOMEM;
-	old = current_cred();
-
-	retval = -EPERM;
-	if (ruid != (uid_t) -1) {
-		new->uid = kruid;
-		if (!uid_eq(old->uid, kruid) &&
-		    !uid_eq(old->euid, kruid) &&
-		    !ns_capable_setid(old->user_ns, CAP_SETUID))
-			goto error;
-	}
-
-	if (euid != (uid_t) -1) {
-		new->euid = keuid;
-		if (!uid_eq(old->uid, keuid) &&
-		    !uid_eq(old->euid, keuid) &&
-		    !uid_eq(old->suid, keuid) &&
-		    !ns_capable_setid(old->user_ns, CAP_SETUID))
-			goto error;
-	}
-
-	if (!uid_eq(new->uid, old->uid)) {
-		retval = set_user(new);
-		if (retval < 0)
-			goto error;
-	}
-	if (ruid != (uid_t) -1 ||
-	    (euid != (uid_t) -1 && !uid_eq(keuid, old->uid)))
-		new->suid = new->euid;
-	new->fsuid = new->euid;
-
-	retval = security_task_fix_setuid(new, old, LSM_SETID_RE);
-	if (retval < 0)
-		goto error;
-
-	retval = set_cred_ucounts(new);
-	if (retval < 0)
-		goto error;
-
-	flag_nproc_exceeded(new);
-	return commit_creds(new);
-
-error:
-	abort_creds(new);
-	return retval;
-}
-
-SYSCALL_DEFINE2(setreuid, uid_t, ruid, uid_t, euid)
-{
-	return __sys_setreuid(ruid, euid);
-}
-
-/*
- * setuid() is implemented like SysV with SAVED_IDS
- *
- * Note that SAVED_ID's is deficient in that a setuid root program
- * like sendmail, for example, cannot set its uid to be a normal
- * user and then switch back, because if you're root, setuid() sets
- * the saved uid too.  If you don't like this, blame the bright people
- * in the POSIX committee and/or USG.  Note that the BSD-style setreuid()
- * will allow a root program to temporarily drop privileges and be able to
- * regain them by swapping the real and effective uid.
- */
-long __sys_setuid(uid_t uid)
-{
-	struct user_namespace *ns = current_user_ns();
-	const struct cred *old;
-	struct cred *new;
-	int retval;
-	kuid_t kuid;
-
-	kuid = make_kuid(ns, uid);
-	if (!uid_valid(kuid))
-		return -EINVAL;
-
-	new = prepare_creds();
-	if (!new)
-		return -ENOMEM;
-	old = current_cred();
-
-	retval = -EPERM;
-	if (ns_capable_setid(old->user_ns, CAP_SETUID)) {
-		new->suid = new->uid = kuid;
-		if (!uid_eq(kuid, old->uid)) {
-			retval = set_user(new);
-			if (retval < 0)
-				goto error;
-		}
-	} else if (!uid_eq(kuid, old->uid) && !uid_eq(kuid, new->suid)) {
-		goto error;
-	}
-
-	new->fsuid = new->euid = kuid;
-
-	retval = security_task_fix_setuid(new, old, LSM_SETID_ID);
-	if (retval < 0)
-		goto error;
-
-	retval = set_cred_ucounts(new);
-	if (retval < 0)
-		goto error;
-
-	flag_nproc_exceeded(new);
-	return commit_creds(new);
-
-error:
-	abort_creds(new);
-	return retval;
-}
-
-SYSCALL_DEFINE1(setuid, uid_t, uid)
-{
-	return __sys_setuid(uid);
-}
-
-
-/*
- * This function implements a generic ability to update ruid, euid,
- * and suid.  This allows you to implement the 4.4 compatible seteuid().
- */
-long __sys_setresuid(uid_t ruid, uid_t euid, uid_t suid)
-{
-	struct user_namespace *ns = current_user_ns();
-	const struct cred *old;
-	struct cred *new;
-	int retval;
-	kuid_t kruid, keuid, ksuid;
-	bool ruid_new, euid_new, suid_new;
-
-	kruid = make_kuid(ns, ruid);
-	keuid = make_kuid(ns, euid);
-	ksuid = make_kuid(ns, suid);
-
-	if ((ruid != (uid_t) -1) && !uid_valid(kruid))
-		return -EINVAL;
-
-	if ((euid != (uid_t) -1) && !uid_valid(keuid))
-		return -EINVAL;
-
-	if ((suid != (uid_t) -1) && !uid_valid(ksuid))
-		return -EINVAL;
-
-	old = current_cred();
-
-	/* check for no-op */
-	if ((ruid == (uid_t) -1 || uid_eq(kruid, old->uid)) &&
-	    (euid == (uid_t) -1 || (uid_eq(keuid, old->euid) &&
-				    uid_eq(keuid, old->fsuid))) &&
-	    (suid == (uid_t) -1 || uid_eq(ksuid, old->suid)))
-		return 0;
-
-	ruid_new = ruid != (uid_t) -1        && !uid_eq(kruid, old->uid) &&
-		   !uid_eq(kruid, old->euid) && !uid_eq(kruid, old->suid);
-	euid_new = euid != (uid_t) -1        && !uid_eq(keuid, old->uid) &&
-		   !uid_eq(keuid, old->euid) && !uid_eq(keuid, old->suid);
-	suid_new = suid != (uid_t) -1        && !uid_eq(ksuid, old->uid) &&
-		   !uid_eq(ksuid, old->euid) && !uid_eq(ksuid, old->suid);
-	if ((ruid_new || euid_new || suid_new) &&
-	    !ns_capable_setid(old->user_ns, CAP_SETUID))
-		return -EPERM;
-
-	new = prepare_creds();
-	if (!new)
-		return -ENOMEM;
-
-	if (ruid != (uid_t) -1) {
-		new->uid = kruid;
-		if (!uid_eq(kruid, old->uid)) {
-			retval = set_user(new);
-			if (retval < 0)
-				goto error;
-		}
-	}
-	if (euid != (uid_t) -1)
-		new->euid = keuid;
-	if (suid != (uid_t) -1)
-		new->suid = ksuid;
-	new->fsuid = new->euid;
-
-	retval = security_task_fix_setuid(new, old, LSM_SETID_RES);
-	if (retval < 0)
-		goto error;
-
-	retval = set_cred_ucounts(new);
-	if (retval < 0)
-		goto error;
-
-	flag_nproc_exceeded(new);
-	return commit_creds(new);
-
-error:
-	abort_creds(new);
-	return retval;
-}
-
-SYSCALL_DEFINE3(setresuid, uid_t, ruid, uid_t, euid, uid_t, suid)
-{
-	return __sys_setresuid(ruid, euid, suid);
-}
-
-SYSCALL_DEFINE3(getresuid, uid_t __user *, ruidp, uid_t __user *, euidp, uid_t __user *, suidp)
-{
-	const struct cred *cred = current_cred();
-	int retval;
-	uid_t ruid, euid, suid;
-
-	ruid = from_kuid_munged(cred->user_ns, cred->uid);
-	euid = from_kuid_munged(cred->user_ns, cred->euid);
-	suid = from_kuid_munged(cred->user_ns, cred->suid);
-
-	retval = put_user(ruid, ruidp);
-	if (!retval) {
-		retval = put_user(euid, euidp);
-		if (!retval)
-			return put_user(suid, suidp);
-	}
-	return retval;
-}
-
-/*
- * Same as above, but for rgid, egid, sgid.
- */
-long __sys_setresgid(gid_t rgid, gid_t egid, gid_t sgid)
-{
-	struct user_namespace *ns = current_user_ns();
-	const struct cred *old;
-	struct cred *new;
-	int retval;
-	kgid_t krgid, kegid, ksgid;
-	bool rgid_new, egid_new, sgid_new;
-
-	krgid = make_kgid(ns, rgid);
-	kegid = make_kgid(ns, egid);
-	ksgid = make_kgid(ns, sgid);
-
-	if ((rgid != (gid_t) -1) && !gid_valid(krgid))
-		return -EINVAL;
-	if ((egid != (gid_t) -1) && !gid_valid(kegid))
-		return -EINVAL;
-	if ((sgid != (gid_t) -1) && !gid_valid(ksgid))
-		return -EINVAL;
-
-	old = current_cred();
-
-	/* check for no-op */
-	if ((rgid == (gid_t) -1 || gid_eq(krgid, old->gid)) &&
-	    (egid == (gid_t) -1 || (gid_eq(kegid, old->egid) &&
-				    gid_eq(kegid, old->fsgid))) &&
-	    (sgid == (gid_t) -1 || gid_eq(ksgid, old->sgid)))
-		return 0;
-
-	rgid_new = rgid != (gid_t) -1        && !gid_eq(krgid, old->gid) &&
-		   !gid_eq(krgid, old->egid) && !gid_eq(krgid, old->sgid);
-	egid_new = egid != (gid_t) -1        && !gid_eq(kegid, old->gid) &&
-		   !gid_eq(kegid, old->egid) && !gid_eq(kegid, old->sgid);
-	sgid_new = sgid != (gid_t) -1        && !gid_eq(ksgid, old->gid) &&
-		   !gid_eq(ksgid, old->egid) && !gid_eq(ksgid, old->sgid);
-	if ((rgid_new || egid_new || sgid_new) &&
-	    !ns_capable_setid(old->user_ns, CAP_SETGID))
-		return -EPERM;
-
-	new = prepare_creds();
-	if (!new)
-		return -ENOMEM;
-
-	if (rgid != (gid_t) -1)
-		new->gid = krgid;
-	if (egid != (gid_t) -1)
-		new->egid = kegid;
-	if (sgid != (gid_t) -1)
-		new->sgid = ksgid;
-	new->fsgid = new->egid;
-
-	retval = security_task_fix_setgid(new, old, LSM_SETID_RES);
-	if (retval < 0)
-		goto error;
-
-	return commit_creds(new);
-
-error:
-	abort_creds(new);
-	return retval;
-}
-
-SYSCALL_DEFINE3(setresgid, gid_t, rgid, gid_t, egid, gid_t, sgid)
-{
-	return __sys_setresgid(rgid, egid, sgid);
-}
-
-SYSCALL_DEFINE3(getresgid, gid_t __user *, rgidp, gid_t __user *, egidp, gid_t __user *, sgidp)
-{
-	const struct cred *cred = current_cred();
-	int retval;
-	gid_t rgid, egid, sgid;
-
-	rgid = from_kgid_munged(cred->user_ns, cred->gid);
-	egid = from_kgid_munged(cred->user_ns, cred->egid);
-	sgid = from_kgid_munged(cred->user_ns, cred->sgid);
-
-	retval = put_user(rgid, rgidp);
-	if (!retval) {
-		retval = put_user(egid, egidp);
-		if (!retval)
-			retval = put_user(sgid, sgidp);
-	}
-
-	return retval;
-}
-
-
-/*
- * "setfsuid()" sets the fsuid - the uid used for filesystem checks. This
- * is used for "access()" and for the NFS daemon (letting nfsd stay at
- * whatever uid it wants to). It normally shadows "euid", except when
- * explicitly set by setfsuid() or for access..
- */
-long __sys_setfsuid(uid_t uid)
-{
-	const struct cred *old;
-	struct cred *new;
-	uid_t old_fsuid;
-	kuid_t kuid;
-
-	old = current_cred();
-	old_fsuid = from_kuid_munged(old->user_ns, old->fsuid);
-
-	kuid = make_kuid(old->user_ns, uid);
-	if (!uid_valid(kuid))
-		return old_fsuid;
-
-	new = prepare_creds();
-	if (!new)
-		return old_fsuid;
-
-	if (uid_eq(kuid, old->uid)  || uid_eq(kuid, old->euid)  ||
-	    uid_eq(kuid, old->suid) || uid_eq(kuid, old->fsuid) ||
-	    ns_capable_setid(old->user_ns, CAP_SETUID)) {
-		if (!uid_eq(kuid, old->fsuid)) {
-			new->fsuid = kuid;
-			if (security_task_fix_setuid(new, old, LSM_SETID_FS) == 0)
-				goto change_okay;
-		}
-	}
-
-	abort_creds(new);
-	return old_fsuid;
-
-change_okay:
-	commit_creds(new);
-	return old_fsuid;
-}
-
-SYSCALL_DEFINE1(setfsuid, uid_t, uid)
-{
-	return __sys_setfsuid(uid);
-}
-
-/*
- * Samma p svenska..
- */
-long __sys_setfsgid(gid_t gid)
-{
-	const struct cred *old;
-	struct cred *new;
-	gid_t old_fsgid;
-	kgid_t kgid;
-
-	old = current_cred();
-	old_fsgid = from_kgid_munged(old->user_ns, old->fsgid);
-
-	kgid = make_kgid(old->user_ns, gid);
-	if (!gid_valid(kgid))
-		return old_fsgid;
-
-	new = prepare_creds();
-	if (!new)
-		return old_fsgid;
-
-	if (gid_eq(kgid, old->gid)  || gid_eq(kgid, old->egid)  ||
-	    gid_eq(kgid, old->sgid) || gid_eq(kgid, old->fsgid) ||
-	    ns_capable_setid(old->user_ns, CAP_SETGID)) {
-		if (!gid_eq(kgid, old->fsgid)) {
-			new->fsgid = kgid;
-			if (security_task_fix_setgid(new,old,LSM_SETID_FS) == 0)
-				goto change_okay;
-		}
-	}
-
-	abort_creds(new);
-	return old_fsgid;
-
-change_okay:
-	commit_creds(new);
-	return old_fsgid;
-}
-
-SYSCALL_DEFINE1(setfsgid, gid_t, gid)
-{
-	return __sys_setfsgid(gid);
-}
-#endif /* CONFIG_MULTIUSER */
-
-/**
- * sys_getpid - return the thread group id of the current process
- *
- * Note, despite the name, this returns the tgid not the pid.  The tgid and
- * the pid are identical unless CLONE_THREAD was specified on clone() in
- * which case the tgid is the same in all threads of the same group.
- *
- * This is SMP safe as current->tgid does not change.
- */
-SYSCALL_DEFINE0(getpid)
-{
-	return task_tgid_vnr(current);
-}
-
-/* Thread ID - the internal kernel "pid" */
-SYSCALL_DEFINE0(gettid)
-{
-	return task_pid_vnr(current);
-}
-
-/*
- * Accessing ->real_parent is not SMP-safe, it could
- * change from under us. However, we can use a stale
- * value of ->real_parent under rcu_read_lock(), see
- * release_task()->call_rcu(delayed_put_task_struct).
- */
-SYSCALL_DEFINE0(getppid)
-{
-	int pid;
-
-	rcu_read_lock();
-	pid = task_tgid_vnr(rcu_dereference(current->real_parent));
-	rcu_read_unlock();
-
-	return pid;
-}
-
-SYSCALL_DEFINE0(getuid)
-{
-	/* Only we change this so SMP safe */
-	return from_kuid_munged(current_user_ns(), current_uid());
-}
-
-SYSCALL_DEFINE0(geteuid)
-{
-	/* Only we change this so SMP safe */
-	return from_kuid_munged(current_user_ns(), current_euid());
-}
-
-SYSCALL_DEFINE0(getgid)
-{
-	/* Only we change this so SMP safe */
-	return from_kgid_munged(current_user_ns(), current_gid());
-}
-
-SYSCALL_DEFINE0(getegid)
-{
-	/* Only we change this so SMP safe */
-	return from_kgid_munged(current_user_ns(), current_egid());
-}
-
-static void do_sys_times(struct tms *tms)
-{
-	u64 tgutime, tgstime, cutime, cstime;
-
-	thread_group_cputime_adjusted(current, &tgutime, &tgstime);
-	cutime = current->signal->cutime;
-	cstime = current->signal->cstime;
-	tms->tms_utime = nsec_to_clock_t(tgutime);
-	tms->tms_stime = nsec_to_clock_t(tgstime);
-	tms->tms_cutime = nsec_to_clock_t(cutime);
-	tms->tms_cstime = nsec_to_clock_t(cstime);
-}
-
-SYSCALL_DEFINE1(times, struct tms __user *, tbuf)
-{
-	if (tbuf) {
-		struct tms tmp;
-
-		do_sys_times(&tmp);
-		if (copy_to_user(tbuf, &tmp, sizeof(struct tms)))
-			return -EFAULT;
-	}
-	force_successful_syscall_return();
-	return (long) jiffies_64_to_clock_t(get_jiffies_64());
-}
-
-#ifdef CONFIG_COMPAT
-static compat_clock_t clock_t_to_compat_clock_t(clock_t x)
-{
-	return compat_jiffies_to_clock_t(clock_t_to_jiffies(x));
-}
-
-COMPAT_SYSCALL_DEFINE1(times, struct compat_tms __user *, tbuf)
-{
-	if (tbuf) {
-		struct tms tms;
-		struct compat_tms tmp;
-
-		do_sys_times(&tms);
-		/* Convert our struct tms to the compat version. */
-		tmp.tms_utime = clock_t_to_compat_clock_t(tms.tms_utime);
-		tmp.tms_stime = clock_t_to_compat_clock_t(tms.tms_stime);
-		tmp.tms_cutime = clock_t_to_compat_clock_t(tms.tms_cutime);
-		tmp.tms_cstime = clock_t_to_compat_clock_t(tms.tms_cstime);
-		if (copy_to_user(tbuf, &tmp, sizeof(tmp)))
-			return -EFAULT;
-	}
-	force_successful_syscall_return();
-	return compat_jiffies_to_clock_t(jiffies);
-}
-#endif
-
-/*
- * This needs some heavy checking ...
- * I just haven't the stomach for it. I also don't fully
- * understand sessions/pgrp etc. Let somebody who does explain it.
- *
- * OK, I think I have the protection semantics right.... this is really
- * only important on a multi-user system anyway, to make sure one user
- * can't send a signal to a process owned by another.  -TYT, 12/12/91
- *
- * !PF_FORKNOEXEC check to conform completely to POSIX.
- */
-SYSCALL_DEFINE2(setpgid, pid_t, pid, pid_t, pgid)
-{
-	struct task_struct *p;
-	struct task_struct *group_leader = current->group_leader;
-	struct pid *pids[PIDTYPE_MAX] = { 0 };
-	struct pid *pgrp;
-	int err;
-
-	if (!pid)
-		pid = task_pid_vnr(group_leader);
-	if (!pgid)
-		pgid = pid;
-	if (pgid < 0)
-		return -EINVAL;
-	rcu_read_lock();
-
-	/* From this point forward we keep holding onto the tasklist lock
-	 * so that our parent does not change from under us. -DaveM
-	 */
-	write_lock_irq(&tasklist_lock);
-
-	err = -ESRCH;
-	p = find_task_by_vpid(pid);
-	if (!p)
-		goto out;
-
-	err = -EINVAL;
-	if (!thread_group_leader(p))
-		goto out;
-
-	if (same_thread_group(p->real_parent, group_leader)) {
-		err = -EPERM;
-		if (task_session(p) != task_session(group_leader))
-			goto out;
-		err = -EACCES;
-		if (!(p->flags & PF_FORKNOEXEC))
-			goto out;
-	} else {
-		err = -ESRCH;
-		if (p != group_leader)
-			goto out;
-	}
-
-	err = -EPERM;
-	if (p->signal->leader)
-		goto out;
-
-	pgrp = task_pid(p);
-	if (pgid != pid) {
-		struct task_struct *g;
-
-		pgrp = find_vpid(pgid);
-		g = pid_task(pgrp, PIDTYPE_PGID);
-		if (!g || task_session(g) != task_session(group_leader))
-			goto out;
-	}
-
-	err = security_task_setpgid(p, pgid);
-	if (err)
-		goto out;
-
-	if (task_pgrp(p) != pgrp)
-		change_pid(pids, p, PIDTYPE_PGID, pgrp);
-
-	err = 0;
-out:
-	/* All paths lead to here, thus we are safe. -DaveM */
-	write_unlock_irq(&tasklist_lock);
-	rcu_read_unlock();
-	free_pids(pids);
-	return err;
-}
-
-static int do_getpgid(pid_t pid)
-{
-	struct task_struct *p;
-	struct pid *grp;
-	int retval;
-
-	rcu_read_lock();
-	if (!pid)
-		grp = task_pgrp(current);
-	else {
-		retval = -ESRCH;
-		p = find_task_by_vpid(pid);
-		if (!p)
-			goto out;
-		grp = task_pgrp(p);
-		if (!grp)
-			goto out;
-
-		retval = security_task_getpgid(p);
-		if (retval)
-			goto out;
-	}
-	retval = pid_vnr(grp);
-out:
-	rcu_read_unlock();
-	return retval;
-}
-
-SYSCALL_DEFINE1(getpgid, pid_t, pid)
-{
-	return do_getpgid(pid);
-}
-
-#ifdef __ARCH_WANT_SYS_GETPGRP
-
-SYSCALL_DEFINE0(getpgrp)
-{
-	return do_getpgid(0);
-}
-
-#endif
-
-SYSCALL_DEFINE1(getsid, pid_t, pid)
-{
-	struct task_struct *p;
-	struct pid *sid;
-	int retval;
-
-	rcu_read_lock();
-	if (!pid)
-		sid = task_session(current);
-	else {
-		retval = -ESRCH;
-		p = find_task_by_vpid(pid);
-		if (!p)
-			goto out;
-		sid = task_session(p);
-		if (!sid)
-			goto out;
-
-		retval = security_task_getsid(p);
-		if (retval)
-			goto out;
-	}
-	retval = pid_vnr(sid);
-out:
-	rcu_read_unlock();
-	return retval;
-}
-
-static void set_special_pids(struct pid **pids, struct pid *pid)
-{
-	struct task_struct *curr = current->group_leader;
-
-	if (task_session(curr) != pid)
-		change_pid(pids, curr, PIDTYPE_SID, pid);
-
-	if (task_pgrp(curr) != pid)
-		change_pid(pids, curr, PIDTYPE_PGID, pid);
-}
-
-int ksys_setsid(void)
-{
-	struct task_struct *group_leader = current->group_leader;
-	struct pid *sid = task_pid(group_leader);
-	struct pid *pids[PIDTYPE_MAX] = { 0 };
-	pid_t session = pid_vnr(sid);
-	int err = -EPERM;
-
-	write_lock_irq(&tasklist_lock);
-	/* Fail if I am already a session leader */
-	if (group_leader->signal->leader)
-		goto out;
-
-	/* Fail if a process group id already exists that equals the
-	 * proposed session id.
-	 */
-	if (pid_task(sid, PIDTYPE_PGID))
-		goto out;
-
-	group_leader->signal->leader = 1;
-	set_special_pids(pids, sid);
-
-	proc_clear_tty(group_leader);
-
-	err = session;
-out:
-	write_unlock_irq(&tasklist_lock);
-	free_pids(pids);
-	if (err > 0) {
-		proc_sid_connector(group_leader);
-		sched_autogroup_create_attach(group_leader);
-	}
-	return err;
-}
-
-SYSCALL_DEFINE0(setsid)
-{
-	return ksys_setsid();
-}
-
-DECLARE_RWSEM(uts_sem);
-
-#ifdef COMPAT_UTS_MACHINE
-#define override_architecture(name) \
-	(personality(current->personality) == PER_LINUX32 && \
-	 copy_to_user(name->machine, COMPAT_UTS_MACHINE, \
-		      sizeof(COMPAT_UTS_MACHINE)))
-#else
-#define override_architecture(name)	0
-#endif
-
-/*
- * Work around broken programs that cannot handle "Linux 3.0".
- * Instead we map 3.x to 2.6.40+x, so e.g. 3.0 would be 2.6.40
- * And we map 4.x and later versions to 2.6.60+x, so 4.0/5.0/6.0/... would be
- * 2.6.60.
- */
-static int override_release(char __user *release, size_t len)
-{
-	int ret = 0;
-
-	if (current->personality & UNAME26) {
-		const char *rest = UTS_RELEASE;
-		char buf[65] = { 0 };
-		int ndots = 0;
-		unsigned v;
-		size_t copy;
-
-		while (*rest) {
-			if (*rest == '.' && ++ndots >= 3)
-				break;
-			if (!isdigit(*rest) && *rest != '.')
-				break;
-			rest++;
-		}
-		v = LINUX_VERSION_PATCHLEVEL + 60;
-		copy = clamp_t(size_t, len, 1, sizeof(buf));
-		copy = scnprintf(buf, copy, "2.6.%u%s", v, rest);
-		ret = copy_to_user(release, buf, copy + 1);
-	}
-	return ret;
-}
-
-SYSCALL_DEFINE1(newuname, struct new_utsname __user *, name)
-{
-	struct new_utsname tmp;
-
-	down_read(&uts_sem);
-	memcpy(&tmp, utsname(), sizeof(tmp));
-	up_read(&uts_sem);
-	if (copy_to_user(name, &tmp, sizeof(tmp)))
-		return -EFAULT;
-
-	if (override_release(name->release, sizeof(name->release)))
-		return -EFAULT;
-	if (override_architecture(name))
-		return -EFAULT;
-	return 0;
-}
-
-#ifdef __ARCH_WANT_SYS_OLD_UNAME
-/*
- * Old cruft
- */
-SYSCALL_DEFINE1(uname, struct old_utsname __user *, name)
-{
-	struct old_utsname tmp;
-
-	if (!name)
-		return -EFAULT;
-
-	down_read(&uts_sem);
-	memcpy(&tmp, utsname(), sizeof(tmp));
-	up_read(&uts_sem);
-	if (copy_to_user(name, &tmp, sizeof(tmp)))
-		return -EFAULT;
-
-	if (override_release(name->release, sizeof(name->release)))
-		return -EFAULT;
-	if (override_architecture(name))
-		return -EFAULT;
-	return 0;
-}
-
-SYSCALL_DEFINE1(olduname, struct oldold_utsname __user *, name)
-{
-	struct oldold_utsname tmp;
-
-	if (!name)
-		return -EFAULT;
-
-	memset(&tmp, 0, sizeof(tmp));
-
-	down_read(&uts_sem);
-	memcpy(&tmp.sysname, &utsname()->sysname, __OLD_UTS_LEN);
-	memcpy(&tmp.nodename, &utsname()->nodename, __OLD_UTS_LEN);
-	memcpy(&tmp.release, &utsname()->release, __OLD_UTS_LEN);
-	memcpy(&tmp.version, &utsname()->version, __OLD_UTS_LEN);
-	memcpy(&tmp.machine, &utsname()->machine, __OLD_UTS_LEN);
-	up_read(&uts_sem);
-	if (copy_to_user(name, &tmp, sizeof(tmp)))
-		return -EFAULT;
-
-	if (override_architecture(name))
-		return -EFAULT;
-	if (override_release(name->release, sizeof(name->release)))
-		return -EFAULT;
-	return 0;
-}
-#endif
-
-SYSCALL_DEFINE2(sethostname, char __user *, name, int, len)
-{
-	int errno;
-	char tmp[__NEW_UTS_LEN];
-
-	if (!ns_capable(current->nsproxy->uts_ns->user_ns, CAP_SYS_ADMIN))
-		return -EPERM;
-
-	if (len < 0 || len > __NEW_UTS_LEN)
-		return -EINVAL;
-	errno = -EFAULT;
-	if (!copy_from_user(tmp, name, len)) {
-		struct new_utsname *u;
-
-		add_device_randomness(tmp, len);
-		down_write(&uts_sem);
-		u = utsname();
-		memcpy(u->nodename, tmp, len);
-		memset(u->nodename + len, 0, sizeof(u->nodename) - len);
-		errno = 0;
-		uts_proc_notify(UTS_PROC_HOSTNAME);
-		up_write(&uts_sem);
-	}
-	return errno;
-}
-
-#ifdef __ARCH_WANT_SYS_GETHOSTNAME
-
-SYSCALL_DEFINE2(gethostname, char __user *, name, int, len)
-{
-	int i;
-	struct new_utsname *u;
-	char tmp[__NEW_UTS_LEN + 1];
-
-	if (len < 0)
-		return -EINVAL;
-	down_read(&uts_sem);
-	u = utsname();
-	i = 1 + strlen(u->nodename);
-	if (i > len)
-		i = len;
-	memcpy(tmp, u->nodename, i);
-	up_read(&uts_sem);
-	if (copy_to_user(name, tmp, i))
-		return -EFAULT;
-	return 0;
-}
-
-#endif
-
-/*
- * Only setdomainname; getdomainname can be implemented by calling
- * uname()
- */
-SYSCALL_DEFINE2(setdomainname, char __user *, name, int, len)
-{
-	int errno;
-	char tmp[__NEW_UTS_LEN];
-
-	if (!ns_capable(current->nsproxy->uts_ns->user_ns, CAP_SYS_ADMIN))
-		return -EPERM;
-	if (len < 0 || len > __NEW_UTS_LEN)
-		return -EINVAL;
-
-	errno = -EFAULT;
-	if (!copy_from_user(tmp, name, len)) {
-		struct new_utsname *u;
-
-		add_device_randomness(tmp, len);
-		down_write(&uts_sem);
-		u = utsname();
-		memcpy(u->domainname, tmp, len);
-		memset(u->domainname + len, 0, sizeof(u->domainname) - len);
-		errno = 0;
-		uts_proc_notify(UTS_PROC_DOMAINNAME);
-		up_write(&uts_sem);
-	}
-	return errno;
-}
-
-/* make sure you are allowed to change @tsk limits before calling this */
-static int do_prlimit(struct task_struct *tsk, unsigned int resource,
-		      struct rlimit *new_rlim, struct rlimit *old_rlim)
-{
-	struct rlimit *rlim;
-	int retval = 0;
-
-	if (resource >= RLIM_NLIMITS)
-		return -EINVAL;
-	resource = array_index_nospec(resource, RLIM_NLIMITS);
-
-	if (new_rlim) {
-		if (new_rlim->rlim_cur > new_rlim->rlim_max)
-			return -EINVAL;
-		if (resource == RLIMIT_NOFILE &&
-				new_rlim->rlim_max > sysctl_nr_open)
-			return -EPERM;
-	}
-
-	/* Holding a refcount on tsk protects tsk->signal from disappearing. */
-	rlim = tsk->signal->rlim + resource;
-	task_lock(tsk->group_leader);
-	if (new_rlim) {
-		/*
-		 * Keep the capable check against init_user_ns until cgroups can
-		 * contain all limits.
-		 */
-		if (new_rlim->rlim_max > rlim->rlim_max &&
-				!capable(CAP_SYS_RESOURCE))
-			retval = -EPERM;
-		if (!retval)
-			retval = security_task_setrlimit(tsk, resource, new_rlim);
-	}
-	if (!retval) {
-		if (old_rlim)
-			*old_rlim = *rlim;
-		if (new_rlim)
-			*rlim = *new_rlim;
-	}
-	task_unlock(tsk->group_leader);
-
-	/*
-	 * RLIMIT_CPU handling. Arm the posix CPU timer if the limit is not
-	 * infinite. In case of RLIM_INFINITY the posix CPU timer code
-	 * ignores the rlimit.
-	 */
-	if (!retval && new_rlim && resource == RLIMIT_CPU &&
-	    new_rlim->rlim_cur != RLIM_INFINITY &&
-	    IS_ENABLED(CONFIG_POSIX_TIMERS)) {
-		/*
-		 * update_rlimit_cpu can fail if the task is exiting, but there
-		 * may be other tasks in the thread group that are not exiting,
-		 * and they need their cpu timers adjusted.
-		 *
-		 * The group_leader is the last task to be released, so if we
-		 * cannot update_rlimit_cpu on it, then the entire process is
-		 * exiting and we do not need to update at all.
-		 */
-		update_rlimit_cpu(tsk->group_leader, new_rlim->rlim_cur);
-	}
-
-	return retval;
-}
-
-SYSCALL_DEFINE2(getrlimit, unsigned int, resource, struct rlimit __user *, rlim)
-{
-	struct rlimit value;
-	int ret;
-
-	ret = do_prlimit(current, resource, NULL, &value);
-	if (!ret)
-		ret = copy_to_user(rlim, &value, sizeof(*rlim)) ? -EFAULT : 0;
-
-	return ret;
-}
-
-#ifdef CONFIG_COMPAT
-
-COMPAT_SYSCALL_DEFINE2(setrlimit, unsigned int, resource,
-		       struct compat_rlimit __user *, rlim)
-{
-	struct rlimit r;
-	struct compat_rlimit r32;
-
-	if (copy_from_user(&r32, rlim, sizeof(struct compat_rlimit)))
-		return -EFAULT;
-
-	if (r32.rlim_cur == COMPAT_RLIM_INFINITY)
-		r.rlim_cur = RLIM_INFINITY;
-	else
-		r.rlim_cur = r32.rlim_cur;
-	if (r32.rlim_max == COMPAT_RLIM_INFINITY)
-		r.rlim_max = RLIM_INFINITY;
-	else
-		r.rlim_max = r32.rlim_max;
-	return do_prlimit(current, resource, &r, NULL);
-}
-
-COMPAT_SYSCALL_DEFINE2(getrlimit, unsigned int, resource,
-		       struct compat_rlimit __user *, rlim)
-{
-	struct rlimit r;
-	int ret;
-
-	ret = do_prlimit(current, resource, NULL, &r);
-	if (!ret) {
-		struct compat_rlimit r32;
-		if (r.rlim_cur > COMPAT_RLIM_INFINITY)
-			r32.rlim_cur = COMPAT_RLIM_INFINITY;
-		else
-			r32.rlim_cur = r.rlim_cur;
-		if (r.rlim_max > COMPAT_RLIM_INFINITY)
-			r32.rlim_max = COMPAT_RLIM_INFINITY;
-		else
-			r32.rlim_max = r.rlim_max;
-
-		if (copy_to_user(rlim, &r32, sizeof(struct compat_rlimit)))
-			return -EFAULT;
-	}
-	return ret;
-}
-
-#endif
-
-#ifdef __ARCH_WANT_SYS_OLD_GETRLIMIT
-
-/*
- *	Back compatibility for getrlimit. Needed for some apps.
- */
-SYSCALL_DEFINE2(old_getrlimit, unsigned int, resource,
-		struct rlimit __user *, rlim)
-{
-	struct rlimit x;
-	if (resource >= RLIM_NLIMITS)
-		return -EINVAL;
-
-	resource = array_index_nospec(resource, RLIM_NLIMITS);
-	task_lock(current->group_leader);
-	x = current->signal->rlim[resource];
-	task_unlock(current->group_leader);
-	if (x.rlim_cur > 0x7FFFFFFF)
-		x.rlim_cur = 0x7FFFFFFF;
-	if (x.rlim_max > 0x7FFFFFFF)
-		x.rlim_max = 0x7FFFFFFF;
-	return copy_to_user(rlim, &x, sizeof(x)) ? -EFAULT : 0;
-}
-
-#ifdef CONFIG_COMPAT
-COMPAT_SYSCALL_DEFINE2(old_getrlimit, unsigned int, resource,
-		       struct compat_rlimit __user *, rlim)
-{
-	struct rlimit r;
-
-	if (resource >= RLIM_NLIMITS)
-		return -EINVAL;
-
-	resource = array_index_nospec(resource, RLIM_NLIMITS);
-	task_lock(current->group_leader);
-	r = current->signal->rlim[resource];
-	task_unlock(current->group_leader);
-	if (r.rlim_cur > 0x7FFFFFFF)
-		r.rlim_cur = 0x7FFFFFFF;
-	if (r.rlim_max > 0x7FFFFFFF)
-		r.rlim_max = 0x7FFFFFFF;
-
-	if (put_user(r.rlim_cur, &rlim->rlim_cur) ||
-	    put_user(r.rlim_max, &rlim->rlim_max))
-		return -EFAULT;
-	return 0;
-}
-#endif
-
-#endif
-
-static inline bool rlim64_is_infinity(__u64 rlim64)
-{
-#if BITS_PER_LONG < 64
-	return rlim64 >= ULONG_MAX;
-#else
-	return rlim64 == RLIM64_INFINITY;
-#endif
-}
-
-static void rlim_to_rlim64(const struct rlimit *rlim, struct rlimit64 *rlim64)
-{
-	if (rlim->rlim_cur == RLIM_INFINITY)
-		rlim64->rlim_cur = RLIM64_INFINITY;
-	else
-		rlim64->rlim_cur = rlim->rlim_cur;
-	if (rlim->rlim_max == RLIM_INFINITY)
-		rlim64->rlim_max = RLIM64_INFINITY;
-	else
-		rlim64->rlim_max = rlim->rlim_max;
-}
-
-static void rlim64_to_rlim(const struct rlimit64 *rlim64, struct rlimit *rlim)
-{
-	if (rlim64_is_infinity(rlim64->rlim_cur))
-		rlim->rlim_cur = RLIM_INFINITY;
-	else
-		rlim->rlim_cur = (unsigned long)rlim64->rlim_cur;
-	if (rlim64_is_infinity(rlim64->rlim_max))
-		rlim->rlim_max = RLIM_INFINITY;
-	else
-		rlim->rlim_max = (unsigned long)rlim64->rlim_max;
-}
-
-/* rcu lock must be held */
-static int check_prlimit_permission(struct task_struct *task,
-				    unsigned int flags)
-{
-	const struct cred *cred = current_cred(), *tcred;
-	bool id_match;
-
-	if (current == task)
-		return 0;
-
-	tcred = __task_cred(task);
-	id_match = (uid_eq(cred->uid, tcred->euid) &&
-		    uid_eq(cred->uid, tcred->suid) &&
-		    uid_eq(cred->uid, tcred->uid)  &&
-		    gid_eq(cred->gid, tcred->egid) &&
-		    gid_eq(cred->gid, tcred->sgid) &&
-		    gid_eq(cred->gid, tcred->gid));
-	if (!id_match && !ns_capable(tcred->user_ns, CAP_SYS_RESOURCE))
-		return -EPERM;
-
-	return security_task_prlimit(cred, tcred, flags);
-}
-
-SYSCALL_DEFINE4(prlimit64, pid_t, pid, unsigned int, resource,
-		const struct rlimit64 __user *, new_rlim,
-		struct rlimit64 __user *, old_rlim)
-{
-	struct rlimit64 old64, new64;
-	struct rlimit old, new;
-	struct task_struct *tsk;
-	unsigned int checkflags = 0;
-	int ret;
-
-	if (old_rlim)
-		checkflags |= LSM_PRLIMIT_READ;
-
-	if (new_rlim) {
-		if (copy_from_user(&new64, new_rlim, sizeof(new64)))
-			return -EFAULT;
-		rlim64_to_rlim(&new64, &new);
-		checkflags |= LSM_PRLIMIT_WRITE;
-	}
-
-	rcu_read_lock();
-	tsk = pid ? find_task_by_vpid(pid) : current;
-	if (!tsk) {
-		rcu_read_unlock();
-		return -ESRCH;
-	}
-	ret = check_prlimit_permission(tsk, checkflags);
-	if (ret) {
-		rcu_read_unlock();
-		return ret;
-	}
-	get_task_struct(tsk);
-	rcu_read_unlock();
-
-	ret = do_prlimit(tsk, resource, new_rlim ? &new : NULL,
-			old_rlim ? &old : NULL);
-
-	if (!ret && old_rlim) {
-		rlim_to_rlim64(&old, &old64);
-		if (copy_to_user(old_rlim, &old64, sizeof(old64)))
-			ret = -EFAULT;
-	}
-
-	put_task_struct(tsk);
-	return ret;
-}
-
-SYSCALL_DEFINE2(setrlimit, unsigned int, resource, struct rlimit __user *, rlim)
-{
-	struct rlimit new_rlim;
-
-	if (copy_from_user(&new_rlim, rlim, sizeof(*rlim)))
-		return -EFAULT;
-	return do_prlimit(current, resource, &new_rlim, NULL);
-}
-
-/*
- * It would make sense to put struct rusage in the task_struct,
- * except that would make the task_struct be *really big*.  After
- * task_struct gets moved into malloc'ed memory, it would
- * make sense to do this.  It will make moving the rest of the information
- * a lot simpler!  (Which we're not doing right now because we're not
- * measuring them yet).
- *
- * When sampling multiple threads for RUSAGE_SELF, under SMP we might have
- * races with threads incrementing their own counters.  But since word
- * reads are atomic, we either get new values or old values and we don't
- * care which for the sums.  We always take the siglock to protect reading
- * the c* fields from p->signal from races with exit.c updating those
- * fields when reaping, so a sample either gets all the additions of a
- * given child after it's reaped, or none so this sample is before reaping.
- *
- * Locking:
- * We need to take the siglock for CHILDEREN, SELF and BOTH
- * for  the cases current multithreaded, non-current single threaded
- * non-current multithreaded.  Thread traversal is now safe with
- * the siglock held.
- * Strictly speaking, we donot need to take the siglock if we are current and
- * single threaded,  as no one else can take our signal_struct away, no one
- * else can  reap the  children to update signal->c* counters, and no one else
- * can race with the signal-> fields. If we do not take any lock, the
- * signal-> fields could be read out of order while another thread was just
- * exiting. So we should  place a read memory barrier when we avoid the lock.
- * On the writer side,  write memory barrier is implied in  __exit_signal
- * as __exit_signal releases  the siglock spinlock after updating the signal->
- * fields. But we don't do this yet to keep things simple.
- *
- */
-
-static void accumulate_thread_rusage(struct task_struct *t, struct rusage *r)
-{
-	r->ru_nvcsw += t->nvcsw;
-	r->ru_nivcsw += t->nivcsw;
-	r->ru_minflt += t->min_flt;
-	r->ru_majflt += t->maj_flt;
-	r->ru_inblock += task_io_get_inblock(t);
-	r->ru_oublock += task_io_get_oublock(t);
-}
-
-void getrusage(struct task_struct *p, int who, struct rusage *r)
-{
-	struct task_struct *t;
-	unsigned long flags;
-	u64 tgutime, tgstime, utime, stime;
-	unsigned long maxrss;
-	struct mm_struct *mm;
-	struct signal_struct *sig = p->signal;
-	unsigned int seq = 0;
-
-retry:
-	memset(r, 0, sizeof(*r));
-	utime = stime = 0;
-	maxrss = 0;
-
-	if (who == RUSAGE_THREAD) {
-		task_cputime_adjusted(current, &utime, &stime);
-		accumulate_thread_rusage(p, r);
-		maxrss = sig->maxrss;
-		goto out_thread;
-	}
-
-	flags = read_seqbegin_or_lock_irqsave(&sig->stats_lock, &seq);
-
-	switch (who) {
-	case RUSAGE_BOTH:
-	case RUSAGE_CHILDREN:
-		utime = sig->cutime;
-		stime = sig->cstime;
-		r->ru_nvcsw = sig->cnvcsw;
-		r->ru_nivcsw = sig->cnivcsw;
-		r->ru_minflt = sig->cmin_flt;
-		r->ru_majflt = sig->cmaj_flt;
-		r->ru_inblock = sig->cinblock;
-		r->ru_oublock = sig->coublock;
-		maxrss = sig->cmaxrss;
-
-		if (who == RUSAGE_CHILDREN)
-			break;
-		fallthrough;
-
-	case RUSAGE_SELF:
-		r->ru_nvcsw += sig->nvcsw;
-		r->ru_nivcsw += sig->nivcsw;
-		r->ru_minflt += sig->min_flt;
-		r->ru_majflt += sig->maj_flt;
-		r->ru_inblock += sig->inblock;
-		r->ru_oublock += sig->oublock;
-		if (maxrss < sig->maxrss)
-			maxrss = sig->maxrss;
-
-		rcu_read_lock();
-		__for_each_thread(sig, t)
-			accumulate_thread_rusage(t, r);
-		rcu_read_unlock();
-
-		break;
-
-	default:
-		BUG();
-	}
-
-	if (need_seqretry(&sig->stats_lock, seq)) {
-		seq = 1;
-		goto retry;
-	}
-	done_seqretry_irqrestore(&sig->stats_lock, seq, flags);
-
-	if (who == RUSAGE_CHILDREN)
-		goto out_children;
-
-	thread_group_cputime_adjusted(p, &tgutime, &tgstime);
-	utime += tgutime;
-	stime += tgstime;
-
-out_thread:
-	mm = get_task_mm(p);
-	if (mm) {
-		setmax_mm_hiwater_rss(&maxrss, mm);
-		mmput(mm);
-	}
-
-out_children:
-	r->ru_maxrss = maxrss * (PAGE_SIZE / 1024); /* convert pages to KBs */
-	r->ru_utime = ns_to_kernel_old_timeval(utime);
-	r->ru_stime = ns_to_kernel_old_timeval(stime);
-}
-
-SYSCALL_DEFINE2(getrusage, int, who, struct rusage __user *, ru)
-{
-	struct rusage r;
-
-	if (who != RUSAGE_SELF && who != RUSAGE_CHILDREN &&
-	    who != RUSAGE_THREAD)
-		return -EINVAL;
-
-	getrusage(current, who, &r);
-	return copy_to_user(ru, &r, sizeof(r)) ? -EFAULT : 0;
-}
-
-#ifdef CONFIG_COMPAT
-COMPAT_SYSCALL_DEFINE2(getrusage, int, who, struct compat_rusage __user *, ru)
-{
-	struct rusage r;
-
-	if (who != RUSAGE_SELF && who != RUSAGE_CHILDREN &&
-	    who != RUSAGE_THREAD)
-		return -EINVAL;
-
-	getrusage(current, who, &r);
-	return put_compat_rusage(&r, ru);
-}
-#endif
-
-SYSCALL_DEFINE1(umask, int, mask)
-{
-	mask = xchg(&current->fs->umask, mask & S_IRWXUGO);
-	return mask;
-}
-
-static int prctl_set_mm_exe_file(struct mm_struct *mm, unsigned int fd)
-{
-	CLASS(fd, exe)(fd);
-	struct inode *inode;
-	int err;
-
-	if (fd_empty(exe))
-		return -EBADF;
-
-	inode = file_inode(fd_file(exe));
-
-	/*
-	 * Because the original mm->exe_file points to executable file, make
-	 * sure that this one is executable as well, to avoid breaking an
-	 * overall picture.
-	 */
-	if (!S_ISREG(inode->i_mode) || path_noexec(&fd_file(exe)->f_path))
-		return -EACCES;
-
-	err = file_permission(fd_file(exe), MAY_EXEC);
-	if (err)
-		return err;
-
-	return replace_mm_exe_file(mm, fd_file(exe));
-}
-
-/*
- * Check arithmetic relations of passed addresses.
- *
- * WARNING: we don't require any capability here so be very careful
- * in what is allowed for modification from userspace.
- */
-static int validate_prctl_map_addr(struct prctl_mm_map *prctl_map)
-{
-	unsigned long mmap_max_addr = TASK_SIZE;
-	int error = -EINVAL, i;
-
-	static const unsigned char offsets[] = {
-		offsetof(struct prctl_mm_map, start_code),
-		offsetof(struct prctl_mm_map, end_code),
-		offsetof(struct prctl_mm_map, start_data),
-		offsetof(struct prctl_mm_map, end_data),
-		offsetof(struct prctl_mm_map, start_brk),
-		offsetof(struct prctl_mm_map, brk),
-		offsetof(struct prctl_mm_map, start_stack),
-		offsetof(struct prctl_mm_map, arg_start),
-		offsetof(struct prctl_mm_map, arg_end),
-		offsetof(struct prctl_mm_map, env_start),
-		offsetof(struct prctl_mm_map, env_end),
-	};
-
-	/*
-	 * Make sure the members are not somewhere outside
-	 * of allowed address space.
-	 */
-	for (i = 0; i < ARRAY_SIZE(offsets); i++) {
-		u64 val = *(u64 *)((char *)prctl_map + offsets[i]);
-
-		if ((unsigned long)val >= mmap_max_addr ||
-		    (unsigned long)val < mmap_min_addr)
-			goto out;
-	}
-
-	/*
-	 * Make sure the pairs are ordered.
-	 */
-#define __prctl_check_order(__m1, __op, __m2)				\
-	((unsigned long)prctl_map->__m1 __op				\
-	 (unsigned long)prctl_map->__m2) ? 0 : -EINVAL
-	error  = __prctl_check_order(start_code, <, end_code);
-	error |= __prctl_check_order(start_data,<=, end_data);
-	error |= __prctl_check_order(start_brk, <=, brk);
-	error |= __prctl_check_order(arg_start, <=, arg_end);
-	error |= __prctl_check_order(env_start, <=, env_end);
-	if (error)
-		goto out;
-#undef __prctl_check_order
-
-	error = -EINVAL;
-
-	/*
-	 * Neither we should allow to override limits if they set.
-	 */
-	if (check_data_rlimit(rlimit(RLIMIT_DATA), prctl_map->brk,
-			      prctl_map->start_brk, prctl_map->end_data,
-			      prctl_map->start_data))
-			goto out;
-
-	error = 0;
-out:
-	return error;
-}
-
-#ifdef CONFIG_CHECKPOINT_RESTORE
-static int prctl_set_mm_map(int opt, const void __user *addr, unsigned long data_size)
-{
-	struct prctl_mm_map prctl_map = { .exe_fd = (u32)-1, };
-	unsigned long user_auxv[AT_VECTOR_SIZE];
-	struct mm_struct *mm = current->mm;
-	int error;
-
-	BUILD_BUG_ON(sizeof(user_auxv) != sizeof(mm->saved_auxv));
-	BUILD_BUG_ON(sizeof(struct prctl_mm_map) > 256);
-
-	if (opt == PR_SET_MM_MAP_SIZE)
-		return put_user((unsigned int)sizeof(prctl_map),
-				(unsigned int __user *)addr);
-
-	if (data_size != sizeof(prctl_map))
-		return -EINVAL;
-
-	if (copy_from_user(&prctl_map, addr, sizeof(prctl_map)))
-		return -EFAULT;
-
-	error = validate_prctl_map_addr(&prctl_map);
-	if (error)
-		return error;
-
-	if (prctl_map.auxv_size) {
-		/*
-		 * Someone is trying to cheat the auxv vector.
-		 */
-		if (!prctl_map.auxv ||
-				prctl_map.auxv_size > sizeof(mm->saved_auxv))
-			return -EINVAL;
-
-		memset(user_auxv, 0, sizeof(user_auxv));
-		if (copy_from_user(user_auxv,
-				   (const void __user *)prctl_map.auxv,
-				   prctl_map.auxv_size))
-			return -EFAULT;
-
-		/* Last entry must be AT_NULL as specification requires */
-		user_auxv[AT_VECTOR_SIZE - 2] = AT_NULL;
-		user_auxv[AT_VECTOR_SIZE - 1] = AT_NULL;
-	}
-
-	if (prctl_map.exe_fd != (u32)-1) {
-		/*
-		 * Check if the current user is checkpoint/restore capable.
-		 * At the time of this writing, it checks for CAP_SYS_ADMIN
-		 * or CAP_CHECKPOINT_RESTORE.
-		 * Note that a user with access to ptrace can masquerade an
-		 * arbitrary program as any executable, even setuid ones.
-		 * This may have implications in the tomoyo subsystem.
-		 */
-		if (!checkpoint_restore_ns_capable(current_user_ns()))
-			return -EPERM;
-
-		error = prctl_set_mm_exe_file(mm, prctl_map.exe_fd);
-		if (error)
-			return error;
-	}
-
-	/*
-	 * arg_lock protects concurrent updates but we still need mmap_lock for
-	 * read to exclude races with sys_brk.
-	 */
-	mmap_read_lock(mm);
-
-	/*
-	 * We don't validate if these members are pointing to
-	 * real present VMAs because application may have correspond
-	 * VMAs already unmapped and kernel uses these members for statistics
-	 * output in procfs mostly, except
-	 *
-	 *  - @start_brk/@brk which are used in do_brk_flags but kernel lookups
-	 *    for VMAs when updating these members so anything wrong written
-	 *    here cause kernel to swear at userspace program but won't lead
-	 *    to any problem in kernel itself
-	 */
-
-	spin_lock(&mm->arg_lock);
-	mm->start_code	= prctl_map.start_code;
-	mm->end_code	= prctl_map.end_code;
-	mm->start_data	= prctl_map.start_data;
-	mm->end_data	= prctl_map.end_data;
-	mm->start_brk	= prctl_map.start_brk;
-	mm->brk		= prctl_map.brk;
-	mm->start_stack	= prctl_map.start_stack;
-	mm->arg_start	= prctl_map.arg_start;
-	mm->arg_end	= prctl_map.arg_end;
-	mm->env_start	= prctl_map.env_start;
-	mm->env_end	= prctl_map.env_end;
-	spin_unlock(&mm->arg_lock);
-
-	/*
-	 * Note this update of @saved_auxv is lockless thus
-	 * if someone reads this member in procfs while we're
-	 * updating -- it may get partly updated results. It's
-	 * known and acceptable trade off: we leave it as is to
-	 * not introduce additional locks here making the kernel
-	 * more complex.
-	 */
-	if (prctl_map.auxv_size)
-		memcpy(mm->saved_auxv, user_auxv, sizeof(user_auxv));
-
-	mmap_read_unlock(mm);
-	return 0;
-}
-#endif /* CONFIG_CHECKPOINT_RESTORE */
-
-static int prctl_set_auxv(struct mm_struct *mm, unsigned long addr,
-			  unsigned long len)
-{
-	/*
-	 * This doesn't move the auxiliary vector itself since it's pinned to
-	 * mm_struct, but it permits filling the vector with new values.  It's
-	 * up to the caller to provide sane values here, otherwise userspace
-	 * tools which use this vector might be unhappy.
-	 */
-	unsigned long user_auxv[AT_VECTOR_SIZE] = {};
-
-	if (len > sizeof(user_auxv))
-		return -EINVAL;
-
-	if (copy_from_user(user_auxv, (const void __user *)addr, len))
-		return -EFAULT;
-
-	/* Make sure the last entry is always AT_NULL */
-	user_auxv[AT_VECTOR_SIZE - 2] = 0;
-	user_auxv[AT_VECTOR_SIZE - 1] = 0;
-
-	BUILD_BUG_ON(sizeof(user_auxv) != sizeof(mm->saved_auxv));
-
-	task_lock(current);
-	memcpy(mm->saved_auxv, user_auxv, len);
-	task_unlock(current);
-
-	return 0;
-}
-
-static int prctl_set_mm(int opt, unsigned long addr,
-			unsigned long arg4, unsigned long arg5)
-{
-	struct mm_struct *mm = current->mm;
-	struct prctl_mm_map prctl_map = {
-		.auxv = NULL,
-		.auxv_size = 0,
-		.exe_fd = -1,
-	};
-	struct vm_area_struct *vma;
-	int error;
-
-	if (arg5 || (arg4 && (opt != PR_SET_MM_AUXV &&
-			      opt != PR_SET_MM_MAP &&
-			      opt != PR_SET_MM_MAP_SIZE)))
-		return -EINVAL;
-
-#ifdef CONFIG_CHECKPOINT_RESTORE
-	if (opt == PR_SET_MM_MAP || opt == PR_SET_MM_MAP_SIZE)
-		return prctl_set_mm_map(opt, (const void __user *)addr, arg4);
-#endif
-
-	if (!capable(CAP_SYS_RESOURCE))
-		return -EPERM;
-
-	if (opt == PR_SET_MM_EXE_FILE)
-		return prctl_set_mm_exe_file(mm, (unsigned int)addr);
-
-	if (opt == PR_SET_MM_AUXV)
-		return prctl_set_auxv(mm, addr, arg4);
-
-	if (addr >= TASK_SIZE || addr < mmap_min_addr)
-		return -EINVAL;
-
-	error = -EINVAL;
-
-	/*
-	 * arg_lock protects concurrent updates of arg boundaries, we need
-	 * mmap_lock for a) concurrent sys_brk, b) finding VMA for addr
-	 * validation.
-	 */
-	mmap_read_lock(mm);
-	vma = find_vma(mm, addr);
-
-	spin_lock(&mm->arg_lock);
-	prctl_map.start_code	= mm->start_code;
-	prctl_map.end_code	= mm->end_code;
-	prctl_map.start_data	= mm->start_data;
-	prctl_map.end_data	= mm->end_data;
-	prctl_map.start_brk	= mm->start_brk;
-	prctl_map.brk		= mm->brk;
-	prctl_map.start_stack	= mm->start_stack;
-	prctl_map.arg_start	= mm->arg_start;
-	prctl_map.arg_end	= mm->arg_end;
-	prctl_map.env_start	= mm->env_start;
-	prctl_map.env_end	= mm->env_end;
-
-	switch (opt) {
-	case PR_SET_MM_START_CODE:
-		prctl_map.start_code = addr;
-		break;
-	case PR_SET_MM_END_CODE:
-		prctl_map.end_code = addr;
-		break;
-	case PR_SET_MM_START_DATA:
-		prctl_map.start_data = addr;
-		break;
-	case PR_SET_MM_END_DATA:
-		prctl_map.end_data = addr;
-		break;
-	case PR_SET_MM_START_STACK:
-		prctl_map.start_stack = addr;
-		break;
-	case PR_SET_MM_START_BRK:
-		prctl_map.start_brk = addr;
-		break;
-	case PR_SET_MM_BRK:
-		prctl_map.brk = addr;
-		break;
-	case PR_SET_MM_ARG_START:
-		prctl_map.arg_start = addr;
-		break;
-	case PR_SET_MM_ARG_END:
-		prctl_map.arg_end = addr;
-		break;
-	case PR_SET_MM_ENV_START:
-		prctl_map.env_start = addr;
-		break;
-	case PR_SET_MM_ENV_END:
-		prctl_map.env_end = addr;
-		break;
-	default:
-		goto out;
-	}
-
-	error = validate_prctl_map_addr(&prctl_map);
-	if (error)
-		goto out;
-
-	switch (opt) {
-	/*
-	 * If command line arguments and environment
-	 * are placed somewhere else on stack, we can
-	 * set them up here, ARG_START/END to setup
-	 * command line arguments and ENV_START/END
-	 * for environment.
-	 */
-	case PR_SET_MM_START_STACK:
-	case PR_SET_MM_ARG_START:
-	case PR_SET_MM_ARG_END:
-	case PR_SET_MM_ENV_START:
-	case PR_SET_MM_ENV_END:
-		if (!vma) {
-			error = -EFAULT;
-			goto out;
-		}
-	}
-
-	mm->start_code	= prctl_map.start_code;
-	mm->end_code	= prctl_map.end_code;
-	mm->start_data	= prctl_map.start_data;
-	mm->end_data	= prctl_map.end_data;
-	mm->start_brk	= prctl_map.start_brk;
-	mm->brk		= prctl_map.brk;
-	mm->start_stack	= prctl_map.start_stack;
-	mm->arg_start	= prctl_map.arg_start;
-	mm->arg_end	= prctl_map.arg_end;
-	mm->env_start	= prctl_map.env_start;
-	mm->env_end	= prctl_map.env_end;
-
-	error = 0;
-out:
-	spin_unlock(&mm->arg_lock);
-	mmap_read_unlock(mm);
-	return error;
-}
-
-#ifdef CONFIG_CHECKPOINT_RESTORE
-static int prctl_get_tid_address(struct task_struct *me, int __user * __user *tid_addr)
-{
-	return put_user(me->clear_child_tid, tid_addr);
-}
-#else
-static int prctl_get_tid_address(struct task_struct *me, int __user * __user *tid_addr)
-{
-	return -EINVAL;
-}
-#endif
-
-static int propagate_has_child_subreaper(struct task_struct *p, void *data)
-{
-	/*
-	 * If task has has_child_subreaper - all its descendants
-	 * already have these flag too and new descendants will
-	 * inherit it on fork, skip them.
-	 *
-	 * If we've found child_reaper - skip descendants in
-	 * it's subtree as they will never get out pidns.
-	 */
-	if (p->signal->has_child_subreaper ||
-	    is_child_reaper(task_pid(p)))
-		return 0;
-
-	p->signal->has_child_subreaper = 1;
-	return 1;
-}
-
-int __weak arch_prctl_spec_ctrl_get(struct task_struct *t, unsigned long which)
-{
-	return -EINVAL;
-}
-
-int __weak arch_prctl_spec_ctrl_set(struct task_struct *t, unsigned long which,
-				    unsigned long ctrl)
-{
-	return -EINVAL;
-}
-
-int __weak arch_get_shadow_stack_status(struct task_struct *t, unsigned long __user *status)
-{
-	return -EINVAL;
-}
-
-int __weak arch_set_shadow_stack_status(struct task_struct *t, unsigned long status)
-{
-	return -EINVAL;
-}
-
-int __weak arch_lock_shadow_stack_status(struct task_struct *t, unsigned long status)
-{
-	return -EINVAL;
-}
-
-#define PR_IO_FLUSHER (PF_MEMALLOC_NOIO | PF_LOCAL_THROTTLE)
-
-#ifdef CONFIG_ANON_VMA_NAME
-
-#define ANON_VMA_NAME_MAX_LEN		80
-#define ANON_VMA_NAME_INVALID_CHARS	"\\`$[]"
-
-static inline bool is_valid_name_char(char ch)
-{
-	/* printable ascii characters, excluding ANON_VMA_NAME_INVALID_CHARS */
-	return ch > 0x1f && ch < 0x7f &&
-		!strchr(ANON_VMA_NAME_INVALID_CHARS, ch);
-}
-
-static int prctl_set_vma(unsigned long opt, unsigned long addr,
-			 unsigned long size, unsigned long arg)
-{
-	struct mm_struct *mm = current->mm;
-	const char __user *uname;
-	struct anon_vma_name *anon_name = NULL;
-	int error;
-
-	switch (opt) {
-	case PR_SET_VMA_ANON_NAME:
-		uname = (const char __user *)arg;
-		if (uname) {
-			char *name, *pch;
-
-			name = strndup_user(uname, ANON_VMA_NAME_MAX_LEN);
-			if (IS_ERR(name))
-				return PTR_ERR(name);
-
-			for (pch = name; *pch != '\0'; pch++) {
-				if (!is_valid_name_char(*pch)) {
-					kfree(name);
-					return -EINVAL;
-				}
-			}
-			/* anon_vma has its own copy */
-			anon_name = anon_vma_name_alloc(name);
-			kfree(name);
-			if (!anon_name)
-				return -ENOMEM;
-
-		}
-
-		mmap_write_lock(mm);
-		error = madvise_set_anon_name(mm, addr, size, anon_name);
-		mmap_write_unlock(mm);
-		anon_vma_name_put(anon_name);
-		break;
-	default:
-		error = -EINVAL;
-	}
-
-	return error;
-}
-
-#else /* CONFIG_ANON_VMA_NAME */
-static int prctl_set_vma(unsigned long opt, unsigned long start,
-			 unsigned long size, unsigned long arg)
-{
-	return -EINVAL;
-}
-#endif /* CONFIG_ANON_VMA_NAME */
-
-static inline unsigned long get_current_mdwe(void)
-{
-	unsigned long ret = 0;
-
-	if (test_bit(MMF_HAS_MDWE, &current->mm->flags))
-		ret |= PR_MDWE_REFUSE_EXEC_GAIN;
-	if (test_bit(MMF_HAS_MDWE_NO_INHERIT, &current->mm->flags))
-		ret |= PR_MDWE_NO_INHERIT;
-
-	return ret;
-}
-
-static inline int prctl_set_mdwe(unsigned long bits, unsigned long arg3,
-				 unsigned long arg4, unsigned long arg5)
-{
-	unsigned long current_bits;
-
-	if (arg3 || arg4 || arg5)
-		return -EINVAL;
-
-	if (bits & ~(PR_MDWE_REFUSE_EXEC_GAIN | PR_MDWE_NO_INHERIT))
-		return -EINVAL;
-
-	/* NO_INHERIT only makes sense with REFUSE_EXEC_GAIN */
-	if (bits & PR_MDWE_NO_INHERIT && !(bits & PR_MDWE_REFUSE_EXEC_GAIN))
-		return -EINVAL;
-
-	/*
-	 * EOPNOTSUPP might be more appropriate here in principle, but
-	 * existing userspace depends on EINVAL specifically.
-	 */
-	if (!arch_memory_deny_write_exec_supported())
-		return -EINVAL;
-
-	current_bits = get_current_mdwe();
-	if (current_bits && current_bits != bits)
-		return -EPERM; /* Cannot unset the flags */
-
-	if (bits & PR_MDWE_NO_INHERIT)
-		set_bit(MMF_HAS_MDWE_NO_INHERIT, &current->mm->flags);
-	if (bits & PR_MDWE_REFUSE_EXEC_GAIN)
-		set_bit(MMF_HAS_MDWE, &current->mm->flags);
-
-	return 0;
-}
-
-static inline int prctl_get_mdwe(unsigned long arg2, unsigned long arg3,
-				 unsigned long arg4, unsigned long arg5)
-{
-	if (arg2 || arg3 || arg4 || arg5)
-		return -EINVAL;
-	return get_current_mdwe();
-}
-
-static int prctl_get_auxv(void __user *addr, unsigned long len)
-{
-	struct mm_struct *mm = current->mm;
-	unsigned long size = min_t(unsigned long, sizeof(mm->saved_auxv), len);
-
-	if (size && copy_to_user(addr, mm->saved_auxv, size))
-		return -EFAULT;
-	return sizeof(mm->saved_auxv);
-}
-
-SYSCALL_DEFINE5(prctl, int, option, unsigned long, arg2, unsigned long, arg3,
-		unsigned long, arg4, unsigned long, arg5)
-{
-	struct task_struct *me = current;
-	unsigned char comm[sizeof(me->comm)];
-	long error;
-
-	error = security_task_prctl(option, arg2, arg3, arg4, arg5);
-	if (error != -ENOSYS)
-		return error;
-
-	error = 0;
-	switch (option) {
-	case PR_SET_PDEATHSIG:
-		if (!valid_signal(arg2)) {
-			error = -EINVAL;
-			break;
-		}
-		me->pdeath_signal = arg2;
-		break;
-	case PR_GET_PDEATHSIG:
-		error = put_user(me->pdeath_signal, (int __user *)arg2);
-		break;
-	case PR_GET_DUMPABLE:
-		error = get_dumpable(me->mm);
-		break;
-	case PR_SET_DUMPABLE:
-		if (arg2 != SUID_DUMP_DISABLE && arg2 != SUID_DUMP_USER) {
-			error = -EINVAL;
-			break;
-		}
-		set_dumpable(me->mm, arg2);
-		break;
-
-	case PR_SET_UNALIGN:
-		error = SET_UNALIGN_CTL(me, arg2);
-		break;
-	case PR_GET_UNALIGN:
-		error = GET_UNALIGN_CTL(me, arg2);
-		break;
-	case PR_SET_FPEMU:
-		error = SET_FPEMU_CTL(me, arg2);
-		break;
-	case PR_GET_FPEMU:
-		error = GET_FPEMU_CTL(me, arg2);
-		break;
-	case PR_SET_FPEXC:
-		error = SET_FPEXC_CTL(me, arg2);
-		break;
-	case PR_GET_FPEXC:
-		error = GET_FPEXC_CTL(me, arg2);
-		break;
-	case PR_GET_TIMING:
-		error = PR_TIMING_STATISTICAL;
-		break;
-	case PR_SET_TIMING:
-		if (arg2 != PR_TIMING_STATISTICAL)
-			error = -EINVAL;
-		break;
-	case PR_SET_NAME:
-		comm[sizeof(me->comm) - 1] = 0;
-		if (strncpy_from_user(comm, (char __user *)arg2,
-				      sizeof(me->comm) - 1) < 0)
-			return -EFAULT;
-		set_task_comm(me, comm);
-		proc_comm_connector(me);
-		break;
-	case PR_GET_NAME:
-		get_task_comm(comm, me);
-		if (copy_to_user((char __user *)arg2, comm, sizeof(comm)))
-			return -EFAULT;
-		break;
-	case PR_GET_ENDIAN:
-		error = GET_ENDIAN(me, arg2);
-		break;
-	case PR_SET_ENDIAN:
-		error = SET_ENDIAN(me, arg2);
-		break;
-	case PR_GET_SECCOMP:
-		error = prctl_get_seccomp();
-		break;
-	case PR_SET_SECCOMP:
-		error = prctl_set_seccomp(arg2, (char __user *)arg3);
-		break;
-	case PR_GET_TSC:
-		error = GET_TSC_CTL(arg2);
-		break;
-	case PR_SET_TSC:
-		error = SET_TSC_CTL(arg2);
-		break;
-	case PR_TASK_PERF_EVENTS_DISABLE:
-		error = perf_event_task_disable();
-		break;
-	case PR_TASK_PERF_EVENTS_ENABLE:
-		error = perf_event_task_enable();
-		break;
-	case PR_GET_TIMERSLACK:
-		if (current->timer_slack_ns > ULONG_MAX)
-			error = ULONG_MAX;
-		else
-			error = current->timer_slack_ns;
-		break;
-	case PR_SET_TIMERSLACK:
-		if (rt_or_dl_task_policy(current))
-			break;
-		if (arg2 <= 0)
-			current->timer_slack_ns =
-					current->default_timer_slack_ns;
-		else
-			current->timer_slack_ns = arg2;
-		break;
-	case PR_MCE_KILL:
-		if (arg4 | arg5)
-			return -EINVAL;
-		switch (arg2) {
-		case PR_MCE_KILL_CLEAR:
-			if (arg3 != 0)
-				return -EINVAL;
-			current->flags &= ~PF_MCE_PROCESS;
-			break;
-		case PR_MCE_KILL_SET:
-			current->flags |= PF_MCE_PROCESS;
-			if (arg3 == PR_MCE_KILL_EARLY)
-				current->flags |= PF_MCE_EARLY;
-			else if (arg3 == PR_MCE_KILL_LATE)
-				current->flags &= ~PF_MCE_EARLY;
-			else if (arg3 == PR_MCE_KILL_DEFAULT)
-				current->flags &=
-						~(PF_MCE_EARLY|PF_MCE_PROCESS);
-			else
-				return -EINVAL;
-			break;
-		default:
-			return -EINVAL;
-		}
-		break;
-	case PR_MCE_KILL_GET:
-		if (arg2 | arg3 | arg4 | arg5)
-			return -EINVAL;
-		if (current->flags & PF_MCE_PROCESS)
-			error = (current->flags & PF_MCE_EARLY) ?
-				PR_MCE_KILL_EARLY : PR_MCE_KILL_LATE;
-		else
-			error = PR_MCE_KILL_DEFAULT;
-		break;
-	case PR_SET_MM:
-		error = prctl_set_mm(arg2, arg3, arg4, arg5);
-		break;
-	case PR_GET_TID_ADDRESS:
-		error = prctl_get_tid_address(me, (int __user * __user *)arg2);
-		break;
-	case PR_SET_CHILD_SUBREAPER:
-		me->signal->is_child_subreaper = !!arg2;
-		if (!arg2)
-			break;
-
-		walk_process_tree(me, propagate_has_child_subreaper, NULL);
-		break;
-	case PR_GET_CHILD_SUBREAPER:
-		error = put_user(me->signal->is_child_subreaper,
-				 (int __user *)arg2);
-		break;
-	case PR_SET_NO_NEW_PRIVS:
-		if (arg2 != 1 || arg3 || arg4 || arg5)
-			return -EINVAL;
-
-		task_set_no_new_privs(current);
-		break;
-	case PR_GET_NO_NEW_PRIVS:
-		if (arg2 || arg3 || arg4 || arg5)
-			return -EINVAL;
-		return task_no_new_privs(current) ? 1 : 0;
-	case PR_GET_THP_DISABLE:
-		if (arg2 || arg3 || arg4 || arg5)
-			return -EINVAL;
-		error = !!test_bit(MMF_DISABLE_THP, &me->mm->flags);
-		break;
-	case PR_SET_THP_DISABLE:
-		if (arg3 || arg4 || arg5)
-			return -EINVAL;
-		if (mmap_write_lock_killable(me->mm))
-			return -EINTR;
-		if (arg2)
-			set_bit(MMF_DISABLE_THP, &me->mm->flags);
-		else
-			clear_bit(MMF_DISABLE_THP, &me->mm->flags);
-		mmap_write_unlock(me->mm);
-		break;
-	case PR_MPX_ENABLE_MANAGEMENT:
-	case PR_MPX_DISABLE_MANAGEMENT:
-		/* No longer implemented: */
-		return -EINVAL;
-	case PR_SET_FP_MODE:
-		error = SET_FP_MODE(me, arg2);
-		break;
-	case PR_GET_FP_MODE:
-		error = GET_FP_MODE(me);
-		break;
-	case PR_SVE_SET_VL:
-		error = SVE_SET_VL(arg2);
-		break;
-	case PR_SVE_GET_VL:
-		error = SVE_GET_VL();
-		break;
-	case PR_SME_SET_VL:
-		error = SME_SET_VL(arg2);
-		break;
-	case PR_SME_GET_VL:
-		error = SME_GET_VL();
-		break;
-	case PR_GET_SPECULATION_CTRL:
-		if (arg3 || arg4 || arg5)
-			return -EINVAL;
-		error = arch_prctl_spec_ctrl_get(me, arg2);
-		break;
-	case PR_SET_SPECULATION_CTRL:
-		if (arg4 || arg5)
-			return -EINVAL;
-		error = arch_prctl_spec_ctrl_set(me, arg2, arg3);
-		break;
-	case PR_PAC_RESET_KEYS:
-		if (arg3 || arg4 || arg5)
-			return -EINVAL;
-		error = PAC_RESET_KEYS(me, arg2);
-		break;
-	case PR_PAC_SET_ENABLED_KEYS:
-		if (arg4 || arg5)
-			return -EINVAL;
-		error = PAC_SET_ENABLED_KEYS(me, arg2, arg3);
-		break;
-	case PR_PAC_GET_ENABLED_KEYS:
-		if (arg2 || arg3 || arg4 || arg5)
-			return -EINVAL;
-		error = PAC_GET_ENABLED_KEYS(me);
-		break;
-	case PR_SET_TAGGED_ADDR_CTRL:
-		if (arg3 || arg4 || arg5)
-			return -EINVAL;
-		error = SET_TAGGED_ADDR_CTRL(arg2);
-		break;
-	case PR_GET_TAGGED_ADDR_CTRL:
-		if (arg2 || arg3 || arg4 || arg5)
-			return -EINVAL;
-		error = GET_TAGGED_ADDR_CTRL();
-		break;
-	case PR_SET_IO_FLUSHER:
-		if (!capable(CAP_SYS_RESOURCE))
-			return -EPERM;
-
-		if (arg3 || arg4 || arg5)
-			return -EINVAL;
-
-		if (arg2 == 1)
-			current->flags |= PR_IO_FLUSHER;
-		else if (!arg2)
-			current->flags &= ~PR_IO_FLUSHER;
-		else
-			return -EINVAL;
-		break;
-	case PR_GET_IO_FLUSHER:
-		if (!capable(CAP_SYS_RESOURCE))
-			return -EPERM;
-
-		if (arg2 || arg3 || arg4 || arg5)
-			return -EINVAL;
-
-		error = (current->flags & PR_IO_FLUSHER) == PR_IO_FLUSHER;
-		break;
-	case PR_SET_SYSCALL_USER_DISPATCH:
-		error = set_syscall_user_dispatch(arg2, arg3, arg4,
-						  (char __user *) arg5);
-		break;
-#ifdef CONFIG_SCHED_CORE
-	case PR_SCHED_CORE:
-		error = sched_core_share_pid(arg2, arg3, arg4, arg5);
-		break;
-#endif
-	case PR_SET_MDWE:
-		error = prctl_set_mdwe(arg2, arg3, arg4, arg5);
-		break;
-	case PR_GET_MDWE:
-		error = prctl_get_mdwe(arg2, arg3, arg4, arg5);
-		break;
-	case PR_PPC_GET_DEXCR:
-		if (arg3 || arg4 || arg5)
-			return -EINVAL;
-		error = PPC_GET_DEXCR_ASPECT(me, arg2);
-		break;
-	case PR_PPC_SET_DEXCR:
-		if (arg4 || arg5)
-			return -EINVAL;
-		error = PPC_SET_DEXCR_ASPECT(me, arg2, arg3);
-		break;
-	case PR_SET_VMA:
-		error = prctl_set_vma(arg2, arg3, arg4, arg5);
-		break;
-	case PR_GET_AUXV:
-		if (arg4 || arg5)
-			return -EINVAL;
-		error = prctl_get_auxv((void __user *)arg2, arg3);
-		break;
-#ifdef CONFIG_KSM
-	case PR_SET_MEMORY_MERGE:
-		if (arg3 || arg4 || arg5)
-			return -EINVAL;
-		if (mmap_write_lock_killable(me->mm))
-			return -EINTR;
-
-		if (arg2)
-			error = ksm_enable_merge_any(me->mm);
-		else
-			error = ksm_disable_merge_any(me->mm);
-		mmap_write_unlock(me->mm);
-		break;
-	case PR_GET_MEMORY_MERGE:
-		if (arg2 || arg3 || arg4 || arg5)
-			return -EINVAL;
-
-		error = !!test_bit(MMF_VM_MERGE_ANY, &me->mm->flags);
-		break;
-#endif
-	case PR_RISCV_V_SET_CONTROL:
-		error = RISCV_V_SET_CONTROL(arg2);
-		break;
-	case PR_RISCV_V_GET_CONTROL:
-		error = RISCV_V_GET_CONTROL();
-		break;
-	case PR_RISCV_SET_ICACHE_FLUSH_CTX:
-		error = RISCV_SET_ICACHE_FLUSH_CTX(arg2, arg3);
-		break;
-	case PR_GET_SHADOW_STACK_STATUS:
-		if (arg3 || arg4 || arg5)
-			return -EINVAL;
-		error = arch_get_shadow_stack_status(me, (unsigned long __user *) arg2);
-		break;
-	case PR_SET_SHADOW_STACK_STATUS:
-		if (arg3 || arg4 || arg5)
-			return -EINVAL;
-		error = arch_set_shadow_stack_status(me, arg2);
-		break;
-	case PR_LOCK_SHADOW_STACK_STATUS:
-		if (arg3 || arg4 || arg5)
-			return -EINVAL;
-		error = arch_lock_shadow_stack_status(me, arg2);
-		break;
-	case PR_TIMER_CREATE_RESTORE_IDS:
-		if (arg3 || arg4 || arg5)
-			return -EINVAL;
-		error = posixtimer_create_prctl(arg2);
-		break;
-	case PR_FUTEX_HASH:
-		error = futex_hash_prctl(arg2, arg3, arg4);
-		break;
-	default:
-		trace_task_prctl_unknown(option, arg2, arg3, arg4, arg5);
-		error = -EINVAL;
-		break;
-	}
-	return error;
-}
-
-SYSCALL_DEFINE3(getcpu, unsigned __user *, cpup, unsigned __user *, nodep,
-		struct getcpu_cache __user *, unused)
-{
-	int err = 0;
-	int cpu = raw_smp_processor_id();
-
-	if (cpup)
-		err |= put_user(cpu, cpup);
-	if (nodep)
-		err |= put_user(cpu_to_node(cpu), nodep);
-	return err ? -EFAULT : 0;
-}
-
-/**
- * do_sysinfo - fill in sysinfo struct
- * @info: pointer to buffer to fill
- */
-static int do_sysinfo(struct sysinfo *info)
-{
-	unsigned long mem_total, sav_total;
-	unsigned int mem_unit, bitcount;
-	struct timespec64 tp;
-
-	memset(info, 0, sizeof(struct sysinfo));
-
-	ktime_get_boottime_ts64(&tp);
-	timens_add_boottime(&tp);
-	info->uptime = tp.tv_sec + (tp.tv_nsec ? 1 : 0);
-
-	get_avenrun(info->loads, 0, SI_LOAD_SHIFT - FSHIFT);
-
-	info->procs = nr_threads;
-
-	si_meminfo(info);
-	si_swapinfo(info);
-
-	/*
-	 * If the sum of all the available memory (i.e. ram + swap)
-	 * is less than can be stored in a 32 bit unsigned long then
-	 * we can be binary compatible with 2.2.x kernels.  If not,
-	 * well, in that case 2.2.x was broken anyways...
-	 *
-	 *  -Erik Andersen <andersee@debian.org>
-	 */
-
-	mem_total = info->totalram + info->totalswap;
-	if (mem_total < info->totalram || mem_total < info->totalswap)
-		goto out;
-	bitcount = 0;
-	mem_unit = info->mem_unit;
-	while (mem_unit > 1) {
-		bitcount++;
-		mem_unit >>= 1;
-		sav_total = mem_total;
-		mem_total <<= 1;
-		if (mem_total < sav_total)
-			goto out;
-	}
-
-	/*
-	 * If mem_total did not overflow, multiply all memory values by
-	 * info->mem_unit and set it to 1.  This leaves things compatible
-	 * with 2.2.x, and also retains compatibility with earlier 2.4.x
-	 * kernels...
-	 */
-
-	info->mem_unit = 1;
-	info->totalram <<= bitcount;
-	info->freeram <<= bitcount;
-	info->sharedram <<= bitcount;
-	info->bufferram <<= bitcount;
-	info->totalswap <<= bitcount;
-	info->freeswap <<= bitcount;
-	info->totalhigh <<= bitcount;
-	info->freehigh <<= bitcount;
-
-out:
-	return 0;
-}
-
-SYSCALL_DEFINE1(sysinfo, struct sysinfo __user *, info)
-{
-	struct sysinfo val;
-
-	do_sysinfo(&val);
-
-	if (copy_to_user(info, &val, sizeof(struct sysinfo)))
-		return -EFAULT;
-
-	return 0;
-}
-
-#ifdef CONFIG_COMPAT
-struct compat_sysinfo {
-	s32 uptime;
-	u32 loads[3];
-	u32 totalram;
-	u32 freeram;
-	u32 sharedram;
-	u32 bufferram;
-	u32 totalswap;
-	u32 freeswap;
-	u16 procs;
-	u16 pad;
-	u32 totalhigh;
-	u32 freehigh;
-	u32 mem_unit;
-	char _f[20-2*sizeof(u32)-sizeof(int)];
-};
-
-COMPAT_SYSCALL_DEFINE1(sysinfo, struct compat_sysinfo __user *, info)
-{
-	struct sysinfo s;
-	struct compat_sysinfo s_32;
-
-	do_sysinfo(&s);
-
-	/* Check to see if any memory value is too large for 32-bit and scale
-	 *  down if needed
-	 */
-	if (upper_32_bits(s.totalram) || upper_32_bits(s.totalswap)) {
-		int bitcount = 0;
-
-		while (s.mem_unit < PAGE_SIZE) {
-			s.mem_unit <<= 1;
-			bitcount++;
-		}
-
-		s.totalram >>= bitcount;
-		s.freeram >>= bitcount;
-		s.sharedram >>= bitcount;
-		s.bufferram >>= bitcount;
-		s.totalswap >>= bitcount;
-		s.freeswap >>= bitcount;
-		s.totalhigh >>= bitcount;
-		s.freehigh >>= bitcount;
-	}
-
-	memset(&s_32, 0, sizeof(s_32));
-	s_32.uptime = s.uptime;
-	s_32.loads[0] = s.loads[0];
-	s_32.loads[1] = s.loads[1];
-	s_32.loads[2] = s.loads[2];
-	s_32.totalram = s.totalram;
-	s_32.freeram = s.freeram;
-	s_32.sharedram = s.sharedram;
-	s_32.bufferram = s.bufferram;
-	s_32.totalswap = s.totalswap;
-	s_32.freeswap = s.freeswap;
-	s_32.procs = s.procs;
-	s_32.totalhigh = s.totalhigh;
-	s_32.freehigh = s.freehigh;
-	s_32.mem_unit = s.mem_unit;
-	if (copy_to_user(info, &s_32, sizeof(s_32)))
-		return -EFAULT;
-	return 0;
-}
-#endif /* CONFIG_COMPAT */
diff -Nrup linux-6.16.7/Makefile linux-lenovo-x13s-linux-6.16.y/Makefile
--- linux-6.16.7/Makefile	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/Makefile	2025-09-11 09:47:42.000000000 -0600
@@ -1,7 +1,7 @@
 # SPDX-License-Identifier: GPL-2.0
 VERSION = 6
 PATCHLEVEL = 16
-SUBLEVEL = 7
+SUBLEVEL = 6
 EXTRAVERSION =
 NAME = Baby Opossum Posse
 
diff -Nrup linux-6.16.7/mm/Kconfig linux-lenovo-x13s-linux-6.16.y/mm/Kconfig
--- linux-6.16.7/mm/Kconfig	2025-09-13 16:15:46.057484155 -0600
+++ linux-lenovo-x13s-linux-6.16.y/mm/Kconfig	2025-09-11 09:47:42.000000000 -0600
@@ -753,8 +753,6 @@ config KSM
 config DEFAULT_MMAP_MIN_ADDR
 	int "Low address space to protect from user allocation"
 	depends on MMU
-	default 65536 if ( X86_64 || X86_32 || PPC64 || IA64 ) && GENTOO_KERNEL_SELF_PROTECTION
-	default 32768 if ( ARM64 || ARM ) && GENTOO_KERNEL_SELF_PROTECTION
 	default 4096
 	help
 	  This is the portion of low virtual memory which should be protected
diff -Nrup linux-6.16.7/mm/Kconfig.orig linux-lenovo-x13s-linux-6.16.y/mm/Kconfig.orig
--- linux-6.16.7/mm/Kconfig.orig	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/mm/Kconfig.orig	1969-12-31 17:00:00.000000000 -0700
@@ -1,1387 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0-only
-
-menu "Memory Management options"
-
-#
-# For some reason microblaze and nios2 hard code SWAP=n.  Hopefully we can
-# add proper SWAP support to them, in which case this can be remove.
-#
-config ARCH_NO_SWAP
-	bool
-
-config ZPOOL
-	bool
-
-menuconfig SWAP
-	bool "Support for paging of anonymous memory (swap)"
-	depends on MMU && BLOCK && !ARCH_NO_SWAP
-	default y
-	help
-	  This option allows you to choose whether you want to have support
-	  for so called swap devices or swap files in your kernel that are
-	  used to provide more virtual memory than the actual RAM present
-	  in your computer.  If unsure say Y.
-
-config ZSWAP
-	bool "Compressed cache for swap pages"
-	depends on SWAP
-	select CRYPTO
-	select ZPOOL
-	help
-	  A lightweight compressed cache for swap pages.  It takes
-	  pages that are in the process of being swapped out and attempts to
-	  compress them into a dynamically allocated RAM-based memory pool.
-	  This can result in a significant I/O reduction on swap device and,
-	  in the case where decompressing from RAM is faster than swap device
-	  reads, can also improve workload performance.
-
-config ZSWAP_DEFAULT_ON
-	bool "Enable the compressed cache for swap pages by default"
-	depends on ZSWAP
-	help
-	  If selected, the compressed cache for swap pages will be enabled
-	  at boot, otherwise it will be disabled.
-
-	  The selection made here can be overridden by using the kernel
-	  command line 'zswap.enabled=' option.
-
-config ZSWAP_SHRINKER_DEFAULT_ON
-	bool "Shrink the zswap pool on memory pressure"
-	depends on ZSWAP
-	default n
-	help
-	  If selected, the zswap shrinker will be enabled, and the pages
-	  stored in the zswap pool will become available for reclaim (i.e
-	  written back to the backing swap device) on memory pressure.
-
-	  This means that zswap writeback could happen even if the pool is
-	  not yet full, or the cgroup zswap limit has not been reached,
-	  reducing the chance that cold pages will reside in the zswap pool
-	  and consume memory indefinitely.
-
-choice
-	prompt "Default compressor"
-	depends on ZSWAP
-	default ZSWAP_COMPRESSOR_DEFAULT_LZO
-	help
-	  Selects the default compression algorithm for the compressed cache
-	  for swap pages.
-
-	  For an overview what kind of performance can be expected from
-	  a particular compression algorithm please refer to the benchmarks
-	  available at the following LWN page:
-	  https://lwn.net/Articles/751795/
-
-	  If in doubt, select 'LZO'.
-
-	  The selection made here can be overridden by using the kernel
-	  command line 'zswap.compressor=' option.
-
-config ZSWAP_COMPRESSOR_DEFAULT_DEFLATE
-	bool "Deflate"
-	select CRYPTO_DEFLATE
-	help
-	  Use the Deflate algorithm as the default compression algorithm.
-
-config ZSWAP_COMPRESSOR_DEFAULT_LZO
-	bool "LZO"
-	select CRYPTO_LZO
-	help
-	  Use the LZO algorithm as the default compression algorithm.
-
-config ZSWAP_COMPRESSOR_DEFAULT_842
-	bool "842"
-	select CRYPTO_842
-	help
-	  Use the 842 algorithm as the default compression algorithm.
-
-config ZSWAP_COMPRESSOR_DEFAULT_LZ4
-	bool "LZ4"
-	select CRYPTO_LZ4
-	help
-	  Use the LZ4 algorithm as the default compression algorithm.
-
-config ZSWAP_COMPRESSOR_DEFAULT_LZ4HC
-	bool "LZ4HC"
-	select CRYPTO_LZ4HC
-	help
-	  Use the LZ4HC algorithm as the default compression algorithm.
-
-config ZSWAP_COMPRESSOR_DEFAULT_ZSTD
-	bool "zstd"
-	select CRYPTO_ZSTD
-	help
-	  Use the zstd algorithm as the default compression algorithm.
-endchoice
-
-config ZSWAP_COMPRESSOR_DEFAULT
-       string
-       depends on ZSWAP
-       default "deflate" if ZSWAP_COMPRESSOR_DEFAULT_DEFLATE
-       default "lzo" if ZSWAP_COMPRESSOR_DEFAULT_LZO
-       default "842" if ZSWAP_COMPRESSOR_DEFAULT_842
-       default "lz4" if ZSWAP_COMPRESSOR_DEFAULT_LZ4
-       default "lz4hc" if ZSWAP_COMPRESSOR_DEFAULT_LZ4HC
-       default "zstd" if ZSWAP_COMPRESSOR_DEFAULT_ZSTD
-       default ""
-
-choice
-	prompt "Default allocator"
-	depends on ZSWAP
-	default ZSWAP_ZPOOL_DEFAULT_ZSMALLOC if MMU
-	help
-	  Selects the default allocator for the compressed cache for
-	  swap pages.
-	  The default is 'zbud' for compatibility, however please do
-	  read the description of each of the allocators below before
-	  making a right choice.
-
-	  The selection made here can be overridden by using the kernel
-	  command line 'zswap.zpool=' option.
-
-config ZSWAP_ZPOOL_DEFAULT_ZSMALLOC
-	bool "zsmalloc"
-	select ZSMALLOC
-	help
-	  Use the zsmalloc allocator as the default allocator.
-endchoice
-
-config ZSWAP_ZPOOL_DEFAULT
-       string
-       depends on ZSWAP
-       default "zsmalloc" if ZSWAP_ZPOOL_DEFAULT_ZSMALLOC
-       default ""
-
-config ZSMALLOC
-	tristate
-	prompt "N:1 compression allocator (zsmalloc)" if (ZSWAP || ZRAM)
-	depends on MMU
-	help
-	  zsmalloc is a slab-based memory allocator designed to store
-	  pages of various compression levels efficiently. It achieves
-	  the highest storage density with the least amount of fragmentation.
-
-config ZSMALLOC_STAT
-	bool "Export zsmalloc statistics"
-	depends on ZSMALLOC
-	select DEBUG_FS
-	help
-	  This option enables code in the zsmalloc to collect various
-	  statistics about what's happening in zsmalloc and exports that
-	  information to userspace via debugfs.
-	  If unsure, say N.
-
-config ZSMALLOC_CHAIN_SIZE
-	int "Maximum number of physical pages per-zspage"
-	default 8
-	range 4 16
-	depends on ZSMALLOC
-	help
-	  This option sets the upper limit on the number of physical pages
-	  that a zmalloc page (zspage) can consist of. The optimal zspage
-	  chain size is calculated for each size class during the
-	  initialization of the pool.
-
-	  Changing this option can alter the characteristics of size classes,
-	  such as the number of pages per zspage and the number of objects
-	  per zspage. This can also result in different configurations of
-	  the pool, as zsmalloc merges size classes with similar
-	  characteristics.
-
-	  For more information, see zsmalloc documentation.
-
-menu "Slab allocator options"
-
-config SLUB
-	def_bool y
-
-config KVFREE_RCU_BATCHED
-	def_bool y
-	depends on !SLUB_TINY && !TINY_RCU
-
-config SLUB_TINY
-	bool "Configure for minimal memory footprint"
-	depends on EXPERT && !COMPILE_TEST
-	select SLAB_MERGE_DEFAULT
-	help
-	   Configures the slab allocator in a way to achieve minimal memory
-	   footprint, sacrificing scalability, debugging and other features.
-	   This is intended only for the smallest system that had used the
-	   SLOB allocator and is not recommended for systems with more than
-	   16MB RAM.
-
-	   If unsure, say N.
-
-config SLAB_MERGE_DEFAULT
-	bool "Allow slab caches to be merged"
-	default y
-	help
-	  For reduced kernel memory fragmentation, slab caches can be
-	  merged when they share the same size and other characteristics.
-	  This carries a risk of kernel heap overflows being able to
-	  overwrite objects from merged caches (and more easily control
-	  cache layout), which makes such heap attacks easier to exploit
-	  by attackers. By keeping caches unmerged, these kinds of exploits
-	  can usually only damage objects in the same cache. To disable
-	  merging at runtime, "slab_nomerge" can be passed on the kernel
-	  command line.
-
-config SLAB_FREELIST_RANDOM
-	bool "Randomize slab freelist"
-	depends on !SLUB_TINY
-	help
-	  Randomizes the freelist order used on creating new pages. This
-	  security feature reduces the predictability of the kernel slab
-	  allocator against heap overflows.
-
-config SLAB_FREELIST_HARDENED
-	bool "Harden slab freelist metadata"
-	depends on !SLUB_TINY
-	help
-	  Many kernel heap attacks try to target slab cache metadata and
-	  other infrastructure. This options makes minor performance
-	  sacrifices to harden the kernel slab allocator against common
-	  freelist exploit methods.
-
-config SLAB_BUCKETS
-	bool "Support allocation from separate kmalloc buckets"
-	depends on !SLUB_TINY
-	default SLAB_FREELIST_HARDENED
-	help
-	  Kernel heap attacks frequently depend on being able to create
-	  specifically-sized allocations with user-controlled contents
-	  that will be allocated into the same kmalloc bucket as a
-	  target object. To avoid sharing these allocation buckets,
-	  provide an explicitly separated set of buckets to be used for
-	  user-controlled allocations. This may very slightly increase
-	  memory fragmentation, though in practice it's only a handful
-	  of extra pages since the bulk of user-controlled allocations
-	  are relatively long-lived.
-
-	  If unsure, say Y.
-
-config SLUB_STATS
-	default n
-	bool "Enable performance statistics"
-	depends on SYSFS && !SLUB_TINY
-	help
-	  The statistics are useful to debug slab allocation behavior in
-	  order find ways to optimize the allocator. This should never be
-	  enabled for production use since keeping statistics slows down
-	  the allocator by a few percentage points. The slabinfo command
-	  supports the determination of the most active slabs to figure
-	  out which slabs are relevant to a particular load.
-	  Try running: slabinfo -DA
-
-config SLUB_CPU_PARTIAL
-	default y
-	depends on SMP && !SLUB_TINY
-	bool "Enable per cpu partial caches"
-	help
-	  Per cpu partial caches accelerate objects allocation and freeing
-	  that is local to a processor at the price of more indeterminism
-	  in the latency of the free. On overflow these caches will be cleared
-	  which requires the taking of locks that may cause latency spikes.
-	  Typically one would choose no for a realtime system.
-
-config RANDOM_KMALLOC_CACHES
-	default n
-	depends on !SLUB_TINY
-	bool "Randomize slab caches for normal kmalloc"
-	help
-	  A hardening feature that creates multiple copies of slab caches for
-	  normal kmalloc allocation and makes kmalloc randomly pick one based
-	  on code address, which makes the attackers more difficult to spray
-	  vulnerable memory objects on the heap for the purpose of exploiting
-	  memory vulnerabilities.
-
-	  Currently the number of copies is set to 16, a reasonably large value
-	  that effectively diverges the memory objects allocated for different
-	  subsystems or modules into different caches, at the expense of a
-	  limited degree of memory and CPU overhead that relates to hardware and
-	  system workload.
-
-endmenu # Slab allocator options
-
-config SHUFFLE_PAGE_ALLOCATOR
-	bool "Page allocator randomization"
-	default SLAB_FREELIST_RANDOM && ACPI_NUMA
-	help
-	  Randomization of the page allocator improves the average
-	  utilization of a direct-mapped memory-side-cache. See section
-	  5.2.27 Heterogeneous Memory Attribute Table (HMAT) in the ACPI
-	  6.2a specification for an example of how a platform advertises
-	  the presence of a memory-side-cache. There are also incidental
-	  security benefits as it reduces the predictability of page
-	  allocations to compliment SLAB_FREELIST_RANDOM, but the
-	  default granularity of shuffling on the MAX_PAGE_ORDER i.e, 10th
-	  order of pages is selected based on cache utilization benefits
-	  on x86.
-
-	  While the randomization improves cache utilization it may
-	  negatively impact workloads on platforms without a cache. For
-	  this reason, by default, the randomization is not enabled even
-	  if SHUFFLE_PAGE_ALLOCATOR=y. The randomization may be force enabled
-	  with the 'page_alloc.shuffle' kernel command line parameter.
-
-	  Say Y if unsure.
-
-config COMPAT_BRK
-	bool "Disable heap randomization"
-	default y
-	help
-	  Randomizing heap placement makes heap exploits harder, but it
-	  also breaks ancient binaries (including anything libc5 based).
-	  This option changes the bootup default to heap randomization
-	  disabled, and can be overridden at runtime by setting
-	  /proc/sys/kernel/randomize_va_space to 2.
-
-	  On non-ancient distros (post-2000 ones) N is usually a safe choice.
-
-config MMAP_ALLOW_UNINITIALIZED
-	bool "Allow mmapped anonymous memory to be uninitialized"
-	depends on EXPERT && !MMU
-	default n
-	help
-	  Normally, and according to the Linux spec, anonymous memory obtained
-	  from mmap() has its contents cleared before it is passed to
-	  userspace.  Enabling this config option allows you to request that
-	  mmap() skip that if it is given an MAP_UNINITIALIZED flag, thus
-	  providing a huge performance boost.  If this option is not enabled,
-	  then the flag will be ignored.
-
-	  This is taken advantage of by uClibc's malloc(), and also by
-	  ELF-FDPIC binfmt's brk and stack allocator.
-
-	  Because of the obvious security issues, this option should only be
-	  enabled on embedded devices where you control what is run in
-	  userspace.  Since that isn't generally a problem on no-MMU systems,
-	  it is normally safe to say Y here.
-
-	  See Documentation/admin-guide/mm/nommu-mmap.rst for more information.
-
-config SELECT_MEMORY_MODEL
-	def_bool y
-	depends on ARCH_SELECT_MEMORY_MODEL
-
-choice
-	prompt "Memory model"
-	depends on SELECT_MEMORY_MODEL
-	default SPARSEMEM_MANUAL if ARCH_SPARSEMEM_DEFAULT
-	default FLATMEM_MANUAL
-	help
-	  This option allows you to change some of the ways that
-	  Linux manages its memory internally. Most users will
-	  only have one option here selected by the architecture
-	  configuration. This is normal.
-
-config FLATMEM_MANUAL
-	bool "Flat Memory"
-	depends on !ARCH_SPARSEMEM_ENABLE || ARCH_FLATMEM_ENABLE
-	help
-	  This option is best suited for non-NUMA systems with
-	  flat address space. The FLATMEM is the most efficient
-	  system in terms of performance and resource consumption
-	  and it is the best option for smaller systems.
-
-	  For systems that have holes in their physical address
-	  spaces and for features like NUMA and memory hotplug,
-	  choose "Sparse Memory".
-
-	  If unsure, choose this option (Flat Memory) over any other.
-
-config SPARSEMEM_MANUAL
-	bool "Sparse Memory"
-	depends on ARCH_SPARSEMEM_ENABLE
-	help
-	  This will be the only option for some systems, including
-	  memory hot-plug systems.  This is normal.
-
-	  This option provides efficient support for systems with
-	  holes is their physical address space and allows memory
-	  hot-plug and hot-remove.
-
-	  If unsure, choose "Flat Memory" over this option.
-
-endchoice
-
-config SPARSEMEM
-	def_bool y
-	depends on (!SELECT_MEMORY_MODEL && ARCH_SPARSEMEM_ENABLE) || SPARSEMEM_MANUAL
-
-config FLATMEM
-	def_bool y
-	depends on !SPARSEMEM || FLATMEM_MANUAL
-
-#
-# SPARSEMEM_EXTREME (which is the default) does some bootmem
-# allocations when sparse_init() is called.  If this cannot
-# be done on your architecture, select this option.  However,
-# statically allocating the mem_section[] array can potentially
-# consume vast quantities of .bss, so be careful.
-#
-# This option will also potentially produce smaller runtime code
-# with gcc 3.4 and later.
-#
-config SPARSEMEM_STATIC
-	bool
-
-#
-# Architecture platforms which require a two level mem_section in SPARSEMEM
-# must select this option. This is usually for architecture platforms with
-# an extremely sparse physical address space.
-#
-config SPARSEMEM_EXTREME
-	def_bool y
-	depends on SPARSEMEM && !SPARSEMEM_STATIC
-
-config SPARSEMEM_VMEMMAP_ENABLE
-	bool
-
-config SPARSEMEM_VMEMMAP
-	bool "Sparse Memory virtual memmap"
-	depends on SPARSEMEM && SPARSEMEM_VMEMMAP_ENABLE
-	default y
-	help
-	  SPARSEMEM_VMEMMAP uses a virtually mapped memmap to optimise
-	  pfn_to_page and page_to_pfn operations.  This is the most
-	  efficient option when sufficient kernel resources are available.
-
-config SPARSEMEM_VMEMMAP_PREINIT
-	bool
-#
-# Select this config option from the architecture Kconfig, if it is preferred
-# to enable the feature of HugeTLB/dev_dax vmemmap optimization.
-#
-config ARCH_WANT_OPTIMIZE_DAX_VMEMMAP
-	bool
-
-config ARCH_WANT_OPTIMIZE_HUGETLB_VMEMMAP
-	bool
-
-config ARCH_WANT_HUGETLB_VMEMMAP_PREINIT
-	bool
-
-config HAVE_MEMBLOCK_PHYS_MAP
-	bool
-
-config HAVE_GUP_FAST
-	depends on MMU
-	bool
-
-# Enable memblock support for scratch memory which is needed for kexec handover
-config MEMBLOCK_KHO_SCRATCH
-	bool
-
-# Don't discard allocated memory used to track "memory" and "reserved" memblocks
-# after early boot, so it can still be used to test for validity of memory.
-# Also, memblocks are updated with memory hot(un)plug.
-config ARCH_KEEP_MEMBLOCK
-	bool
-
-# Keep arch NUMA mapping infrastructure post-init.
-config NUMA_KEEP_MEMINFO
-	bool
-
-config MEMORY_ISOLATION
-	bool
-
-# IORESOURCE_SYSTEM_RAM regions in the kernel resource tree that are marked
-# IORESOURCE_EXCLUSIVE cannot be mapped to user space, for example, via
-# /dev/mem.
-config EXCLUSIVE_SYSTEM_RAM
-	def_bool y
-	depends on !DEVMEM || STRICT_DEVMEM
-
-#
-# Only be set on architectures that have completely implemented memory hotplug
-# feature. If you are not sure, don't touch it.
-#
-config HAVE_BOOTMEM_INFO_NODE
-	def_bool n
-
-config ARCH_ENABLE_MEMORY_HOTPLUG
-	bool
-
-config ARCH_ENABLE_MEMORY_HOTREMOVE
-	bool
-
-# eventually, we can have this option just 'select SPARSEMEM'
-menuconfig MEMORY_HOTPLUG
-	bool "Memory hotplug"
-	select MEMORY_ISOLATION
-	depends on SPARSEMEM
-	depends on ARCH_ENABLE_MEMORY_HOTPLUG
-	depends on 64BIT
-	select NUMA_KEEP_MEMINFO if NUMA
-
-if MEMORY_HOTPLUG
-
-choice
-	prompt "Memory Hotplug Default Online Type"
-	default MHP_DEFAULT_ONLINE_TYPE_OFFLINE
-	help
-	  Default memory type for hotplugged memory.
-
-	  This option sets the default policy setting for memory hotplug
-	  onlining policy (/sys/devices/system/memory/auto_online_blocks) which
-	  determines what happens to newly added memory regions. Policy setting
-	  can always be changed at runtime.
-
-	  The default is 'offline'.
-
-	  Select offline to defer onlining to drivers and user policy.
-	  Select auto to let the kernel choose what zones to utilize.
-	  Select online_kernel to generally allow kernel usage of this memory.
-	  Select online_movable to generally disallow kernel usage of this memory.
-
-	  Example kernel usage would be page structs and page tables.
-
-	  See Documentation/admin-guide/mm/memory-hotplug.rst for more information.
-
-config MHP_DEFAULT_ONLINE_TYPE_OFFLINE
-	bool "offline"
-	help
-	  Hotplugged memory will not be onlined by default.
-	  Choose this for systems with drivers and user policy that
-	  handle onlining of hotplug memory policy.
-
-config MHP_DEFAULT_ONLINE_TYPE_ONLINE_AUTO
-	bool "auto"
-	help
-	  Select this if you want the kernel to automatically online
-	  hotplugged memory into the zone it thinks is reasonable.
-	  This memory may be utilized for kernel data.
-
-config MHP_DEFAULT_ONLINE_TYPE_ONLINE_KERNEL
-	bool "kernel"
-	help
-	  Select this if you want the kernel to automatically online
-	  hotplugged memory into a zone capable of being used for kernel
-	  data. This typically means ZONE_NORMAL.
-
-config MHP_DEFAULT_ONLINE_TYPE_ONLINE_MOVABLE
-	bool "movable"
-	help
-	  Select this if you want the kernel to automatically online
-	  hotplug memory into ZONE_MOVABLE. This memory will generally
-	  not be utilized for kernel data.
-
-	  This should only be used when the admin knows sufficient
-	  ZONE_NORMAL memory is available to describe hotplug memory,
-	  otherwise hotplug memory may fail to online. For example,
-	  sufficient kernel-capable memory (ZONE_NORMAL) must be
-	  available to allocate page structs to describe ZONE_MOVABLE.
-
-endchoice
-
-config MEMORY_HOTREMOVE
-	bool "Allow for memory hot remove"
-	select HAVE_BOOTMEM_INFO_NODE if (X86_64 || PPC64)
-	depends on MEMORY_HOTPLUG && ARCH_ENABLE_MEMORY_HOTREMOVE
-	depends on MIGRATION
-
-config MHP_MEMMAP_ON_MEMORY
-	def_bool y
-	depends on MEMORY_HOTPLUG && SPARSEMEM_VMEMMAP
-	depends on ARCH_MHP_MEMMAP_ON_MEMORY_ENABLE
-
-endif # MEMORY_HOTPLUG
-
-config ARCH_MHP_MEMMAP_ON_MEMORY_ENABLE
-       bool
-
-# Heavily threaded applications may benefit from splitting the mm-wide
-# page_table_lock, so that faults on different parts of the user address
-# space can be handled with less contention: split it at this NR_CPUS.
-# Default to 4 for wider testing, though 8 might be more appropriate.
-# ARM's adjust_pte (unused if VIPT) depends on mm-wide page_table_lock.
-# PA-RISC 7xxx's spinlock_t would enlarge struct page from 32 to 44 bytes.
-# SPARC32 allocates multiple pte tables within a single page, and therefore
-# a per-page lock leads to problems when multiple tables need to be locked
-# at the same time (e.g. copy_page_range()).
-# DEBUG_SPINLOCK and DEBUG_LOCK_ALLOC spinlock_t also enlarge struct page.
-#
-config SPLIT_PTE_PTLOCKS
-	def_bool y
-	depends on MMU
-	depends on SMP
-	depends on NR_CPUS >= 4
-	depends on !ARM || CPU_CACHE_VIPT
-	depends on !PARISC || PA20
-	depends on !SPARC32
-
-config ARCH_ENABLE_SPLIT_PMD_PTLOCK
-	bool
-
-config SPLIT_PMD_PTLOCKS
-	def_bool y
-	depends on SPLIT_PTE_PTLOCKS && ARCH_ENABLE_SPLIT_PMD_PTLOCK
-
-#
-# support for memory balloon
-config MEMORY_BALLOON
-	bool
-
-#
-# support for memory balloon compaction
-config BALLOON_COMPACTION
-	bool "Allow for balloon memory compaction/migration"
-	default y
-	depends on COMPACTION && MEMORY_BALLOON
-	help
-	  Memory fragmentation introduced by ballooning might reduce
-	  significantly the number of 2MB contiguous memory blocks that can be
-	  used within a guest, thus imposing performance penalties associated
-	  with the reduced number of transparent huge pages that could be used
-	  by the guest workload. Allowing the compaction & migration for memory
-	  pages enlisted as being part of memory balloon devices avoids the
-	  scenario aforementioned and helps improving memory defragmentation.
-
-#
-# support for memory compaction
-config COMPACTION
-	bool "Allow for memory compaction"
-	default y
-	select MIGRATION
-	depends on MMU
-	help
-	  Compaction is the only memory management component to form
-	  high order (larger physically contiguous) memory blocks
-	  reliably. The page allocator relies on compaction heavily and
-	  the lack of the feature can lead to unexpected OOM killer
-	  invocations for high order memory requests. You shouldn't
-	  disable this option unless there really is a strong reason for
-	  it and then we would be really interested to hear about that at
-	  linux-mm@kvack.org.
-
-config COMPACT_UNEVICTABLE_DEFAULT
-	int
-	depends on COMPACTION
-	default 0 if PREEMPT_RT
-	default 1
-
-#
-# support for free page reporting
-config PAGE_REPORTING
-	bool "Free page reporting"
-	help
-	  Free page reporting allows for the incremental acquisition of
-	  free pages from the buddy allocator for the purpose of reporting
-	  those pages to another entity, such as a hypervisor, so that the
-	  memory can be freed within the host for other uses.
-
-#
-# support for page migration
-#
-config MIGRATION
-	bool "Page migration"
-	default y
-	depends on (NUMA || ARCH_ENABLE_MEMORY_HOTREMOVE || COMPACTION || CMA) && MMU
-	help
-	  Allows the migration of the physical location of pages of processes
-	  while the virtual addresses are not changed. This is useful in
-	  two situations. The first is on NUMA systems to put pages nearer
-	  to the processors accessing. The second is when allocating huge
-	  pages as migration can relocate pages to satisfy a huge page
-	  allocation instead of reclaiming.
-
-config DEVICE_MIGRATION
-	def_bool MIGRATION && ZONE_DEVICE
-
-config ARCH_ENABLE_HUGEPAGE_MIGRATION
-	bool
-
-config ARCH_ENABLE_THP_MIGRATION
-	bool
-
-config HUGETLB_PAGE_SIZE_VARIABLE
-	def_bool n
-	help
-	  Allows the pageblock_order value to be dynamic instead of just standard
-	  HUGETLB_PAGE_ORDER when there are multiple HugeTLB page sizes available
-	  on a platform.
-
-	  Note that the pageblock_order cannot exceed MAX_PAGE_ORDER and will be
-	  clamped down to MAX_PAGE_ORDER.
-
-config CONTIG_ALLOC
-	def_bool (MEMORY_ISOLATION && COMPACTION) || CMA
-
-config PCP_BATCH_SCALE_MAX
-	int "Maximum scale factor of PCP (Per-CPU pageset) batch allocate/free"
-	default 5
-	range 0 6
-	help
-	  In page allocator, PCP (Per-CPU pageset) is refilled and drained in
-	  batches.  The batch number is scaled automatically to improve page
-	  allocation/free throughput.  But too large scale factor may hurt
-	  latency.  This option sets the upper limit of scale factor to limit
-	  the maximum latency.
-
-config PHYS_ADDR_T_64BIT
-	def_bool 64BIT
-
-config BOUNCE
-	bool "Enable bounce buffers"
-	default y
-	depends on BLOCK && MMU && HIGHMEM
-	help
-	  Enable bounce buffers for devices that cannot access the full range of
-	  memory available to the CPU. Enabled by default when HIGHMEM is
-	  selected, but you may say n to override this.
-
-config MMU_NOTIFIER
-	bool
-	select INTERVAL_TREE
-
-config KSM
-	bool "Enable KSM for page merging"
-	depends on MMU
-	select XXHASH
-	help
-	  Enable Kernel Samepage Merging: KSM periodically scans those areas
-	  of an application's address space that an app has advised may be
-	  mergeable.  When it finds pages of identical content, it replaces
-	  the many instances by a single page with that content, so
-	  saving memory until one or another app needs to modify the content.
-	  Recommended for use with KVM, or with other duplicative applications.
-	  See Documentation/mm/ksm.rst for more information: KSM is inactive
-	  until a program has madvised that an area is MADV_MERGEABLE, and
-	  root has set /sys/kernel/mm/ksm/run to 1 (if CONFIG_SYSFS is set).
-
-config DEFAULT_MMAP_MIN_ADDR
-	int "Low address space to protect from user allocation"
-	depends on MMU
-	default 4096
-	help
-	  This is the portion of low virtual memory which should be protected
-	  from userspace allocation.  Keeping a user from writing to low pages
-	  can help reduce the impact of kernel NULL pointer bugs.
-
-	  For most arm64, ppc64 and x86 users with lots of address space
-	  a value of 65536 is reasonable and should cause no problems.
-	  On arm and other archs it should not be higher than 32768.
-	  Programs which use vm86 functionality or have some need to map
-	  this low address space will need CAP_SYS_RAWIO or disable this
-	  protection by setting the value to 0.
-
-	  This value can be changed after boot using the
-	  /proc/sys/vm/mmap_min_addr tunable.
-
-config ARCH_SUPPORTS_MEMORY_FAILURE
-	bool
-
-config MEMORY_FAILURE
-	depends on MMU
-	depends on ARCH_SUPPORTS_MEMORY_FAILURE
-	bool "Enable recovery from hardware memory errors"
-	select MEMORY_ISOLATION
-	select RAS
-	help
-	  Enables code to recover from some memory failures on systems
-	  with MCA recovery. This allows a system to continue running
-	  even when some of its memory has uncorrected errors. This requires
-	  special hardware support and typically ECC memory.
-
-config HWPOISON_INJECT
-	tristate "HWPoison pages injector"
-	depends on MEMORY_FAILURE && DEBUG_KERNEL && PROC_FS
-	select PROC_PAGE_MONITOR
-
-config NOMMU_INITIAL_TRIM_EXCESS
-	int "Turn on mmap() excess space trimming before booting"
-	depends on !MMU
-	default 1
-	help
-	  The NOMMU mmap() frequently needs to allocate large contiguous chunks
-	  of memory on which to store mappings, but it can only ask the system
-	  allocator for chunks in 2^N*PAGE_SIZE amounts - which is frequently
-	  more than it requires.  To deal with this, mmap() is able to trim off
-	  the excess and return it to the allocator.
-
-	  If trimming is enabled, the excess is trimmed off and returned to the
-	  system allocator, which can cause extra fragmentation, particularly
-	  if there are a lot of transient processes.
-
-	  If trimming is disabled, the excess is kept, but not used, which for
-	  long-term mappings means that the space is wasted.
-
-	  Trimming can be dynamically controlled through a sysctl option
-	  (/proc/sys/vm/nr_trim_pages) which specifies the minimum number of
-	  excess pages there must be before trimming should occur, or zero if
-	  no trimming is to occur.
-
-	  This option specifies the initial value of this option.  The default
-	  of 1 says that all excess pages should be trimmed.
-
-	  See Documentation/admin-guide/mm/nommu-mmap.rst for more information.
-
-config ARCH_WANT_GENERAL_HUGETLB
-	bool
-
-config ARCH_WANTS_THP_SWAP
-	def_bool n
-
-config MM_ID
-	def_bool n
-
-menuconfig TRANSPARENT_HUGEPAGE
-	bool "Transparent Hugepage Support"
-	depends on HAVE_ARCH_TRANSPARENT_HUGEPAGE && !PREEMPT_RT
-	select COMPACTION
-	select XARRAY_MULTI
-	select MM_ID
-	help
-	  Transparent Hugepages allows the kernel to use huge pages and
-	  huge tlb transparently to the applications whenever possible.
-	  This feature can improve computing performance to certain
-	  applications by speeding up page faults during memory
-	  allocation, by reducing the number of tlb misses and by speeding
-	  up the pagetable walking.
-
-	  If memory constrained on embedded, you may want to say N.
-
-if TRANSPARENT_HUGEPAGE
-
-choice
-	prompt "Transparent Hugepage Support sysfs defaults"
-	depends on TRANSPARENT_HUGEPAGE
-	default TRANSPARENT_HUGEPAGE_ALWAYS
-	help
-	  Selects the sysfs defaults for Transparent Hugepage Support.
-
-	config TRANSPARENT_HUGEPAGE_ALWAYS
-		bool "always"
-	help
-	  Enabling Transparent Hugepage always, can increase the
-	  memory footprint of applications without a guaranteed
-	  benefit but it will work automatically for all applications.
-
-	config TRANSPARENT_HUGEPAGE_MADVISE
-		bool "madvise"
-	help
-	  Enabling Transparent Hugepage madvise, will only provide a
-	  performance improvement benefit to the applications using
-	  madvise(MADV_HUGEPAGE) but it won't risk to increase the
-	  memory footprint of applications without a guaranteed
-	  benefit.
-
-	config TRANSPARENT_HUGEPAGE_NEVER
-		bool "never"
-	help
-	  Disable Transparent Hugepage by default. It can still be
-	  enabled at runtime via sysfs.
-endchoice
-
-config THP_SWAP
-	def_bool y
-	depends on TRANSPARENT_HUGEPAGE && ARCH_WANTS_THP_SWAP && SWAP && 64BIT
-	help
-	  Swap transparent huge pages in one piece, without splitting.
-	  XXX: For now, swap cluster backing transparent huge page
-	  will be split after swapout.
-
-	  For selection by architectures with reasonable THP sizes.
-
-config READ_ONLY_THP_FOR_FS
-	bool "Read-only THP for filesystems (EXPERIMENTAL)"
-	depends on TRANSPARENT_HUGEPAGE
-
-	help
-	  Allow khugepaged to put read-only file-backed pages in THP.
-
-	  This is marked experimental because it is a new feature. Write
-	  support of file THPs will be developed in the next few release
-	  cycles.
-
-config NO_PAGE_MAPCOUNT
-	bool "No per-page mapcount (EXPERIMENTAL)"
-	help
-	  Do not maintain per-page mapcounts for pages part of larger
-	  allocations, such as transparent huge pages.
-
-	  When this config option is enabled, some interfaces that relied on
-	  this information will rely on less-precise per-allocation information
-	  instead: for example, using the average per-page mapcount in such
-	  a large allocation instead of the per-page mapcount.
-
-	  EXPERIMENTAL because the impact of some changes is still unclear.
-
-endif # TRANSPARENT_HUGEPAGE
-
-# simple helper to make the code a bit easier to read
-config PAGE_MAPCOUNT
-	def_bool !NO_PAGE_MAPCOUNT
-
-#
-# The architecture supports pgtable leaves that is larger than PAGE_SIZE
-#
-config PGTABLE_HAS_HUGE_LEAVES
-	def_bool TRANSPARENT_HUGEPAGE || HUGETLB_PAGE
-
-# TODO: Allow to be enabled without THP
-config ARCH_SUPPORTS_HUGE_PFNMAP
-	def_bool n
-	depends on TRANSPARENT_HUGEPAGE
-
-config ARCH_SUPPORTS_PMD_PFNMAP
-	def_bool y
-	depends on ARCH_SUPPORTS_HUGE_PFNMAP && HAVE_ARCH_TRANSPARENT_HUGEPAGE
-
-config ARCH_SUPPORTS_PUD_PFNMAP
-	def_bool y
-	depends on ARCH_SUPPORTS_HUGE_PFNMAP && HAVE_ARCH_TRANSPARENT_HUGEPAGE_PUD
-
-#
-# UP and nommu archs use km based percpu allocator
-#
-config NEED_PER_CPU_KM
-	depends on !SMP || !MMU
-	bool
-	default y
-
-config NEED_PER_CPU_EMBED_FIRST_CHUNK
-	bool
-
-config NEED_PER_CPU_PAGE_FIRST_CHUNK
-	bool
-
-config USE_PERCPU_NUMA_NODE_ID
-	bool
-
-config HAVE_SETUP_PER_CPU_AREA
-	bool
-
-config CMA
-	bool "Contiguous Memory Allocator"
-	depends on MMU
-	select MIGRATION
-	select MEMORY_ISOLATION
-	help
-	  This enables the Contiguous Memory Allocator which allows other
-	  subsystems to allocate big physically-contiguous blocks of memory.
-	  CMA reserves a region of memory and allows only movable pages to
-	  be allocated from it. This way, the kernel can use the memory for
-	  pagecache and when a subsystem requests for contiguous area, the
-	  allocated pages are migrated away to serve the contiguous request.
-
-	  If unsure, say "n".
-
-config CMA_DEBUGFS
-	bool "CMA debugfs interface"
-	depends on CMA && DEBUG_FS
-	help
-	  Turns on the DebugFS interface for CMA.
-
-config CMA_SYSFS
-	bool "CMA information through sysfs interface"
-	depends on CMA && SYSFS
-	help
-	  This option exposes some sysfs attributes to get information
-	  from CMA.
-
-config CMA_AREAS
-	int "Maximum count of the CMA areas"
-	depends on CMA
-	default 20 if NUMA
-	default 8
-	help
-	  CMA allows to create CMA areas for particular purpose, mainly,
-	  used as device private area. This parameter sets the maximum
-	  number of CMA area in the system.
-
-	  If unsure, leave the default value "8" in UMA and "20" in NUMA.
-
-#
-# Select this config option from the architecture Kconfig, if available, to set
-# the max page order for physically contiguous allocations.
-#
-config ARCH_FORCE_MAX_ORDER
-	int
-
-#
-# When ARCH_FORCE_MAX_ORDER is not defined,
-# the default page block order is MAX_PAGE_ORDER (10) as per
-# include/linux/mmzone.h.
-#
-config PAGE_BLOCK_ORDER
-	int "Page Block Order"
-	range 1 10 if ARCH_FORCE_MAX_ORDER = 0
-	default 10 if ARCH_FORCE_MAX_ORDER = 0
-	range 1 ARCH_FORCE_MAX_ORDER if ARCH_FORCE_MAX_ORDER != 0
-	default ARCH_FORCE_MAX_ORDER if ARCH_FORCE_MAX_ORDER != 0
-	help
-	  The page block order refers to the power of two number of pages that
-	  are physically contiguous and can have a migrate type associated to
-	  them. The maximum size of the page block order is limited by
-	  ARCH_FORCE_MAX_ORDER.
-
-	  This config allows overriding the default page block order when the
-	  page block order is required to be smaller than ARCH_FORCE_MAX_ORDER
-	  or MAX_PAGE_ORDER.
-
-	  Reducing pageblock order can negatively impact THP generation
-	  success rate. If your workloads uses THP heavily, please use this
-	  option with caution.
-
-	  Don't change if unsure.
-
-config MEM_SOFT_DIRTY
-	bool "Track memory changes"
-	depends on CHECKPOINT_RESTORE && HAVE_ARCH_SOFT_DIRTY && PROC_FS
-	select PROC_PAGE_MONITOR
-	help
-	  This option enables memory changes tracking by introducing a
-	  soft-dirty bit on pte-s. This bit it set when someone writes
-	  into a page just as regular dirty bit, but unlike the latter
-	  it can be cleared by hands.
-
-	  See Documentation/admin-guide/mm/soft-dirty.rst for more details.
-
-config GENERIC_EARLY_IOREMAP
-	bool
-
-config STACK_MAX_DEFAULT_SIZE_MB
-	int "Default maximum user stack size for 32-bit processes (MB)"
-	default 100
-	range 8 2048
-	depends on STACK_GROWSUP && (!64BIT || COMPAT)
-	help
-	  This is the maximum stack size in Megabytes in the VM layout of 32-bit
-	  user processes when the stack grows upwards (currently only on parisc
-	  arch) when the RLIMIT_STACK hard limit is unlimited.
-
-	  A sane initial value is 100 MB.
-
-config DEFERRED_STRUCT_PAGE_INIT
-	bool "Defer initialisation of struct pages to kthreads"
-	depends on SPARSEMEM
-	depends on !NEED_PER_CPU_KM
-	depends on 64BIT
-	depends on !KMSAN
-	select PADATA
-	help
-	  Ordinarily all struct pages are initialised during early boot in a
-	  single thread. On very large machines this can take a considerable
-	  amount of time. If this option is set, large machines will bring up
-	  a subset of memmap at boot and then initialise the rest in parallel.
-	  This has a potential performance impact on tasks running early in the
-	  lifetime of the system until these kthreads finish the
-	  initialisation.
-
-config PAGE_IDLE_FLAG
-	bool
-	select PAGE_EXTENSION if !64BIT
-	help
-	  This adds PG_idle and PG_young flags to 'struct page'.  PTE Accessed
-	  bit writers can set the state of the bit in the flags so that PTE
-	  Accessed bit readers may avoid disturbance.
-
-config IDLE_PAGE_TRACKING
-	bool "Enable idle page tracking"
-	depends on SYSFS && MMU
-	select PAGE_IDLE_FLAG
-	help
-	  This feature allows to estimate the amount of user pages that have
-	  not been touched during a given period of time. This information can
-	  be useful to tune memory cgroup limits and/or for job placement
-	  within a compute cluster.
-
-	  See Documentation/admin-guide/mm/idle_page_tracking.rst for
-	  more details.
-
-# Architectures which implement cpu_dcache_is_aliasing() to query
-# whether the data caches are aliased (VIVT or VIPT with dcache
-# aliasing) need to select this.
-config ARCH_HAS_CPU_CACHE_ALIASING
-	bool
-
-config ARCH_HAS_CACHE_LINE_SIZE
-	bool
-
-config ARCH_HAS_CURRENT_STACK_POINTER
-	bool
-	help
-	  In support of HARDENED_USERCOPY performing stack variable lifetime
-	  checking, an architecture-agnostic way to find the stack pointer
-	  is needed. Once an architecture defines an unsigned long global
-	  register alias named "current_stack_pointer", this config can be
-	  selected.
-
-config ARCH_HAS_PTE_DEVMAP
-	bool
-
-config ARCH_HAS_ZONE_DMA_SET
-	bool
-
-config ZONE_DMA
-	bool "Support DMA zone" if ARCH_HAS_ZONE_DMA_SET
-	default y if ARM64 || X86
-
-config ZONE_DMA32
-	bool "Support DMA32 zone" if ARCH_HAS_ZONE_DMA_SET
-	depends on !X86_32
-	default y if ARM64
-
-config ZONE_DEVICE
-	bool "Device memory (pmem, HMM, etc...) hotplug support"
-	depends on MEMORY_HOTPLUG
-	depends on MEMORY_HOTREMOVE
-	depends on SPARSEMEM_VMEMMAP
-	depends on ARCH_HAS_PTE_DEVMAP
-	select XARRAY_MULTI
-
-	help
-	  Device memory hotplug support allows for establishing pmem,
-	  or other device driver discovered memory regions, in the
-	  memmap. This allows pfn_to_page() lookups of otherwise
-	  "device-physical" addresses which is needed for using a DAX
-	  mapping in an O_DIRECT operation, among other things.
-
-	  If FS_DAX is enabled, then say Y.
-
-#
-# Helpers to mirror range of the CPU page tables of a process into device page
-# tables.
-#
-config HMM_MIRROR
-	bool
-	depends on MMU
-
-config GET_FREE_REGION
-	bool
-
-config DEVICE_PRIVATE
-	bool "Unaddressable device memory (GPU memory, ...)"
-	depends on ZONE_DEVICE
-	select GET_FREE_REGION
-
-	help
-	  Allows creation of struct pages to represent unaddressable device
-	  memory; i.e., memory that is only accessible from the device (or
-	  group of devices). You likely also want to select HMM_MIRROR.
-
-config VMAP_PFN
-	bool
-
-config ARCH_USES_HIGH_VMA_FLAGS
-	bool
-config ARCH_HAS_PKEYS
-	bool
-
-config ARCH_USES_PG_ARCH_2
-	bool
-config ARCH_USES_PG_ARCH_3
-	bool
-
-config VM_EVENT_COUNTERS
-	default y
-	bool "Enable VM event counters for /proc/vmstat" if EXPERT
-	help
-	  VM event counters are needed for event counts to be shown.
-	  This option allows the disabling of the VM event counters
-	  on EXPERT systems.  /proc/vmstat will only show page counts
-	  if VM event counters are disabled.
-
-config PERCPU_STATS
-	bool "Collect percpu memory statistics"
-	help
-	  This feature collects and exposes statistics via debugfs. The
-	  information includes global and per chunk statistics, which can
-	  be used to help understand percpu memory usage.
-
-config GUP_TEST
-	bool "Enable infrastructure for get_user_pages()-related unit tests"
-	depends on DEBUG_FS
-	help
-	  Provides /sys/kernel/debug/gup_test, which in turn provides a way
-	  to make ioctl calls that can launch kernel-based unit tests for
-	  the get_user_pages*() and pin_user_pages*() family of API calls.
-
-	  These tests include benchmark testing of the _fast variants of
-	  get_user_pages*() and pin_user_pages*(), as well as smoke tests of
-	  the non-_fast variants.
-
-	  There is also a sub-test that allows running dump_page() on any
-	  of up to eight pages (selected by command line args) within the
-	  range of user-space addresses. These pages are either pinned via
-	  pin_user_pages*(), or pinned via get_user_pages*(), as specified
-	  by other command line arguments.
-
-	  See tools/testing/selftests/mm/gup_test.c
-
-comment "GUP_TEST needs to have DEBUG_FS enabled"
-	depends on !GUP_TEST && !DEBUG_FS
-
-config GUP_GET_PXX_LOW_HIGH
-	bool
-
-config DMAPOOL_TEST
-	tristate "Enable a module to run time tests on dma_pool"
-	depends on HAS_DMA
-	help
-	  Provides a test module that will allocate and free many blocks of
-	  various sizes and report how long it takes. This is intended to
-	  provide a consistent way to measure how changes to the
-	  dma_pool_alloc/free routines affect performance.
-
-config ARCH_HAS_PTE_SPECIAL
-	bool
-
-config MAPPING_DIRTY_HELPERS
-        bool
-
-config KMAP_LOCAL
-	bool
-
-config KMAP_LOCAL_NON_LINEAR_PTE_ARRAY
-	bool
-
-# struct io_mapping based helper.  Selected by drivers that need them
-config IO_MAPPING
-	bool
-
-config MEMFD_CREATE
-	bool "Enable memfd_create() system call" if EXPERT
-
-config SECRETMEM
-	default y
-	bool "Enable memfd_secret() system call" if EXPERT
-	depends on ARCH_HAS_SET_DIRECT_MAP
-	help
-	  Enable the memfd_secret() system call with the ability to create
-	  memory areas visible only in the context of the owning process and
-	  not mapped to other processes and other kernel page tables.
-
-config ANON_VMA_NAME
-	bool "Anonymous VMA name support"
-	depends on PROC_FS && ADVISE_SYSCALLS && MMU
-
-	help
-	  Allow naming anonymous virtual memory areas.
-
-	  This feature allows assigning names to virtual memory areas. Assigned
-	  names can be later retrieved from /proc/pid/maps and /proc/pid/smaps
-	  and help identifying individual anonymous memory areas.
-	  Assigning a name to anonymous virtual memory area might prevent that
-	  area from being merged with adjacent virtual memory areas due to the
-	  difference in their name.
-
-config HAVE_ARCH_USERFAULTFD_WP
-	bool
-	help
-	  Arch has userfaultfd write protection support
-
-config HAVE_ARCH_USERFAULTFD_MINOR
-	bool
-	help
-	  Arch has userfaultfd minor fault support
-
-menuconfig USERFAULTFD
-	bool "Enable userfaultfd() system call"
-	depends on MMU
-	help
-	  Enable the userfaultfd() system call that allows to intercept and
-	  handle page faults in userland.
-
-if USERFAULTFD
-config PTE_MARKER_UFFD_WP
-	bool "Userfaultfd write protection support for shmem/hugetlbfs"
-	default y
-	depends on HAVE_ARCH_USERFAULTFD_WP
-
-	help
-	  Allows to create marker PTEs for userfaultfd write protection
-	  purposes.  It is required to enable userfaultfd write protection on
-	  file-backed memory types like shmem and hugetlbfs.
-endif # USERFAULTFD
-
-# multi-gen LRU {
-config LRU_GEN
-	bool "Multi-Gen LRU"
-	depends on MMU
-	# make sure folio->flags has enough spare bits
-	depends on 64BIT || !SPARSEMEM || SPARSEMEM_VMEMMAP
-	help
-	  A high performance LRU implementation to overcommit memory. See
-	  Documentation/admin-guide/mm/multigen_lru.rst for details.
-
-config LRU_GEN_ENABLED
-	bool "Enable by default"
-	depends on LRU_GEN
-	help
-	  This option enables the multi-gen LRU by default.
-
-config LRU_GEN_STATS
-	bool "Full stats for debugging"
-	depends on LRU_GEN
-	help
-	  Do not enable this option unless you plan to look at historical stats
-	  from evicted generations for debugging purpose.
-
-	  This option has a per-memcg and per-node memory overhead.
-
-config LRU_GEN_WALKS_MMU
-	def_bool y
-	depends on LRU_GEN && ARCH_HAS_HW_PTE_YOUNG
-# }
-
-config ARCH_SUPPORTS_PER_VMA_LOCK
-       def_bool n
-
-config PER_VMA_LOCK
-	def_bool y
-	depends on ARCH_SUPPORTS_PER_VMA_LOCK && MMU && SMP
-	help
-	  Allow per-vma locking during page fault handling.
-
-	  This feature allows locking each virtual memory area separately when
-	  handling page faults instead of taking mmap_lock.
-
-config LOCK_MM_AND_FIND_VMA
-	bool
-	depends on !STACK_GROWSUP
-
-config IOMMU_MM_DATA
-	bool
-
-config EXECMEM
-	bool
-
-config NUMA_MEMBLKS
-	bool
-
-config NUMA_EMU
-	bool "NUMA emulation"
-	depends on NUMA_MEMBLKS
-	depends on X86 || GENERIC_ARCH_NUMA
-	help
-	  Enable NUMA emulation. A flat machine will be split
-	  into virtual nodes when booted with "numa=fake=N", where N is the
-	  number of nodes. This is only useful for debugging.
-
-config ARCH_HAS_USER_SHADOW_STACK
-	bool
-	help
-	  The architecture has hardware support for userspace shadow call
-          stacks (eg, x86 CET, arm64 GCS or RISC-V Zicfiss).
-
-config ARCH_SUPPORTS_PT_RECLAIM
-	def_bool n
-
-config PT_RECLAIM
-	bool "reclaim empty user page table pages"
-	default y
-	depends on ARCH_SUPPORTS_PT_RECLAIM && MMU && SMP
-	select MMU_GATHER_RCU_TABLE_FREE
-	help
-	  Try to reclaim empty user page table pages in paths other than munmap
-	  and exit_mmap path.
-
-	  Note: now only empty user PTE page table pages will be reclaimed.
-
-
-source "mm/damon/Kconfig"
-
-endmenu
diff -Nrup linux-6.16.7/net/bluetooth/hci_conn.c linux-lenovo-x13s-linux-6.16.y/net/bluetooth/hci_conn.c
--- linux-6.16.7/net/bluetooth/hci_conn.c	2025-09-13 16:15:43.485173815 -0600
+++ linux-lenovo-x13s-linux-6.16.y/net/bluetooth/hci_conn.c	2025-09-11 09:47:42.000000000 -0600
@@ -2366,13 +2366,8 @@ int hci_conn_check_link_mode(struct hci_
 		return 0;
 	}
 
-	/* If Secure Simple Pairing is not enabled, then legacy connection
-	 * setup is used and no encryption or key sizes can be enforced.
-	 */
-	if (!hci_conn_ssp_enabled(conn))
-		return 1;
-
-	if (!test_bit(HCI_CONN_ENCRYPT, &conn->flags))
+	if (hci_conn_ssp_enabled(conn) &&
+	    !test_bit(HCI_CONN_ENCRYPT, &conn->flags))
 		return 0;
 
 	return 1;
diff -Nrup linux-6.16.7/net/bluetooth/hci_conn.c.orig linux-lenovo-x13s-linux-6.16.y/net/bluetooth/hci_conn.c.orig
--- linux-6.16.7/net/bluetooth/hci_conn.c.orig	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/net/bluetooth/hci_conn.c.orig	1969-12-31 17:00:00.000000000 -0700
@@ -1,3139 +0,0 @@
-/*
-   BlueZ - Bluetooth protocol stack for Linux
-   Copyright (c) 2000-2001, 2010, Code Aurora Forum. All rights reserved.
-   Copyright 2023-2024 NXP
-
-   Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License version 2 as
-   published by the Free Software Foundation;
-
-   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
-   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.
-   IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) AND AUTHOR(S) BE LIABLE FOR ANY
-   CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES
-   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
-   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
-   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-
-   ALL LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PATENTS,
-   COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS
-   SOFTWARE IS DISCLAIMED.
-*/
-
-/* Bluetooth HCI connection handling. */
-
-#include <linux/export.h>
-#include <linux/debugfs.h>
-#include <linux/errqueue.h>
-
-#include <net/bluetooth/bluetooth.h>
-#include <net/bluetooth/hci_core.h>
-#include <net/bluetooth/l2cap.h>
-#include <net/bluetooth/iso.h>
-#include <net/bluetooth/mgmt.h>
-
-#include "smp.h"
-#include "eir.h"
-
-struct sco_param {
-	u16 pkt_type;
-	u16 max_latency;
-	u8  retrans_effort;
-};
-
-struct conn_handle_t {
-	struct hci_conn *conn;
-	__u16 handle;
-};
-
-static const struct sco_param esco_param_cvsd[] = {
-	{ EDR_ESCO_MASK & ~ESCO_2EV3, 0x000a,	0x01 }, /* S3 */
-	{ EDR_ESCO_MASK & ~ESCO_2EV3, 0x0007,	0x01 }, /* S2 */
-	{ EDR_ESCO_MASK | ESCO_EV3,   0x0007,	0x01 }, /* S1 */
-	{ EDR_ESCO_MASK | ESCO_HV3,   0xffff,	0x01 }, /* D1 */
-	{ EDR_ESCO_MASK | ESCO_HV1,   0xffff,	0x01 }, /* D0 */
-};
-
-static const struct sco_param sco_param_cvsd[] = {
-	{ EDR_ESCO_MASK | ESCO_HV3,   0xffff,	0xff }, /* D1 */
-	{ EDR_ESCO_MASK | ESCO_HV1,   0xffff,	0xff }, /* D0 */
-};
-
-static const struct sco_param esco_param_msbc[] = {
-	{ EDR_ESCO_MASK & ~ESCO_2EV3, 0x000d,	0x02 }, /* T2 */
-	{ EDR_ESCO_MASK | ESCO_EV3,   0x0008,	0x02 }, /* T1 */
-};
-
-/* This function requires the caller holds hdev->lock */
-void hci_connect_le_scan_cleanup(struct hci_conn *conn, u8 status)
-{
-	struct hci_conn_params *params;
-	struct hci_dev *hdev = conn->hdev;
-	struct smp_irk *irk;
-	bdaddr_t *bdaddr;
-	u8 bdaddr_type;
-
-	bdaddr = &conn->dst;
-	bdaddr_type = conn->dst_type;
-
-	/* Check if we need to convert to identity address */
-	irk = hci_get_irk(hdev, bdaddr, bdaddr_type);
-	if (irk) {
-		bdaddr = &irk->bdaddr;
-		bdaddr_type = irk->addr_type;
-	}
-
-	params = hci_pend_le_action_lookup(&hdev->pend_le_conns, bdaddr,
-					   bdaddr_type);
-	if (!params)
-		return;
-
-	if (params->conn) {
-		hci_conn_drop(params->conn);
-		hci_conn_put(params->conn);
-		params->conn = NULL;
-	}
-
-	if (!params->explicit_connect)
-		return;
-
-	/* If the status indicates successful cancellation of
-	 * the attempt (i.e. Unknown Connection Id) there's no point of
-	 * notifying failure since we'll go back to keep trying to
-	 * connect. The only exception is explicit connect requests
-	 * where a timeout + cancel does indicate an actual failure.
-	 */
-	if (status && status != HCI_ERROR_UNKNOWN_CONN_ID)
-		mgmt_connect_failed(hdev, conn, status);
-
-	/* The connection attempt was doing scan for new RPA, and is
-	 * in scan phase. If params are not associated with any other
-	 * autoconnect action, remove them completely. If they are, just unmark
-	 * them as waiting for connection, by clearing explicit_connect field.
-	 */
-	params->explicit_connect = false;
-
-	hci_pend_le_list_del_init(params);
-
-	switch (params->auto_connect) {
-	case HCI_AUTO_CONN_EXPLICIT:
-		hci_conn_params_del(hdev, bdaddr, bdaddr_type);
-		/* return instead of break to avoid duplicate scan update */
-		return;
-	case HCI_AUTO_CONN_DIRECT:
-	case HCI_AUTO_CONN_ALWAYS:
-		hci_pend_le_list_add(params, &hdev->pend_le_conns);
-		break;
-	case HCI_AUTO_CONN_REPORT:
-		hci_pend_le_list_add(params, &hdev->pend_le_reports);
-		break;
-	default:
-		break;
-	}
-
-	hci_update_passive_scan(hdev);
-}
-
-static void hci_conn_cleanup(struct hci_conn *conn)
-{
-	struct hci_dev *hdev = conn->hdev;
-
-	if (test_bit(HCI_CONN_PARAM_REMOVAL_PEND, &conn->flags))
-		hci_conn_params_del(conn->hdev, &conn->dst, conn->dst_type);
-
-	if (test_and_clear_bit(HCI_CONN_FLUSH_KEY, &conn->flags))
-		hci_remove_link_key(hdev, &conn->dst);
-
-	hci_chan_list_flush(conn);
-
-	if (HCI_CONN_HANDLE_UNSET(conn->handle))
-		ida_free(&hdev->unset_handle_ida, conn->handle);
-
-	if (conn->cleanup)
-		conn->cleanup(conn);
-
-	if (conn->type == SCO_LINK || conn->type == ESCO_LINK) {
-		switch (conn->setting & SCO_AIRMODE_MASK) {
-		case SCO_AIRMODE_CVSD:
-		case SCO_AIRMODE_TRANSP:
-			if (hdev->notify)
-				hdev->notify(hdev, HCI_NOTIFY_DISABLE_SCO);
-			break;
-		}
-	} else {
-		if (hdev->notify)
-			hdev->notify(hdev, HCI_NOTIFY_CONN_DEL);
-	}
-
-	debugfs_remove_recursive(conn->debugfs);
-
-	hci_conn_del_sysfs(conn);
-
-	hci_dev_put(hdev);
-}
-
-int hci_disconnect(struct hci_conn *conn, __u8 reason)
-{
-	BT_DBG("hcon %p", conn);
-
-	/* When we are central of an established connection and it enters
-	 * the disconnect timeout, then go ahead and try to read the
-	 * current clock offset.  Processing of the result is done
-	 * within the event handling and hci_clock_offset_evt function.
-	 */
-	if (conn->type == ACL_LINK && conn->role == HCI_ROLE_MASTER &&
-	    (conn->state == BT_CONNECTED || conn->state == BT_CONFIG)) {
-		struct hci_dev *hdev = conn->hdev;
-		struct hci_cp_read_clock_offset clkoff_cp;
-
-		clkoff_cp.handle = cpu_to_le16(conn->handle);
-		hci_send_cmd(hdev, HCI_OP_READ_CLOCK_OFFSET, sizeof(clkoff_cp),
-			     &clkoff_cp);
-	}
-
-	return hci_abort_conn(conn, reason);
-}
-
-static void hci_add_sco(struct hci_conn *conn, __u16 handle)
-{
-	struct hci_dev *hdev = conn->hdev;
-	struct hci_cp_add_sco cp;
-
-	BT_DBG("hcon %p", conn);
-
-	conn->state = BT_CONNECT;
-	conn->out = true;
-
-	conn->attempt++;
-
-	cp.handle   = cpu_to_le16(handle);
-	cp.pkt_type = cpu_to_le16(conn->pkt_type);
-
-	hci_send_cmd(hdev, HCI_OP_ADD_SCO, sizeof(cp), &cp);
-}
-
-static bool find_next_esco_param(struct hci_conn *conn,
-				 const struct sco_param *esco_param, int size)
-{
-	if (!conn->parent)
-		return false;
-
-	for (; conn->attempt <= size; conn->attempt++) {
-		if (lmp_esco_2m_capable(conn->parent) ||
-		    (esco_param[conn->attempt - 1].pkt_type & ESCO_2EV3))
-			break;
-		BT_DBG("hcon %p skipped attempt %d, eSCO 2M not supported",
-		       conn, conn->attempt);
-	}
-
-	return conn->attempt <= size;
-}
-
-static int configure_datapath_sync(struct hci_dev *hdev, struct bt_codec *codec)
-{
-	int err;
-	__u8 vnd_len, *vnd_data = NULL;
-	struct hci_op_configure_data_path *cmd = NULL;
-
-	/* Do not take below 2 checks as error since the 1st means user do not
-	 * want to use HFP offload mode and the 2nd means the vendor controller
-	 * do not need to send below HCI command for offload mode.
-	 */
-	if (!codec->data_path || !hdev->get_codec_config_data)
-		return 0;
-
-	err = hdev->get_codec_config_data(hdev, ESCO_LINK, codec, &vnd_len,
-					  &vnd_data);
-	if (err < 0)
-		goto error;
-
-	cmd = kzalloc(sizeof(*cmd) + vnd_len, GFP_KERNEL);
-	if (!cmd) {
-		err = -ENOMEM;
-		goto error;
-	}
-
-	err = hdev->get_data_path_id(hdev, &cmd->data_path_id);
-	if (err < 0)
-		goto error;
-
-	cmd->vnd_len = vnd_len;
-	memcpy(cmd->vnd_data, vnd_data, vnd_len);
-
-	cmd->direction = 0x00;
-	__hci_cmd_sync_status(hdev, HCI_CONFIGURE_DATA_PATH,
-			      sizeof(*cmd) + vnd_len, cmd, HCI_CMD_TIMEOUT);
-
-	cmd->direction = 0x01;
-	err = __hci_cmd_sync_status(hdev, HCI_CONFIGURE_DATA_PATH,
-				    sizeof(*cmd) + vnd_len, cmd,
-				    HCI_CMD_TIMEOUT);
-error:
-
-	kfree(cmd);
-	kfree(vnd_data);
-	return err;
-}
-
-static int hci_enhanced_setup_sync(struct hci_dev *hdev, void *data)
-{
-	struct conn_handle_t *conn_handle = data;
-	struct hci_conn *conn = conn_handle->conn;
-	__u16 handle = conn_handle->handle;
-	struct hci_cp_enhanced_setup_sync_conn cp;
-	const struct sco_param *param;
-
-	kfree(conn_handle);
-
-	if (!hci_conn_valid(hdev, conn))
-		return -ECANCELED;
-
-	bt_dev_dbg(hdev, "hcon %p", conn);
-
-	configure_datapath_sync(hdev, &conn->codec);
-
-	conn->state = BT_CONNECT;
-	conn->out = true;
-
-	conn->attempt++;
-
-	memset(&cp, 0x00, sizeof(cp));
-
-	cp.handle   = cpu_to_le16(handle);
-
-	cp.tx_bandwidth   = cpu_to_le32(0x00001f40);
-	cp.rx_bandwidth   = cpu_to_le32(0x00001f40);
-
-	switch (conn->codec.id) {
-	case BT_CODEC_MSBC:
-		if (!find_next_esco_param(conn, esco_param_msbc,
-					  ARRAY_SIZE(esco_param_msbc)))
-			return -EINVAL;
-
-		param = &esco_param_msbc[conn->attempt - 1];
-		cp.tx_coding_format.id = 0x05;
-		cp.rx_coding_format.id = 0x05;
-		cp.tx_codec_frame_size = __cpu_to_le16(60);
-		cp.rx_codec_frame_size = __cpu_to_le16(60);
-		cp.in_bandwidth = __cpu_to_le32(32000);
-		cp.out_bandwidth = __cpu_to_le32(32000);
-		cp.in_coding_format.id = 0x04;
-		cp.out_coding_format.id = 0x04;
-		cp.in_coded_data_size = __cpu_to_le16(16);
-		cp.out_coded_data_size = __cpu_to_le16(16);
-		cp.in_pcm_data_format = 2;
-		cp.out_pcm_data_format = 2;
-		cp.in_pcm_sample_payload_msb_pos = 0;
-		cp.out_pcm_sample_payload_msb_pos = 0;
-		cp.in_data_path = conn->codec.data_path;
-		cp.out_data_path = conn->codec.data_path;
-		cp.in_transport_unit_size = 1;
-		cp.out_transport_unit_size = 1;
-		break;
-
-	case BT_CODEC_TRANSPARENT:
-		if (!find_next_esco_param(conn, esco_param_msbc,
-					  ARRAY_SIZE(esco_param_msbc)))
-			return -EINVAL;
-
-		param = &esco_param_msbc[conn->attempt - 1];
-		cp.tx_coding_format.id = 0x03;
-		cp.rx_coding_format.id = 0x03;
-		cp.tx_codec_frame_size = __cpu_to_le16(60);
-		cp.rx_codec_frame_size = __cpu_to_le16(60);
-		cp.in_bandwidth = __cpu_to_le32(0x1f40);
-		cp.out_bandwidth = __cpu_to_le32(0x1f40);
-		cp.in_coding_format.id = 0x03;
-		cp.out_coding_format.id = 0x03;
-		cp.in_coded_data_size = __cpu_to_le16(16);
-		cp.out_coded_data_size = __cpu_to_le16(16);
-		cp.in_pcm_data_format = 2;
-		cp.out_pcm_data_format = 2;
-		cp.in_pcm_sample_payload_msb_pos = 0;
-		cp.out_pcm_sample_payload_msb_pos = 0;
-		cp.in_data_path = conn->codec.data_path;
-		cp.out_data_path = conn->codec.data_path;
-		cp.in_transport_unit_size = 1;
-		cp.out_transport_unit_size = 1;
-		break;
-
-	case BT_CODEC_CVSD:
-		if (conn->parent && lmp_esco_capable(conn->parent)) {
-			if (!find_next_esco_param(conn, esco_param_cvsd,
-						  ARRAY_SIZE(esco_param_cvsd)))
-				return -EINVAL;
-			param = &esco_param_cvsd[conn->attempt - 1];
-		} else {
-			if (conn->attempt > ARRAY_SIZE(sco_param_cvsd))
-				return -EINVAL;
-			param = &sco_param_cvsd[conn->attempt - 1];
-		}
-		cp.tx_coding_format.id = 2;
-		cp.rx_coding_format.id = 2;
-		cp.tx_codec_frame_size = __cpu_to_le16(60);
-		cp.rx_codec_frame_size = __cpu_to_le16(60);
-		cp.in_bandwidth = __cpu_to_le32(16000);
-		cp.out_bandwidth = __cpu_to_le32(16000);
-		cp.in_coding_format.id = 4;
-		cp.out_coding_format.id = 4;
-		cp.in_coded_data_size = __cpu_to_le16(16);
-		cp.out_coded_data_size = __cpu_to_le16(16);
-		cp.in_pcm_data_format = 2;
-		cp.out_pcm_data_format = 2;
-		cp.in_pcm_sample_payload_msb_pos = 0;
-		cp.out_pcm_sample_payload_msb_pos = 0;
-		cp.in_data_path = conn->codec.data_path;
-		cp.out_data_path = conn->codec.data_path;
-		cp.in_transport_unit_size = 16;
-		cp.out_transport_unit_size = 16;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	cp.retrans_effort = param->retrans_effort;
-	cp.pkt_type = __cpu_to_le16(param->pkt_type);
-	cp.max_latency = __cpu_to_le16(param->max_latency);
-
-	if (hci_send_cmd(hdev, HCI_OP_ENHANCED_SETUP_SYNC_CONN, sizeof(cp), &cp) < 0)
-		return -EIO;
-
-	return 0;
-}
-
-static bool hci_setup_sync_conn(struct hci_conn *conn, __u16 handle)
-{
-	struct hci_dev *hdev = conn->hdev;
-	struct hci_cp_setup_sync_conn cp;
-	const struct sco_param *param;
-
-	bt_dev_dbg(hdev, "hcon %p", conn);
-
-	conn->state = BT_CONNECT;
-	conn->out = true;
-
-	conn->attempt++;
-
-	cp.handle   = cpu_to_le16(handle);
-
-	cp.tx_bandwidth   = cpu_to_le32(0x00001f40);
-	cp.rx_bandwidth   = cpu_to_le32(0x00001f40);
-	cp.voice_setting  = cpu_to_le16(conn->setting);
-
-	switch (conn->setting & SCO_AIRMODE_MASK) {
-	case SCO_AIRMODE_TRANSP:
-		if (!find_next_esco_param(conn, esco_param_msbc,
-					  ARRAY_SIZE(esco_param_msbc)))
-			return false;
-		param = &esco_param_msbc[conn->attempt - 1];
-		break;
-	case SCO_AIRMODE_CVSD:
-		if (conn->parent && lmp_esco_capable(conn->parent)) {
-			if (!find_next_esco_param(conn, esco_param_cvsd,
-						  ARRAY_SIZE(esco_param_cvsd)))
-				return false;
-			param = &esco_param_cvsd[conn->attempt - 1];
-		} else {
-			if (conn->attempt > ARRAY_SIZE(sco_param_cvsd))
-				return false;
-			param = &sco_param_cvsd[conn->attempt - 1];
-		}
-		break;
-	default:
-		return false;
-	}
-
-	cp.retrans_effort = param->retrans_effort;
-	cp.pkt_type = __cpu_to_le16(param->pkt_type);
-	cp.max_latency = __cpu_to_le16(param->max_latency);
-
-	if (hci_send_cmd(hdev, HCI_OP_SETUP_SYNC_CONN, sizeof(cp), &cp) < 0)
-		return false;
-
-	return true;
-}
-
-bool hci_setup_sync(struct hci_conn *conn, __u16 handle)
-{
-	int result;
-	struct conn_handle_t *conn_handle;
-
-	if (enhanced_sync_conn_capable(conn->hdev)) {
-		conn_handle = kzalloc(sizeof(*conn_handle), GFP_KERNEL);
-
-		if (!conn_handle)
-			return false;
-
-		conn_handle->conn = conn;
-		conn_handle->handle = handle;
-		result = hci_cmd_sync_queue(conn->hdev, hci_enhanced_setup_sync,
-					    conn_handle, NULL);
-		if (result < 0)
-			kfree(conn_handle);
-
-		return result == 0;
-	}
-
-	return hci_setup_sync_conn(conn, handle);
-}
-
-u8 hci_le_conn_update(struct hci_conn *conn, u16 min, u16 max, u16 latency,
-		      u16 to_multiplier)
-{
-	struct hci_dev *hdev = conn->hdev;
-	struct hci_conn_params *params;
-	struct hci_cp_le_conn_update cp;
-
-	hci_dev_lock(hdev);
-
-	params = hci_conn_params_lookup(hdev, &conn->dst, conn->dst_type);
-	if (params) {
-		params->conn_min_interval = min;
-		params->conn_max_interval = max;
-		params->conn_latency = latency;
-		params->supervision_timeout = to_multiplier;
-	}
-
-	hci_dev_unlock(hdev);
-
-	memset(&cp, 0, sizeof(cp));
-	cp.handle		= cpu_to_le16(conn->handle);
-	cp.conn_interval_min	= cpu_to_le16(min);
-	cp.conn_interval_max	= cpu_to_le16(max);
-	cp.conn_latency		= cpu_to_le16(latency);
-	cp.supervision_timeout	= cpu_to_le16(to_multiplier);
-	cp.min_ce_len		= cpu_to_le16(0x0000);
-	cp.max_ce_len		= cpu_to_le16(0x0000);
-
-	hci_send_cmd(hdev, HCI_OP_LE_CONN_UPDATE, sizeof(cp), &cp);
-
-	if (params)
-		return 0x01;
-
-	return 0x00;
-}
-
-void hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __le64 rand,
-		      __u8 ltk[16], __u8 key_size)
-{
-	struct hci_dev *hdev = conn->hdev;
-	struct hci_cp_le_start_enc cp;
-
-	BT_DBG("hcon %p", conn);
-
-	memset(&cp, 0, sizeof(cp));
-
-	cp.handle = cpu_to_le16(conn->handle);
-	cp.rand = rand;
-	cp.ediv = ediv;
-	memcpy(cp.ltk, ltk, key_size);
-
-	hci_send_cmd(hdev, HCI_OP_LE_START_ENC, sizeof(cp), &cp);
-}
-
-/* Device _must_ be locked */
-void hci_sco_setup(struct hci_conn *conn, __u8 status)
-{
-	struct hci_link *link;
-
-	link = list_first_entry_or_null(&conn->link_list, struct hci_link, list);
-	if (!link || !link->conn)
-		return;
-
-	BT_DBG("hcon %p", conn);
-
-	if (!status) {
-		if (lmp_esco_capable(conn->hdev))
-			hci_setup_sync(link->conn, conn->handle);
-		else
-			hci_add_sco(link->conn, conn->handle);
-	} else {
-		hci_connect_cfm(link->conn, status);
-		hci_conn_del(link->conn);
-	}
-}
-
-static void hci_conn_timeout(struct work_struct *work)
-{
-	struct hci_conn *conn = container_of(work, struct hci_conn,
-					     disc_work.work);
-	int refcnt = atomic_read(&conn->refcnt);
-
-	BT_DBG("hcon %p state %s", conn, state_to_string(conn->state));
-
-	WARN_ON(refcnt < 0);
-
-	/* FIXME: It was observed that in pairing failed scenario, refcnt
-	 * drops below 0. Probably this is because l2cap_conn_del calls
-	 * l2cap_chan_del for each channel, and inside l2cap_chan_del conn is
-	 * dropped. After that loop hci_chan_del is called which also drops
-	 * conn. For now make sure that ACL is alive if refcnt is higher then 0,
-	 * otherwise drop it.
-	 */
-	if (refcnt > 0)
-		return;
-
-	hci_abort_conn(conn, hci_proto_disconn_ind(conn));
-}
-
-/* Enter sniff mode */
-static void hci_conn_idle(struct work_struct *work)
-{
-	struct hci_conn *conn = container_of(work, struct hci_conn,
-					     idle_work.work);
-	struct hci_dev *hdev = conn->hdev;
-
-	BT_DBG("hcon %p mode %d", conn, conn->mode);
-
-	if (!lmp_sniff_capable(hdev) || !lmp_sniff_capable(conn))
-		return;
-
-	if (conn->mode != HCI_CM_ACTIVE || !(conn->link_policy & HCI_LP_SNIFF))
-		return;
-
-	if (lmp_sniffsubr_capable(hdev) && lmp_sniffsubr_capable(conn)) {
-		struct hci_cp_sniff_subrate cp;
-		cp.handle             = cpu_to_le16(conn->handle);
-		cp.max_latency        = cpu_to_le16(0);
-		cp.min_remote_timeout = cpu_to_le16(0);
-		cp.min_local_timeout  = cpu_to_le16(0);
-		hci_send_cmd(hdev, HCI_OP_SNIFF_SUBRATE, sizeof(cp), &cp);
-	}
-
-	if (!test_and_set_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->flags)) {
-		struct hci_cp_sniff_mode cp;
-		cp.handle       = cpu_to_le16(conn->handle);
-		cp.max_interval = cpu_to_le16(hdev->sniff_max_interval);
-		cp.min_interval = cpu_to_le16(hdev->sniff_min_interval);
-		cp.attempt      = cpu_to_le16(4);
-		cp.timeout      = cpu_to_le16(1);
-		hci_send_cmd(hdev, HCI_OP_SNIFF_MODE, sizeof(cp), &cp);
-	}
-}
-
-static void hci_conn_auto_accept(struct work_struct *work)
-{
-	struct hci_conn *conn = container_of(work, struct hci_conn,
-					     auto_accept_work.work);
-
-	hci_send_cmd(conn->hdev, HCI_OP_USER_CONFIRM_REPLY, sizeof(conn->dst),
-		     &conn->dst);
-}
-
-static void le_disable_advertising(struct hci_dev *hdev)
-{
-	if (ext_adv_capable(hdev)) {
-		struct hci_cp_le_set_ext_adv_enable cp;
-
-		cp.enable = 0x00;
-		cp.num_of_sets = 0x00;
-
-		hci_send_cmd(hdev, HCI_OP_LE_SET_EXT_ADV_ENABLE, sizeof(cp),
-			     &cp);
-	} else {
-		u8 enable = 0x00;
-		hci_send_cmd(hdev, HCI_OP_LE_SET_ADV_ENABLE, sizeof(enable),
-			     &enable);
-	}
-}
-
-static void le_conn_timeout(struct work_struct *work)
-{
-	struct hci_conn *conn = container_of(work, struct hci_conn,
-					     le_conn_timeout.work);
-	struct hci_dev *hdev = conn->hdev;
-
-	BT_DBG("");
-
-	/* We could end up here due to having done directed advertising,
-	 * so clean up the state if necessary. This should however only
-	 * happen with broken hardware or if low duty cycle was used
-	 * (which doesn't have a timeout of its own).
-	 */
-	if (conn->role == HCI_ROLE_SLAVE) {
-		/* Disable LE Advertising */
-		le_disable_advertising(hdev);
-		hci_dev_lock(hdev);
-		hci_conn_failed(conn, HCI_ERROR_ADVERTISING_TIMEOUT);
-		hci_dev_unlock(hdev);
-		return;
-	}
-
-	hci_abort_conn(conn, HCI_ERROR_REMOTE_USER_TERM);
-}
-
-struct iso_list_data {
-	union {
-		u8  cig;
-		u8  big;
-	};
-	union {
-		u8  cis;
-		u8  bis;
-		u16 sync_handle;
-	};
-	int count;
-	bool big_term;
-	bool pa_sync_term;
-	bool big_sync_term;
-};
-
-static void bis_list(struct hci_conn *conn, void *data)
-{
-	struct iso_list_data *d = data;
-
-	/* Skip if not broadcast/ANY address */
-	if (bacmp(&conn->dst, BDADDR_ANY))
-		return;
-
-	if (d->big != conn->iso_qos.bcast.big || d->bis == BT_ISO_QOS_BIS_UNSET ||
-	    d->bis != conn->iso_qos.bcast.bis)
-		return;
-
-	d->count++;
-}
-
-static int terminate_big_sync(struct hci_dev *hdev, void *data)
-{
-	struct iso_list_data *d = data;
-
-	bt_dev_dbg(hdev, "big 0x%2.2x bis 0x%2.2x", d->big, d->bis);
-
-	hci_disable_per_advertising_sync(hdev, d->bis);
-	hci_remove_ext_adv_instance_sync(hdev, d->bis, NULL);
-
-	/* Only terminate BIG if it has been created */
-	if (!d->big_term)
-		return 0;
-
-	return hci_le_terminate_big_sync(hdev, d->big,
-					 HCI_ERROR_LOCAL_HOST_TERM);
-}
-
-static void terminate_big_destroy(struct hci_dev *hdev, void *data, int err)
-{
-	kfree(data);
-}
-
-static int hci_le_terminate_big(struct hci_dev *hdev, struct hci_conn *conn)
-{
-	struct iso_list_data *d;
-	int ret;
-
-	bt_dev_dbg(hdev, "big 0x%2.2x bis 0x%2.2x", conn->iso_qos.bcast.big,
-		   conn->iso_qos.bcast.bis);
-
-	d = kzalloc(sizeof(*d), GFP_KERNEL);
-	if (!d)
-		return -ENOMEM;
-
-	d->big = conn->iso_qos.bcast.big;
-	d->bis = conn->iso_qos.bcast.bis;
-	d->big_term = test_and_clear_bit(HCI_CONN_BIG_CREATED, &conn->flags);
-
-	ret = hci_cmd_sync_queue(hdev, terminate_big_sync, d,
-				 terminate_big_destroy);
-	if (ret)
-		kfree(d);
-
-	return ret;
-}
-
-static int big_terminate_sync(struct hci_dev *hdev, void *data)
-{
-	struct iso_list_data *d = data;
-
-	bt_dev_dbg(hdev, "big 0x%2.2x sync_handle 0x%4.4x", d->big,
-		   d->sync_handle);
-
-	if (d->big_sync_term)
-		hci_le_big_terminate_sync(hdev, d->big);
-
-	if (d->pa_sync_term)
-		return hci_le_pa_terminate_sync(hdev, d->sync_handle);
-
-	return 0;
-}
-
-static void find_bis(struct hci_conn *conn, void *data)
-{
-	struct iso_list_data *d = data;
-
-	/* Ignore if BIG doesn't match */
-	if (d->big != conn->iso_qos.bcast.big)
-		return;
-
-	d->count++;
-}
-
-static int hci_le_big_terminate(struct hci_dev *hdev, u8 big, struct hci_conn *conn)
-{
-	struct iso_list_data *d;
-	int ret;
-
-	bt_dev_dbg(hdev, "big 0x%2.2x sync_handle 0x%4.4x", big, conn->sync_handle);
-
-	d = kzalloc(sizeof(*d), GFP_KERNEL);
-	if (!d)
-		return -ENOMEM;
-
-	d->big = big;
-	d->sync_handle = conn->sync_handle;
-
-	if (test_and_clear_bit(HCI_CONN_PA_SYNC, &conn->flags)) {
-		hci_conn_hash_list_flag(hdev, find_bis, PA_LINK,
-					HCI_CONN_PA_SYNC, d);
-
-		if (!d->count)
-			d->pa_sync_term = true;
-
-		d->count = 0;
-	}
-
-	if (test_and_clear_bit(HCI_CONN_BIG_SYNC, &conn->flags)) {
-		hci_conn_hash_list_flag(hdev, find_bis, BIS_LINK,
-					HCI_CONN_BIG_SYNC, d);
-
-		if (!d->count)
-			d->big_sync_term = true;
-	}
-
-	ret = hci_cmd_sync_queue(hdev, big_terminate_sync, d,
-				 terminate_big_destroy);
-	if (ret)
-		kfree(d);
-
-	return ret;
-}
-
-/* Cleanup BIS connection
- *
- * Detects if there any BIS left connected in a BIG
- * broadcaster: Remove advertising instance and terminate BIG.
- * broadcaster receiver: Teminate BIG sync and terminate PA sync.
- */
-static void bis_cleanup(struct hci_conn *conn)
-{
-	struct hci_dev *hdev = conn->hdev;
-	struct hci_conn *bis;
-
-	bt_dev_dbg(hdev, "conn %p", conn);
-
-	if (conn->role == HCI_ROLE_MASTER) {
-		if (!test_and_clear_bit(HCI_CONN_PER_ADV, &conn->flags))
-			return;
-
-		/* Check if ISO connection is a BIS and terminate advertising
-		 * set and BIG if there are no other connections using it.
-		 */
-		bis = hci_conn_hash_lookup_big(hdev, conn->iso_qos.bcast.big);
-		if (bis)
-			return;
-
-		hci_le_terminate_big(hdev, conn);
-	} else {
-		hci_le_big_terminate(hdev, conn->iso_qos.bcast.big,
-				     conn);
-	}
-}
-
-static int remove_cig_sync(struct hci_dev *hdev, void *data)
-{
-	u8 handle = PTR_UINT(data);
-
-	return hci_le_remove_cig_sync(hdev, handle);
-}
-
-static int hci_le_remove_cig(struct hci_dev *hdev, u8 handle)
-{
-	bt_dev_dbg(hdev, "handle 0x%2.2x", handle);
-
-	return hci_cmd_sync_queue(hdev, remove_cig_sync, UINT_PTR(handle),
-				  NULL);
-}
-
-static void find_cis(struct hci_conn *conn, void *data)
-{
-	struct iso_list_data *d = data;
-
-	/* Ignore broadcast or if CIG don't match */
-	if (!bacmp(&conn->dst, BDADDR_ANY) || d->cig != conn->iso_qos.ucast.cig)
-		return;
-
-	d->count++;
-}
-
-/* Cleanup CIS connection:
- *
- * Detects if there any CIS left connected in a CIG and remove it.
- */
-static void cis_cleanup(struct hci_conn *conn)
-{
-	struct hci_dev *hdev = conn->hdev;
-	struct iso_list_data d;
-
-	if (conn->iso_qos.ucast.cig == BT_ISO_QOS_CIG_UNSET)
-		return;
-
-	memset(&d, 0, sizeof(d));
-	d.cig = conn->iso_qos.ucast.cig;
-
-	/* Check if ISO connection is a CIS and remove CIG if there are
-	 * no other connections using it.
-	 */
-	hci_conn_hash_list_state(hdev, find_cis, CIS_LINK, BT_BOUND, &d);
-	hci_conn_hash_list_state(hdev, find_cis, CIS_LINK, BT_CONNECT,
-				 &d);
-	hci_conn_hash_list_state(hdev, find_cis, CIS_LINK, BT_CONNECTED,
-				 &d);
-	if (d.count)
-		return;
-
-	hci_le_remove_cig(hdev, conn->iso_qos.ucast.cig);
-}
-
-static int hci_conn_hash_alloc_unset(struct hci_dev *hdev)
-{
-	return ida_alloc_range(&hdev->unset_handle_ida, HCI_CONN_HANDLE_MAX + 1,
-			       U16_MAX, GFP_ATOMIC);
-}
-
-static struct hci_conn *__hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst,
-				       u8 role, u16 handle)
-{
-	struct hci_conn *conn;
-
-	switch (type) {
-	case ACL_LINK:
-		if (!hdev->acl_mtu)
-			return ERR_PTR(-ECONNREFUSED);
-		break;
-	case CIS_LINK:
-	case BIS_LINK:
-	case PA_LINK:
-		if (hdev->iso_mtu)
-			/* Dedicated ISO Buffer exists */
-			break;
-		fallthrough;
-	case LE_LINK:
-		if (hdev->le_mtu && hdev->le_mtu < HCI_MIN_LE_MTU)
-			return ERR_PTR(-ECONNREFUSED);
-		if (!hdev->le_mtu && hdev->acl_mtu < HCI_MIN_LE_MTU)
-			return ERR_PTR(-ECONNREFUSED);
-		break;
-	case SCO_LINK:
-	case ESCO_LINK:
-		if (!hdev->sco_pkts)
-			/* Controller does not support SCO or eSCO over HCI */
-			return ERR_PTR(-ECONNREFUSED);
-		break;
-	default:
-		return ERR_PTR(-ECONNREFUSED);
-	}
-
-	bt_dev_dbg(hdev, "dst %pMR handle 0x%4.4x", dst, handle);
-
-	conn = kzalloc(sizeof(*conn), GFP_KERNEL);
-	if (!conn)
-		return ERR_PTR(-ENOMEM);
-
-	bacpy(&conn->dst, dst);
-	bacpy(&conn->src, &hdev->bdaddr);
-	conn->handle = handle;
-	conn->hdev  = hdev;
-	conn->type  = type;
-	conn->role  = role;
-	conn->mode  = HCI_CM_ACTIVE;
-	conn->state = BT_OPEN;
-	conn->auth_type = HCI_AT_GENERAL_BONDING;
-	conn->io_capability = hdev->io_capability;
-	conn->remote_auth = 0xff;
-	conn->key_type = 0xff;
-	conn->rssi = HCI_RSSI_INVALID;
-	conn->tx_power = HCI_TX_POWER_INVALID;
-	conn->max_tx_power = HCI_TX_POWER_INVALID;
-	conn->sync_handle = HCI_SYNC_HANDLE_INVALID;
-	conn->sid = HCI_SID_INVALID;
-
-	set_bit(HCI_CONN_POWER_SAVE, &conn->flags);
-	conn->disc_timeout = HCI_DISCONN_TIMEOUT;
-
-	/* Set Default Authenticated payload timeout to 30s */
-	conn->auth_payload_timeout = DEFAULT_AUTH_PAYLOAD_TIMEOUT;
-
-	if (conn->role == HCI_ROLE_MASTER)
-		conn->out = true;
-
-	switch (type) {
-	case ACL_LINK:
-		conn->pkt_type = hdev->pkt_type & ACL_PTYPE_MASK;
-		conn->mtu = hdev->acl_mtu;
-		break;
-	case LE_LINK:
-		/* conn->src should reflect the local identity address */
-		hci_copy_identity_address(hdev, &conn->src, &conn->src_type);
-		conn->mtu = hdev->le_mtu ? hdev->le_mtu : hdev->acl_mtu;
-		break;
-	case CIS_LINK:
-	case BIS_LINK:
-	case PA_LINK:
-		/* conn->src should reflect the local identity address */
-		hci_copy_identity_address(hdev, &conn->src, &conn->src_type);
-
-		/* set proper cleanup function */
-		if (!bacmp(dst, BDADDR_ANY))
-			conn->cleanup = bis_cleanup;
-		else if (conn->role == HCI_ROLE_MASTER)
-			conn->cleanup = cis_cleanup;
-
-		conn->mtu = hdev->iso_mtu ? hdev->iso_mtu :
-			    hdev->le_mtu ? hdev->le_mtu : hdev->acl_mtu;
-		break;
-	case SCO_LINK:
-		if (lmp_esco_capable(hdev))
-			conn->pkt_type = (hdev->esco_type & SCO_ESCO_MASK) |
-					(hdev->esco_type & EDR_ESCO_MASK);
-		else
-			conn->pkt_type = hdev->pkt_type & SCO_PTYPE_MASK;
-
-		conn->mtu = hdev->sco_mtu;
-		break;
-	case ESCO_LINK:
-		conn->pkt_type = hdev->esco_type & ~EDR_ESCO_MASK;
-		conn->mtu = hdev->sco_mtu;
-		break;
-	}
-
-	skb_queue_head_init(&conn->data_q);
-	skb_queue_head_init(&conn->tx_q.queue);
-
-	INIT_LIST_HEAD(&conn->chan_list);
-	INIT_LIST_HEAD(&conn->link_list);
-
-	INIT_DELAYED_WORK(&conn->disc_work, hci_conn_timeout);
-	INIT_DELAYED_WORK(&conn->auto_accept_work, hci_conn_auto_accept);
-	INIT_DELAYED_WORK(&conn->idle_work, hci_conn_idle);
-	INIT_DELAYED_WORK(&conn->le_conn_timeout, le_conn_timeout);
-
-	atomic_set(&conn->refcnt, 0);
-
-	hci_dev_hold(hdev);
-
-	hci_conn_hash_add(hdev, conn);
-
-	/* The SCO and eSCO connections will only be notified when their
-	 * setup has been completed. This is different to ACL links which
-	 * can be notified right away.
-	 */
-	if (conn->type != SCO_LINK && conn->type != ESCO_LINK) {
-		if (hdev->notify)
-			hdev->notify(hdev, HCI_NOTIFY_CONN_ADD);
-	}
-
-	hci_conn_init_sysfs(conn);
-	return conn;
-}
-
-struct hci_conn *hci_conn_add_unset(struct hci_dev *hdev, int type,
-				    bdaddr_t *dst, u8 role)
-{
-	int handle;
-
-	bt_dev_dbg(hdev, "dst %pMR", dst);
-
-	handle = hci_conn_hash_alloc_unset(hdev);
-	if (unlikely(handle < 0))
-		return ERR_PTR(-ECONNREFUSED);
-
-	return __hci_conn_add(hdev, type, dst, role, handle);
-}
-
-struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst,
-			      u8 role, u16 handle)
-{
-	if (handle > HCI_CONN_HANDLE_MAX)
-		return ERR_PTR(-EINVAL);
-
-	return __hci_conn_add(hdev, type, dst, role, handle);
-}
-
-static void hci_conn_cleanup_child(struct hci_conn *conn, u8 reason)
-{
-	if (!reason)
-		reason = HCI_ERROR_REMOTE_USER_TERM;
-
-	/* Due to race, SCO/ISO conn might be not established yet at this point,
-	 * and nothing else will clean it up. In other cases it is done via HCI
-	 * events.
-	 */
-	switch (conn->type) {
-	case SCO_LINK:
-	case ESCO_LINK:
-		if (HCI_CONN_HANDLE_UNSET(conn->handle))
-			hci_conn_failed(conn, reason);
-		break;
-	case CIS_LINK:
-	case BIS_LINK:
-	case PA_LINK:
-		if ((conn->state != BT_CONNECTED &&
-		    !test_bit(HCI_CONN_CREATE_CIS, &conn->flags)) ||
-		    test_bit(HCI_CONN_BIG_CREATED, &conn->flags))
-			hci_conn_failed(conn, reason);
-		break;
-	}
-}
-
-static void hci_conn_unlink(struct hci_conn *conn)
-{
-	struct hci_dev *hdev = conn->hdev;
-
-	bt_dev_dbg(hdev, "hcon %p", conn);
-
-	if (!conn->parent) {
-		struct hci_link *link, *t;
-
-		list_for_each_entry_safe(link, t, &conn->link_list, list) {
-			struct hci_conn *child = link->conn;
-
-			hci_conn_unlink(child);
-
-			/* If hdev is down it means
-			 * hci_dev_close_sync/hci_conn_hash_flush is in progress
-			 * and links don't need to be cleanup as all connections
-			 * would be cleanup.
-			 */
-			if (!test_bit(HCI_UP, &hdev->flags))
-				continue;
-
-			hci_conn_cleanup_child(child, conn->abort_reason);
-		}
-
-		return;
-	}
-
-	if (!conn->link)
-		return;
-
-	list_del_rcu(&conn->link->list);
-	synchronize_rcu();
-
-	hci_conn_drop(conn->parent);
-	hci_conn_put(conn->parent);
-	conn->parent = NULL;
-
-	kfree(conn->link);
-	conn->link = NULL;
-}
-
-void hci_conn_del(struct hci_conn *conn)
-{
-	struct hci_dev *hdev = conn->hdev;
-
-	BT_DBG("%s hcon %p handle %d", hdev->name, conn, conn->handle);
-
-	hci_conn_unlink(conn);
-
-	disable_delayed_work_sync(&conn->disc_work);
-	disable_delayed_work_sync(&conn->auto_accept_work);
-	disable_delayed_work_sync(&conn->idle_work);
-
-	/* Remove the connection from the list so unacked logic can detect when
-	 * a certain pool is not being utilized.
-	 */
-	hci_conn_hash_del(hdev, conn);
-
-	/* Handle unacked frames:
-	 *
-	 * - In case there are no connection, or if restoring the buffers
-	 *   considered in transist would overflow, restore all buffers to the
-	 *   pool.
-	 * - Otherwise restore just the buffers considered in transit for the
-	 *   hci_conn
-	 */
-	switch (conn->type) {
-	case ACL_LINK:
-		if (!hci_conn_num(hdev, ACL_LINK) ||
-		    hdev->acl_cnt + conn->sent > hdev->acl_pkts)
-			hdev->acl_cnt = hdev->acl_pkts;
-		else
-			hdev->acl_cnt += conn->sent;
-		break;
-	case LE_LINK:
-		cancel_delayed_work(&conn->le_conn_timeout);
-
-		if (hdev->le_pkts) {
-			if (!hci_conn_num(hdev, LE_LINK) ||
-			    hdev->le_cnt + conn->sent > hdev->le_pkts)
-				hdev->le_cnt = hdev->le_pkts;
-			else
-				hdev->le_cnt += conn->sent;
-		} else {
-			if ((!hci_conn_num(hdev, LE_LINK) &&
-			     !hci_conn_num(hdev, ACL_LINK)) ||
-			    hdev->acl_cnt + conn->sent > hdev->acl_pkts)
-				hdev->acl_cnt = hdev->acl_pkts;
-			else
-				hdev->acl_cnt += conn->sent;
-		}
-		break;
-	case CIS_LINK:
-	case BIS_LINK:
-	case PA_LINK:
-		if (!hci_iso_count(hdev) ||
-		    hdev->iso_cnt + conn->sent > hdev->iso_pkts)
-			hdev->iso_cnt = hdev->iso_pkts;
-		else
-			hdev->iso_cnt += conn->sent;
-		break;
-	}
-
-	skb_queue_purge(&conn->data_q);
-	skb_queue_purge(&conn->tx_q.queue);
-
-	/* Remove the connection from the list and cleanup its remaining
-	 * state. This is a separate function since for some cases like
-	 * BT_CONNECT_SCAN we *only* want the cleanup part without the
-	 * rest of hci_conn_del.
-	 */
-	hci_conn_cleanup(conn);
-
-	/* Dequeue callbacks using connection pointer as data */
-	hci_cmd_sync_dequeue(hdev, NULL, conn, NULL);
-}
-
-struct hci_dev *hci_get_route(bdaddr_t *dst, bdaddr_t *src, uint8_t src_type)
-{
-	int use_src = bacmp(src, BDADDR_ANY);
-	struct hci_dev *hdev = NULL, *d;
-
-	BT_DBG("%pMR -> %pMR", src, dst);
-
-	read_lock(&hci_dev_list_lock);
-
-	list_for_each_entry(d, &hci_dev_list, list) {
-		if (!test_bit(HCI_UP, &d->flags) ||
-		    hci_dev_test_flag(d, HCI_USER_CHANNEL))
-			continue;
-
-		/* Simple routing:
-		 *   No source address - find interface with bdaddr != dst
-		 *   Source address    - find interface with bdaddr == src
-		 */
-
-		if (use_src) {
-			bdaddr_t id_addr;
-			u8 id_addr_type;
-
-			if (src_type == BDADDR_BREDR) {
-				if (!lmp_bredr_capable(d))
-					continue;
-				bacpy(&id_addr, &d->bdaddr);
-				id_addr_type = BDADDR_BREDR;
-			} else {
-				if (!lmp_le_capable(d))
-					continue;
-
-				hci_copy_identity_address(d, &id_addr,
-							  &id_addr_type);
-
-				/* Convert from HCI to three-value type */
-				if (id_addr_type == ADDR_LE_DEV_PUBLIC)
-					id_addr_type = BDADDR_LE_PUBLIC;
-				else
-					id_addr_type = BDADDR_LE_RANDOM;
-			}
-
-			if (!bacmp(&id_addr, src) && id_addr_type == src_type) {
-				hdev = d; break;
-			}
-		} else {
-			if (bacmp(&d->bdaddr, dst)) {
-				hdev = d; break;
-			}
-		}
-	}
-
-	if (hdev)
-		hdev = hci_dev_hold(hdev);
-
-	read_unlock(&hci_dev_list_lock);
-	return hdev;
-}
-EXPORT_SYMBOL(hci_get_route);
-
-/* This function requires the caller holds hdev->lock */
-static void hci_le_conn_failed(struct hci_conn *conn, u8 status)
-{
-	struct hci_dev *hdev = conn->hdev;
-
-	hci_connect_le_scan_cleanup(conn, status);
-
-	/* Enable advertising in case this was a failed connection
-	 * attempt as a peripheral.
-	 */
-	hci_enable_advertising(hdev);
-}
-
-/* This function requires the caller holds hdev->lock */
-void hci_conn_failed(struct hci_conn *conn, u8 status)
-{
-	struct hci_dev *hdev = conn->hdev;
-
-	bt_dev_dbg(hdev, "status 0x%2.2x", status);
-
-	switch (conn->type) {
-	case LE_LINK:
-		hci_le_conn_failed(conn, status);
-		break;
-	case ACL_LINK:
-		mgmt_connect_failed(hdev, conn, status);
-		break;
-	}
-
-	/* In case of BIG/PA sync failed, clear conn flags so that
-	 * the conns will be correctly cleaned up by ISO layer
-	 */
-	test_and_clear_bit(HCI_CONN_BIG_SYNC_FAILED, &conn->flags);
-	test_and_clear_bit(HCI_CONN_PA_SYNC_FAILED, &conn->flags);
-
-	conn->state = BT_CLOSED;
-	hci_connect_cfm(conn, status);
-	hci_conn_del(conn);
-}
-
-/* This function requires the caller holds hdev->lock */
-u8 hci_conn_set_handle(struct hci_conn *conn, u16 handle)
-{
-	struct hci_dev *hdev = conn->hdev;
-
-	bt_dev_dbg(hdev, "hcon %p handle 0x%4.4x", conn, handle);
-
-	if (conn->handle == handle)
-		return 0;
-
-	if (handle > HCI_CONN_HANDLE_MAX) {
-		bt_dev_err(hdev, "Invalid handle: 0x%4.4x > 0x%4.4x",
-			   handle, HCI_CONN_HANDLE_MAX);
-		return HCI_ERROR_INVALID_PARAMETERS;
-	}
-
-	/* If abort_reason has been sent it means the connection is being
-	 * aborted and the handle shall not be changed.
-	 */
-	if (conn->abort_reason)
-		return conn->abort_reason;
-
-	if (HCI_CONN_HANDLE_UNSET(conn->handle))
-		ida_free(&hdev->unset_handle_ida, conn->handle);
-
-	conn->handle = handle;
-
-	return 0;
-}
-
-struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
-				u8 dst_type, bool dst_resolved, u8 sec_level,
-				u16 conn_timeout, u8 role, u8 phy, u8 sec_phy)
-{
-	struct hci_conn *conn;
-	struct smp_irk *irk;
-	int err;
-
-	/* Let's make sure that le is enabled.*/
-	if (!hci_dev_test_flag(hdev, HCI_LE_ENABLED)) {
-		if (lmp_le_capable(hdev))
-			return ERR_PTR(-ECONNREFUSED);
-
-		return ERR_PTR(-EOPNOTSUPP);
-	}
-
-	/* Since the controller supports only one LE connection attempt at a
-	 * time, we return -EBUSY if there is any connection attempt running.
-	 */
-	if (hci_lookup_le_connect(hdev))
-		return ERR_PTR(-EBUSY);
-
-	/* If there's already a connection object but it's not in
-	 * scanning state it means it must already be established, in
-	 * which case we can't do anything else except report a failure
-	 * to connect.
-	 */
-	conn = hci_conn_hash_lookup_le(hdev, dst, dst_type);
-	if (conn && !test_bit(HCI_CONN_SCANNING, &conn->flags)) {
-		return ERR_PTR(-EBUSY);
-	}
-
-	/* Check if the destination address has been resolved by the controller
-	 * since if it did then the identity address shall be used.
-	 */
-	if (!dst_resolved) {
-		/* When given an identity address with existing identity
-		 * resolving key, the connection needs to be established
-		 * to a resolvable random address.
-		 *
-		 * Storing the resolvable random address is required here
-		 * to handle connection failures. The address will later
-		 * be resolved back into the original identity address
-		 * from the connect request.
-		 */
-		irk = hci_find_irk_by_addr(hdev, dst, dst_type);
-		if (irk && bacmp(&irk->rpa, BDADDR_ANY)) {
-			dst = &irk->rpa;
-			dst_type = ADDR_LE_DEV_RANDOM;
-		}
-	}
-
-	if (conn) {
-		bacpy(&conn->dst, dst);
-	} else {
-		conn = hci_conn_add_unset(hdev, LE_LINK, dst, role);
-		if (IS_ERR(conn))
-			return conn;
-		hci_conn_hold(conn);
-		conn->pending_sec_level = sec_level;
-	}
-
-	conn->dst_type = dst_type;
-	conn->sec_level = BT_SECURITY_LOW;
-	conn->conn_timeout = conn_timeout;
-	conn->le_adv_phy = phy;
-	conn->le_adv_sec_phy = sec_phy;
-
-	err = hci_connect_le_sync(hdev, conn);
-	if (err) {
-		hci_conn_del(conn);
-		return ERR_PTR(err);
-	}
-
-	return conn;
-}
-
-static bool is_connected(struct hci_dev *hdev, bdaddr_t *addr, u8 type)
-{
-	struct hci_conn *conn;
-
-	conn = hci_conn_hash_lookup_le(hdev, addr, type);
-	if (!conn)
-		return false;
-
-	if (conn->state != BT_CONNECTED)
-		return false;
-
-	return true;
-}
-
-/* This function requires the caller holds hdev->lock */
-static int hci_explicit_conn_params_set(struct hci_dev *hdev,
-					bdaddr_t *addr, u8 addr_type)
-{
-	struct hci_conn_params *params;
-
-	if (is_connected(hdev, addr, addr_type))
-		return -EISCONN;
-
-	params = hci_conn_params_lookup(hdev, addr, addr_type);
-	if (!params) {
-		params = hci_conn_params_add(hdev, addr, addr_type);
-		if (!params)
-			return -ENOMEM;
-
-		/* If we created new params, mark them to be deleted in
-		 * hci_connect_le_scan_cleanup. It's different case than
-		 * existing disabled params, those will stay after cleanup.
-		 */
-		params->auto_connect = HCI_AUTO_CONN_EXPLICIT;
-	}
-
-	/* We're trying to connect, so make sure params are at pend_le_conns */
-	if (params->auto_connect == HCI_AUTO_CONN_DISABLED ||
-	    params->auto_connect == HCI_AUTO_CONN_REPORT ||
-	    params->auto_connect == HCI_AUTO_CONN_EXPLICIT) {
-		hci_pend_le_list_del_init(params);
-		hci_pend_le_list_add(params, &hdev->pend_le_conns);
-	}
-
-	params->explicit_connect = true;
-
-	BT_DBG("addr %pMR (type %u) auto_connect %u", addr, addr_type,
-	       params->auto_connect);
-
-	return 0;
-}
-
-static int qos_set_big(struct hci_dev *hdev, struct bt_iso_qos *qos)
-{
-	struct hci_conn *conn;
-	u8  big;
-
-	/* Allocate a BIG if not set */
-	if (qos->bcast.big == BT_ISO_QOS_BIG_UNSET) {
-		for (big = 0x00; big < 0xef; big++) {
-
-			conn = hci_conn_hash_lookup_big(hdev, big);
-			if (!conn)
-				break;
-		}
-
-		if (big == 0xef)
-			return -EADDRNOTAVAIL;
-
-		/* Update BIG */
-		qos->bcast.big = big;
-	}
-
-	return 0;
-}
-
-static int qos_set_bis(struct hci_dev *hdev, struct bt_iso_qos *qos)
-{
-	struct hci_conn *conn;
-	u8  bis;
-
-	/* Allocate BIS if not set */
-	if (qos->bcast.bis == BT_ISO_QOS_BIS_UNSET) {
-		if (qos->bcast.big != BT_ISO_QOS_BIG_UNSET) {
-			conn = hci_conn_hash_lookup_big(hdev, qos->bcast.big);
-
-			if (conn) {
-				/* If the BIG handle is already matched to an advertising
-				 * handle, do not allocate a new one.
-				 */
-				qos->bcast.bis = conn->iso_qos.bcast.bis;
-				return 0;
-			}
-		}
-
-		/* Find an unused adv set to advertise BIS, skip instance 0x00
-		 * since it is reserved as general purpose set.
-		 */
-		for (bis = 0x01; bis < hdev->le_num_of_adv_sets;
-		     bis++) {
-
-			conn = hci_conn_hash_lookup_bis(hdev, BDADDR_ANY, bis);
-			if (!conn)
-				break;
-		}
-
-		if (bis == hdev->le_num_of_adv_sets)
-			return -EADDRNOTAVAIL;
-
-		/* Update BIS */
-		qos->bcast.bis = bis;
-	}
-
-	return 0;
-}
-
-/* This function requires the caller holds hdev->lock */
-static struct hci_conn *hci_add_bis(struct hci_dev *hdev, bdaddr_t *dst,
-				    __u8 sid, struct bt_iso_qos *qos,
-				    __u8 base_len, __u8 *base)
-{
-	struct hci_conn *conn;
-	int err;
-
-	/* Let's make sure that le is enabled.*/
-	if (!hci_dev_test_flag(hdev, HCI_LE_ENABLED)) {
-		if (lmp_le_capable(hdev))
-			return ERR_PTR(-ECONNREFUSED);
-		return ERR_PTR(-EOPNOTSUPP);
-	}
-
-	err = qos_set_big(hdev, qos);
-	if (err)
-		return ERR_PTR(err);
-
-	err = qos_set_bis(hdev, qos);
-	if (err)
-		return ERR_PTR(err);
-
-	/* Check if the LE Create BIG command has already been sent */
-	conn = hci_conn_hash_lookup_per_adv_bis(hdev, dst, qos->bcast.big,
-						qos->bcast.big);
-	if (conn)
-		return ERR_PTR(-EADDRINUSE);
-
-	/* Check BIS settings against other bound BISes, since all
-	 * BISes in a BIG must have the same value for all parameters
-	 */
-	conn = hci_conn_hash_lookup_big(hdev, qos->bcast.big);
-
-	if (conn && (memcmp(qos, &conn->iso_qos, sizeof(*qos)) ||
-		     base_len != conn->le_per_adv_data_len ||
-		     memcmp(conn->le_per_adv_data, base, base_len)))
-		return ERR_PTR(-EADDRINUSE);
-
-	conn = hci_conn_add_unset(hdev, BIS_LINK, dst, HCI_ROLE_MASTER);
-	if (IS_ERR(conn))
-		return conn;
-
-	conn->state = BT_CONNECT;
-	conn->sid = sid;
-
-	hci_conn_hold(conn);
-	return conn;
-}
-
-/* This function requires the caller holds hdev->lock */
-struct hci_conn *hci_connect_le_scan(struct hci_dev *hdev, bdaddr_t *dst,
-				     u8 dst_type, u8 sec_level,
-				     u16 conn_timeout,
-				     enum conn_reasons conn_reason)
-{
-	struct hci_conn *conn;
-
-	/* Let's make sure that le is enabled.*/
-	if (!hci_dev_test_flag(hdev, HCI_LE_ENABLED)) {
-		if (lmp_le_capable(hdev))
-			return ERR_PTR(-ECONNREFUSED);
-
-		return ERR_PTR(-EOPNOTSUPP);
-	}
-
-	/* Some devices send ATT messages as soon as the physical link is
-	 * established. To be able to handle these ATT messages, the user-
-	 * space first establishes the connection and then starts the pairing
-	 * process.
-	 *
-	 * So if a hci_conn object already exists for the following connection
-	 * attempt, we simply update pending_sec_level and auth_type fields
-	 * and return the object found.
-	 */
-	conn = hci_conn_hash_lookup_le(hdev, dst, dst_type);
-	if (conn) {
-		if (conn->pending_sec_level < sec_level)
-			conn->pending_sec_level = sec_level;
-		goto done;
-	}
-
-	BT_DBG("requesting refresh of dst_addr");
-
-	conn = hci_conn_add_unset(hdev, LE_LINK, dst, HCI_ROLE_MASTER);
-	if (IS_ERR(conn))
-		return conn;
-
-	if (hci_explicit_conn_params_set(hdev, dst, dst_type) < 0) {
-		hci_conn_del(conn);
-		return ERR_PTR(-EBUSY);
-	}
-
-	conn->state = BT_CONNECT;
-	set_bit(HCI_CONN_SCANNING, &conn->flags);
-	conn->dst_type = dst_type;
-	conn->sec_level = BT_SECURITY_LOW;
-	conn->pending_sec_level = sec_level;
-	conn->conn_timeout = conn_timeout;
-	conn->conn_reason = conn_reason;
-
-	hci_update_passive_scan(hdev);
-
-done:
-	hci_conn_hold(conn);
-	return conn;
-}
-
-struct hci_conn *hci_connect_acl(struct hci_dev *hdev, bdaddr_t *dst,
-				 u8 sec_level, u8 auth_type,
-				 enum conn_reasons conn_reason, u16 timeout)
-{
-	struct hci_conn *acl;
-
-	if (!hci_dev_test_flag(hdev, HCI_BREDR_ENABLED)) {
-		if (lmp_bredr_capable(hdev))
-			return ERR_PTR(-ECONNREFUSED);
-
-		return ERR_PTR(-EOPNOTSUPP);
-	}
-
-	/* Reject outgoing connection to device with same BD ADDR against
-	 * CVE-2020-26555
-	 */
-	if (!bacmp(&hdev->bdaddr, dst)) {
-		bt_dev_dbg(hdev, "Reject connection with same BD_ADDR %pMR\n",
-			   dst);
-		return ERR_PTR(-ECONNREFUSED);
-	}
-
-	acl = hci_conn_hash_lookup_ba(hdev, ACL_LINK, dst);
-	if (!acl) {
-		acl = hci_conn_add_unset(hdev, ACL_LINK, dst, HCI_ROLE_MASTER);
-		if (IS_ERR(acl))
-			return acl;
-	}
-
-	hci_conn_hold(acl);
-
-	acl->conn_reason = conn_reason;
-	if (acl->state == BT_OPEN || acl->state == BT_CLOSED) {
-		int err;
-
-		acl->sec_level = BT_SECURITY_LOW;
-		acl->pending_sec_level = sec_level;
-		acl->auth_type = auth_type;
-		acl->conn_timeout = timeout;
-
-		err = hci_connect_acl_sync(hdev, acl);
-		if (err) {
-			hci_conn_del(acl);
-			return ERR_PTR(err);
-		}
-	}
-
-	return acl;
-}
-
-static struct hci_link *hci_conn_link(struct hci_conn *parent,
-				      struct hci_conn *conn)
-{
-	struct hci_dev *hdev = parent->hdev;
-	struct hci_link *link;
-
-	bt_dev_dbg(hdev, "parent %p hcon %p", parent, conn);
-
-	if (conn->link)
-		return conn->link;
-
-	if (conn->parent)
-		return NULL;
-
-	link = kzalloc(sizeof(*link), GFP_KERNEL);
-	if (!link)
-		return NULL;
-
-	link->conn = hci_conn_hold(conn);
-	conn->link = link;
-	conn->parent = hci_conn_get(parent);
-
-	/* Use list_add_tail_rcu append to the list */
-	list_add_tail_rcu(&link->list, &parent->link_list);
-
-	return link;
-}
-
-struct hci_conn *hci_connect_sco(struct hci_dev *hdev, int type, bdaddr_t *dst,
-				 __u16 setting, struct bt_codec *codec,
-				 u16 timeout)
-{
-	struct hci_conn *acl;
-	struct hci_conn *sco;
-	struct hci_link *link;
-
-	acl = hci_connect_acl(hdev, dst, BT_SECURITY_LOW, HCI_AT_NO_BONDING,
-			      CONN_REASON_SCO_CONNECT, timeout);
-	if (IS_ERR(acl))
-		return acl;
-
-	sco = hci_conn_hash_lookup_ba(hdev, type, dst);
-	if (!sco) {
-		sco = hci_conn_add_unset(hdev, type, dst, HCI_ROLE_MASTER);
-		if (IS_ERR(sco)) {
-			hci_conn_drop(acl);
-			return sco;
-		}
-	}
-
-	link = hci_conn_link(acl, sco);
-	if (!link) {
-		hci_conn_drop(acl);
-		hci_conn_drop(sco);
-		return ERR_PTR(-ENOLINK);
-	}
-
-	sco->setting = setting;
-	sco->codec = *codec;
-
-	if (acl->state == BT_CONNECTED &&
-	    (sco->state == BT_OPEN || sco->state == BT_CLOSED)) {
-		set_bit(HCI_CONN_POWER_SAVE, &acl->flags);
-		hci_conn_enter_active_mode(acl, BT_POWER_FORCE_ACTIVE_ON);
-
-		if (test_bit(HCI_CONN_MODE_CHANGE_PEND, &acl->flags)) {
-			/* defer SCO setup until mode change completed */
-			set_bit(HCI_CONN_SCO_SETUP_PEND, &acl->flags);
-			return sco;
-		}
-
-		hci_sco_setup(acl, 0x00);
-	}
-
-	return sco;
-}
-
-static int hci_le_create_big(struct hci_conn *conn, struct bt_iso_qos *qos)
-{
-	struct hci_dev *hdev = conn->hdev;
-	struct hci_cp_le_create_big cp;
-	struct iso_list_data data;
-
-	memset(&cp, 0, sizeof(cp));
-
-	data.big = qos->bcast.big;
-	data.bis = qos->bcast.bis;
-	data.count = 0;
-
-	/* Create a BIS for each bound connection */
-	hci_conn_hash_list_state(hdev, bis_list, BIS_LINK,
-				 BT_BOUND, &data);
-
-	cp.handle = qos->bcast.big;
-	cp.adv_handle = qos->bcast.bis;
-	cp.num_bis  = data.count;
-	hci_cpu_to_le24(qos->bcast.out.interval, cp.bis.sdu_interval);
-	cp.bis.sdu = cpu_to_le16(qos->bcast.out.sdu);
-	cp.bis.latency =  cpu_to_le16(qos->bcast.out.latency);
-	cp.bis.rtn  = qos->bcast.out.rtn;
-	cp.bis.phy  = qos->bcast.out.phy;
-	cp.bis.packing = qos->bcast.packing;
-	cp.bis.framing = qos->bcast.framing;
-	cp.bis.encryption = qos->bcast.encryption;
-	memcpy(cp.bis.bcode, qos->bcast.bcode, sizeof(cp.bis.bcode));
-
-	return hci_send_cmd(hdev, HCI_OP_LE_CREATE_BIG, sizeof(cp), &cp);
-}
-
-static int set_cig_params_sync(struct hci_dev *hdev, void *data)
-{
-	DEFINE_FLEX(struct hci_cp_le_set_cig_params, pdu, cis, num_cis, 0x1f);
-	u8 cig_id = PTR_UINT(data);
-	struct hci_conn *conn;
-	struct bt_iso_qos *qos;
-	u8 aux_num_cis = 0;
-	u8 cis_id;
-
-	conn = hci_conn_hash_lookup_cig(hdev, cig_id);
-	if (!conn)
-		return 0;
-
-	qos = &conn->iso_qos;
-	pdu->cig_id = cig_id;
-	hci_cpu_to_le24(qos->ucast.out.interval, pdu->c_interval);
-	hci_cpu_to_le24(qos->ucast.in.interval, pdu->p_interval);
-	pdu->sca = qos->ucast.sca;
-	pdu->packing = qos->ucast.packing;
-	pdu->framing = qos->ucast.framing;
-	pdu->c_latency = cpu_to_le16(qos->ucast.out.latency);
-	pdu->p_latency = cpu_to_le16(qos->ucast.in.latency);
-
-	/* Reprogram all CIS(s) with the same CIG, valid range are:
-	 * num_cis: 0x00 to 0x1F
-	 * cis_id: 0x00 to 0xEF
-	 */
-	for (cis_id = 0x00; cis_id < 0xf0 &&
-	     aux_num_cis < pdu->num_cis; cis_id++) {
-		struct hci_cis_params *cis;
-
-		conn = hci_conn_hash_lookup_cis(hdev, NULL, 0, cig_id, cis_id);
-		if (!conn)
-			continue;
-
-		qos = &conn->iso_qos;
-
-		cis = &pdu->cis[aux_num_cis++];
-		cis->cis_id = cis_id;
-		cis->c_sdu  = cpu_to_le16(conn->iso_qos.ucast.out.sdu);
-		cis->p_sdu  = cpu_to_le16(conn->iso_qos.ucast.in.sdu);
-		cis->c_phy  = qos->ucast.out.phy ? qos->ucast.out.phy :
-			      qos->ucast.in.phy;
-		cis->p_phy  = qos->ucast.in.phy ? qos->ucast.in.phy :
-			      qos->ucast.out.phy;
-		cis->c_rtn  = qos->ucast.out.rtn;
-		cis->p_rtn  = qos->ucast.in.rtn;
-	}
-	pdu->num_cis = aux_num_cis;
-
-	if (!pdu->num_cis)
-		return 0;
-
-	return __hci_cmd_sync_status(hdev, HCI_OP_LE_SET_CIG_PARAMS,
-				     struct_size(pdu, cis, pdu->num_cis),
-				     pdu, HCI_CMD_TIMEOUT);
-}
-
-static bool hci_le_set_cig_params(struct hci_conn *conn, struct bt_iso_qos *qos)
-{
-	struct hci_dev *hdev = conn->hdev;
-	struct iso_list_data data;
-
-	memset(&data, 0, sizeof(data));
-
-	/* Allocate first still reconfigurable CIG if not set */
-	if (qos->ucast.cig == BT_ISO_QOS_CIG_UNSET) {
-		for (data.cig = 0x00; data.cig < 0xf0; data.cig++) {
-			data.count = 0;
-
-			hci_conn_hash_list_state(hdev, find_cis, CIS_LINK,
-						 BT_CONNECT, &data);
-			if (data.count)
-				continue;
-
-			hci_conn_hash_list_state(hdev, find_cis, CIS_LINK,
-						 BT_CONNECTED, &data);
-			if (!data.count)
-				break;
-		}
-
-		if (data.cig == 0xf0)
-			return false;
-
-		/* Update CIG */
-		qos->ucast.cig = data.cig;
-	}
-
-	if (qos->ucast.cis != BT_ISO_QOS_CIS_UNSET) {
-		if (hci_conn_hash_lookup_cis(hdev, NULL, 0, qos->ucast.cig,
-					     qos->ucast.cis))
-			return false;
-		goto done;
-	}
-
-	/* Allocate first available CIS if not set */
-	for (data.cig = qos->ucast.cig, data.cis = 0x00; data.cis < 0xf0;
-	     data.cis++) {
-		if (!hci_conn_hash_lookup_cis(hdev, NULL, 0, data.cig,
-					      data.cis)) {
-			/* Update CIS */
-			qos->ucast.cis = data.cis;
-			break;
-		}
-	}
-
-	if (qos->ucast.cis == BT_ISO_QOS_CIS_UNSET)
-		return false;
-
-done:
-	if (hci_cmd_sync_queue(hdev, set_cig_params_sync,
-			       UINT_PTR(qos->ucast.cig), NULL) < 0)
-		return false;
-
-	return true;
-}
-
-struct hci_conn *hci_bind_cis(struct hci_dev *hdev, bdaddr_t *dst,
-			      __u8 dst_type, struct bt_iso_qos *qos)
-{
-	struct hci_conn *cis;
-
-	cis = hci_conn_hash_lookup_cis(hdev, dst, dst_type, qos->ucast.cig,
-				       qos->ucast.cis);
-	if (!cis) {
-		cis = hci_conn_add_unset(hdev, CIS_LINK, dst,
-					 HCI_ROLE_MASTER);
-		if (IS_ERR(cis))
-			return cis;
-		cis->cleanup = cis_cleanup;
-		cis->dst_type = dst_type;
-		cis->iso_qos.ucast.cig = BT_ISO_QOS_CIG_UNSET;
-		cis->iso_qos.ucast.cis = BT_ISO_QOS_CIS_UNSET;
-	}
-
-	if (cis->state == BT_CONNECTED)
-		return cis;
-
-	/* Check if CIS has been set and the settings matches */
-	if (cis->state == BT_BOUND &&
-	    !memcmp(&cis->iso_qos, qos, sizeof(*qos)))
-		return cis;
-
-	/* Update LINK PHYs according to QoS preference */
-	cis->le_tx_phy = qos->ucast.out.phy;
-	cis->le_rx_phy = qos->ucast.in.phy;
-
-	/* If output interval is not set use the input interval as it cannot be
-	 * 0x000000.
-	 */
-	if (!qos->ucast.out.interval)
-		qos->ucast.out.interval = qos->ucast.in.interval;
-
-	/* If input interval is not set use the output interval as it cannot be
-	 * 0x000000.
-	 */
-	if (!qos->ucast.in.interval)
-		qos->ucast.in.interval = qos->ucast.out.interval;
-
-	/* If output latency is not set use the input latency as it cannot be
-	 * 0x0000.
-	 */
-	if (!qos->ucast.out.latency)
-		qos->ucast.out.latency = qos->ucast.in.latency;
-
-	/* If input latency is not set use the output latency as it cannot be
-	 * 0x0000.
-	 */
-	if (!qos->ucast.in.latency)
-		qos->ucast.in.latency = qos->ucast.out.latency;
-
-	if (!hci_le_set_cig_params(cis, qos)) {
-		hci_conn_drop(cis);
-		return ERR_PTR(-EINVAL);
-	}
-
-	hci_conn_hold(cis);
-
-	cis->iso_qos = *qos;
-	cis->state = BT_BOUND;
-
-	return cis;
-}
-
-bool hci_iso_setup_path(struct hci_conn *conn)
-{
-	struct hci_dev *hdev = conn->hdev;
-	struct hci_cp_le_setup_iso_path cmd;
-
-	memset(&cmd, 0, sizeof(cmd));
-
-	if (conn->iso_qos.ucast.out.sdu) {
-		cmd.handle = cpu_to_le16(conn->handle);
-		cmd.direction = 0x00; /* Input (Host to Controller) */
-		cmd.path = 0x00; /* HCI path if enabled */
-		cmd.codec = 0x03; /* Transparent Data */
-
-		if (hci_send_cmd(hdev, HCI_OP_LE_SETUP_ISO_PATH, sizeof(cmd),
-				 &cmd) < 0)
-			return false;
-	}
-
-	if (conn->iso_qos.ucast.in.sdu) {
-		cmd.handle = cpu_to_le16(conn->handle);
-		cmd.direction = 0x01; /* Output (Controller to Host) */
-		cmd.path = 0x00; /* HCI path if enabled */
-		cmd.codec = 0x03; /* Transparent Data */
-
-		if (hci_send_cmd(hdev, HCI_OP_LE_SETUP_ISO_PATH, sizeof(cmd),
-				 &cmd) < 0)
-			return false;
-	}
-
-	return true;
-}
-
-int hci_conn_check_create_cis(struct hci_conn *conn)
-{
-	if (conn->type != CIS_LINK)
-		return -EINVAL;
-
-	if (!conn->parent || conn->parent->state != BT_CONNECTED ||
-	    conn->state != BT_CONNECT || HCI_CONN_HANDLE_UNSET(conn->handle))
-		return 1;
-
-	return 0;
-}
-
-static int hci_create_cis_sync(struct hci_dev *hdev, void *data)
-{
-	return hci_le_create_cis_sync(hdev);
-}
-
-int hci_le_create_cis_pending(struct hci_dev *hdev)
-{
-	struct hci_conn *conn;
-	bool pending = false;
-
-	rcu_read_lock();
-
-	list_for_each_entry_rcu(conn, &hdev->conn_hash.list, list) {
-		if (test_bit(HCI_CONN_CREATE_CIS, &conn->flags)) {
-			rcu_read_unlock();
-			return -EBUSY;
-		}
-
-		if (!hci_conn_check_create_cis(conn))
-			pending = true;
-	}
-
-	rcu_read_unlock();
-
-	if (!pending)
-		return 0;
-
-	/* Queue Create CIS */
-	return hci_cmd_sync_queue(hdev, hci_create_cis_sync, NULL, NULL);
-}
-
-static void hci_iso_qos_setup(struct hci_dev *hdev, struct hci_conn *conn,
-			      struct bt_iso_io_qos *qos, __u8 phy)
-{
-	/* Only set MTU if PHY is enabled */
-	if (!qos->sdu && qos->phy)
-		qos->sdu = conn->mtu;
-
-	/* Use the same PHY as ACL if set to any */
-	if (qos->phy == BT_ISO_PHY_ANY)
-		qos->phy = phy;
-
-	/* Use LE ACL connection interval if not set */
-	if (!qos->interval)
-		/* ACL interval unit in 1.25 ms to us */
-		qos->interval = conn->le_conn_interval * 1250;
-
-	/* Use LE ACL connection latency if not set */
-	if (!qos->latency)
-		qos->latency = conn->le_conn_latency;
-}
-
-static int create_big_sync(struct hci_dev *hdev, void *data)
-{
-	struct hci_conn *conn = data;
-	struct bt_iso_qos *qos = &conn->iso_qos;
-	u16 interval, sync_interval = 0;
-	u32 flags = 0;
-	int err;
-
-	if (qos->bcast.out.phy == 0x02)
-		flags |= MGMT_ADV_FLAG_SEC_2M;
-
-	/* Align intervals */
-	interval = (qos->bcast.out.interval / 1250) * qos->bcast.sync_factor;
-
-	if (qos->bcast.bis)
-		sync_interval = interval * 4;
-
-	err = hci_start_per_adv_sync(hdev, qos->bcast.bis, conn->sid,
-				     conn->le_per_adv_data_len,
-				     conn->le_per_adv_data, flags, interval,
-				     interval, sync_interval);
-	if (err)
-		return err;
-
-	return hci_le_create_big(conn, &conn->iso_qos);
-}
-
-struct hci_conn *hci_pa_create_sync(struct hci_dev *hdev, bdaddr_t *dst,
-				    __u8 dst_type, __u8 sid,
-				    struct bt_iso_qos *qos)
-{
-	struct hci_conn *conn;
-
-	bt_dev_dbg(hdev, "dst %pMR type %d sid %d", dst, dst_type, sid);
-
-	conn = hci_conn_add_unset(hdev, PA_LINK, dst, HCI_ROLE_SLAVE);
-	if (IS_ERR(conn))
-		return conn;
-
-	conn->iso_qos = *qos;
-	conn->dst_type = dst_type;
-	conn->sid = sid;
-	conn->state = BT_LISTEN;
-	conn->conn_timeout = msecs_to_jiffies(qos->bcast.sync_timeout * 10);
-
-	hci_conn_hold(conn);
-
-	hci_connect_pa_sync(hdev, conn);
-
-	return conn;
-}
-
-int hci_conn_big_create_sync(struct hci_dev *hdev, struct hci_conn *hcon,
-			     struct bt_iso_qos *qos, __u16 sync_handle,
-			     __u8 num_bis, __u8 bis[])
-{
-	int err;
-
-	if (num_bis < 0x01 || num_bis > ISO_MAX_NUM_BIS)
-		return -EINVAL;
-
-	err = qos_set_big(hdev, qos);
-	if (err)
-		return err;
-
-	if (hcon) {
-		/* Update hcon QoS */
-		hcon->iso_qos = *qos;
-
-		hcon->num_bis = num_bis;
-		memcpy(hcon->bis, bis, num_bis);
-		hcon->conn_timeout = msecs_to_jiffies(qos->bcast.timeout * 10);
-	}
-
-	return hci_connect_big_sync(hdev, hcon);
-}
-
-static void create_big_complete(struct hci_dev *hdev, void *data, int err)
-{
-	struct hci_conn *conn = data;
-
-	bt_dev_dbg(hdev, "conn %p", conn);
-
-	if (err) {
-		bt_dev_err(hdev, "Unable to create BIG: %d", err);
-		hci_connect_cfm(conn, err);
-		hci_conn_del(conn);
-	}
-}
-
-struct hci_conn *hci_bind_bis(struct hci_dev *hdev, bdaddr_t *dst, __u8 sid,
-			      struct bt_iso_qos *qos,
-			      __u8 base_len, __u8 *base)
-{
-	struct hci_conn *conn;
-	struct hci_conn *parent;
-	__u8 eir[HCI_MAX_PER_AD_LENGTH];
-	struct hci_link *link;
-
-	/* Look for any BIS that is open for rebinding */
-	conn = hci_conn_hash_lookup_big_state(hdev, qos->bcast.big, BT_OPEN,
-					      HCI_ROLE_MASTER);
-	if (conn) {
-		memcpy(qos, &conn->iso_qos, sizeof(*qos));
-		conn->state = BT_CONNECTED;
-		return conn;
-	}
-
-	if (base_len && base)
-		base_len = eir_append_service_data(eir, 0,  0x1851,
-						   base, base_len);
-
-	/* We need hci_conn object using the BDADDR_ANY as dst */
-	conn = hci_add_bis(hdev, dst, sid, qos, base_len, eir);
-	if (IS_ERR(conn))
-		return conn;
-
-	/* Update LINK PHYs according to QoS preference */
-	conn->le_tx_phy = qos->bcast.out.phy;
-	conn->le_tx_phy = qos->bcast.out.phy;
-
-	/* Add Basic Announcement into Peridic Adv Data if BASE is set */
-	if (base_len && base) {
-		memcpy(conn->le_per_adv_data,  eir, sizeof(eir));
-		conn->le_per_adv_data_len = base_len;
-	}
-
-	hci_iso_qos_setup(hdev, conn, &qos->bcast.out,
-			  conn->le_tx_phy ? conn->le_tx_phy :
-			  hdev->le_tx_def_phys);
-
-	conn->iso_qos = *qos;
-	conn->state = BT_BOUND;
-
-	/* Link BISes together */
-	parent = hci_conn_hash_lookup_big(hdev,
-					  conn->iso_qos.bcast.big);
-	if (parent && parent != conn) {
-		link = hci_conn_link(parent, conn);
-		hci_conn_drop(conn);
-		if (!link)
-			return ERR_PTR(-ENOLINK);
-	}
-
-	return conn;
-}
-
-static void bis_mark_per_adv(struct hci_conn *conn, void *data)
-{
-	struct iso_list_data *d = data;
-
-	/* Skip if not broadcast/ANY address */
-	if (bacmp(&conn->dst, BDADDR_ANY))
-		return;
-
-	if (d->big != conn->iso_qos.bcast.big ||
-	    d->bis == BT_ISO_QOS_BIS_UNSET ||
-	    d->bis != conn->iso_qos.bcast.bis)
-		return;
-
-	set_bit(HCI_CONN_PER_ADV, &conn->flags);
-}
-
-struct hci_conn *hci_connect_bis(struct hci_dev *hdev, bdaddr_t *dst,
-				 __u8 dst_type, __u8 sid,
-				 struct bt_iso_qos *qos,
-				 __u8 base_len, __u8 *base)
-{
-	struct hci_conn *conn;
-	int err;
-	struct iso_list_data data;
-
-	conn = hci_bind_bis(hdev, dst, sid, qos, base_len, base);
-	if (IS_ERR(conn))
-		return conn;
-
-	if (conn->state == BT_CONNECTED)
-		return conn;
-
-	/* Check if SID needs to be allocated then search for the first
-	 * available.
-	 */
-	if (conn->sid == HCI_SID_INVALID) {
-		u8 sid;
-
-		for (sid = 0; sid <= 0x0f; sid++) {
-			if (!hci_find_adv_sid(hdev, sid)) {
-				conn->sid = sid;
-				break;
-			}
-		}
-	}
-
-	data.big = qos->bcast.big;
-	data.bis = qos->bcast.bis;
-
-	/* Set HCI_CONN_PER_ADV for all bound connections, to mark that
-	 * the start periodic advertising and create BIG commands have
-	 * been queued
-	 */
-	hci_conn_hash_list_state(hdev, bis_mark_per_adv, PA_LINK,
-				 BT_BOUND, &data);
-
-	/* Queue start periodic advertising and create BIG */
-	err = hci_cmd_sync_queue(hdev, create_big_sync, conn,
-				 create_big_complete);
-	if (err < 0) {
-		hci_conn_drop(conn);
-		return ERR_PTR(err);
-	}
-
-	return conn;
-}
-
-struct hci_conn *hci_connect_cis(struct hci_dev *hdev, bdaddr_t *dst,
-				 __u8 dst_type, struct bt_iso_qos *qos)
-{
-	struct hci_conn *le;
-	struct hci_conn *cis;
-	struct hci_link *link;
-
-	if (hci_dev_test_flag(hdev, HCI_ADVERTISING))
-		le = hci_connect_le(hdev, dst, dst_type, false,
-				    BT_SECURITY_LOW,
-				    HCI_LE_CONN_TIMEOUT,
-				    HCI_ROLE_SLAVE, 0, 0);
-	else
-		le = hci_connect_le_scan(hdev, dst, dst_type,
-					 BT_SECURITY_LOW,
-					 HCI_LE_CONN_TIMEOUT,
-					 CONN_REASON_ISO_CONNECT);
-	if (IS_ERR(le))
-		return le;
-
-	hci_iso_qos_setup(hdev, le, &qos->ucast.out,
-			  le->le_tx_phy ? le->le_tx_phy : hdev->le_tx_def_phys);
-	hci_iso_qos_setup(hdev, le, &qos->ucast.in,
-			  le->le_rx_phy ? le->le_rx_phy : hdev->le_rx_def_phys);
-
-	cis = hci_bind_cis(hdev, dst, dst_type, qos);
-	if (IS_ERR(cis)) {
-		hci_conn_drop(le);
-		return cis;
-	}
-
-	link = hci_conn_link(le, cis);
-	hci_conn_drop(cis);
-	if (!link) {
-		hci_conn_drop(le);
-		return ERR_PTR(-ENOLINK);
-	}
-
-	cis->state = BT_CONNECT;
-
-	hci_le_create_cis_pending(hdev);
-
-	return cis;
-}
-
-/* Check link security requirement */
-int hci_conn_check_link_mode(struct hci_conn *conn)
-{
-	BT_DBG("hcon %p", conn);
-
-	/* In Secure Connections Only mode, it is required that Secure
-	 * Connections is used and the link is encrypted with AES-CCM
-	 * using a P-256 authenticated combination key.
-	 */
-	if (hci_dev_test_flag(conn->hdev, HCI_SC_ONLY)) {
-		if (!hci_conn_sc_enabled(conn) ||
-		    !test_bit(HCI_CONN_AES_CCM, &conn->flags) ||
-		    conn->key_type != HCI_LK_AUTH_COMBINATION_P256)
-			return 0;
-	}
-
-	 /* AES encryption is required for Level 4:
-	  *
-	  * BLUETOOTH CORE SPECIFICATION Version 5.2 | Vol 3, Part C
-	  * page 1319:
-	  *
-	  * 128-bit equivalent strength for link and encryption keys
-	  * required using FIPS approved algorithms (E0 not allowed,
-	  * SAFER+ not allowed, and P-192 not allowed; encryption key
-	  * not shortened)
-	  */
-	if (conn->sec_level == BT_SECURITY_FIPS &&
-	    !test_bit(HCI_CONN_AES_CCM, &conn->flags)) {
-		bt_dev_err(conn->hdev,
-			   "Invalid security: Missing AES-CCM usage");
-		return 0;
-	}
-
-	if (hci_conn_ssp_enabled(conn) &&
-	    !test_bit(HCI_CONN_ENCRYPT, &conn->flags))
-		return 0;
-
-	return 1;
-}
-
-/* Authenticate remote device */
-static int hci_conn_auth(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
-{
-	BT_DBG("hcon %p", conn);
-
-	if (conn->pending_sec_level > sec_level)
-		sec_level = conn->pending_sec_level;
-
-	if (sec_level > conn->sec_level)
-		conn->pending_sec_level = sec_level;
-	else if (test_bit(HCI_CONN_AUTH, &conn->flags))
-		return 1;
-
-	/* Make sure we preserve an existing MITM requirement*/
-	auth_type |= (conn->auth_type & 0x01);
-
-	conn->auth_type = auth_type;
-
-	if (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->flags)) {
-		struct hci_cp_auth_requested cp;
-
-		cp.handle = cpu_to_le16(conn->handle);
-		hci_send_cmd(conn->hdev, HCI_OP_AUTH_REQUESTED,
-			     sizeof(cp), &cp);
-
-		/* Set the ENCRYPT_PEND to trigger encryption after
-		 * authentication.
-		 */
-		if (!test_bit(HCI_CONN_ENCRYPT, &conn->flags))
-			set_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags);
-	}
-
-	return 0;
-}
-
-/* Encrypt the link */
-static void hci_conn_encrypt(struct hci_conn *conn)
-{
-	BT_DBG("hcon %p", conn);
-
-	if (!test_and_set_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags)) {
-		struct hci_cp_set_conn_encrypt cp;
-		cp.handle  = cpu_to_le16(conn->handle);
-		cp.encrypt = 0x01;
-		hci_send_cmd(conn->hdev, HCI_OP_SET_CONN_ENCRYPT, sizeof(cp),
-			     &cp);
-	}
-}
-
-/* Enable security */
-int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type,
-		      bool initiator)
-{
-	BT_DBG("hcon %p", conn);
-
-	if (conn->type == LE_LINK)
-		return smp_conn_security(conn, sec_level);
-
-	/* For sdp we don't need the link key. */
-	if (sec_level == BT_SECURITY_SDP)
-		return 1;
-
-	/* For non 2.1 devices and low security level we don't need the link
-	   key. */
-	if (sec_level == BT_SECURITY_LOW && !hci_conn_ssp_enabled(conn))
-		return 1;
-
-	/* For other security levels we need the link key. */
-	if (!test_bit(HCI_CONN_AUTH, &conn->flags))
-		goto auth;
-
-	switch (conn->key_type) {
-	case HCI_LK_AUTH_COMBINATION_P256:
-		/* An authenticated FIPS approved combination key has
-		 * sufficient security for security level 4 or lower.
-		 */
-		if (sec_level <= BT_SECURITY_FIPS)
-			goto encrypt;
-		break;
-	case HCI_LK_AUTH_COMBINATION_P192:
-		/* An authenticated combination key has sufficient security for
-		 * security level 3 or lower.
-		 */
-		if (sec_level <= BT_SECURITY_HIGH)
-			goto encrypt;
-		break;
-	case HCI_LK_UNAUTH_COMBINATION_P192:
-	case HCI_LK_UNAUTH_COMBINATION_P256:
-		/* An unauthenticated combination key has sufficient security
-		 * for security level 2 or lower.
-		 */
-		if (sec_level <= BT_SECURITY_MEDIUM)
-			goto encrypt;
-		break;
-	case HCI_LK_COMBINATION:
-		/* A combination key has always sufficient security for the
-		 * security levels 2 or lower. High security level requires the
-		 * combination key is generated using maximum PIN code length
-		 * (16). For pre 2.1 units.
-		 */
-		if (sec_level <= BT_SECURITY_MEDIUM || conn->pin_length == 16)
-			goto encrypt;
-		break;
-	default:
-		break;
-	}
-
-auth:
-	if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags))
-		return 0;
-
-	if (initiator)
-		set_bit(HCI_CONN_AUTH_INITIATOR, &conn->flags);
-
-	if (!hci_conn_auth(conn, sec_level, auth_type))
-		return 0;
-
-encrypt:
-	if (test_bit(HCI_CONN_ENCRYPT, &conn->flags)) {
-		/* Ensure that the encryption key size has been read,
-		 * otherwise stall the upper layer responses.
-		 */
-		if (!conn->enc_key_size)
-			return 0;
-
-		/* Nothing else needed, all requirements are met */
-		return 1;
-	}
-
-	hci_conn_encrypt(conn);
-	return 0;
-}
-EXPORT_SYMBOL(hci_conn_security);
-
-/* Check secure link requirement */
-int hci_conn_check_secure(struct hci_conn *conn, __u8 sec_level)
-{
-	BT_DBG("hcon %p", conn);
-
-	/* Accept if non-secure or higher security level is required */
-	if (sec_level != BT_SECURITY_HIGH && sec_level != BT_SECURITY_FIPS)
-		return 1;
-
-	/* Accept if secure or higher security level is already present */
-	if (conn->sec_level == BT_SECURITY_HIGH ||
-	    conn->sec_level == BT_SECURITY_FIPS)
-		return 1;
-
-	/* Reject not secure link */
-	return 0;
-}
-EXPORT_SYMBOL(hci_conn_check_secure);
-
-/* Switch role */
-int hci_conn_switch_role(struct hci_conn *conn, __u8 role)
-{
-	BT_DBG("hcon %p", conn);
-
-	if (role == conn->role)
-		return 1;
-
-	if (!test_and_set_bit(HCI_CONN_RSWITCH_PEND, &conn->flags)) {
-		struct hci_cp_switch_role cp;
-		bacpy(&cp.bdaddr, &conn->dst);
-		cp.role = role;
-		hci_send_cmd(conn->hdev, HCI_OP_SWITCH_ROLE, sizeof(cp), &cp);
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL(hci_conn_switch_role);
-
-/* Enter active mode */
-void hci_conn_enter_active_mode(struct hci_conn *conn, __u8 force_active)
-{
-	struct hci_dev *hdev = conn->hdev;
-
-	BT_DBG("hcon %p mode %d", conn, conn->mode);
-
-	if (conn->mode != HCI_CM_SNIFF)
-		goto timer;
-
-	if (!test_bit(HCI_CONN_POWER_SAVE, &conn->flags) && !force_active)
-		goto timer;
-
-	if (!test_and_set_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->flags)) {
-		struct hci_cp_exit_sniff_mode cp;
-		cp.handle = cpu_to_le16(conn->handle);
-		hci_send_cmd(hdev, HCI_OP_EXIT_SNIFF_MODE, sizeof(cp), &cp);
-	}
-
-timer:
-	if (hdev->idle_timeout > 0)
-		queue_delayed_work(hdev->workqueue, &conn->idle_work,
-				   msecs_to_jiffies(hdev->idle_timeout));
-}
-
-/* Drop all connection on the device */
-void hci_conn_hash_flush(struct hci_dev *hdev)
-{
-	struct list_head *head = &hdev->conn_hash.list;
-	struct hci_conn *conn;
-
-	BT_DBG("hdev %s", hdev->name);
-
-	/* We should not traverse the list here, because hci_conn_del
-	 * can remove extra links, which may cause the list traversal
-	 * to hit items that have already been released.
-	 */
-	while ((conn = list_first_entry_or_null(head,
-						struct hci_conn,
-						list)) != NULL) {
-		conn->state = BT_CLOSED;
-		hci_disconn_cfm(conn, HCI_ERROR_LOCAL_HOST_TERM);
-		hci_conn_del(conn);
-	}
-}
-
-static u32 get_link_mode(struct hci_conn *conn)
-{
-	u32 link_mode = 0;
-
-	if (conn->role == HCI_ROLE_MASTER)
-		link_mode |= HCI_LM_MASTER;
-
-	if (test_bit(HCI_CONN_ENCRYPT, &conn->flags))
-		link_mode |= HCI_LM_ENCRYPT;
-
-	if (test_bit(HCI_CONN_AUTH, &conn->flags))
-		link_mode |= HCI_LM_AUTH;
-
-	if (test_bit(HCI_CONN_SECURE, &conn->flags))
-		link_mode |= HCI_LM_SECURE;
-
-	if (test_bit(HCI_CONN_FIPS, &conn->flags))
-		link_mode |= HCI_LM_FIPS;
-
-	return link_mode;
-}
-
-int hci_get_conn_list(void __user *arg)
-{
-	struct hci_conn *c;
-	struct hci_conn_list_req req, *cl;
-	struct hci_conn_info *ci;
-	struct hci_dev *hdev;
-	int n = 0, size, err;
-
-	if (copy_from_user(&req, arg, sizeof(req)))
-		return -EFAULT;
-
-	if (!req.conn_num || req.conn_num > (PAGE_SIZE * 2) / sizeof(*ci))
-		return -EINVAL;
-
-	size = sizeof(req) + req.conn_num * sizeof(*ci);
-
-	cl = kmalloc(size, GFP_KERNEL);
-	if (!cl)
-		return -ENOMEM;
-
-	hdev = hci_dev_get(req.dev_id);
-	if (!hdev) {
-		kfree(cl);
-		return -ENODEV;
-	}
-
-	ci = cl->conn_info;
-
-	hci_dev_lock(hdev);
-	list_for_each_entry(c, &hdev->conn_hash.list, list) {
-		bacpy(&(ci + n)->bdaddr, &c->dst);
-		(ci + n)->handle = c->handle;
-		(ci + n)->type  = c->type;
-		(ci + n)->out   = c->out;
-		(ci + n)->state = c->state;
-		(ci + n)->link_mode = get_link_mode(c);
-		if (++n >= req.conn_num)
-			break;
-	}
-	hci_dev_unlock(hdev);
-
-	cl->dev_id = hdev->id;
-	cl->conn_num = n;
-	size = sizeof(req) + n * sizeof(*ci);
-
-	hci_dev_put(hdev);
-
-	err = copy_to_user(arg, cl, size);
-	kfree(cl);
-
-	return err ? -EFAULT : 0;
-}
-
-int hci_get_conn_info(struct hci_dev *hdev, void __user *arg)
-{
-	struct hci_conn_info_req req;
-	struct hci_conn_info ci;
-	struct hci_conn *conn;
-	char __user *ptr = arg + sizeof(req);
-
-	if (copy_from_user(&req, arg, sizeof(req)))
-		return -EFAULT;
-
-	hci_dev_lock(hdev);
-	conn = hci_conn_hash_lookup_ba(hdev, req.type, &req.bdaddr);
-	if (conn) {
-		bacpy(&ci.bdaddr, &conn->dst);
-		ci.handle = conn->handle;
-		ci.type  = conn->type;
-		ci.out   = conn->out;
-		ci.state = conn->state;
-		ci.link_mode = get_link_mode(conn);
-	}
-	hci_dev_unlock(hdev);
-
-	if (!conn)
-		return -ENOENT;
-
-	return copy_to_user(ptr, &ci, sizeof(ci)) ? -EFAULT : 0;
-}
-
-int hci_get_auth_info(struct hci_dev *hdev, void __user *arg)
-{
-	struct hci_auth_info_req req;
-	struct hci_conn *conn;
-
-	if (copy_from_user(&req, arg, sizeof(req)))
-		return -EFAULT;
-
-	hci_dev_lock(hdev);
-	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &req.bdaddr);
-	if (conn)
-		req.type = conn->auth_type;
-	hci_dev_unlock(hdev);
-
-	if (!conn)
-		return -ENOENT;
-
-	return copy_to_user(arg, &req, sizeof(req)) ? -EFAULT : 0;
-}
-
-struct hci_chan *hci_chan_create(struct hci_conn *conn)
-{
-	struct hci_dev *hdev = conn->hdev;
-	struct hci_chan *chan;
-
-	BT_DBG("%s hcon %p", hdev->name, conn);
-
-	if (test_bit(HCI_CONN_DROP, &conn->flags)) {
-		BT_DBG("Refusing to create new hci_chan");
-		return NULL;
-	}
-
-	chan = kzalloc(sizeof(*chan), GFP_KERNEL);
-	if (!chan)
-		return NULL;
-
-	chan->conn = hci_conn_get(conn);
-	skb_queue_head_init(&chan->data_q);
-	chan->state = BT_CONNECTED;
-
-	list_add_rcu(&chan->list, &conn->chan_list);
-
-	return chan;
-}
-
-void hci_chan_del(struct hci_chan *chan)
-{
-	struct hci_conn *conn = chan->conn;
-	struct hci_dev *hdev = conn->hdev;
-
-	BT_DBG("%s hcon %p chan %p", hdev->name, conn, chan);
-
-	list_del_rcu(&chan->list);
-
-	synchronize_rcu();
-
-	/* Prevent new hci_chan's to be created for this hci_conn */
-	set_bit(HCI_CONN_DROP, &conn->flags);
-
-	hci_conn_put(conn);
-
-	skb_queue_purge(&chan->data_q);
-	kfree(chan);
-}
-
-void hci_chan_list_flush(struct hci_conn *conn)
-{
-	struct hci_chan *chan, *n;
-
-	BT_DBG("hcon %p", conn);
-
-	list_for_each_entry_safe(chan, n, &conn->chan_list, list)
-		hci_chan_del(chan);
-}
-
-static struct hci_chan *__hci_chan_lookup_handle(struct hci_conn *hcon,
-						 __u16 handle)
-{
-	struct hci_chan *hchan;
-
-	list_for_each_entry(hchan, &hcon->chan_list, list) {
-		if (hchan->handle == handle)
-			return hchan;
-	}
-
-	return NULL;
-}
-
-struct hci_chan *hci_chan_lookup_handle(struct hci_dev *hdev, __u16 handle)
-{
-	struct hci_conn_hash *h = &hdev->conn_hash;
-	struct hci_conn *hcon;
-	struct hci_chan *hchan = NULL;
-
-	rcu_read_lock();
-
-	list_for_each_entry_rcu(hcon, &h->list, list) {
-		hchan = __hci_chan_lookup_handle(hcon, handle);
-		if (hchan)
-			break;
-	}
-
-	rcu_read_unlock();
-
-	return hchan;
-}
-
-u32 hci_conn_get_phy(struct hci_conn *conn)
-{
-	u32 phys = 0;
-
-	/* BLUETOOTH CORE SPECIFICATION Version 5.2 | Vol 2, Part B page 471:
-	 * Table 6.2: Packets defined for synchronous, asynchronous, and
-	 * CPB logical transport types.
-	 */
-	switch (conn->type) {
-	case SCO_LINK:
-		/* SCO logical transport (1 Mb/s):
-		 * HV1, HV2, HV3 and DV.
-		 */
-		phys |= BT_PHY_BR_1M_1SLOT;
-
-		break;
-
-	case ACL_LINK:
-		/* ACL logical transport (1 Mb/s) ptt=0:
-		 * DH1, DM3, DH3, DM5 and DH5.
-		 */
-		phys |= BT_PHY_BR_1M_1SLOT;
-
-		if (conn->pkt_type & (HCI_DM3 | HCI_DH3))
-			phys |= BT_PHY_BR_1M_3SLOT;
-
-		if (conn->pkt_type & (HCI_DM5 | HCI_DH5))
-			phys |= BT_PHY_BR_1M_5SLOT;
-
-		/* ACL logical transport (2 Mb/s) ptt=1:
-		 * 2-DH1, 2-DH3 and 2-DH5.
-		 */
-		if (!(conn->pkt_type & HCI_2DH1))
-			phys |= BT_PHY_EDR_2M_1SLOT;
-
-		if (!(conn->pkt_type & HCI_2DH3))
-			phys |= BT_PHY_EDR_2M_3SLOT;
-
-		if (!(conn->pkt_type & HCI_2DH5))
-			phys |= BT_PHY_EDR_2M_5SLOT;
-
-		/* ACL logical transport (3 Mb/s) ptt=1:
-		 * 3-DH1, 3-DH3 and 3-DH5.
-		 */
-		if (!(conn->pkt_type & HCI_3DH1))
-			phys |= BT_PHY_EDR_3M_1SLOT;
-
-		if (!(conn->pkt_type & HCI_3DH3))
-			phys |= BT_PHY_EDR_3M_3SLOT;
-
-		if (!(conn->pkt_type & HCI_3DH5))
-			phys |= BT_PHY_EDR_3M_5SLOT;
-
-		break;
-
-	case ESCO_LINK:
-		/* eSCO logical transport (1 Mb/s): EV3, EV4 and EV5 */
-		phys |= BT_PHY_BR_1M_1SLOT;
-
-		if (!(conn->pkt_type & (ESCO_EV4 | ESCO_EV5)))
-			phys |= BT_PHY_BR_1M_3SLOT;
-
-		/* eSCO logical transport (2 Mb/s): 2-EV3, 2-EV5 */
-		if (!(conn->pkt_type & ESCO_2EV3))
-			phys |= BT_PHY_EDR_2M_1SLOT;
-
-		if (!(conn->pkt_type & ESCO_2EV5))
-			phys |= BT_PHY_EDR_2M_3SLOT;
-
-		/* eSCO logical transport (3 Mb/s): 3-EV3, 3-EV5 */
-		if (!(conn->pkt_type & ESCO_3EV3))
-			phys |= BT_PHY_EDR_3M_1SLOT;
-
-		if (!(conn->pkt_type & ESCO_3EV5))
-			phys |= BT_PHY_EDR_3M_3SLOT;
-
-		break;
-
-	case LE_LINK:
-		if (conn->le_tx_phy & HCI_LE_SET_PHY_1M)
-			phys |= BT_PHY_LE_1M_TX;
-
-		if (conn->le_rx_phy & HCI_LE_SET_PHY_1M)
-			phys |= BT_PHY_LE_1M_RX;
-
-		if (conn->le_tx_phy & HCI_LE_SET_PHY_2M)
-			phys |= BT_PHY_LE_2M_TX;
-
-		if (conn->le_rx_phy & HCI_LE_SET_PHY_2M)
-			phys |= BT_PHY_LE_2M_RX;
-
-		if (conn->le_tx_phy & HCI_LE_SET_PHY_CODED)
-			phys |= BT_PHY_LE_CODED_TX;
-
-		if (conn->le_rx_phy & HCI_LE_SET_PHY_CODED)
-			phys |= BT_PHY_LE_CODED_RX;
-
-		break;
-	}
-
-	return phys;
-}
-
-static int abort_conn_sync(struct hci_dev *hdev, void *data)
-{
-	struct hci_conn *conn = data;
-
-	if (!hci_conn_valid(hdev, conn))
-		return -ECANCELED;
-
-	return hci_abort_conn_sync(hdev, conn, conn->abort_reason);
-}
-
-int hci_abort_conn(struct hci_conn *conn, u8 reason)
-{
-	struct hci_dev *hdev = conn->hdev;
-
-	/* If abort_reason has already been set it means the connection is
-	 * already being aborted so don't attempt to overwrite it.
-	 */
-	if (conn->abort_reason)
-		return 0;
-
-	bt_dev_dbg(hdev, "handle 0x%2.2x reason 0x%2.2x", conn->handle, reason);
-
-	conn->abort_reason = reason;
-
-	/* If the connection is pending check the command opcode since that
-	 * might be blocking on hci_cmd_sync_work while waiting its respective
-	 * event so we need to hci_cmd_sync_cancel to cancel it.
-	 *
-	 * hci_connect_le serializes the connection attempts so only one
-	 * connection can be in BT_CONNECT at time.
-	 */
-	if (conn->state == BT_CONNECT && hdev->req_status == HCI_REQ_PEND) {
-		switch (hci_skb_event(hdev->sent_cmd)) {
-		case HCI_EV_CONN_COMPLETE:
-		case HCI_EV_LE_CONN_COMPLETE:
-		case HCI_EV_LE_ENHANCED_CONN_COMPLETE:
-		case HCI_EVT_LE_CIS_ESTABLISHED:
-			hci_cmd_sync_cancel(hdev, ECANCELED);
-			break;
-		}
-	/* Cancel connect attempt if still queued/pending */
-	} else if (!hci_cancel_connect_sync(hdev, conn)) {
-		return 0;
-	}
-
-	/* Run immediately if on cmd_sync_work since this may be called
-	 * as a result to MGMT_OP_DISCONNECT/MGMT_OP_UNPAIR which does
-	 * already queue its callback on cmd_sync_work.
-	 */
-	return hci_cmd_sync_run_once(hdev, abort_conn_sync, conn, NULL);
-}
-
-void hci_setup_tx_timestamp(struct sk_buff *skb, size_t key_offset,
-			    const struct sockcm_cookie *sockc)
-{
-	struct sock *sk = skb ? skb->sk : NULL;
-	int key;
-
-	/* This shall be called on a single skb of those generated by user
-	 * sendmsg(), and only when the sendmsg() does not return error to
-	 * user. This is required for keeping the tskey that increments here in
-	 * sync with possible sendmsg() counting by user.
-	 *
-	 * Stream sockets shall set key_offset to sendmsg() length in bytes
-	 * and call with the last fragment, others to 1 and first fragment.
-	 */
-
-	if (!skb || !sockc || !sk || !key_offset)
-		return;
-
-	sock_tx_timestamp(sk, sockc, &skb_shinfo(skb)->tx_flags);
-
-	if (sk->sk_type == SOCK_STREAM)
-		key = atomic_add_return(key_offset, &sk->sk_tskey);
-
-	if (sockc->tsflags & SOF_TIMESTAMPING_OPT_ID &&
-	    sockc->tsflags & SOF_TIMESTAMPING_TX_RECORD_MASK) {
-		if (sockc->tsflags & SOCKCM_FLAG_TS_OPT_ID) {
-			skb_shinfo(skb)->tskey = sockc->ts_opt_id;
-		} else {
-			if (sk->sk_type != SOCK_STREAM)
-				key = atomic_inc_return(&sk->sk_tskey);
-			skb_shinfo(skb)->tskey = key - 1;
-		}
-	}
-}
-
-void hci_conn_tx_queue(struct hci_conn *conn, struct sk_buff *skb)
-{
-	struct tx_queue *comp = &conn->tx_q;
-	bool track = false;
-
-	/* Emit SND now, ie. just before sending to driver */
-	if (skb_shinfo(skb)->tx_flags & SKBTX_SW_TSTAMP)
-		__skb_tstamp_tx(skb, NULL, NULL, skb->sk, SCM_TSTAMP_SND);
-
-	/* COMPLETION tstamp is emitted for tracked skb later in Number of
-	 * Completed Packets event. Available only for flow controlled cases.
-	 *
-	 * TODO: SCO support without flowctl (needs to be done in drivers)
-	 */
-	switch (conn->type) {
-	case CIS_LINK:
-	case BIS_LINK:
-	case PA_LINK:
-	case ACL_LINK:
-	case LE_LINK:
-		break;
-	case SCO_LINK:
-	case ESCO_LINK:
-		if (!hci_dev_test_flag(conn->hdev, HCI_SCO_FLOWCTL))
-			return;
-		break;
-	default:
-		return;
-	}
-
-	if (skb->sk && (skb_shinfo(skb)->tx_flags & SKBTX_COMPLETION_TSTAMP))
-		track = true;
-
-	/* If nothing is tracked, just count extra skbs at the queue head */
-	if (!track && !comp->tracked) {
-		comp->extra++;
-		return;
-	}
-
-	if (track) {
-		skb = skb_clone_sk(skb);
-		if (!skb)
-			goto count_only;
-
-		comp->tracked++;
-	} else {
-		skb = skb_clone(skb, GFP_KERNEL);
-		if (!skb)
-			goto count_only;
-	}
-
-	skb_queue_tail(&comp->queue, skb);
-	return;
-
-count_only:
-	/* Stop tracking skbs, and only count. This will not emit timestamps for
-	 * the packets, but if we get here something is more seriously wrong.
-	 */
-	comp->tracked = 0;
-	comp->extra += skb_queue_len(&comp->queue) + 1;
-	skb_queue_purge(&comp->queue);
-}
-
-void hci_conn_tx_dequeue(struct hci_conn *conn)
-{
-	struct tx_queue *comp = &conn->tx_q;
-	struct sk_buff *skb;
-
-	/* If there are tracked skbs, the counted extra go before dequeuing real
-	 * skbs, to keep ordering. When nothing is tracked, the ordering doesn't
-	 * matter so dequeue real skbs first to get rid of them ASAP.
-	 */
-	if (comp->extra && (comp->tracked || skb_queue_empty(&comp->queue))) {
-		comp->extra--;
-		return;
-	}
-
-	skb = skb_dequeue(&comp->queue);
-	if (!skb)
-		return;
-
-	if (skb->sk) {
-		comp->tracked--;
-		__skb_tstamp_tx(skb, NULL, NULL, skb->sk,
-				SCM_TSTAMP_COMPLETION);
-	}
-
-	kfree_skb(skb);
-}
-
-u8 *hci_conn_key_enc_size(struct hci_conn *conn)
-{
-	if (conn->type == ACL_LINK) {
-		struct link_key *key;
-
-		key = hci_find_link_key(conn->hdev, &conn->dst);
-		if (!key)
-			return NULL;
-
-		return &key->pin_len;
-	} else if (conn->type == LE_LINK) {
-		struct smp_ltk *ltk;
-
-		ltk = hci_find_ltk(conn->hdev, &conn->dst, conn->dst_type,
-				   conn->role);
-		if (!ltk)
-			return NULL;
-
-		return &ltk->enc_size;
-	}
-
-	return NULL;
-}
-
-int hci_ethtool_ts_info(unsigned int index, int sk_proto,
-			struct kernel_ethtool_ts_info *info)
-{
-	struct hci_dev *hdev;
-
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return -ENODEV;
-
-	info->so_timestamping =
-		SOF_TIMESTAMPING_RX_SOFTWARE |
-		SOF_TIMESTAMPING_SOFTWARE;
-	info->phc_index = -1;
-	info->tx_types = BIT(HWTSTAMP_TX_OFF);
-	info->rx_filters = BIT(HWTSTAMP_FILTER_NONE);
-
-	switch (sk_proto) {
-	case BTPROTO_ISO:
-	case BTPROTO_L2CAP:
-		info->so_timestamping |= SOF_TIMESTAMPING_TX_SOFTWARE;
-		info->so_timestamping |= SOF_TIMESTAMPING_TX_COMPLETION;
-		break;
-	case BTPROTO_SCO:
-		info->so_timestamping |= SOF_TIMESTAMPING_TX_SOFTWARE;
-		if (hci_dev_test_flag(hdev, HCI_SCO_FLOWCTL))
-			info->so_timestamping |= SOF_TIMESTAMPING_TX_COMPLETION;
-		break;
-	}
-
-	hci_dev_put(hdev);
-	return 0;
-}
diff -Nrup linux-6.16.7/net/qrtr/mhi.c linux-lenovo-x13s-linux-6.16.y/net/qrtr/mhi.c
--- linux-6.16.7/net/qrtr/mhi.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/net/qrtr/mhi.c	2025-09-11 09:47:42.000000000 -0600
@@ -15,6 +15,7 @@ struct qrtr_mhi_dev {
 	struct qrtr_endpoint ep;
 	struct mhi_device *mhi_dev;
 	struct device *dev;
+	struct completion prepared;
 };
 
 /* From MHI to QRTR */
@@ -53,6 +54,10 @@ static int qcom_mhi_qrtr_send(struct qrt
 	if (skb->sk)
 		sock_hold(skb->sk);
 
+	rc = wait_for_completion_interruptible(&qdev->prepared);
+	if (rc)
+		goto free_skb;
+
 	rc = skb_linearize(skb);
 	if (rc)
 		goto free_skb;
@@ -85,6 +90,7 @@ static int qcom_mhi_qrtr_probe(struct mh
 	qdev->mhi_dev = mhi_dev;
 	qdev->dev = &mhi_dev->dev;
 	qdev->ep.xmit = qcom_mhi_qrtr_send;
+	init_completion(&qdev->prepared);
 
 	dev_set_drvdata(&mhi_dev->dev, qdev);
 	rc = qrtr_endpoint_register(&qdev->ep, QRTR_EP_NID_AUTO);
@@ -97,6 +103,7 @@ static int qcom_mhi_qrtr_probe(struct mh
 		qrtr_endpoint_unregister(&qdev->ep);
 		return rc;
 	}
+	complete_all(&qdev->prepared);
 
 	dev_dbg(qdev->dev, "Qualcomm MHI QRTR driver probed\n");
 
File linux-6.16.7/scripts/dtc/include-prefixes/arc is a directory while file linux-lenovo-x13s-linux-6.16.y/scripts/dtc/include-prefixes/arc is a regular file
File linux-6.16.7/scripts/dtc/include-prefixes/arm is a directory while file linux-lenovo-x13s-linux-6.16.y/scripts/dtc/include-prefixes/arm is a regular file
File linux-6.16.7/scripts/dtc/include-prefixes/arm64 is a directory while file linux-lenovo-x13s-linux-6.16.y/scripts/dtc/include-prefixes/arm64 is a regular file
File linux-6.16.7/scripts/dtc/include-prefixes/dt-bindings is a directory while file linux-lenovo-x13s-linux-6.16.y/scripts/dtc/include-prefixes/dt-bindings is a regular file
File linux-6.16.7/scripts/dtc/include-prefixes/microblaze is a directory while file linux-lenovo-x13s-linux-6.16.y/scripts/dtc/include-prefixes/microblaze is a regular file
File linux-6.16.7/scripts/dtc/include-prefixes/mips is a directory while file linux-lenovo-x13s-linux-6.16.y/scripts/dtc/include-prefixes/mips is a regular file
File linux-6.16.7/scripts/dtc/include-prefixes/nios2 is a directory while file linux-lenovo-x13s-linux-6.16.y/scripts/dtc/include-prefixes/nios2 is a regular file
File linux-6.16.7/scripts/dtc/include-prefixes/openrisc is a directory while file linux-lenovo-x13s-linux-6.16.y/scripts/dtc/include-prefixes/openrisc is a regular file
File linux-6.16.7/scripts/dtc/include-prefixes/powerpc is a directory while file linux-lenovo-x13s-linux-6.16.y/scripts/dtc/include-prefixes/powerpc is a regular file
File linux-6.16.7/scripts/dtc/include-prefixes/riscv is a directory while file linux-lenovo-x13s-linux-6.16.y/scripts/dtc/include-prefixes/riscv is a regular file
File linux-6.16.7/scripts/dtc/include-prefixes/sh is a directory while file linux-lenovo-x13s-linux-6.16.y/scripts/dtc/include-prefixes/sh is a regular file
File linux-6.16.7/scripts/dtc/include-prefixes/xtensa is a directory while file linux-lenovo-x13s-linux-6.16.y/scripts/dtc/include-prefixes/xtensa is a regular file
diff -Nrup linux-6.16.7/scripts/dummy-tools/nm linux-lenovo-x13s-linux-6.16.y/scripts/dummy-tools/nm
--- linux-6.16.7/scripts/dummy-tools/nm	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/scripts/dummy-tools/nm	2025-09-11 09:47:42.000000000 -0600
@@ -1,30 +1 @@
-#!/bin/sh
-# SPDX-License-Identifier: GPL-2.0-only
-
-# Dummy script that always succeeds.
-
-# Check if the first parameter appears in the rest. Succeeds if found.
-# This helper is useful if a particular option was passed to this script.
-# Typically used like this:
-#   arg_contain <word-you-are-searching-for> "$@"
-arg_contain ()
-{
-	search="$1"
-	shift
-
-	while [ $# -gt 0 ]
-	do
-		if [ "$search" = "$1" ]; then
-			return 0
-		fi
-		shift
-	done
-
-	return 1
-}
-
-if arg_contain --version "$@" || arg_contain -v "$@"; then
-	progname=$(basename $0)
-	echo "GNU $progname (scripts/dummy-tools/$progname) 2.50"
-	exit 0
-fi
+ld
\ No newline at end of file
diff -Nrup linux-6.16.7/scripts/dummy-tools/objcopy linux-lenovo-x13s-linux-6.16.y/scripts/dummy-tools/objcopy
--- linux-6.16.7/scripts/dummy-tools/objcopy	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/scripts/dummy-tools/objcopy	2025-09-11 09:47:42.000000000 -0600
@@ -1,30 +1 @@
-#!/bin/sh
-# SPDX-License-Identifier: GPL-2.0-only
-
-# Dummy script that always succeeds.
-
-# Check if the first parameter appears in the rest. Succeeds if found.
-# This helper is useful if a particular option was passed to this script.
-# Typically used like this:
-#   arg_contain <word-you-are-searching-for> "$@"
-arg_contain ()
-{
-	search="$1"
-	shift
-
-	while [ $# -gt 0 ]
-	do
-		if [ "$search" = "$1" ]; then
-			return 0
-		fi
-		shift
-	done
-
-	return 1
-}
-
-if arg_contain --version "$@" || arg_contain -v "$@"; then
-	progname=$(basename $0)
-	echo "GNU $progname (scripts/dummy-tools/$progname) 2.50"
-	exit 0
-fi
+ld
\ No newline at end of file
diff -Nrup linux-6.16.7/scripts/kconfig/lxdialog/dialog.h linux-lenovo-x13s-linux-6.16.y/scripts/kconfig/lxdialog/dialog.h
--- linux-6.16.7/scripts/kconfig/lxdialog/dialog.h	2025-09-13 16:15:46.041935250 -0600
+++ linux-lenovo-x13s-linux-6.16.y/scripts/kconfig/lxdialog/dialog.h	2025-09-11 09:47:42.000000000 -0600
@@ -58,8 +58,6 @@
 #define ACS_DARROW 'v'
 #endif
 
-#define KEY_ACTION_SORT 11
-
 /* error return codes */
 #define ERRDISPLAYTOOSMALL (KEY_MAX + 1)
 
@@ -129,7 +127,6 @@ void item_set_selected(int val);
 int item_activate_selected(void);
 void *item_data(void);
 char item_tag(void);
-void sort_items(void);
 
 /* item list manipulation for lxdialog use */
 #define MAXITEMSTR 200
@@ -199,7 +196,7 @@ int dialog_textbox(const char *title, co
 		   int initial_width, int *_vscroll, int *_hscroll,
 		   int (*extra_key_cb)(int, size_t, size_t, void *), void *data);
 int dialog_menu(const char *title, const char *prompt,
-		const void *selected, int *s_scroll, bool sort);
+		const void *selected, int *s_scroll);
 int dialog_checklist(const char *title, const char *prompt, int height,
 		     int width, int list_height);
 int dialog_inputbox(const char *title, const char *prompt, int height,
diff -Nrup linux-6.16.7/scripts/kconfig/lxdialog/menubox.c linux-lenovo-x13s-linux-6.16.y/scripts/kconfig/lxdialog/menubox.c
--- linux-6.16.7/scripts/kconfig/lxdialog/menubox.c	2025-09-13 16:15:46.042247314 -0600
+++ linux-lenovo-x13s-linux-6.16.y/scripts/kconfig/lxdialog/menubox.c	2025-09-11 09:47:42.000000000 -0600
@@ -161,7 +161,7 @@ static void do_scroll(WINDOW *win, int *
  * Display a menu for choosing among a number of options
  */
 int dialog_menu(const char *title, const char *prompt,
-		const void *selected, int *s_scroll, bool sort)
+		const void *selected, int *s_scroll)
 {
 	int i, j, x, y, box_x, box_y;
 	int height, width, menu_height;
@@ -181,9 +181,6 @@ do_resize:
 
 	max_choice = MIN(menu_height, item_count());
 
-	if (sort)
-		sort_items();
-
 	/* center dialog box on screen */
 	x = (getmaxx(stdscr) - width) / 2;
 	y = (getmaxy(stdscr) - height) / 2;
@@ -411,8 +408,6 @@ do_resize:
 			delwin(menu);
 			delwin(dialog);
 			goto do_resize;
-		case '>':
-			return KEY_ACTION_SORT;
 		}
 	}
 	delwin(menu);
diff -Nrup linux-6.16.7/scripts/kconfig/lxdialog/util.c linux-lenovo-x13s-linux-6.16.y/scripts/kconfig/lxdialog/util.c
--- linux-6.16.7/scripts/kconfig/lxdialog/util.c	2025-09-13 16:15:46.042621144 -0600
+++ linux-lenovo-x13s-linux-6.16.y/scripts/kconfig/lxdialog/util.c	2025-09-11 09:47:42.000000000 -0600
@@ -563,85 +563,6 @@ void item_reset(void)
 	item_cur = &item_nil;
 }
 
-/*
- * Function skips a part of the label to get the actual label text
- * (without the '[ ]'-like prefix).
- */
-static char *skip_spec_characters(char *s)
-{
-	bool unbalanced = false;
-
-	while (*s) {
-		if (isalnum(*s) && !unbalanced) {
-			break;
-		} else if (*s == '[' || *s == '<' || *s == '(') {
-			/*
-			 * '[', '<' or '(' means that we need to look for
-			 * closure
-			 */
-			unbalanced = true;
-		} else if (*s == '-') {
-			/*
-			 * Labels could start with "-*-", so '-' here either
-			 * opens or closes the "checkbox"
-			 */
-			unbalanced = !unbalanced;
-		} else if (*s == '>' || *s == ']' || *s == ')') {
-			unbalanced = false;
-		}
-		s++;
-	}
-	return s;
-}
-
-static int compare_labels(const void *a, const void *b)
-{
-	struct dialog_list *el1 = *((struct dialog_list **)a);
-	struct dialog_list *el2 = *((struct dialog_list **)b);
-
-	return strcasecmp(skip_spec_characters(el1->node.str),
-			  skip_spec_characters(el2->node.str));
-}
-
-void sort_items(void)
-{
-	struct dialog_list **arr;
-	struct dialog_list *cur;
-	size_t n, i;
-
-	n = item_count();
-	if (n == 0)
-		return;
-
-	/* Copy all items from linked list into array */
-	cur = item_head;
-	arr = malloc(sizeof(*arr) * n);
-
-	if (!arr) {
-		/* Don't have enough memory, so don't do anything */
-		return;
-	}
-
-	for (i = 0; i < n; i++) {
-		arr[i] = cur;
-		cur = cur->next;
-	}
-
-	qsort(arr, n, sizeof(struct dialog_list *), compare_labels);
-
-	/* Restore the linked list structure from the sorted array */
-	for (i = 0; i < n; i++) {
-		if (i < n - 1)
-			arr[i]->next = arr[i + 1];
-		else
-			arr[i]->next = NULL;
-	}
-
-	item_head = arr[0];
-
-	free(arr);
-}
-
 void item_make(const char *fmt, ...)
 {
 	va_list ap;
diff -Nrup linux-6.16.7/scripts/kconfig/mconf.c linux-lenovo-x13s-linux-6.16.y/scripts/kconfig/mconf.c
--- linux-6.16.7/scripts/kconfig/mconf.c	2025-09-13 16:15:46.043010026 -0600
+++ linux-lenovo-x13s-linux-6.16.y/scripts/kconfig/mconf.c	2025-09-11 09:47:42.000000000 -0600
@@ -750,7 +750,6 @@ static void conf_save(void)
 	}
 }
 
-static bool should_sort;
 static void conf(struct menu *menu, struct menu *active_menu)
 {
 	struct menu *submenu;
@@ -776,15 +775,9 @@ static void conf(struct menu *menu, stru
 		dialog_clear();
 		res = dialog_menu(prompt ? prompt : "Main Menu",
 				  menu_instructions,
-				  active_menu, &s_scroll, should_sort);
+				  active_menu, &s_scroll);
 		if (res == 1 || res == KEY_ESC || res == -ERRDISPLAYTOOSMALL)
 			break;
-
-		if (res == KEY_ACTION_SORT) {
-			should_sort = !should_sort;
-			continue;
-		}
-
 		if (item_count() != 0) {
 			if (!item_activate_selected())
 				continue;
diff -Nrup linux-6.16.7/scripts/kconfig/mconf.c.orig linux-lenovo-x13s-linux-6.16.y/scripts/kconfig/mconf.c.orig
--- linux-6.16.7/scripts/kconfig/mconf.c.orig	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/scripts/kconfig/mconf.c.orig	1969-12-31 17:00:00.000000000 -0700
@@ -1,963 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
- *
- * Introduced single menu mode (show all sub-menus in one large tree).
- * 2002-11-06 Petr Baudis <pasky@ucw.cz>
- *
- * i18n, 2005, Arnaldo Carvalho de Melo <acme@conectiva.com.br>
- */
-
-#include <ctype.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <limits.h>
-#include <stdarg.h>
-#include <stdlib.h>
-#include <string.h>
-#include <strings.h>
-#include <signal.h>
-#include <unistd.h>
-
-#include <list.h>
-#include <xalloc.h>
-#include "lkc.h"
-#include "lxdialog/dialog.h"
-#include "mnconf-common.h"
-
-static const char mconf_readme[] =
-"Overview\n"
-"--------\n"
-"This interface lets you select features and parameters for the build.\n"
-"Features can either be built-in, modularized, or ignored. Parameters\n"
-"must be entered in as decimal or hexadecimal numbers or text.\n"
-"\n"
-"Menu items beginning with following braces represent features that\n"
-"  [ ] can be built in or removed\n"
-"  < > can be built in, modularized or removed\n"
-"  { } can be built in or modularized (selected by other feature)\n"
-"  - - are selected by other feature,\n"
-"while *, M or whitespace inside braces means to build in, build as\n"
-"a module or to exclude the feature respectively.\n"
-"\n"
-"To change any of these features, highlight it with the cursor\n"
-"keys and press <Y> to build it in, <M> to make it a module or\n"
-"<N> to remove it.  You may also press the <Space Bar> to cycle\n"
-"through the available options (i.e. Y->N->M->Y).\n"
-"\n"
-"Some additional keyboard hints:\n"
-"\n"
-"Menus\n"
-"----------\n"
-"o  Use the Up/Down arrow keys (cursor keys) to highlight the item you\n"
-"   wish to change or the submenu you wish to select and press <Enter>.\n"
-"   Submenus are designated by \"--->\", empty ones by \"----\".\n"
-"\n"
-"   Shortcut: Press the option's highlighted letter (hotkey).\n"
-"             Pressing a hotkey more than once will sequence\n"
-"             through all visible items which use that hotkey.\n"
-"\n"
-"   You may also use the <PAGE UP> and <PAGE DOWN> keys to scroll\n"
-"   unseen options into view.\n"
-"\n"
-"o  To exit a menu use the cursor keys to highlight the <Exit> button\n"
-"   and press <ENTER>.\n"
-"\n"
-"   Shortcut: Press <ESC><ESC> or <E> or <X> if there is no hotkey\n"
-"             using those letters.  You may press a single <ESC>, but\n"
-"             there is a delayed response which you may find annoying.\n"
-"\n"
-"   Also, the <TAB> and cursor keys will cycle between <Select>,\n"
-"   <Exit>, <Help>, <Save>, and <Load>.\n"
-"\n"
-"o  To get help with an item, use the cursor keys to highlight <Help>\n"
-"   and press <ENTER>.\n"
-"\n"
-"   Shortcut: Press <H> or <?>.\n"
-"\n"
-"o  To toggle the display of hidden options, press <Z>.\n"
-"\n"
-"\n"
-"Radiolists  (Choice lists)\n"
-"-----------\n"
-"o  Use the cursor keys to select the option you wish to set and press\n"
-"   <S> or the <SPACE BAR>.\n"
-"\n"
-"   Shortcut: Press the first letter of the option you wish to set then\n"
-"             press <S> or <SPACE BAR>.\n"
-"\n"
-"o  To see available help for the item, use the cursor keys to highlight\n"
-"   <Help> and Press <ENTER>.\n"
-"\n"
-"   Shortcut: Press <H> or <?>.\n"
-"\n"
-"   Also, the <TAB> and cursor keys will cycle between <Select> and\n"
-"   <Help>\n"
-"\n"
-"\n"
-"Data Entry\n"
-"-----------\n"
-"o  Enter the requested information and press <ENTER>\n"
-"   If you are entering hexadecimal values, it is not necessary to\n"
-"   add the '0x' prefix to the entry.\n"
-"\n"
-"o  For help, use the <TAB> or cursor keys to highlight the help option\n"
-"   and press <ENTER>.  You can try <TAB><H> as well.\n"
-"\n"
-"\n"
-"Text Box    (Help Window)\n"
-"--------\n"
-"o  Use the cursor keys to scroll up/down/left/right.  The VI editor\n"
-"   keys h,j,k,l function here as do <u>, <d>, <SPACE BAR> and <B> for\n"
-"   those who are familiar with less and lynx.\n"
-"\n"
-"o  Press <E>, <X>, <q>, <Enter> or <Esc><Esc> to exit.\n"
-"\n"
-"\n"
-"Alternate Configuration Files\n"
-"-----------------------------\n"
-"Menuconfig supports the use of alternate configuration files for\n"
-"those who, for various reasons, find it necessary to switch\n"
-"between different configurations.\n"
-"\n"
-"The <Save> button will let you save the current configuration to\n"
-"a file of your choosing.  Use the <Load> button to load a previously\n"
-"saved alternate configuration.\n"
-"\n"
-"Even if you don't use alternate configuration files, but you find\n"
-"during a Menuconfig session that you have completely messed up your\n"
-"settings, you may use the <Load> button to restore your previously\n"
-"saved settings from \".config\" without restarting Menuconfig.\n"
-"\n"
-"Other information\n"
-"-----------------\n"
-"If you use Menuconfig in an XTERM window, make sure you have your\n"
-"$TERM variable set to point to an xterm definition which supports\n"
-"color.  Otherwise, Menuconfig will look rather bad.  Menuconfig will\n"
-"not display correctly in an RXVT window because rxvt displays only one\n"
-"intensity of color, bright.\n"
-"\n"
-"Menuconfig will display larger menus on screens or xterms which are\n"
-"set to display more than the standard 25 row by 80 column geometry.\n"
-"In order for this to work, the \"stty size\" command must be able to\n"
-"display the screen's current row and column geometry.  I STRONGLY\n"
-"RECOMMEND that you make sure you do NOT have the shell variables\n"
-"LINES and COLUMNS exported into your environment.  Some distributions\n"
-"export those variables via /etc/profile.  Some ncurses programs can\n"
-"become confused when those variables (LINES & COLUMNS) don't reflect\n"
-"the true screen size.\n"
-"\n"
-"Optional personality available\n"
-"------------------------------\n"
-"If you prefer to have all of the options listed in a single menu,\n"
-"rather than the default multimenu hierarchy, run the menuconfig with\n"
-"MENUCONFIG_MODE environment variable set to single_menu. Example:\n"
-"\n"
-"make MENUCONFIG_MODE=single_menu menuconfig\n"
-"\n"
-"<Enter> will then unroll the appropriate category, or enfold it if it\n"
-"is already unrolled.\n"
-"\n"
-"Note that this mode can eventually be a little more CPU expensive\n"
-"(especially with a larger number of unrolled categories) than the\n"
-"default mode.\n"
-"\n"
-
-"Search\n"
-"-------\n"
-"Pressing the forward-slash (/) anywhere brings up a search dialog box.\n"
-"\n"
-
-"Different color themes available\n"
-"--------------------------------\n"
-"It is possible to select different color themes using the variable\n"
-"MENUCONFIG_COLOR. To select a theme use:\n"
-"\n"
-"make MENUCONFIG_COLOR=<theme> menuconfig\n"
-"\n"
-"Available themes are\n"
-" mono       => selects colors suitable for monochrome displays\n"
-" blackbg    => selects a color scheme with black background\n"
-" classic    => theme with blue background. The classic look\n"
-" bluetitle  => an LCD friendly version of classic. (default)\n"
-"\n",
-menu_instructions[] =
-	"Arrow keys navigate the menu.  "
-	"<Enter> selects submenus ---> (or empty submenus ----).  "
-	"Highlighted letters are hotkeys.  "
-	"Pressing <Y> includes, <N> excludes, <M> modularizes features.  "
-	"Press <Esc><Esc> to exit, <?> for Help, </> for Search.  "
-	"Legend: [*] built-in  [ ] excluded  <M> module  < > module capable",
-radiolist_instructions[] =
-	"Use the arrow keys to navigate this window or "
-	"press the hotkey of the item you wish to select "
-	"followed by the <SPACE BAR>. "
-	"Press <?> for additional information about this option.",
-inputbox_instructions_int[] =
-	"Please enter a decimal value. "
-	"Fractions will not be accepted.  "
-	"Use the <TAB> key to move from the input field to the buttons below it.",
-inputbox_instructions_hex[] =
-	"Please enter a hexadecimal value. "
-	"Use the <TAB> key to move from the input field to the buttons below it.",
-inputbox_instructions_string[] =
-	"Please enter a string value. "
-	"Use the <TAB> key to move from the input field to the buttons below it.",
-setmod_text[] =
-	"This feature depends on another which has been configured as a module.\n"
-	"As a result, this feature will be built as a module.",
-load_config_text[] =
-	"Enter the name of the configuration file you wish to load.  "
-	"Accept the name shown to restore the configuration you "
-	"last retrieved.  Leave blank to abort.",
-load_config_help[] =
-	"\n"
-	"For various reasons, one may wish to keep several different\n"
-	"configurations available on a single machine.\n"
-	"\n"
-	"If you have saved a previous configuration in a file other than the\n"
-	"default one, entering its name here will allow you to modify that\n"
-	"configuration.\n"
-	"\n"
-	"If you are uncertain, then you have probably never used alternate\n"
-	"configuration files. You should therefore leave this blank to abort.\n",
-save_config_text[] =
-	"Enter a filename to which this configuration should be saved "
-	"as an alternate.  Leave blank to abort.",
-save_config_help[] =
-	"\n"
-	"For various reasons, one may wish to keep different configurations\n"
-	"available on a single machine.\n"
-	"\n"
-	"Entering a file name here will allow you to later retrieve, modify\n"
-	"and use the current configuration as an alternate to whatever\n"
-	"configuration options you have selected at that time.\n"
-	"\n"
-	"If you are uncertain what all this means then you should probably\n"
-	"leave this blank.\n",
-search_help[] =
-	"\n"
-	"Search for symbols and display their relations.\n"
-	"Regular expressions are allowed.\n"
-	"Example: search for \"^FOO\"\n"
-	"Result:\n"
-	"-----------------------------------------------------------------\n"
-	"Symbol: FOO [=m]\n"
-	"Type  : tristate\n"
-	"Prompt: Foo bus is used to drive the bar HW\n"
-	"  Location:\n"
-	"    -> Bus options (PCI, PCMCIA, EISA, ISA)\n"
-	"      -> PCI support (PCI [=y])\n"
-	"(1)     -> PCI access mode (<choice> [=y])\n"
-	"  Defined at drivers/pci/Kconfig:47\n"
-	"  Depends on: X86_LOCAL_APIC && X86_IO_APIC\n"
-	"  Selects: LIBCRC32\n"
-	"  Selected by: BAR [=n]\n"
-	"-----------------------------------------------------------------\n"
-	"o The line 'Type:' shows the type of the configuration option for\n"
-	"  this symbol (bool, tristate, string, ...)\n"
-	"o The line 'Prompt:' shows the text used in the menu structure for\n"
-	"  this symbol\n"
-	"o The 'Defined at' line tells at what file / line number the symbol\n"
-	"  is defined\n"
-	"o The 'Depends on:' line tells what symbols need to be defined for\n"
-	"  this symbol to be visible in the menu (selectable)\n"
-	"o The 'Location:' lines tells where in the menu structure this symbol\n"
-	"  is located\n"
-	"    A location followed by a [=y] indicates that this is a\n"
-	"    selectable menu item - and the current value is displayed inside\n"
-	"    brackets.\n"
-	"    Press the key in the (#) prefix to jump directly to that\n"
-	"    location. You will be returned to the current search results\n"
-	"    after exiting this new menu.\n"
-	"o The 'Selects:' line tells what symbols will be automatically\n"
-	"  selected if this symbol is selected (y or m)\n"
-	"o The 'Selected by' line tells what symbol has selected this symbol\n"
-	"\n"
-	"Only relevant lines are shown.\n"
-	"\n\n"
-	"Search examples:\n"
-	"Examples: USB	=> find all symbols containing USB\n"
-	"          ^USB => find all symbols starting with USB\n"
-	"          USB$ => find all symbols ending with USB\n"
-	"\n";
-
-static int indent;
-static struct menu *current_menu;
-static int child_count;
-static int single_menu_mode;
-static int show_all_options;
-static int save_and_exit;
-static int silent;
-
-static void conf(struct menu *menu, struct menu *active_menu);
-
-static char filename[PATH_MAX+1];
-static void set_config_filename(const char *config_filename)
-{
-	static char menu_backtitle[PATH_MAX+128];
-
-	snprintf(menu_backtitle, sizeof(menu_backtitle), "%s - %s",
-		 config_filename, rootmenu.prompt->text);
-	set_dialog_backtitle(menu_backtitle);
-
-	snprintf(filename, sizeof(filename), "%s", config_filename);
-}
-
-struct subtitle_part {
-	struct list_head entries;
-	const char *text;
-};
-static LIST_HEAD(trail);
-
-static struct subtitle_list *subtitles;
-static void set_subtitle(void)
-{
-	struct subtitle_part *sp;
-	struct subtitle_list *pos, *tmp;
-
-	for (pos = subtitles; pos != NULL; pos = tmp) {
-		tmp = pos->next;
-		free(pos);
-	}
-
-	subtitles = NULL;
-	list_for_each_entry(sp, &trail, entries) {
-		if (sp->text) {
-			if (pos) {
-				pos->next = xcalloc(1, sizeof(*pos));
-				pos = pos->next;
-			} else {
-				subtitles = pos = xcalloc(1, sizeof(*pos));
-			}
-			pos->text = sp->text;
-		}
-	}
-
-	set_dialog_subtitles(subtitles);
-}
-
-static void reset_subtitle(void)
-{
-	struct subtitle_list *pos, *tmp;
-
-	for (pos = subtitles; pos != NULL; pos = tmp) {
-		tmp = pos->next;
-		free(pos);
-	}
-	subtitles = NULL;
-	set_dialog_subtitles(subtitles);
-}
-
-static int show_textbox_ext(const char *title, const char *text, int r, int c,
-			    int *vscroll, int *hscroll,
-			    int (*extra_key_cb)(int, size_t, size_t, void *),
-			    void *data)
-{
-	dialog_clear();
-	return dialog_textbox(title, text, r, c, vscroll, hscroll,
-			      extra_key_cb, data);
-}
-
-static void show_textbox(const char *title, const char *text, int r, int c)
-{
-	show_textbox_ext(title, text, r, c, NULL, NULL, NULL, NULL);
-}
-
-static void show_helptext(const char *title, const char *text)
-{
-	show_textbox(title, text, 0, 0);
-}
-
-static void show_help(struct menu *menu)
-{
-	struct gstr help = str_new();
-
-	help.max_width = getmaxx(stdscr) - 10;
-	menu_get_ext_help(menu, &help);
-
-	show_helptext(menu_get_prompt(menu), str_get(&help));
-	str_free(&help);
-}
-
-static void search_conf(void)
-{
-	struct symbol **sym_arr;
-	struct gstr res;
-	struct gstr title;
-	char *dialog_input;
-	int dres, vscroll = 0, hscroll = 0;
-	bool again;
-	struct gstr sttext;
-	struct subtitle_part stpart;
-
-	title = str_new();
-	str_printf( &title, "Enter (sub)string or regexp to search for "
-			      "(with or without \"%s\")", CONFIG_);
-
-again:
-	dialog_clear();
-	dres = dialog_inputbox("Search Configuration Parameter",
-			      str_get(&title),
-			      10, 75, "");
-	switch (dres) {
-	case 0:
-		break;
-	case 1:
-		show_helptext("Search Configuration", search_help);
-		goto again;
-	default:
-		str_free(&title);
-		return;
-	}
-
-	/* strip the prefix if necessary */
-	dialog_input = dialog_input_result;
-	if (strncasecmp(dialog_input_result, CONFIG_, strlen(CONFIG_)) == 0)
-		dialog_input += strlen(CONFIG_);
-
-	sttext = str_new();
-	str_printf(&sttext, "Search (%s)", dialog_input_result);
-	stpart.text = str_get(&sttext);
-	list_add_tail(&stpart.entries, &trail);
-
-	sym_arr = sym_re_search(dialog_input);
-	do {
-		LIST_HEAD(head);
-		struct search_data data = {
-			.head = &head,
-		};
-		struct jump_key *pos, *tmp;
-
-		jump_key_char = 0;
-		res = get_relations_str(sym_arr, &head);
-		set_subtitle();
-		dres = show_textbox_ext("Search Results", str_get(&res), 0, 0,
-					&vscroll, &hscroll,
-					handle_search_keys, &data);
-		again = false;
-		if (dres >= '1' && dres <= '9') {
-			assert(data.target != NULL);
-			conf(data.target->parent, data.target);
-			again = true;
-		}
-		str_free(&res);
-		list_for_each_entry_safe(pos, tmp, &head, entries)
-			free(pos);
-	} while (again);
-	free(sym_arr);
-	str_free(&title);
-	list_del(trail.prev);
-	str_free(&sttext);
-}
-
-static void build_conf(struct menu *menu)
-{
-	struct symbol *sym;
-	struct property *prop;
-	struct menu *child;
-	int type, tmp, doint = 2;
-	tristate val;
-	char ch;
-	bool visible;
-
-	/*
-	 * note: menu_is_visible() has side effect that it will
-	 * recalc the value of the symbol.
-	 */
-	visible = menu_is_visible(menu);
-	if (show_all_options && !menu_has_prompt(menu))
-		return;
-	else if (!show_all_options && !visible)
-		return;
-
-	sym = menu->sym;
-	prop = menu->prompt;
-	if (!sym) {
-		if (prop && menu != current_menu) {
-			const char *prompt = menu_get_prompt(menu);
-			switch (prop->type) {
-			case P_MENU:
-				child_count++;
-				if (single_menu_mode) {
-					item_make("%s%*c%s",
-						  menu->data ? "-->" : "++>",
-						  indent + 1, ' ', prompt);
-				} else
-					item_make("   %*c%s  %s",
-						  indent + 1, ' ', prompt,
-						  menu_is_empty(menu) ? "----" : "--->");
-				item_set_tag('m');
-				item_set_data(menu);
-				if (single_menu_mode && menu->data)
-					goto conf_childs;
-				return;
-			case P_COMMENT:
-				if (prompt) {
-					child_count++;
-					item_make("   %*c*** %s ***", indent + 1, ' ', prompt);
-					item_set_tag(':');
-					item_set_data(menu);
-				}
-				break;
-			default:
-				if (prompt) {
-					child_count++;
-					item_make("---%*c%s", indent + 1, ' ', prompt);
-					item_set_tag(':');
-					item_set_data(menu);
-				}
-			}
-		} else
-			doint = 0;
-		goto conf_childs;
-	}
-
-	type = sym_get_type(sym);
-	if (sym_is_choice(sym)) {
-		struct symbol *def_sym = sym_calc_choice(menu);
-		struct menu *def_menu = NULL;
-
-		child_count++;
-		for (child = menu->list; child; child = child->next) {
-			if (menu_is_visible(child) && child->sym == def_sym)
-				def_menu = child;
-		}
-
-		item_make("   ");
-		item_set_tag(def_menu ? 't' : ':');
-		item_set_data(menu);
-
-		item_add_str("%*c%s", indent + 1, ' ', menu_get_prompt(menu));
-		if (def_menu)
-			item_add_str(" (%s)  --->", menu_get_prompt(def_menu));
-		return;
-	} else {
-		if (menu == current_menu) {
-			item_make("---%*c%s", indent + 1, ' ', menu_get_prompt(menu));
-			item_set_tag(':');
-			item_set_data(menu);
-			goto conf_childs;
-		}
-		child_count++;
-		val = sym_get_tristate_value(sym);
-		switch (type) {
-		case S_BOOLEAN:
-			if (sym_is_changeable(sym))
-				item_make("[%c]", val == no ? ' ' : '*');
-			else
-				item_make("-%c-", val == no ? ' ' : '*');
-			item_set_tag('t');
-			item_set_data(menu);
-			break;
-		case S_TRISTATE:
-			switch (val) {
-			case yes: ch = '*'; break;
-			case mod: ch = 'M'; break;
-			default:  ch = ' '; break;
-			}
-			if (sym_is_changeable(sym)) {
-				if (sym->rev_dep.tri == mod)
-					item_make("{%c}", ch);
-				else
-					item_make("<%c>", ch);
-			} else
-				item_make("-%c-", ch);
-			item_set_tag('t');
-			item_set_data(menu);
-			break;
-		default:
-			tmp = 2 + strlen(sym_get_string_value(sym)); /* () = 2 */
-			item_make("(%s)", sym_get_string_value(sym));
-			tmp = indent - tmp + 4;
-			if (tmp < 0)
-				tmp = 0;
-			item_add_str("%*c%s%s", tmp, ' ', menu_get_prompt(menu),
-				     (sym_has_value(sym) || !sym_is_changeable(sym)) ?
-				     "" : " (NEW)");
-			item_set_tag('s');
-			item_set_data(menu);
-			goto conf_childs;
-		}
-		item_add_str("%*c%s%s", indent + 1, ' ', menu_get_prompt(menu),
-			  (sym_has_value(sym) || !sym_is_changeable(sym)) ?
-			  "" : " (NEW)");
-		if (menu->prompt->type == P_MENU) {
-			item_add_str("  %s", menu_is_empty(menu) ? "----" : "--->");
-			return;
-		}
-	}
-
-conf_childs:
-	indent += doint;
-	for (child = menu->list; child; child = child->next)
-		build_conf(child);
-	indent -= doint;
-}
-
-static void conf_choice(struct menu *menu)
-{
-	const char *prompt = menu_get_prompt(menu);
-	struct menu *child;
-	struct symbol *active;
-
-	active = sym_calc_choice(menu);
-	while (1) {
-		int res;
-		int selected;
-		item_reset();
-
-		current_menu = menu;
-		for (child = menu->list; child; child = child->next) {
-			if (!menu_is_visible(child))
-				continue;
-			if (child->sym)
-				item_make("%s", menu_get_prompt(child));
-			else {
-				item_make("*** %s ***", menu_get_prompt(child));
-				item_set_tag(':');
-			}
-			item_set_data(child);
-			if (child->sym == active)
-				item_set_selected(1);
-			if (child->sym == sym_calc_choice(menu))
-				item_set_tag('X');
-		}
-		dialog_clear();
-		res = dialog_checklist(prompt ? prompt : "Main Menu",
-					radiolist_instructions,
-					MENUBOX_HEIGHT_MIN,
-					MENUBOX_WIDTH_MIN,
-					CHECKLIST_HEIGHT_MIN);
-		selected = item_activate_selected();
-		switch (res) {
-		case 0:
-			if (selected) {
-				child = item_data();
-				if (!child->sym)
-					break;
-
-				choice_set_value(menu, child->sym);
-			}
-			return;
-		case 1:
-			if (selected) {
-				child = item_data();
-				show_help(child);
-				active = child->sym;
-			} else
-				show_help(menu);
-			break;
-		case KEY_ESC:
-			return;
-		case -ERRDISPLAYTOOSMALL:
-			return;
-		}
-	}
-}
-
-static void conf_string(struct menu *menu)
-{
-	const char *prompt = menu_get_prompt(menu);
-
-	while (1) {
-		int res;
-		const char *heading;
-
-		switch (sym_get_type(menu->sym)) {
-		case S_INT:
-			heading = inputbox_instructions_int;
-			break;
-		case S_HEX:
-			heading = inputbox_instructions_hex;
-			break;
-		case S_STRING:
-			heading = inputbox_instructions_string;
-			break;
-		default:
-			heading = "Internal mconf error!";
-		}
-		dialog_clear();
-		res = dialog_inputbox(prompt ? prompt : "Main Menu",
-				      heading, 10, 75,
-				      sym_get_string_value(menu->sym));
-		switch (res) {
-		case 0:
-			if (sym_set_string_value(menu->sym, dialog_input_result))
-				return;
-			show_textbox(NULL, "You have made an invalid entry.", 5, 43);
-			break;
-		case 1:
-			show_help(menu);
-			break;
-		case KEY_ESC:
-			return;
-		}
-	}
-}
-
-static void conf_load(void)
-{
-
-	while (1) {
-		int res;
-		dialog_clear();
-		res = dialog_inputbox(NULL, load_config_text,
-				      11, 55, filename);
-		switch(res) {
-		case 0:
-			if (!dialog_input_result[0])
-				return;
-			if (!conf_read(dialog_input_result)) {
-				set_config_filename(dialog_input_result);
-				conf_set_changed(true);
-				return;
-			}
-			show_textbox(NULL, "File does not exist!", 5, 38);
-			break;
-		case 1:
-			show_helptext("Load Alternate Configuration", load_config_help);
-			break;
-		case KEY_ESC:
-			return;
-		}
-	}
-}
-
-static void conf_save(void)
-{
-	while (1) {
-		int res;
-		dialog_clear();
-		res = dialog_inputbox(NULL, save_config_text,
-				      11, 55, filename);
-		switch(res) {
-		case 0:
-			if (!dialog_input_result[0])
-				return;
-			if (!conf_write(dialog_input_result)) {
-				set_config_filename(dialog_input_result);
-				return;
-			}
-			show_textbox(NULL, "Can't create file!", 5, 60);
-			break;
-		case 1:
-			show_helptext("Save Alternate Configuration", save_config_help);
-			break;
-		case KEY_ESC:
-			return;
-		}
-	}
-}
-
-static void conf(struct menu *menu, struct menu *active_menu)
-{
-	struct menu *submenu;
-	const char *prompt = menu_get_prompt(menu);
-	struct subtitle_part stpart;
-	struct symbol *sym;
-	int res;
-	int s_scroll = 0;
-
-	if (menu != &rootmenu)
-		stpart.text = menu_get_prompt(menu);
-	else
-		stpart.text = NULL;
-	list_add_tail(&stpart.entries, &trail);
-
-	while (1) {
-		item_reset();
-		current_menu = menu;
-		build_conf(menu);
-		if (!child_count)
-			break;
-		set_subtitle();
-		dialog_clear();
-		res = dialog_menu(prompt ? prompt : "Main Menu",
-				  menu_instructions,
-				  active_menu, &s_scroll);
-		if (res == 1 || res == KEY_ESC || res == -ERRDISPLAYTOOSMALL)
-			break;
-		if (item_count() != 0) {
-			if (!item_activate_selected())
-				continue;
-			if (!item_tag())
-				continue;
-		}
-		submenu = item_data();
-		active_menu = item_data();
-		if (submenu)
-			sym = submenu->sym;
-		else
-			sym = NULL;
-
-		switch (res) {
-		case 0:
-			switch (item_tag()) {
-			case 'm':
-				if (single_menu_mode)
-					submenu->data = (void *) (long) !submenu->data;
-				else
-					conf(submenu, NULL);
-				break;
-			case 't':
-				if (sym_is_choice(sym))
-					conf_choice(submenu);
-				else if (submenu->prompt->type == P_MENU)
-					conf(submenu, NULL);
-				break;
-			case 's':
-				conf_string(submenu);
-				break;
-			}
-			break;
-		case 2:
-			if (sym)
-				show_help(submenu);
-			else {
-				reset_subtitle();
-				show_helptext("README", mconf_readme);
-			}
-			break;
-		case 3:
-			reset_subtitle();
-			conf_save();
-			break;
-		case 4:
-			reset_subtitle();
-			conf_load();
-			break;
-		case 5:
-			if (item_is_tag('t')) {
-				if (sym_set_tristate_value(sym, yes))
-					break;
-				if (sym_set_tristate_value(sym, mod))
-					show_textbox(NULL, setmod_text, 6, 74);
-			}
-			break;
-		case 6:
-			if (item_is_tag('t'))
-				sym_set_tristate_value(sym, no);
-			break;
-		case 7:
-			if (item_is_tag('t'))
-				sym_set_tristate_value(sym, mod);
-			break;
-		case 8:
-			if (item_is_tag('t'))
-				sym_toggle_tristate_value(sym);
-			else if (item_is_tag('m'))
-				conf(submenu, NULL);
-			break;
-		case 9:
-			search_conf();
-			break;
-		case 10:
-			show_all_options = !show_all_options;
-			break;
-		}
-	}
-
-	list_del(trail.prev);
-}
-
-static void conf_message_callback(const char *s)
-{
-	if (save_and_exit) {
-		if (!silent)
-			printf("%s", s);
-	} else {
-		show_textbox(NULL, s, 6, 60);
-	}
-}
-
-static int handle_exit(void)
-{
-	int res;
-
-	save_and_exit = 1;
-	reset_subtitle();
-	dialog_clear();
-	if (conf_get_changed())
-		res = dialog_yesno(NULL,
-				   "Do you wish to save your new configuration?\n"
-				     "(Press <ESC><ESC> to continue kernel configuration.)",
-				   6, 60);
-	else
-		res = -1;
-
-	end_dialog(saved_x, saved_y);
-
-	switch (res) {
-	case 0:
-		if (conf_write(filename)) {
-			fprintf(stderr, "\n\n"
-					  "Error while writing of the configuration.\n"
-					  "Your configuration changes were NOT saved."
-					  "\n\n");
-			return 1;
-		}
-		conf_write_autoconf(0);
-		/* fall through */
-	case -1:
-		if (!silent)
-			printf("\n\n"
-				 "*** End of the configuration.\n"
-				 "*** Execute 'make' to start the build or try 'make help'."
-				 "\n\n");
-		res = 0;
-		break;
-	default:
-		if (!silent)
-			fprintf(stderr, "\n\n"
-					  "Your configuration changes were NOT saved."
-					  "\n\n");
-		if (res != KEY_ESC)
-			res = 0;
-	}
-
-	return res;
-}
-
-static void sig_handler(int signo)
-{
-	exit(handle_exit());
-}
-
-int main(int ac, char **av)
-{
-	char *mode;
-	int res;
-
-	signal(SIGINT, sig_handler);
-
-	if (ac > 1 && strcmp(av[1], "-s") == 0) {
-		silent = 1;
-		/* Silence conf_read() until the real callback is set up */
-		conf_set_message_callback(NULL);
-		av++;
-	}
-	conf_parse(av[1]);
-	conf_read(NULL);
-
-	mode = getenv("MENUCONFIG_MODE");
-	if (mode) {
-		if (!strcasecmp(mode, "single_menu"))
-			single_menu_mode = 1;
-	}
-
-	if (init_dialog(NULL)) {
-		fprintf(stderr, "Your display is too small to run Menuconfig!\n");
-		fprintf(stderr, "It must be at least 19 lines by 80 columns.\n");
-		return 1;
-	}
-
-	set_config_filename(conf_get_configname());
-	conf_set_message_callback(conf_message_callback);
-	do {
-		conf(&rootmenu, NULL);
-		res = handle_exit();
-	} while (res == KEY_ESC);
-
-	return res;
-}
diff -Nrup linux-6.16.7/scripts/kernel-doc linux-lenovo-x13s-linux-6.16.y/scripts/kernel-doc
--- linux-6.16.7/scripts/kernel-doc	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/scripts/kernel-doc	2025-09-11 09:47:42.000000000 -0600
@@ -1,315 +1 @@
-#!/usr/bin/env python3
-# SPDX-License-Identifier: GPL-2.0
-# Copyright(c) 2025: Mauro Carvalho Chehab <mchehab@kernel.org>.
-#
-# pylint: disable=C0103,R0915
-#
-# Converted from the kernel-doc script originally written in Perl
-# under GPLv2, copyrighted since 1998 by the following authors:
-#
-#    Aditya Srivastava <yashsri421@gmail.com>
-#    Akira Yokosawa <akiyks@gmail.com>
-#    Alexander A. Klimov <grandmaster@al2klimov.de>
-#    Alexander Lobakin <aleksander.lobakin@intel.com>
-#    Andr Almeida <andrealmeid@igalia.com>
-#    Andy Shevchenko <andriy.shevchenko@linux.intel.com>
-#    Anna-Maria Behnsen <anna-maria@linutronix.de>
-#    Armin Kuster <akuster@mvista.com>
-#    Bart Van Assche <bart.vanassche@sandisk.com>
-#    Ben Hutchings <ben@decadent.org.uk>
-#    Borislav Petkov <bbpetkov@yahoo.de>
-#    Chen-Yu Tsai <wenst@chromium.org>
-#    Coco Li <lixiaoyan@google.com>
-#    Conchr Navid <conchur@web.de>
-#    Daniel Santos <daniel.santos@pobox.com>
-#    Danilo Cesar Lemes de Paula <danilo.cesar@collabora.co.uk>
-#    Dan Luedtke <mail@danrl.de>
-#    Donald Hunter <donald.hunter@gmail.com>
-#    Gabriel Krisman Bertazi <krisman@collabora.co.uk>
-#    Greg Kroah-Hartman <gregkh@linuxfoundation.org>
-#    Harvey Harrison <harvey.harrison@gmail.com>
-#    Horia Geanta <horia.geanta@freescale.com>
-#    Ilya Dryomov <idryomov@gmail.com>
-#    Jakub Kicinski <kuba@kernel.org>
-#    Jani Nikula <jani.nikula@intel.com>
-#    Jason Baron <jbaron@redhat.com>
-#    Jason Gunthorpe <jgg@nvidia.com>
-#    Jrmy Bobbio <lunar@debian.org>
-#    Johannes Berg <johannes.berg@intel.com>
-#    Johannes Weiner <hannes@cmpxchg.org>
-#    Jonathan Cameron <Jonathan.Cameron@huawei.com>
-#    Jonathan Corbet <corbet@lwn.net>
-#    Jonathan Neuschfer <j.neuschaefer@gmx.net>
-#    Kamil Rytarowski <n54@gmx.com>
-#    Kees Cook <kees@kernel.org>
-#    Laurent Pinchart <laurent.pinchart@ideasonboard.com>
-#    Levin, Alexander (Sasha Levin) <alexander.levin@verizon.com>
-#    Linus Torvalds <torvalds@linux-foundation.org>
-#    Lucas De Marchi <lucas.demarchi@profusion.mobi>
-#    Mark Rutland <mark.rutland@arm.com>
-#    Markus Heiser <markus.heiser@darmarit.de>
-#    Martin Waitz <tali@admingilde.org>
-#    Masahiro Yamada <masahiroy@kernel.org>
-#    Matthew Wilcox <willy@infradead.org>
-#    Mauro Carvalho Chehab <mchehab+huawei@kernel.org>
-#    Michal Wajdeczko <michal.wajdeczko@intel.com>
-#    Michael Zucchi
-#    Mike Rapoport <rppt@linux.ibm.com>
-#    Niklas Sderlund <niklas.soderlund@corigine.com>
-#    Nishanth Menon <nm@ti.com>
-#    Paolo Bonzini <pbonzini@redhat.com>
-#    Pavan Kumar Linga <pavan.kumar.linga@intel.com>
-#    Pavel Pisa <pisa@cmp.felk.cvut.cz>
-#    Peter Maydell <peter.maydell@linaro.org>
-#    Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
-#    Randy Dunlap <rdunlap@infradead.org>
-#    Richard Kennedy <richard@rsk.demon.co.uk>
-#    Rich Walker <rw@shadow.org.uk>
-#    Rolf Eike Beer <eike-kernel@sf-tec.de>
-#    Sakari Ailus <sakari.ailus@linux.intel.com>
-#    Silvio Fricke <silvio.fricke@gmail.com>
-#    Simon Huggins
-#    Tim Waugh <twaugh@redhat.com>
-#    Tomasz Warnieo <tomasz.warniello@gmail.com>
-#    Utkarsh Tripathi <utripathi2002@gmail.com>
-#    valdis.kletnieks@vt.edu <valdis.kletnieks@vt.edu>
-#    Vegard Nossum <vegard.nossum@oracle.com>
-#    Will Deacon <will.deacon@arm.com>
-#    Yacine Belkadi <yacine.belkadi.1@gmail.com>
-#    Yujie Liu <yujie.liu@intel.com>
-
-"""
-kernel_doc
-==========
-
-Print formatted kernel documentation to stdout
-
-Read C language source or header FILEs, extract embedded
-documentation comments, and print formatted documentation
-to standard output.
-
-The documentation comments are identified by the "/**"
-opening comment mark.
-
-See Documentation/doc-guide/kernel-doc.rst for the
-documentation comment syntax.
-"""
-
-import argparse
-import logging
-import os
-import sys
-
-# Import Python modules
-
-LIB_DIR = "lib/kdoc"
-SRC_DIR = os.path.dirname(os.path.realpath(__file__))
-
-sys.path.insert(0, os.path.join(SRC_DIR, LIB_DIR))
-
-from kdoc_files import KernelFiles                      # pylint: disable=C0413
-from kdoc_output import RestFormat, ManFormat           # pylint: disable=C0413
-
-DESC = """
-Read C language source or header FILEs, extract embedded documentation comments,
-and print formatted documentation to standard output.
-
-The documentation comments are identified by the "/**" opening comment mark.
-
-See Documentation/doc-guide/kernel-doc.rst for the documentation comment syntax.
-"""
-
-EXPORT_FILE_DESC = """
-Specify an additional FILE in which to look for EXPORT_SYMBOL information.
-
-May be used multiple times.
-"""
-
-EXPORT_DESC = """
-Only output documentation for the symbols that have been
-exported using EXPORT_SYMBOL() and related macros in any input
-FILE or -export-file FILE.
-"""
-
-INTERNAL_DESC = """
-Only output documentation for the symbols that have NOT been
-exported using EXPORT_SYMBOL() and related macros in any input
-FILE or -export-file FILE.
-"""
-
-FUNCTION_DESC = """
-Only output documentation for the given function or DOC: section
-title. All other functions and DOC: sections are ignored.
-
-May be used multiple times.
-"""
-
-NOSYMBOL_DESC = """
-Exclude the specified symbol from the output documentation.
-
-May be used multiple times.
-"""
-
-FILES_DESC = """
-Header and C source files to be parsed.
-"""
-
-WARN_CONTENTS_BEFORE_SECTIONS_DESC = """
-Warns if there are contents before sections (deprecated).
-
-This option is kept just for backward-compatibility, but it does nothing,
-neither here nor at the original Perl script.
-"""
-
-
-class MsgFormatter(logging.Formatter):
-    """Helper class to format warnings on a similar way to kernel-doc.pl"""
-
-    def format(self, record):
-        record.levelname = record.levelname.capitalize()
-        return logging.Formatter.format(self, record)
-
-def main():
-    """Main program"""
-
-    parser = argparse.ArgumentParser(formatter_class=argparse.RawTextHelpFormatter,
-                                     description=DESC)
-
-    # Normal arguments
-
-    parser.add_argument("-v", "-verbose", "--verbose", action="store_true",
-                        help="Verbose output, more warnings and other information.")
-
-    parser.add_argument("-d", "-debug", "--debug", action="store_true",
-                        help="Enable debug messages")
-
-    parser.add_argument("-M", "-modulename", "--modulename",
-                        default="Kernel API",
-                        help="Allow setting a module name at the output.")
-
-    parser.add_argument("-l", "-enable-lineno", "--enable_lineno",
-                        action="store_true",
-                        help="Enable line number output (only in ReST mode)")
-
-    # Arguments to control the warning behavior
-
-    parser.add_argument("-Wreturn", "--wreturn", action="store_true",
-                        help="Warns about the lack of a return markup on functions.")
-
-    parser.add_argument("-Wshort-desc", "-Wshort-description", "--wshort-desc",
-                        action="store_true",
-                        help="Warns if initial short description is missing")
-
-    parser.add_argument("-Wcontents-before-sections",
-                        "--wcontents-before-sections", action="store_true",
-                        help=WARN_CONTENTS_BEFORE_SECTIONS_DESC)
-
-    parser.add_argument("-Wall", "--wall", action="store_true",
-                        help="Enable all types of warnings")
-
-    parser.add_argument("-Werror", "--werror", action="store_true",
-                        help="Treat warnings as errors.")
-
-    parser.add_argument("-export-file", "--export-file", action='append',
-                        help=EXPORT_FILE_DESC)
-
-    # Output format mutually-exclusive group
-
-    out_group = parser.add_argument_group("Output format selection (mutually exclusive)")
-
-    out_fmt = out_group.add_mutually_exclusive_group()
-
-    out_fmt.add_argument("-m", "-man", "--man", action="store_true",
-                         help="Output troff manual page format.")
-    out_fmt.add_argument("-r", "-rst", "--rst", action="store_true",
-                         help="Output reStructuredText format (default).")
-    out_fmt.add_argument("-N", "-none", "--none", action="store_true",
-                         help="Do not output documentation, only warnings.")
-
-    # Output selection mutually-exclusive group
-
-    sel_group = parser.add_argument_group("Output selection (mutually exclusive)")
-    sel_mut = sel_group.add_mutually_exclusive_group()
-
-    sel_mut.add_argument("-e", "-export", "--export", action='store_true',
-                         help=EXPORT_DESC)
-
-    sel_mut.add_argument("-i", "-internal", "--internal", action='store_true',
-                         help=INTERNAL_DESC)
-
-    sel_mut.add_argument("-s", "-function", "--symbol", action='append',
-                         help=FUNCTION_DESC)
-
-    # Those are valid for all 3 types of filter
-    parser.add_argument("-n", "-nosymbol", "--nosymbol", action='append',
-                        help=NOSYMBOL_DESC)
-
-    parser.add_argument("-D", "-no-doc-sections", "--no-doc-sections",
-                        action='store_true', help="Don't outputt DOC sections")
-
-    parser.add_argument("files", metavar="FILE",
-                        nargs="+", help=FILES_DESC)
-
-    args = parser.parse_args()
-
-    if args.wall:
-        args.wreturn = True
-        args.wshort_desc = True
-        args.wcontents_before_sections = True
-
-    logger = logging.getLogger()
-
-    if not args.debug:
-        logger.setLevel(logging.INFO)
-    else:
-        logger.setLevel(logging.DEBUG)
-
-    formatter = MsgFormatter('%(levelname)s: %(message)s')
-
-    handler = logging.StreamHandler()
-    handler.setFormatter(formatter)
-
-    logger.addHandler(handler)
-
-    if args.man:
-        out_style = ManFormat(modulename=args.modulename)
-    elif args.none:
-        out_style = None
-    else:
-        out_style = RestFormat()
-
-    kfiles = KernelFiles(verbose=args.verbose,
-                         out_style=out_style, werror=args.werror,
-                         wreturn=args.wreturn, wshort_desc=args.wshort_desc,
-                         wcontents_before_sections=args.wcontents_before_sections)
-
-    kfiles.parse(args.files, export_file=args.export_file)
-
-    for t in kfiles.msg(enable_lineno=args.enable_lineno, export=args.export,
-                        internal=args.internal, symbol=args.symbol,
-                        nosymbol=args.nosymbol, export_file=args.export_file,
-                        no_doc_sections=args.no_doc_sections):
-        msg = t[1]
-        if msg:
-            print(msg)
-
-    error_count = kfiles.errors
-    if not error_count:
-        sys.exit(0)
-
-    if args.werror:
-        print(f"{error_count} warnings as errors")
-        sys.exit(error_count)
-
-    if args.verbose:
-        print(f"{error_count} errors")
-
-    if args.none:
-        sys.exit(0)
-
-    sys.exit(error_count)
-
-
-# Call main method
-if __name__ == "__main__":
-    main()
+kernel-doc.py
\ No newline at end of file
diff -Nrup linux-6.16.7/scripts/sign-file.c linux-lenovo-x13s-linux-6.16.y/scripts/sign-file.c
--- linux-6.16.7/scripts/sign-file.c	2025-09-13 16:15:46.046904569 -0600
+++ linux-lenovo-x13s-linux-6.16.y/scripts/sign-file.c	2025-09-11 09:47:42.000000000 -0600
@@ -51,10 +51,9 @@
  * signing with anything other than SHA1 - so we're stuck with that if such is
  * the case.
  */
-#if defined(OPENSSL_NO_CMS) || \
-	( defined(LIBRESSL_VERSION_NUMBER) \
-	&& (LIBRESSL_VERSION_NUMBER < 0x3010000fL) ) || \
-	OPENSSL_VERSION_NUMBER < 0x10000000L
+#if defined(LIBRESSL_VERSION_NUMBER) || \
+	OPENSSL_VERSION_NUMBER < 0x10000000L || \
+	defined(OPENSSL_NO_CMS)
 #define USE_PKCS7
 #endif
 #ifndef USE_PKCS7
diff -Nrup linux-6.16.7/scripts/sign-file.c.orig linux-lenovo-x13s-linux-6.16.y/scripts/sign-file.c.orig
--- linux-6.16.7/scripts/sign-file.c.orig	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/scripts/sign-file.c.orig	1969-12-31 17:00:00.000000000 -0700
@@ -1,410 +0,0 @@
-/* Sign a module file using the given key.
- *
- * Copyright  2014-2016 Red Hat, Inc. All Rights Reserved.
- * Copyright  2015      Intel Corporation.
- * Copyright  2016      Hewlett Packard Enterprise Development LP
- *
- * Authors: David Howells <dhowells@redhat.com>
- *          David Woodhouse <dwmw2@infradead.org>
- *          Juerg Haefliger <juerg.haefliger@hpe.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public License
- * as published by the Free Software Foundation; either version 2.1
- * of the licence, or (at your option) any later version.
- */
-#define _GNU_SOURCE
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdint.h>
-#include <stdbool.h>
-#include <string.h>
-#include <getopt.h>
-#include <err.h>
-#include <arpa/inet.h>
-#include <openssl/opensslv.h>
-#include <openssl/bio.h>
-#include <openssl/evp.h>
-#include <openssl/pem.h>
-#include <openssl/err.h>
-#if OPENSSL_VERSION_MAJOR >= 3
-# define USE_PKCS11_PROVIDER
-# include <openssl/provider.h>
-# include <openssl/store.h>
-#else
-# if !defined(OPENSSL_NO_ENGINE) && !defined(OPENSSL_NO_DEPRECATED_3_0)
-#  define USE_PKCS11_ENGINE
-#  include <openssl/engine.h>
-# endif
-#endif
-#include "ssl-common.h"
-
-/*
- * Use CMS if we have openssl-1.0.0 or newer available - otherwise we have to
- * assume that it's not available and its header file is missing and that we
- * should use PKCS#7 instead.  Switching to the older PKCS#7 format restricts
- * the options we have on specifying the X.509 certificate we want.
- *
- * Further, older versions of OpenSSL don't support manually adding signers to
- * the PKCS#7 message so have to accept that we get a certificate included in
- * the signature message.  Nor do such older versions of OpenSSL support
- * signing with anything other than SHA1 - so we're stuck with that if such is
- * the case.
- */
-#if defined(LIBRESSL_VERSION_NUMBER) || \
-	OPENSSL_VERSION_NUMBER < 0x10000000L || \
-	defined(OPENSSL_NO_CMS)
-#define USE_PKCS7
-#endif
-#ifndef USE_PKCS7
-#include <openssl/cms.h>
-#else
-#include <openssl/pkcs7.h>
-#endif
-
-struct module_signature {
-	uint8_t		algo;		/* Public-key crypto algorithm [0] */
-	uint8_t		hash;		/* Digest algorithm [0] */
-	uint8_t		id_type;	/* Key identifier type [PKEY_ID_PKCS7] */
-	uint8_t		signer_len;	/* Length of signer's name [0] */
-	uint8_t		key_id_len;	/* Length of key identifier [0] */
-	uint8_t		__pad[3];
-	uint32_t	sig_len;	/* Length of signature data */
-};
-
-#define PKEY_ID_PKCS7 2
-
-static char magic_number[] = "~Module signature appended~\n";
-
-static __attribute__((noreturn))
-void format(void)
-{
-	fprintf(stderr,
-		"Usage: scripts/sign-file [-dp] <hash algo> <key> <x509> <module> [<dest>]\n");
-	fprintf(stderr,
-		"       scripts/sign-file -s <raw sig> <hash algo> <x509> <module> [<dest>]\n");
-	exit(2);
-}
-
-static const char *key_pass;
-
-static int pem_pw_cb(char *buf, int len, int w, void *v)
-{
-	int pwlen;
-
-	if (!key_pass)
-		return -1;
-
-	pwlen = strlen(key_pass);
-	if (pwlen >= len)
-		return -1;
-
-	strcpy(buf, key_pass);
-
-	/* If it's wrong, don't keep trying it. */
-	key_pass = NULL;
-
-	return pwlen;
-}
-
-static EVP_PKEY *read_private_key_pkcs11(const char *private_key_name)
-{
-	EVP_PKEY *private_key = NULL;
-#ifdef USE_PKCS11_PROVIDER
-	OSSL_STORE_CTX *store;
-
-	if (!OSSL_PROVIDER_try_load(NULL, "pkcs11", true))
-		ERR(1, "OSSL_PROVIDER_try_load(pkcs11)");
-	if (!OSSL_PROVIDER_try_load(NULL, "default", true))
-		ERR(1, "OSSL_PROVIDER_try_load(default)");
-
-	store = OSSL_STORE_open(private_key_name, NULL, NULL, NULL, NULL);
-	ERR(!store, "OSSL_STORE_open");
-
-	while (!OSSL_STORE_eof(store)) {
-		OSSL_STORE_INFO *info = OSSL_STORE_load(store);
-
-		if (!info) {
-			drain_openssl_errors(__LINE__, 0);
-			continue;
-		}
-		if (OSSL_STORE_INFO_get_type(info) == OSSL_STORE_INFO_PKEY) {
-			private_key = OSSL_STORE_INFO_get1_PKEY(info);
-			ERR(!private_key, "OSSL_STORE_INFO_get1_PKEY");
-		}
-		OSSL_STORE_INFO_free(info);
-		if (private_key)
-			break;
-	}
-	OSSL_STORE_close(store);
-#elif defined(USE_PKCS11_ENGINE)
-	ENGINE *e;
-
-	ENGINE_load_builtin_engines();
-	drain_openssl_errors(__LINE__, 1);
-	e = ENGINE_by_id("pkcs11");
-	ERR(!e, "Load PKCS#11 ENGINE");
-	if (ENGINE_init(e))
-		drain_openssl_errors(__LINE__, 1);
-	else
-		ERR(1, "ENGINE_init");
-	if (key_pass)
-		ERR(!ENGINE_ctrl_cmd_string(e, "PIN", key_pass, 0), "Set PKCS#11 PIN");
-	private_key = ENGINE_load_private_key(e, private_key_name, NULL, NULL);
-	ERR(!private_key, "%s", private_key_name);
-#else
-	fprintf(stderr, "no pkcs11 engine/provider available\n");
-	exit(1);
-#endif
-	return private_key;
-}
-
-static EVP_PKEY *read_private_key(const char *private_key_name)
-{
-	if (!strncmp(private_key_name, "pkcs11:", 7)) {
-		return read_private_key_pkcs11(private_key_name);
-	} else {
-		EVP_PKEY *private_key;
-		BIO *b;
-
-		b = BIO_new_file(private_key_name, "rb");
-		ERR(!b, "%s", private_key_name);
-		private_key = PEM_read_bio_PrivateKey(b, NULL, pem_pw_cb,
-						      NULL);
-		ERR(!private_key, "%s", private_key_name);
-		BIO_free(b);
-
-		return private_key;
-	}
-}
-
-static X509 *read_x509(const char *x509_name)
-{
-	unsigned char buf[2];
-	X509 *x509;
-	BIO *b;
-	int n;
-
-	b = BIO_new_file(x509_name, "rb");
-	ERR(!b, "%s", x509_name);
-
-	/* Look at the first two bytes of the file to determine the encoding */
-	n = BIO_read(b, buf, 2);
-	if (n != 2) {
-		if (BIO_should_retry(b)) {
-			fprintf(stderr, "%s: Read wanted retry\n", x509_name);
-			exit(1);
-		}
-		if (n >= 0) {
-			fprintf(stderr, "%s: Short read\n", x509_name);
-			exit(1);
-		}
-		ERR(1, "%s", x509_name);
-	}
-
-	ERR(BIO_reset(b) != 0, "%s", x509_name);
-
-	if (buf[0] == 0x30 && buf[1] >= 0x81 && buf[1] <= 0x84)
-		/* Assume raw DER encoded X.509 */
-		x509 = d2i_X509_bio(b, NULL);
-	else
-		/* Assume PEM encoded X.509 */
-		x509 = PEM_read_bio_X509(b, NULL, NULL, NULL);
-
-	BIO_free(b);
-	ERR(!x509, "%s", x509_name);
-
-	return x509;
-}
-
-int main(int argc, char **argv)
-{
-	struct module_signature sig_info = { .id_type = PKEY_ID_PKCS7 };
-	char *hash_algo = NULL;
-	char *private_key_name = NULL, *raw_sig_name = NULL;
-	char *x509_name, *module_name, *dest_name;
-	bool save_sig = false, replace_orig;
-	bool sign_only = false;
-	bool raw_sig = false;
-	unsigned char buf[4096];
-	unsigned long module_size, sig_size;
-	unsigned int use_signed_attrs;
-	const EVP_MD *digest_algo;
-	EVP_PKEY *private_key;
-#ifndef USE_PKCS7
-	CMS_ContentInfo *cms = NULL;
-	unsigned int use_keyid = 0;
-#else
-	PKCS7 *pkcs7 = NULL;
-#endif
-	X509 *x509;
-	BIO *bd, *bm;
-	int opt, n;
-	OpenSSL_add_all_algorithms();
-	ERR_load_crypto_strings();
-	ERR_clear_error();
-
-	key_pass = getenv("KBUILD_SIGN_PIN");
-
-#ifndef USE_PKCS7
-	use_signed_attrs = CMS_NOATTR;
-#else
-	use_signed_attrs = PKCS7_NOATTR;
-#endif
-
-	do {
-		opt = getopt(argc, argv, "sdpk");
-		switch (opt) {
-		case 's': raw_sig = true; break;
-		case 'p': save_sig = true; break;
-		case 'd': sign_only = true; save_sig = true; break;
-#ifndef USE_PKCS7
-		case 'k': use_keyid = CMS_USE_KEYID; break;
-#endif
-		case -1: break;
-		default: format();
-		}
-	} while (opt != -1);
-
-	argc -= optind;
-	argv += optind;
-	if (argc < 4 || argc > 5)
-		format();
-
-	if (raw_sig) {
-		raw_sig_name = argv[0];
-		hash_algo = argv[1];
-	} else {
-		hash_algo = argv[0];
-		private_key_name = argv[1];
-	}
-	x509_name = argv[2];
-	module_name = argv[3];
-	if (argc == 5 && strcmp(argv[3], argv[4]) != 0) {
-		dest_name = argv[4];
-		replace_orig = false;
-	} else {
-		ERR(asprintf(&dest_name, "%s.~signed~", module_name) < 0,
-		    "asprintf");
-		replace_orig = true;
-	}
-
-#ifdef USE_PKCS7
-	if (strcmp(hash_algo, "sha1") != 0) {
-		fprintf(stderr, "sign-file: %s only supports SHA1 signing\n",
-			OPENSSL_VERSION_TEXT);
-		exit(3);
-	}
-#endif
-
-	/* Open the module file */
-	bm = BIO_new_file(module_name, "rb");
-	ERR(!bm, "%s", module_name);
-
-	if (!raw_sig) {
-		/* Read the private key and the X.509 cert the PKCS#7 message
-		 * will point to.
-		 */
-		private_key = read_private_key(private_key_name);
-		x509 = read_x509(x509_name);
-
-		/* Digest the module data. */
-		OpenSSL_add_all_digests();
-		drain_openssl_errors(__LINE__, 0);
-		digest_algo = EVP_get_digestbyname(hash_algo);
-		ERR(!digest_algo, "EVP_get_digestbyname");
-
-#ifndef USE_PKCS7
-		/* Load the signature message from the digest buffer. */
-		cms = CMS_sign(NULL, NULL, NULL, NULL,
-			       CMS_NOCERTS | CMS_PARTIAL | CMS_BINARY |
-			       CMS_DETACHED | CMS_STREAM);
-		ERR(!cms, "CMS_sign");
-
-		ERR(!CMS_add1_signer(cms, x509, private_key, digest_algo,
-				     CMS_NOCERTS | CMS_BINARY |
-				     CMS_NOSMIMECAP | use_keyid |
-				     use_signed_attrs),
-		    "CMS_add1_signer");
-		ERR(CMS_final(cms, bm, NULL, CMS_NOCERTS | CMS_BINARY) != 1,
-		    "CMS_final");
-
-#else
-		pkcs7 = PKCS7_sign(x509, private_key, NULL, bm,
-				   PKCS7_NOCERTS | PKCS7_BINARY |
-				   PKCS7_DETACHED | use_signed_attrs);
-		ERR(!pkcs7, "PKCS7_sign");
-#endif
-
-		if (save_sig) {
-			char *sig_file_name;
-			BIO *b;
-
-			ERR(asprintf(&sig_file_name, "%s.p7s", module_name) < 0,
-			    "asprintf");
-			b = BIO_new_file(sig_file_name, "wb");
-			ERR(!b, "%s", sig_file_name);
-#ifndef USE_PKCS7
-			ERR(i2d_CMS_bio_stream(b, cms, NULL, 0) != 1,
-			    "%s", sig_file_name);
-#else
-			ERR(i2d_PKCS7_bio(b, pkcs7) != 1,
-			    "%s", sig_file_name);
-#endif
-			BIO_free(b);
-		}
-
-		if (sign_only) {
-			BIO_free(bm);
-			return 0;
-		}
-	}
-
-	/* Open the destination file now so that we can shovel the module data
-	 * across as we read it.
-	 */
-	bd = BIO_new_file(dest_name, "wb");
-	ERR(!bd, "%s", dest_name);
-
-	/* Append the marker and the PKCS#7 message to the destination file */
-	ERR(BIO_reset(bm) < 0, "%s", module_name);
-	while ((n = BIO_read(bm, buf, sizeof(buf))),
-	       n > 0) {
-		ERR(BIO_write(bd, buf, n) < 0, "%s", dest_name);
-	}
-	BIO_free(bm);
-	ERR(n < 0, "%s", module_name);
-	module_size = BIO_number_written(bd);
-
-	if (!raw_sig) {
-#ifndef USE_PKCS7
-		ERR(i2d_CMS_bio_stream(bd, cms, NULL, 0) != 1, "%s", dest_name);
-#else
-		ERR(i2d_PKCS7_bio(bd, pkcs7) != 1, "%s", dest_name);
-#endif
-	} else {
-		BIO *b;
-
-		/* Read the raw signature file and write the data to the
-		 * destination file
-		 */
-		b = BIO_new_file(raw_sig_name, "rb");
-		ERR(!b, "%s", raw_sig_name);
-		while ((n = BIO_read(b, buf, sizeof(buf))), n > 0)
-			ERR(BIO_write(bd, buf, n) < 0, "%s", dest_name);
-		BIO_free(b);
-	}
-
-	sig_size = BIO_number_written(bd) - module_size;
-	sig_info.sig_len = htonl(sig_size);
-	ERR(BIO_write(bd, &sig_info, sizeof(sig_info)) < 0, "%s", dest_name);
-	ERR(BIO_write(bd, magic_number, sizeof(magic_number) - 1) < 0, "%s", dest_name);
-
-	ERR(BIO_free(bd) != 1, "%s", dest_name);
-
-	/* Finally, if we're signing in place, replace the original. */
-	if (replace_orig)
-		ERR(rename(dest_name, module_name) < 0, "%s", dest_name);
-
-	return 0;
-}
diff -Nrup linux-6.16.7/sound/soc/codecs/Kconfig linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/Kconfig
--- linux-6.16.7/sound/soc/codecs/Kconfig	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/Kconfig	2025-09-11 09:47:42.000000000 -0600
@@ -2227,6 +2227,9 @@ config SND_SOC_UDA1380
 config SND_SOC_WCD_CLASSH
 	tristate
 
+config SND_SOC_WCD_COMMON
+	tristate
+
 config SND_SOC_WCD9335
 	tristate "WCD9335 Codec"
 	depends on SLIMBUS
@@ -2248,6 +2251,7 @@ config SND_SOC_WCD934X
 	select REGMAP_IRQ
 	select REGMAP_SLIMBUS
 	select SND_SOC_WCD_CLASSH
+	select SND_SOC_WCD_COMMON
 	select SND_SOC_WCD_MBHC
 	depends on MFD_WCD934X || COMPILE_TEST
 	help
@@ -2259,6 +2263,7 @@ config SND_SOC_WCD937X
 	tristate
 	depends on SOUNDWIRE || !SOUNDWIRE
 	select SND_SOC_WCD_CLASSH
+	select SND_SOC_WCD_COMMON
 
 config SND_SOC_WCD937X_SDW
 	tristate "WCD9370/WCD9375 Codec - SDW"
@@ -2278,6 +2283,7 @@ config SND_SOC_WCD938X
 	tristate
 	depends on SOUNDWIRE || !SOUNDWIRE
 	select SND_SOC_WCD_CLASSH
+	select SND_SOC_WCD_COMMON
 	select MULTIPLEXER
 
 config SND_SOC_WCD938X_SDW
@@ -2297,6 +2303,7 @@ config SND_SOC_WCD939X
 	depends on SOUNDWIRE || !SOUNDWIRE
 	depends on TYPEC || !TYPEC
 	select SND_SOC_WCD_CLASSH
+	select SND_SOC_WCD_COMMON
 
 config SND_SOC_WCD939X_SDW
 	tristate "WCD9390/WCD9395 Codec - SDW"
diff -Nrup linux-6.16.7/sound/soc/codecs/Makefile linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/Makefile
--- linux-6.16.7/sound/soc/codecs/Makefile	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/Makefile	2025-09-11 09:47:42.000000000 -0600
@@ -338,6 +338,7 @@ snd-soc-uda1334-y := uda1334.o
 snd-soc-uda1342-y := uda1342.o
 snd-soc-uda1380-y := uda1380.o
 snd-soc-wcd-classh-y := wcd-clsh-v2.o
+snd-soc-wcd-common-y := wcd-common.o
 snd-soc-wcd-mbhc-y := wcd-mbhc-v2.o
 snd-soc-wcd9335-y := wcd9335.o
 snd-soc-wcd934x-y := wcd934x.o
@@ -759,6 +760,7 @@ obj-$(CONFIG_SND_SOC_UDA1334)	+= snd-soc
 obj-$(CONFIG_SND_SOC_UDA1342)	+= snd-soc-uda1342.o
 obj-$(CONFIG_SND_SOC_UDA1380)	+= snd-soc-uda1380.o
 obj-$(CONFIG_SND_SOC_WCD_CLASSH)	+= snd-soc-wcd-classh.o
+obj-$(CONFIG_SND_SOC_WCD_COMMON)	+= snd-soc-wcd-common.o
 obj-$(CONFIG_SND_SOC_WCD_MBHC)	+= snd-soc-wcd-mbhc.o
 obj-$(CONFIG_SND_SOC_WCD9335)	+= snd-soc-wcd9335.o
 obj-$(CONFIG_SND_SOC_WCD934X)	+= snd-soc-wcd934x.o
diff -Nrup linux-6.16.7/sound/soc/codecs/wcd934x.c linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd934x.c
--- linux-6.16.7/sound/soc/codecs/wcd934x.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd934x.c	2025-09-11 09:47:42.000000000 -0600
@@ -21,6 +21,7 @@
 #include <sound/soc-dapm.h>
 #include <sound/tlv.h>
 #include "wcd-clsh-v2.h"
+#include "wcd-common.h"
 #include "wcd-mbhc-v2.h"
 
 #include <dt-bindings/sound/qcom,wcd934x.h>
@@ -116,9 +117,6 @@
 #define WCD934X_DEC_PWR_LVL_DF		0x00
 #define WCD934X_DEC_PWR_LVL_HYBRID WCD934X_DEC_PWR_LVL_DF
 
-#define WCD934X_DEF_MICBIAS_MV	1800
-#define WCD934X_MAX_MICBIAS_MV	2850
-
 #define WCD_IIR_FILTER_SIZE	(sizeof(u32) * BAND_MAX)
 
 #define WCD_IIR_FILTER_CTL(xname, iidx, bidx) \
@@ -530,6 +528,7 @@ struct wcd934x_codec {
 	struct slim_device *sdev;
 	struct slim_device *sidev;
 	struct wcd_clsh_ctrl *clsh_ctrl;
+	struct wcd_common common;
 	struct snd_soc_component *component;
 	struct wcd934x_slim_ch rx_chs[WCD934X_RX_MAX];
 	struct wcd934x_slim_ch tx_chs[WCD934X_TX_MAX];
@@ -557,7 +556,6 @@ struct wcd934x_codec {
 	struct mutex micb_lock;
 	u32 micb_ref[WCD934X_MAX_MICBIAS];
 	u32 pullup_ref[WCD934X_MAX_MICBIAS];
-	u32 micb2_mv;
 };
 
 #define to_wcd934x_codec(_hw) container_of(_hw, struct wcd934x_codec, hw)
@@ -2172,55 +2170,24 @@ static struct clk *wcd934x_register_mclk
 	return NULL;
 }
 
-static int wcd934x_get_micbias_val(struct device *dev, const char *micbias,
-				   u32 *micb_mv)
-{
-	int mv;
-
-	if (of_property_read_u32(dev->parent->of_node, micbias, &mv)) {
-		dev_err(dev, "%s value not found, using default\n", micbias);
-		mv = WCD934X_DEF_MICBIAS_MV;
-	} else {
-		/* convert it to milli volts */
-		mv = mv/1000;
-	}
-
-	if (mv < 1000 || mv > 2850) {
-		dev_err(dev, "%s value not in valid range, using default\n",
-			micbias);
-		mv = WCD934X_DEF_MICBIAS_MV;
-	}
-
-	if (micb_mv)
-		*micb_mv = mv;
-
-	return (mv - 1000) / 50;
-}
-
 static int wcd934x_init_dmic(struct snd_soc_component *comp)
 {
-	int vout_ctl_1, vout_ctl_2, vout_ctl_3, vout_ctl_4;
 	struct wcd934x_codec *wcd = dev_get_drvdata(comp->dev);
 	u32 def_dmic_rate, dmic_clk_drv;
+	int ret;
 
-	vout_ctl_1 = wcd934x_get_micbias_val(comp->dev,
-					     "qcom,micbias1-microvolt", NULL);
-	vout_ctl_2 = wcd934x_get_micbias_val(comp->dev,
-					     "qcom,micbias2-microvolt",
-					     &wcd->micb2_mv);
-	vout_ctl_3 = wcd934x_get_micbias_val(comp->dev,
-					     "qcom,micbias3-microvolt", NULL);
-	vout_ctl_4 = wcd934x_get_micbias_val(comp->dev,
-					     "qcom,micbias4-microvolt", NULL);
+	ret = wcd_dt_parse_mbhc_data(comp->dev, &wcd->mbhc_cfg);
+	if (ret)
+		return ret;
 
 	snd_soc_component_update_bits(comp, WCD934X_ANA_MICB1,
-				      WCD934X_MICB_VAL_MASK, vout_ctl_1);
+				      WCD934X_MICB_VAL_MASK, wcd->common.micb_vout[0]);
 	snd_soc_component_update_bits(comp, WCD934X_ANA_MICB2,
-				      WCD934X_MICB_VAL_MASK, vout_ctl_2);
+				      WCD934X_MICB_VAL_MASK, wcd->common.micb_vout[1]);
 	snd_soc_component_update_bits(comp, WCD934X_ANA_MICB3,
-				      WCD934X_MICB_VAL_MASK, vout_ctl_3);
+				      WCD934X_MICB_VAL_MASK, wcd->common.micb_vout[2]);
 	snd_soc_component_update_bits(comp, WCD934X_ANA_MICB4,
-				      WCD934X_MICB_VAL_MASK, vout_ctl_4);
+				      WCD934X_MICB_VAL_MASK, wcd->common.micb_vout[3]);
 
 	if (wcd->rate == WCD934X_MCLK_CLK_9P6MHZ)
 		def_dmic_rate = WCD9XXX_DMIC_SAMPLE_RATE_4P8MHZ;
@@ -2521,15 +2488,6 @@ static void wcd934x_mbhc_micb_ramp_contr
 	}
 }
 
-static int wcd934x_get_micb_vout_ctl_val(u32 micb_mv)
-{
-	/* min micbias voltage is 1V and maximum is 2.85V */
-	if (micb_mv < 1000 || micb_mv > 2850)
-		return -EINVAL;
-
-	return (micb_mv - 1000) / 50;
-}
-
 static int wcd934x_mbhc_micb_adjust_voltage(struct snd_soc_component *component,
 					    int req_volt, int micb_num)
 {
@@ -2566,7 +2524,7 @@ static int wcd934x_mbhc_micb_adjust_volt
 	cur_vout_ctl = snd_soc_component_read_field(component, micb_reg,
 						    WCD934X_MICB_VAL_MASK);
 
-	req_vout_ctl = wcd934x_get_micb_vout_ctl_val(req_volt);
+	req_vout_ctl = wcd_get_micb_vout_ctl_val(component->dev, req_volt);
 	if (req_vout_ctl < 0) {
 		ret = -EINVAL;
 		goto exit;
@@ -2614,10 +2572,10 @@ static int wcd934x_mbhc_micb_ctrl_thresh
 	 * voltage needed to detect threshold microphone, then do
 	 * not change the micbias, just return.
 	 */
-	if (wcd934x->micb2_mv >= WCD_MBHC_THR_HS_MICB_MV)
+	if (wcd934x->common.micb_mv[1] >= WCD_MBHC_THR_HS_MICB_MV)
 		return 0;
 
-	micb_mv = req_en ? WCD_MBHC_THR_HS_MICB_MV : wcd934x->micb2_mv;
+	micb_mv = req_en ? WCD_MBHC_THR_HS_MICB_MV : wcd934x->common.micb_mv[1];
 
 	rc = wcd934x_mbhc_micb_adjust_voltage(component, micb_mv, MIC_BIAS_2);
 
@@ -3040,7 +2998,7 @@ static void wcd934x_mbhc_deinit(struct s
 static int wcd934x_comp_probe(struct snd_soc_component *component)
 {
 	struct wcd934x_codec *wcd = dev_get_drvdata(component->dev);
-	int i;
+	int i, ret;
 
 	snd_soc_component_init_regmap(component, wcd->regmap);
 	wcd->component = component;
@@ -3058,7 +3016,12 @@ static int wcd934x_comp_probe(struct snd
 	for (i = 0; i < NUM_CODEC_DAIS; i++)
 		INIT_LIST_HEAD(&wcd->dai[i].slim_ch_list);
 
-	wcd934x_init_dmic(component);
+
+	ret = wcd934x_init_dmic(component);
+	if (ret) {
+		dev_err(component->dev, "Failed to Initialize micbias\n");
+		return ret;
+	}
 
 	if (wcd934x_mbhc_init(component))
 		dev_err(component->dev, "Failed to Initialize MBHC\n");
@@ -5864,14 +5827,13 @@ static int wcd934x_codec_parse_data(stru
 	cfg->anc_micbias = MIC_BIAS_2;
 	cfg->v_hs_max = WCD_MBHC_HS_V_MAX;
 	cfg->num_btn = WCD934X_MBHC_MAX_BUTTONS;
-	cfg->micb_mv = wcd->micb2_mv;
+	cfg->micb_mv = wcd->common.micb_mv[1];
 	cfg->linein_th = 5000;
 	cfg->hs_thr = 1700;
 	cfg->hph_thr = 50;
 
 	wcd_dt_parse_mbhc_data(dev, cfg);
 
-
 	return 0;
 }
 
@@ -5892,6 +5854,8 @@ static int wcd934x_codec_probe(struct pl
 	wcd->sdev = to_slim_device(data->dev);
 	mutex_init(&wcd->sysclk_mutex);
 	mutex_init(&wcd->micb_lock);
+	wcd->common.dev = dev->parent;
+	wcd->common.max_bias = 4;
 
 	ret = wcd934x_codec_parse_data(wcd);
 	if (ret)
diff -Nrup linux-6.16.7/sound/soc/codecs/wcd937x.c linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd937x.c
--- linux-6.16.7/sound/soc/codecs/wcd937x.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd937x.c	2025-09-11 09:47:42.000000000 -0600
@@ -21,6 +21,7 @@
 #include <sound/tlv.h>
 
 #include "wcd-clsh-v2.h"
+#include "wcd-common.h"
 #include "wcd-mbhc-v2.h"
 #include "wcd937x.h"
 
@@ -87,6 +88,7 @@ struct wcd937x_priv {
 	struct wcd_mbhc_config mbhc_cfg;
 	struct wcd_mbhc_intr intr_ids;
 	struct wcd_clsh_ctrl *clsh_info;
+	struct wcd_common common;
 	struct irq_domain *virq;
 	struct regmap_irq_chip *wcd_regmap_irq_chip;
 	struct regmap_irq_chip_data *irq_chip;
@@ -97,9 +99,6 @@ struct wcd937x_priv {
 	s32 pullup_ref[WCD937X_MAX_MICBIAS];
 	u32 hph_mode;
 	int ear_rx_path;
-	u32 micb1_mv;
-	u32 micb2_mv;
-	u32 micb3_mv;
 	int hphr_pdm_wd_int;
 	int hphl_pdm_wd_int;
 	int aux_pdm_wd_int;
@@ -872,15 +871,6 @@ static int wcd937x_enable_rx3(struct snd
 	return 0;
 }
 
-static int wcd937x_get_micb_vout_ctl_val(u32 micb_mv)
-{
-	if (micb_mv < 1000 || micb_mv > 2850) {
-		pr_err("Unsupported micbias voltage (%u mV)\n", micb_mv);
-		return -EINVAL;
-	}
-
-	return (micb_mv - 1000) / 50;
-}
 
 static int wcd937x_tx_swr_ctrl(struct snd_soc_dapm_widget *w,
 			       struct snd_kcontrol *kcontrol, int event)
@@ -1193,7 +1183,7 @@ static int wcd937x_codec_enable_micbias_
 static int wcd937x_connect_port(struct wcd937x_sdw_priv *wcd, u8 port_idx, u8 ch_id, bool enable)
 {
 	struct sdw_port_config *port_config = &wcd->port_config[port_idx - 1];
-	const struct wcd937x_sdw_ch_info *ch_info = &wcd->ch_info[ch_id];
+	const struct wcd_sdw_ch_info *ch_info = &wcd->ch_info[ch_id];
 	u8 port_num = ch_info->port_num;
 	u8 ch_mask = ch_info->ch_mask;
 	u8 mstr_port_num, mstr_ch_mask;
@@ -1481,7 +1471,7 @@ static int wcd937x_mbhc_micb_adjust_volt
 	cur_vout_ctl = snd_soc_component_read_field(component, micb_reg,
 						    WCD937X_MICB_VOUT_MASK);
 
-	req_vout_ctl = wcd937x_get_micb_vout_ctl_val(req_volt);
+	req_vout_ctl = wcd_get_micb_vout_ctl_val(component->dev, req_volt);
 	if (req_vout_ctl < 0) {
 		ret = -EINVAL;
 		goto exit;
@@ -1529,10 +1519,10 @@ static int wcd937x_mbhc_micb_ctrl_thresh
 	 * voltage needed to detect threshold microphone, then do
 	 * not change the micbias, just return.
 	 */
-	if (wcd937x->micb2_mv >= WCD_MBHC_THR_HS_MICB_MV)
+	if (wcd937x->common.micb_mv[2] >= WCD_MBHC_THR_HS_MICB_MV)
 		return 0;
 
-	micb_mv = req_en ? WCD_MBHC_THR_HS_MICB_MV : wcd937x->micb2_mv;
+	micb_mv = req_en ? WCD_MBHC_THR_HS_MICB_MV : wcd937x->common.micb_mv[2];
 
 	return wcd937x_mbhc_micb_adjust_voltage(component, micb_mv, MIC_BIAS_2);
 }
@@ -2046,9 +2036,9 @@ static const struct snd_kcontrol_new wcd
 	SOC_ENUM_EXT("RX HPH Mode", rx_hph_mode_mux_enum,
 		     wcd937x_rx_hph_mode_get, wcd937x_rx_hph_mode_put),
 
-	SOC_SINGLE_EXT("HPHL_COMP Switch", SND_SOC_NOPM, 0, 1, 0,
+	SOC_SINGLE_EXT("HPHL_COMP Switch", WCD937X_COMP_L, 0, 1, 0,
 		       wcd937x_get_compander, wcd937x_set_compander),
-	SOC_SINGLE_EXT("HPHR_COMP Switch", SND_SOC_NOPM, 1, 1, 0,
+	SOC_SINGLE_EXT("HPHR_COMP Switch", WCD937X_COMP_R, 1, 1, 0,
 		       wcd937x_get_compander, wcd937x_set_compander),
 
 	SOC_SINGLE_TLV("HPHL Volume", WCD937X_HPH_L_EN, 0, 20, 1, line_gain),
@@ -2436,22 +2426,14 @@ static const struct snd_soc_dapm_route w
 	{ "DMIC6_MIXER", "Switch", "DMIC6" },
 };
 
-static int wcd937x_set_micbias_data(struct wcd937x_priv *wcd937x)
+static void wcd937x_set_micbias_data(struct device *dev, struct wcd937x_priv *wcd937x)
 {
-	int vout_ctl[3];
-
-	/* Set micbias voltage */
-	vout_ctl[0] = wcd937x_get_micb_vout_ctl_val(wcd937x->micb1_mv);
-	vout_ctl[1] = wcd937x_get_micb_vout_ctl_val(wcd937x->micb2_mv);
-	vout_ctl[2] = wcd937x_get_micb_vout_ctl_val(wcd937x->micb3_mv);
-	if ((vout_ctl[0] | vout_ctl[1] | vout_ctl[2]) < 0)
-		return -EINVAL;
-
-	regmap_update_bits(wcd937x->regmap, WCD937X_ANA_MICB1, WCD937X_ANA_MICB_VOUT, vout_ctl[0]);
-	regmap_update_bits(wcd937x->regmap, WCD937X_ANA_MICB2, WCD937X_ANA_MICB_VOUT, vout_ctl[1]);
-	regmap_update_bits(wcd937x->regmap, WCD937X_ANA_MICB3, WCD937X_ANA_MICB_VOUT, vout_ctl[2]);
-
-	return 0;
+	regmap_update_bits(wcd937x->regmap, WCD937X_ANA_MICB1, WCD937X_ANA_MICB_VOUT,
+			wcd937x->common.micb_vout[0]);
+	regmap_update_bits(wcd937x->regmap, WCD937X_ANA_MICB2, WCD937X_ANA_MICB_VOUT,
+			wcd937x->common.micb_vout[1]);
+	regmap_update_bits(wcd937x->regmap, WCD937X_ANA_MICB3, WCD937X_ANA_MICB_VOUT,
+			wcd937x->common.micb_vout[2]);
 }
 
 static irqreturn_t wcd937x_wd_handle_irq(int irq, void *data)
@@ -2630,31 +2612,6 @@ static const struct snd_soc_component_dr
 	.endianness = 1,
 };
 
-static void wcd937x_dt_parse_micbias_info(struct device *dev, struct wcd937x_priv *wcd)
-{
-	struct device_node *np = dev->of_node;
-	u32 prop_val = 0;
-	int ret = 0;
-
-	ret = of_property_read_u32(np, "qcom,micbias1-microvolt", &prop_val);
-	if (!ret)
-		wcd->micb1_mv = prop_val / 1000;
-	else
-		dev_warn(dev, "Micbias1 DT property not found\n");
-
-	ret = of_property_read_u32(np, "qcom,micbias2-microvolt", &prop_val);
-	if (!ret)
-		wcd->micb2_mv = prop_val / 1000;
-	else
-		dev_warn(dev, "Micbias2 DT property not found\n");
-
-	ret = of_property_read_u32(np, "qcom,micbias3-microvolt", &prop_val);
-	if (!ret)
-		wcd->micb3_mv = prop_val / 1000;
-	else
-		dev_warn(dev, "Micbias3 DT property not found\n");
-}
-
 static bool wcd937x_swap_gnd_mic(struct snd_soc_component *component)
 {
 	int value;
@@ -2788,7 +2745,7 @@ static int wcd937x_bind(struct device *d
 		return ret;
 	}
 
-	wcd937x->rxdev = wcd937x_sdw_device_get(wcd937x->rxnode);
+	wcd937x->rxdev = of_sdw_find_device_by_node(wcd937x->rxnode);
 	if (!wcd937x->rxdev) {
 		dev_err(dev, "could not find slave with matching of node\n");
 		return -EINVAL;
@@ -2797,7 +2754,7 @@ static int wcd937x_bind(struct device *d
 	wcd937x->sdw_priv[AIF1_PB] = dev_get_drvdata(wcd937x->rxdev);
 	wcd937x->sdw_priv[AIF1_PB]->wcd937x = wcd937x;
 
-	wcd937x->txdev = wcd937x_sdw_device_get(wcd937x->txnode);
+	wcd937x->txdev = of_sdw_find_device_by_node(wcd937x->txnode);
 	if (!wcd937x->txdev) {
 		dev_err(dev, "could not find txslave with matching of node\n");
 		return -EINVAL;
@@ -2833,7 +2790,7 @@ static int wcd937x_bind(struct device *d
 		return -EINVAL;
 	}
 
-	wcd937x->regmap = dev_get_regmap(&wcd937x->tx_sdw_dev->dev, NULL);
+	wcd937x->regmap = wcd937x->sdw_priv[AIF1_CAP]->regmap;
 	if (!wcd937x->regmap) {
 		dev_err(dev, "could not get TX device regmap\n");
 		return -EINVAL;
@@ -2848,11 +2805,7 @@ static int wcd937x_bind(struct device *d
 	wcd937x->sdw_priv[AIF1_PB]->slave_irq = wcd937x->virq;
 	wcd937x->sdw_priv[AIF1_CAP]->slave_irq = wcd937x->virq;
 
-	ret = wcd937x_set_micbias_data(wcd937x);
-	if (ret < 0) {
-		dev_err(dev, "Bad micbias pdata\n");
-		return ret;
-	}
+	wcd937x_set_micbias_data(dev, wcd937x);
 
 	ret = snd_soc_register_component(dev, &soc_codec_dev_wcd937x,
 					 wcd937x_dais, ARRAY_SIZE(wcd937x_dais));
@@ -2920,6 +2873,8 @@ static int wcd937x_probe(struct platform
 
 	dev_set_drvdata(dev, wcd937x);
 	mutex_init(&wcd937x->micb_lock);
+	wcd937x->common.dev = dev;
+	wcd937x->common.max_bias = 3;
 
 	wcd937x->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_LOW);
 	if (IS_ERR(wcd937x->reset_gpio))
@@ -2947,13 +2902,15 @@ static int wcd937x_probe(struct platform
 	if (ret)
 		return dev_err_probe(dev, ret, "Failed to enable supplies\n");
 
-	wcd937x_dt_parse_micbias_info(dev, wcd937x);
+	ret = wcd_dt_parse_micbias_info(&wcd937x->common);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get micbias\n");
 
 	cfg->mbhc_micbias = MIC_BIAS_2;
 	cfg->anc_micbias = MIC_BIAS_2;
 	cfg->v_hs_max = WCD_MBHC_HS_V_MAX;
 	cfg->num_btn = WCD937X_MBHC_MAX_BUTTONS;
-	cfg->micb_mv = wcd937x->micb2_mv;
+	cfg->micb_mv = wcd937x->common.micb_mv[2];
 	cfg->linein_th = 5000;
 	cfg->hs_thr = 1700;
 	cfg->hph_thr = 50;
diff -Nrup linux-6.16.7/sound/soc/codecs/wcd937x.h linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd937x.h
--- linux-6.16.7/sound/soc/codecs/wcd937x.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd937x.h	2025-09-11 09:47:42.000000000 -0600
@@ -7,6 +7,7 @@
 
 #include <linux/soundwire/sdw.h>
 #include <linux/soundwire/sdw_type.h>
+#include "wcd-common.h"
 
 #define WCD937X_BASE_ADDRESS			0x3000
 #define WCD937X_ANA_BIAS			0x3001
@@ -508,26 +509,13 @@ enum wcd937x_rx_sdw_ports {
 	WCD937X_MAX_SWR_PORTS = WCD937X_DSD_PORT,
 };
 
-struct wcd937x_sdw_ch_info {
-	int port_num;
-	unsigned int ch_mask;
-	unsigned int master_ch_mask;
-};
-
-#define WCD_SDW_CH(id, pn, cmask)	\
-	[id] = {			\
-		.port_num = pn,		\
-		.ch_mask = cmask,	\
-		.master_ch_mask = cmask,	\
-	}
-
 struct wcd937x_priv;
 struct wcd937x_sdw_priv {
 	struct sdw_slave *sdev;
 	struct sdw_stream_config sconfig;
 	struct sdw_stream_runtime *sruntime;
 	struct sdw_port_config port_config[WCD937X_MAX_SWR_PORTS];
-	struct wcd937x_sdw_ch_info *ch_info;
+	struct wcd_sdw_ch_info *ch_info;
 	bool port_enable[WCD937X_MAX_SWR_CH_IDS];
 	unsigned int master_channel_map[SDW_MAX_PORTS];
 	int active_ports;
@@ -550,24 +538,22 @@ int wcd937x_sdw_hw_params(struct wcd937x
 			  struct snd_pcm_hw_params *params,
 			  struct snd_soc_dai *dai);
 
-struct device *wcd937x_sdw_device_get(struct device_node *np);
-
 #else
-int wcd937x_sdw_free(struct wcd937x_sdw_priv *wcd,
+static inline int wcd937x_sdw_free(struct wcd937x_sdw_priv *wcd,
 		     struct snd_pcm_substream *substream,
 		     struct snd_soc_dai *dai)
 {
 	return -EOPNOTSUPP;
 }
 
-int wcd937x_sdw_set_sdw_stream(struct wcd937x_sdw_priv *wcd,
+static inline int wcd937x_sdw_set_sdw_stream(struct wcd937x_sdw_priv *wcd,
 			       struct snd_soc_dai *dai,
 			       void *stream, int direction)
 {
 	return -EOPNOTSUPP;
 }
 
-int wcd937x_sdw_hw_params(struct wcd937x_sdw_priv *wcd,
+static inline int wcd937x_sdw_hw_params(struct wcd937x_sdw_priv *wcd,
 			  struct snd_pcm_substream *substream,
 			  struct snd_pcm_hw_params *params,
 			  struct snd_soc_dai *dai)
diff -Nrup linux-6.16.7/sound/soc/codecs/wcd937x-sdw.c linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd937x-sdw.c
--- linux-6.16.7/sound/soc/codecs/wcd937x-sdw.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd937x-sdw.c	2025-09-11 09:47:42.000000000 -0600
@@ -19,7 +19,7 @@
 #include <sound/soc.h>
 #include "wcd937x.h"
 
-static struct wcd937x_sdw_ch_info wcd937x_sdw_rx_ch_info[] = {
+static struct wcd_sdw_ch_info wcd937x_sdw_rx_ch_info[] = {
 	WCD_SDW_CH(WCD937X_HPH_L, WCD937X_HPH_PORT, BIT(0)),
 	WCD_SDW_CH(WCD937X_HPH_R, WCD937X_HPH_PORT, BIT(1)),
 	WCD_SDW_CH(WCD937X_CLSH, WCD937X_CLSH_PORT, BIT(0)),
@@ -30,7 +30,7 @@ static struct wcd937x_sdw_ch_info wcd937
 	WCD_SDW_CH(WCD937X_DSD_R, WCD937X_DSD_PORT, BIT(1)),
 };
 
-static struct wcd937x_sdw_ch_info wcd937x_sdw_tx_ch_info[] = {
+static struct wcd_sdw_ch_info wcd937x_sdw_tx_ch_info[] = {
 	WCD_SDW_CH(WCD937X_ADC1, WCD937X_ADC_1_PORT, BIT(0)),
 	WCD_SDW_CH(WCD937X_ADC2, WCD937X_ADC_2_3_PORT, BIT(0)),
 	WCD_SDW_CH(WCD937X_ADC3, WCD937X_ADC_2_3_PORT, BIT(0)),
@@ -78,12 +78,6 @@ static struct sdw_dpn_prop wcd937x_dpn_p
 	}
 };
 
-struct device *wcd937x_sdw_device_get(struct device_node *np)
-{
-	return bus_find_device_by_of_node(&sdw_bus_type, np);
-}
-EXPORT_SYMBOL_GPL(wcd937x_sdw_device_get);
-
 int wcd937x_sdw_hw_params(struct wcd937x_sdw_priv *wcd,
 			  struct snd_pcm_substream *substream,
 			  struct snd_pcm_hw_params *params,
@@ -118,19 +112,6 @@ int wcd937x_sdw_hw_params(struct wcd937x
 }
 EXPORT_SYMBOL_GPL(wcd937x_sdw_hw_params);
 
-static int wcd9370_update_status(struct sdw_slave *slave, enum sdw_slave_status status)
-{
-	struct wcd937x_sdw_priv *wcd = dev_get_drvdata(&slave->dev);
-
-	if (wcd->regmap && status == SDW_SLAVE_ATTACHED) {
-		/* Write out any cached changes that happened between probe and attach */
-		regcache_cache_only(wcd->regmap, false);
-		return regcache_sync(wcd->regmap);
-	}
-
-	return 0;
-}
-
 /*
  * Handle Soundwire out-of-band interrupt event by triggering
  * the first irq of the slave_irq irq domain, which then will
@@ -141,18 +122,9 @@ static int wcd9370_interrupt_callback(st
 				      struct sdw_slave_intr_status *status)
 {
 	struct wcd937x_sdw_priv *wcd = dev_get_drvdata(&slave->dev);
-	struct irq_domain *slave_irq = wcd->slave_irq;
-	u32 sts1, sts2, sts3;
-
-	do {
-		handle_nested_irq(irq_find_mapping(slave_irq, 0));
-		regmap_read(wcd->regmap, WCD937X_DIGITAL_INTR_STATUS_0, &sts1);
-		regmap_read(wcd->regmap, WCD937X_DIGITAL_INTR_STATUS_1, &sts2);
-		regmap_read(wcd->regmap, WCD937X_DIGITAL_INTR_STATUS_2, &sts3);
 
-	} while (sts1 || sts2 || sts3);
-
-	return IRQ_HANDLED;
+	return wcd_interrupt_callback(slave, wcd->slave_irq, WCD937X_DIGITAL_INTR_STATUS_0,
+				WCD937X_DIGITAL_INTR_STATUS_1, WCD937X_DIGITAL_INTR_STATUS_2);
 }
 
 static const struct reg_default wcd937x_defaults[] = {
@@ -985,35 +957,10 @@ static const struct regmap_config wcd937
 };
 
 static const struct sdw_slave_ops wcd9370_slave_ops = {
-	.update_status = wcd9370_update_status,
+	.update_status = wcd_update_status,
 	.interrupt_callback = wcd9370_interrupt_callback,
 };
 
-static int wcd937x_sdw_component_bind(struct device *dev,
-				      struct device *master, void *data)
-{
-	pm_runtime_set_autosuspend_delay(dev, 3000);
-	pm_runtime_use_autosuspend(dev);
-	pm_runtime_mark_last_busy(dev);
-	pm_runtime_set_active(dev);
-	pm_runtime_enable(dev);
-
-	return 0;
-}
-
-static void wcd937x_sdw_component_unbind(struct device *dev,
-					 struct device *master, void *data)
-{
-	pm_runtime_disable(dev);
-	pm_runtime_set_suspended(dev);
-	pm_runtime_dont_use_autosuspend(dev);
-}
-
-static const struct component_ops wcd937x_sdw_component_ops = {
-	.bind = wcd937x_sdw_component_bind,
-	.unbind = wcd937x_sdw_component_unbind,
-};
-
 static int wcd9370_probe(struct sdw_slave *pdev,
 			 const struct sdw_device_id *id)
 {
@@ -1099,7 +1046,7 @@ static int wcd9370_probe(struct sdw_slav
 	}
 
 
-	ret = component_add(dev, &wcd937x_sdw_component_ops);
+	ret = component_add(dev, &wcd_sdw_component_ops);
 	if (ret)
 		return ret;
 
@@ -1113,7 +1060,7 @@ static int wcd9370_remove(struct sdw_sla
 {
 	struct device *dev = &pdev->dev;
 
-	component_del(dev, &wcd937x_sdw_component_ops);
+	component_del(dev, &wcd_sdw_component_ops);
 
 	return 0;
 }
diff -Nrup linux-6.16.7/sound/soc/codecs/wcd938x.c linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd938x.c
--- linux-6.16.7/sound/soc/codecs/wcd938x.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd938x.c	2025-09-11 09:47:42.000000000 -0600
@@ -22,6 +22,7 @@
 #include <linux/regulator/consumer.h>
 
 #include "wcd-clsh-v2.h"
+#include "wcd-common.h"
 #include "wcd-mbhc-v2.h"
 #include "wcd938x.h"
 
@@ -158,6 +159,7 @@ struct wcd938x_priv {
 	struct wcd_mbhc_config mbhc_cfg;
 	struct wcd_mbhc_intr intr_ids;
 	struct wcd_clsh_ctrl *clsh_info;
+	struct wcd_common common;
 	struct irq_domain *virq;
 	struct regmap_irq_chip *wcd_regmap_irq_chip;
 	struct regmap_irq_chip_data *irq_chip;
@@ -175,10 +177,6 @@ struct wcd938x_priv {
 	struct gpio_desc *us_euro_gpio;
 	struct mux_control *us_euro_mux;
 	unsigned int mux_state;
-	u32 micb1_mv;
-	u32 micb2_mv;
-	u32 micb3_mv;
-	u32 micb4_mv;
 	int hphr_pdm_wd_int;
 	int hphl_pdm_wd_int;
 	int aux_pdm_wd_int;
@@ -398,7 +396,7 @@ static int wcd938x_io_init(struct wcd938
 
 }
 
-static int wcd938x_sdw_connect_port(const struct wcd938x_sdw_ch_info *ch_info,
+static int wcd938x_sdw_connect_port(const struct wcd_sdw_ch_info *ch_info,
 				    struct sdw_port_config *port_config,
 				    u8 enable)
 {
@@ -1096,8 +1094,7 @@ static int wcd938x_tx_swr_ctrl(struct sn
 	int bank;
 	int rate;
 
-	bank = (wcd938x_swr_get_current_bank(wcd938x->sdw_priv[AIF1_CAP]->sdev)) ? 0 : 1;
-	bank = bank ? 0 : 1;
+	bank = sdw_slave_get_current_bank(wcd938x->sdw_priv[AIF1_CAP]->sdev);
 
 	switch (event) {
 	case SND_SOC_DAPM_PRE_PMU:
@@ -1977,15 +1974,6 @@ static void wcd938x_mbhc_micb_ramp_contr
 	}
 }
 
-static int wcd938x_get_micb_vout_ctl_val(u32 micb_mv)
-{
-	/* min micbias voltage is 1V and maximum is 2.85V */
-	if (micb_mv < 1000 || micb_mv > 2850)
-		return -EINVAL;
-
-	return (micb_mv - 1000) / 50;
-}
-
 static int wcd938x_mbhc_micb_adjust_voltage(struct snd_soc_component *component,
 					    int req_volt, int micb_num)
 {
@@ -2022,7 +2010,7 @@ static int wcd938x_mbhc_micb_adjust_volt
 	cur_vout_ctl = snd_soc_component_read_field(component, micb_reg,
 						    WCD938X_MICB_VOUT_MASK);
 
-	req_vout_ctl = wcd938x_get_micb_vout_ctl_val(req_volt);
+	req_vout_ctl = wcd_get_micb_vout_ctl_val(component->dev, req_volt);
 	if (req_vout_ctl < 0) {
 		ret = -EINVAL;
 		goto exit;
@@ -2070,10 +2058,10 @@ static int wcd938x_mbhc_micb_ctrl_thresh
 	 * voltage needed to detect threshold microphone, then do
 	 * not change the micbias, just return.
 	 */
-	if (wcd938x->micb2_mv >= WCD_MBHC_THR_HS_MICB_MV)
+	if (wcd938x->common.micb_mv[2] >= WCD_MBHC_THR_HS_MICB_MV)
 		return 0;
 
-	micb_mv = req_en ? WCD_MBHC_THR_HS_MICB_MV : wcd938x->micb2_mv;
+	micb_mv = req_en ? WCD_MBHC_THR_HS_MICB_MV : wcd938x->common.micb_mv[2];
 
 	return wcd938x_mbhc_micb_adjust_voltage(component, micb_mv, MIC_BIAS_2);
 }
@@ -2978,28 +2966,16 @@ static const struct snd_soc_dapm_route w
 	{"EAR", NULL, "EAR PGA"},
 };
 
-static int wcd938x_set_micbias_data(struct wcd938x_priv *wcd938x)
+static void wcd938x_set_micbias_data(struct device *dev, struct wcd938x_priv *wcd938x)
 {
-	int vout_ctl_1, vout_ctl_2, vout_ctl_3, vout_ctl_4;
-
-	/* set micbias voltage */
-	vout_ctl_1 = wcd938x_get_micb_vout_ctl_val(wcd938x->micb1_mv);
-	vout_ctl_2 = wcd938x_get_micb_vout_ctl_val(wcd938x->micb2_mv);
-	vout_ctl_3 = wcd938x_get_micb_vout_ctl_val(wcd938x->micb3_mv);
-	vout_ctl_4 = wcd938x_get_micb_vout_ctl_val(wcd938x->micb4_mv);
-	if (vout_ctl_1 < 0 || vout_ctl_2 < 0 || vout_ctl_3 < 0 || vout_ctl_4 < 0)
-		return -EINVAL;
-
 	regmap_update_bits(wcd938x->regmap, WCD938X_ANA_MICB1,
-			   WCD938X_MICB_VOUT_MASK, vout_ctl_1);
+			   WCD938X_MICB_VOUT_MASK, wcd938x->common.micb_vout[0]);
 	regmap_update_bits(wcd938x->regmap, WCD938X_ANA_MICB2,
-			   WCD938X_MICB_VOUT_MASK, vout_ctl_2);
+			   WCD938X_MICB_VOUT_MASK, wcd938x->common.micb_vout[1]);
 	regmap_update_bits(wcd938x->regmap, WCD938X_ANA_MICB3,
-			   WCD938X_MICB_VOUT_MASK, vout_ctl_3);
+			   WCD938X_MICB_VOUT_MASK, wcd938x->common.micb_vout[2]);
 	regmap_update_bits(wcd938x->regmap, WCD938X_ANA_MICB4,
-			   WCD938X_MICB_VOUT_MASK, vout_ctl_4);
-
-	return 0;
+			   WCD938X_MICB_VOUT_MASK, wcd938x->common.micb_vout[3]);
 }
 
 static irqreturn_t wcd938x_wd_handle_irq(int irq, void *data)
@@ -3202,37 +3178,6 @@ static const struct snd_soc_component_dr
 	.endianness = 1,
 };
 
-static void wcd938x_dt_parse_micbias_info(struct device *dev, struct wcd938x_priv *wcd)
-{
-	struct device_node *np = dev->of_node;
-	u32 prop_val = 0;
-	int rc = 0;
-
-	rc = of_property_read_u32(np, "qcom,micbias1-microvolt",  &prop_val);
-	if (!rc)
-		wcd->micb1_mv = prop_val/1000;
-	else
-		dev_info(dev, "%s: Micbias1 DT property not found\n", __func__);
-
-	rc = of_property_read_u32(np, "qcom,micbias2-microvolt",  &prop_val);
-	if (!rc)
-		wcd->micb2_mv = prop_val/1000;
-	else
-		dev_info(dev, "%s: Micbias2 DT property not found\n", __func__);
-
-	rc = of_property_read_u32(np, "qcom,micbias3-microvolt", &prop_val);
-	if (!rc)
-		wcd->micb3_mv = prop_val/1000;
-	else
-		dev_info(dev, "%s: Micbias3 DT property not found\n", __func__);
-
-	rc = of_property_read_u32(np, "qcom,micbias4-microvolt",  &prop_val);
-	if (!rc)
-		wcd->micb4_mv = prop_val/1000;
-	else
-		dev_info(dev, "%s: Micbias4 DT property not found\n", __func__);
-}
-
 static bool wcd938x_swap_gnd_mic(struct snd_soc_component *component)
 {
 	struct wcd938x_priv *wcd938x = snd_soc_component_get_drvdata(component);
@@ -3307,13 +3252,15 @@ static int wcd938x_populate_dt_data(stru
 		return dev_err_probe(dev, ret, "Failed to enable supplies\n");
 	}
 
-	wcd938x_dt_parse_micbias_info(dev, wcd938x);
+	ret = wcd_dt_parse_micbias_info(&wcd938x->common);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get and enable supplies\n");
 
 	cfg->mbhc_micbias = MIC_BIAS_2;
 	cfg->anc_micbias = MIC_BIAS_2;
 	cfg->v_hs_max = WCD_MBHC_HS_V_MAX;
 	cfg->num_btn = WCD938X_MBHC_MAX_BUTTONS;
-	cfg->micb_mv = wcd938x->micb2_mv;
+	cfg->micb_mv = wcd938x->common.micb_mv[2];
 	cfg->linein_th = 5000;
 	cfg->hs_thr = 1700;
 	cfg->hph_thr = 50;
@@ -3411,7 +3358,7 @@ static int wcd938x_bind(struct device *d
 		return ret;
 	}
 
-	wcd938x->rxdev = wcd938x_sdw_device_get(wcd938x->rxnode);
+	wcd938x->rxdev = of_sdw_find_device_by_node(wcd938x->rxnode);
 	if (!wcd938x->rxdev) {
 		dev_err(dev, "could not find slave with matching of node\n");
 		ret = -EINVAL;
@@ -3420,7 +3367,7 @@ static int wcd938x_bind(struct device *d
 	wcd938x->sdw_priv[AIF1_PB] = dev_get_drvdata(wcd938x->rxdev);
 	wcd938x->sdw_priv[AIF1_PB]->wcd938x = wcd938x;
 
-	wcd938x->txdev = wcd938x_sdw_device_get(wcd938x->txnode);
+	wcd938x->txdev = of_sdw_find_device_by_node(wcd938x->txnode);
 	if (!wcd938x->txdev) {
 		dev_err(dev, "could not find txslave with matching of node\n");
 		ret = -EINVAL;
@@ -3453,7 +3400,7 @@ static int wcd938x_bind(struct device *d
 		goto err_remove_tx_link;
 	}
 
-	wcd938x->regmap = dev_get_regmap(&wcd938x->tx_sdw_dev->dev, NULL);
+	wcd938x->regmap = wcd938x->sdw_priv[AIF1_CAP]->regmap;
 	if (!wcd938x->regmap) {
 		dev_err(dev, "could not get TX device regmap\n");
 		ret = -EINVAL;
@@ -3469,11 +3416,7 @@ static int wcd938x_bind(struct device *d
 	wcd938x->sdw_priv[AIF1_PB]->slave_irq = wcd938x->virq;
 	wcd938x->sdw_priv[AIF1_CAP]->slave_irq = wcd938x->virq;
 
-	ret = wcd938x_set_micbias_data(wcd938x);
-	if (ret < 0) {
-		dev_err(dev, "%s: bad micbias pdata\n", __func__);
-		goto err_remove_rx_link;
-	}
+	wcd938x_set_micbias_data(dev, wcd938x);
 
 	ret = snd_soc_register_component(dev, &soc_codec_dev_wcd938x,
 					 wcd938x_dais, ARRAY_SIZE(wcd938x_dais));
@@ -3562,6 +3505,8 @@ static int wcd938x_probe(struct platform
 
 	dev_set_drvdata(dev, wcd938x);
 	mutex_init(&wcd938x->micb_lock);
+	wcd938x->common.dev = dev;
+	wcd938x->common.max_bias = 4;
 
 	ret = wcd938x_populate_dt_data(wcd938x, dev);
 	if (ret)
diff -Nrup linux-6.16.7/sound/soc/codecs/wcd938x.h linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd938x.h
--- linux-6.16.7/sound/soc/codecs/wcd938x.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd938x.h	2025-09-11 09:47:42.000000000 -0600
@@ -587,17 +587,6 @@
 
 #define WCD938X_MAX_SWR_CH_IDS	15
 
-struct wcd938x_sdw_ch_info {
-	int port_num;
-	unsigned int ch_mask;
-};
-
-#define WCD_SDW_CH(id, pn, cmask)	\
-	[id] = {			\
-		.port_num = pn,		\
-		.ch_mask = cmask,	\
-	}
-
 enum wcd938x_tx_sdw_ports {
 	WCD938X_ADC_1_2_PORT = 1,
 	WCD938X_ADC_3_4_PORT,
@@ -649,7 +638,7 @@ struct wcd938x_sdw_priv {
 	struct sdw_stream_config sconfig;
 	struct sdw_stream_runtime *sruntime;
 	struct sdw_port_config port_config[WCD938X_MAX_SWR_PORTS];
-	const struct wcd938x_sdw_ch_info *ch_info;
+	const struct wcd_sdw_ch_info *ch_info;
 	bool port_enable[WCD938X_MAX_SWR_CH_IDS];
 	int active_ports;
 	bool is_tx;
@@ -669,10 +658,6 @@ int wcd938x_sdw_hw_params(struct wcd938x
 			  struct snd_pcm_substream *substream,
 			  struct snd_pcm_hw_params *params,
 			  struct snd_soc_dai *dai);
-
-struct device *wcd938x_sdw_device_get(struct device_node *np);
-int wcd938x_swr_get_current_bank(struct sdw_slave *sdev);
-
 #else
 
 static inline int wcd938x_sdw_free(struct wcd938x_sdw_priv *wcd,
@@ -697,14 +682,5 @@ static inline int wcd938x_sdw_hw_params(
 	return -EOPNOTSUPP;
 }
 
-static inline struct device *wcd938x_sdw_device_get(struct device_node *np)
-{
-	return NULL;
-}
-
-static inline int wcd938x_swr_get_current_bank(struct sdw_slave *sdev)
-{
-	return 0;
-}
 #endif /* CONFIG_SND_SOC_WCD938X_SDW */
 #endif /* __WCD938X_H__ */
diff -Nrup linux-6.16.7/sound/soc/codecs/wcd938x-sdw.c linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd938x-sdw.c
--- linux-6.16.7/sound/soc/codecs/wcd938x-sdw.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd938x-sdw.c	2025-09-11 09:47:42.000000000 -0600
@@ -18,10 +18,9 @@
 #include <sound/soc.h>
 #include <sound/soc-dapm.h>
 #include "wcd938x.h"
+#include "wcd-common.h"
 
-#define SWRS_SCP_HOST_CLK_DIV2_CTL_BANK(m) (0xE0 + 0x10 * (m))
-
-static const struct wcd938x_sdw_ch_info wcd938x_sdw_rx_ch_info[] = {
+static const struct wcd_sdw_ch_info wcd938x_sdw_rx_ch_info[] = {
 	WCD_SDW_CH(WCD938X_HPH_L, WCD938X_HPH_PORT, BIT(0)),
 	WCD_SDW_CH(WCD938X_HPH_R, WCD938X_HPH_PORT, BIT(1)),
 	WCD_SDW_CH(WCD938X_CLSH, WCD938X_CLSH_PORT, BIT(0)),
@@ -32,7 +31,7 @@ static const struct wcd938x_sdw_ch_info
 	WCD_SDW_CH(WCD938X_DSD_R, WCD938X_DSD_PORT, BIT(1)),
 };
 
-static const struct wcd938x_sdw_ch_info wcd938x_sdw_tx_ch_info[] = {
+static const struct wcd_sdw_ch_info wcd938x_sdw_tx_ch_info[] = {
 	WCD_SDW_CH(WCD938X_ADC1, WCD938X_ADC_1_2_PORT, BIT(0)),
 	WCD_SDW_CH(WCD938X_ADC2, WCD938X_ADC_1_2_PORT, BIT(1)),
 	WCD_SDW_CH(WCD938X_ADC3, WCD938X_ADC_3_4_PORT, BIT(0)),
@@ -82,23 +81,6 @@ static struct sdw_dpn_prop wcd938x_dpn_p
 	}
 };
 
-struct device *wcd938x_sdw_device_get(struct device_node *np)
-{
-	return bus_find_device_by_of_node(&sdw_bus_type, np);
-
-}
-EXPORT_SYMBOL_GPL(wcd938x_sdw_device_get);
-
-int wcd938x_swr_get_current_bank(struct sdw_slave *sdev)
-{
-	int bank;
-
-	bank  = sdw_read(sdev, SDW_SCP_CTRL);
-
-	return ((bank & 0x40) ? 1 : 0);
-}
-EXPORT_SYMBOL_GPL(wcd938x_swr_get_current_bank);
-
 int wcd938x_sdw_hw_params(struct wcd938x_sdw_priv *wcd,
 			  struct snd_pcm_substream *substream,
 			  struct snd_pcm_hw_params *params,
@@ -158,44 +140,13 @@ int wcd938x_sdw_set_sdw_stream(struct wc
 }
 EXPORT_SYMBOL_GPL(wcd938x_sdw_set_sdw_stream);
 
-static int wcd9380_update_status(struct sdw_slave *slave,
-				 enum sdw_slave_status status)
-{
-	struct wcd938x_sdw_priv *wcd = dev_get_drvdata(&slave->dev);
-
-	if (wcd->regmap && (status == SDW_SLAVE_ATTACHED)) {
-		/* Write out any cached changes that happened between probe and attach */
-		regcache_cache_only(wcd->regmap, false);
-		return regcache_sync(wcd->regmap);
-	}
-
-	return 0;
-}
-
-static int wcd9380_bus_config(struct sdw_slave *slave,
-			      struct sdw_bus_params *params)
-{
-	sdw_write(slave, SWRS_SCP_HOST_CLK_DIV2_CTL_BANK(params->next_bank),  0x01);
-
-	return 0;
-}
-
 static int wcd9380_interrupt_callback(struct sdw_slave *slave,
 				      struct sdw_slave_intr_status *status)
 {
 	struct wcd938x_sdw_priv *wcd = dev_get_drvdata(&slave->dev);
-	struct irq_domain *slave_irq = wcd->slave_irq;
-	u32 sts1, sts2, sts3;
-
-	do {
-		handle_nested_irq(irq_find_mapping(slave_irq, 0));
-		regmap_read(wcd->regmap, WCD938X_DIGITAL_INTR_STATUS_0, &sts1);
-		regmap_read(wcd->regmap, WCD938X_DIGITAL_INTR_STATUS_1, &sts2);
-		regmap_read(wcd->regmap, WCD938X_DIGITAL_INTR_STATUS_2, &sts3);
 
-	} while (sts1 || sts2 || sts3);
-
-	return IRQ_HANDLED;
+	return wcd_interrupt_callback(slave, wcd->slave_irq, WCD938X_DIGITAL_INTR_STATUS_0,
+				WCD938X_DIGITAL_INTR_STATUS_1, WCD938X_DIGITAL_INTR_STATUS_2);
 }
 
 static const struct reg_default wcd938x_defaults[] = {
@@ -1193,25 +1144,9 @@ static const struct regmap_config wcd938
 };
 
 static const struct sdw_slave_ops wcd9380_slave_ops = {
-	.update_status = wcd9380_update_status,
+	.update_status = wcd_update_status,
 	.interrupt_callback = wcd9380_interrupt_callback,
-	.bus_config = wcd9380_bus_config,
-};
-
-static int wcd938x_sdw_component_bind(struct device *dev,
-				      struct device *master, void *data)
-{
-	return 0;
-}
-
-static void wcd938x_sdw_component_unbind(struct device *dev,
-					 struct device *master, void *data)
-{
-}
-
-static const struct component_ops wcd938x_sdw_component_ops = {
-	.bind   = wcd938x_sdw_component_bind,
-	.unbind = wcd938x_sdw_component_unbind,
+	.bus_config = wcd_bus_config,
 };
 
 static int wcd9380_probe(struct sdw_slave *pdev,
@@ -1278,7 +1213,7 @@ static int wcd9380_probe(struct sdw_slav
 	pm_runtime_set_active(dev);
 	pm_runtime_enable(dev);
 
-	ret = component_add(dev, &wcd938x_sdw_component_ops);
+	ret = component_add(dev, &wcd_sdw_component_ops);
 	if (ret)
 		goto err_disable_rpm;
 
@@ -1296,7 +1231,7 @@ static int wcd9380_remove(struct sdw_sla
 {
 	struct device *dev = &pdev->dev;
 
-	component_del(dev, &wcd938x_sdw_component_ops);
+	component_del(dev, &wcd_sdw_component_ops);
 
 	pm_runtime_disable(dev);
 	pm_runtime_set_suspended(dev);
diff -Nrup linux-6.16.7/sound/soc/codecs/wcd939x.c linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd939x.c
--- linux-6.16.7/sound/soc/codecs/wcd939x.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd939x.c	2025-09-11 09:47:42.000000000 -0600
@@ -28,6 +28,7 @@
 #include <linux/usb/typec_altmode.h>
 
 #include "wcd-clsh-v2.h"
+#include "wcd-common.h"
 #include "wcd-mbhc-v2.h"
 #include "wcd939x.h"
 
@@ -189,6 +190,7 @@ struct wcd939x_priv {
 	struct wcd_mbhc_config mbhc_cfg;
 	struct wcd_mbhc_intr intr_ids;
 	struct wcd_clsh_ctrl *clsh_info;
+	struct wcd_common common;
 	struct irq_domain *virq;
 	struct regmap_irq_chip *wcd_regmap_irq_chip;
 	struct regmap_irq_chip_data *irq_chip;
@@ -201,10 +203,6 @@ struct wcd939x_priv {
 	u32 tx_mode[TX_ADC_MAX];
 	int variant;
 	struct gpio_desc *reset_gpio;
-	u32 micb1_mv;
-	u32 micb2_mv;
-	u32 micb3_mv;
-	u32 micb4_mv;
 	int hphr_pdm_wd_int;
 	int hphl_pdm_wd_int;
 	int ear_pdm_wd_int;
@@ -411,7 +409,7 @@ static int wcd939x_io_init(struct snd_so
 	return 0;
 }
 
-static int wcd939x_sdw_connect_port(const struct wcd939x_sdw_ch_info *ch_info,
+static int wcd939x_sdw_connect_port(const struct wcd_sdw_ch_info *ch_info,
 				    struct sdw_port_config *port_config,
 				    u8 enable)
 {
@@ -1013,7 +1011,7 @@ static int wcd939x_tx_swr_ctrl(struct sn
 	int bank;
 	int rate;
 
-	bank = wcd939x_swr_get_current_bank(wcd939x->sdw_priv[AIF1_CAP]->sdev);
+	bank = sdw_slave_get_current_bank(wcd939x->sdw_priv[AIF1_CAP]->sdev);
 
 	switch (event) {
 	case SND_SOC_DAPM_PRE_PMU:
@@ -1915,17 +1913,6 @@ static void wcd939x_mbhc_micb_ramp_contr
 	}
 }
 
-static int wcd939x_get_micb_vout_ctl_val(u32 micb_mv)
-{
-	/* min micbias voltage is 1V and maximum is 2.85V */
-	if (micb_mv < 1000 || micb_mv > 2850) {
-		pr_err("%s: unsupported micbias voltage\n", __func__);
-		return -EINVAL;
-	}
-
-	return (micb_mv - 1000) / 50;
-}
-
 static int wcd939x_mbhc_micb_adjust_voltage(struct snd_soc_component *component,
 					    int req_volt, int micb_num)
 {
@@ -1965,7 +1952,7 @@ static int wcd939x_mbhc_micb_adjust_volt
 	cur_vout_ctl = snd_soc_component_read_field(component, micb_reg,
 						    WCD939X_MICB_VOUT_CTL);
 
-	req_vout_ctl = wcd939x_get_micb_vout_ctl_val(req_volt);
+	req_vout_ctl = wcd_get_micb_vout_ctl_val(component->dev, req_volt);
 	if (req_vout_ctl < 0) {
 		ret = req_vout_ctl;
 		goto exit;
@@ -2017,10 +2004,10 @@ static int wcd939x_mbhc_micb_ctrl_thresh
 	 * voltage needed to detect threshold microphone, then do
 	 * not change the micbias, just return.
 	 */
-	if (wcd939x->micb2_mv >= WCD_MBHC_THR_HS_MICB_MV)
+	if (wcd939x->common.micb_mv[1] >= WCD_MBHC_THR_HS_MICB_MV)
 		return 0;
 
-	micb_mv = req_en ? WCD_MBHC_THR_HS_MICB_MV : wcd939x->micb2_mv;
+	micb_mv = req_en ? WCD_MBHC_THR_HS_MICB_MV : wcd939x->common.micb_mv[1];
 
 	return wcd939x_mbhc_micb_adjust_voltage(component, micb_mv, MIC_BIAS_2);
 }
@@ -2891,28 +2878,16 @@ static const struct snd_soc_dapm_route w
 	{"EAR", NULL, "EAR PGA"},
 };
 
-static int wcd939x_set_micbias_data(struct wcd939x_priv *wcd939x)
+static void wcd939x_set_micbias_data(struct device *dev, struct wcd939x_priv *wcd939x)
 {
-	int vout_ctl_1, vout_ctl_2, vout_ctl_3, vout_ctl_4;
-
-	/* set micbias voltage */
-	vout_ctl_1 = wcd939x_get_micb_vout_ctl_val(wcd939x->micb1_mv);
-	vout_ctl_2 = wcd939x_get_micb_vout_ctl_val(wcd939x->micb2_mv);
-	vout_ctl_3 = wcd939x_get_micb_vout_ctl_val(wcd939x->micb3_mv);
-	vout_ctl_4 = wcd939x_get_micb_vout_ctl_val(wcd939x->micb4_mv);
-	if (vout_ctl_1 < 0 || vout_ctl_2 < 0 || vout_ctl_3 < 0 || vout_ctl_4 < 0)
-		return -EINVAL;
-
 	regmap_update_bits(wcd939x->regmap, WCD939X_ANA_MICB1,
-			   WCD939X_MICB_VOUT_CTL, vout_ctl_1);
+			   WCD939X_MICB_VOUT_CTL, wcd939x->common.micb_vout[0]);
 	regmap_update_bits(wcd939x->regmap, WCD939X_ANA_MICB2,
-			   WCD939X_MICB_VOUT_CTL, vout_ctl_2);
+			   WCD939X_MICB_VOUT_CTL, wcd939x->common.micb_vout[1]);
 	regmap_update_bits(wcd939x->regmap, WCD939X_ANA_MICB3,
-			   WCD939X_MICB_VOUT_CTL, vout_ctl_3);
+			   WCD939X_MICB_VOUT_CTL, wcd939x->common.micb_vout[2]);
 	regmap_update_bits(wcd939x->regmap, WCD939X_ANA_MICB4,
-			   WCD939X_MICB_VOUT_CTL, vout_ctl_4);
-
-	return 0;
+			   WCD939X_MICB_VOUT_CTL, wcd939x->common.micb_vout[3]);
 }
 
 static irqreturn_t wcd939x_wd_handle_irq(int irq, void *data)
@@ -3182,37 +3157,6 @@ static int wcd939x_typec_mux_set(struct
 }
 #endif /* CONFIG_TYPEC */
 
-static void wcd939x_dt_parse_micbias_info(struct device *dev, struct wcd939x_priv *wcd)
-{
-	struct device_node *np = dev->of_node;
-	u32 prop_val = 0;
-	int rc = 0;
-
-	rc = of_property_read_u32(np, "qcom,micbias1-microvolt",  &prop_val);
-	if (!rc)
-		wcd->micb1_mv = prop_val / 1000;
-	else
-		dev_info(dev, "%s: Micbias1 DT property not found\n", __func__);
-
-	rc = of_property_read_u32(np, "qcom,micbias2-microvolt",  &prop_val);
-	if (!rc)
-		wcd->micb2_mv = prop_val / 1000;
-	else
-		dev_info(dev, "%s: Micbias2 DT property not found\n", __func__);
-
-	rc = of_property_read_u32(np, "qcom,micbias3-microvolt", &prop_val);
-	if (!rc)
-		wcd->micb3_mv = prop_val / 1000;
-	else
-		dev_info(dev, "%s: Micbias3 DT property not found\n", __func__);
-
-	rc = of_property_read_u32(np, "qcom,micbias4-microvolt",  &prop_val);
-	if (!rc)
-		wcd->micb4_mv = prop_val / 1000;
-	else
-		dev_info(dev, "%s: Micbias4 DT property not found\n", __func__);
-}
-
 #if IS_ENABLED(CONFIG_TYPEC)
 static bool wcd939x_swap_gnd_mic(struct snd_soc_component *component)
 {
@@ -3259,13 +3203,15 @@ static int wcd939x_populate_dt_data(stru
 		return dev_err_probe(dev, ret, "Failed to enable supplies\n");
 	}
 
-	wcd939x_dt_parse_micbias_info(dev, wcd939x);
+	ret = wcd_dt_parse_micbias_info(&wcd939x->common);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get micbias\n");
 
 	cfg->mbhc_micbias = MIC_BIAS_2;
 	cfg->anc_micbias = MIC_BIAS_2;
 	cfg->v_hs_max = WCD_MBHC_HS_V_MAX;
 	cfg->num_btn = WCD939X_MBHC_MAX_BUTTONS;
-	cfg->micb_mv = wcd939x->micb2_mv;
+	cfg->micb_mv = wcd939x->common.micb_mv[1];
 	cfg->linein_th = 5000;
 	cfg->hs_thr = 1700;
 	cfg->hph_thr = 50;
@@ -3390,7 +3336,7 @@ static int wcd939x_bind(struct device *d
 		goto err_put_typec_switch;
 	}
 
-	wcd939x->rxdev = wcd939x_sdw_device_get(wcd939x->rxnode);
+	wcd939x->rxdev = of_sdw_find_device_by_node(wcd939x->rxnode);
 	if (!wcd939x->rxdev) {
 		dev_err(dev, "could not find slave with matching of node\n");
 		ret = -EINVAL;
@@ -3399,7 +3345,7 @@ static int wcd939x_bind(struct device *d
 	wcd939x->sdw_priv[AIF1_PB] = dev_get_drvdata(wcd939x->rxdev);
 	wcd939x->sdw_priv[AIF1_PB]->wcd939x = wcd939x;
 
-	wcd939x->txdev = wcd939x_sdw_device_get(wcd939x->txnode);
+	wcd939x->txdev = of_sdw_find_device_by_node(wcd939x->txnode);
 	if (!wcd939x->txdev) {
 		dev_err(dev, "could not find txslave with matching of node\n");
 		ret = -EINVAL;
@@ -3435,10 +3381,10 @@ static int wcd939x_bind(struct device *d
 	}
 
 	/* Get regmap from TX SoundWire device */
-	wcd939x->regmap = wcd939x_swr_get_regmap(wcd939x->sdw_priv[AIF1_CAP]);
-	if (IS_ERR(wcd939x->regmap)) {
+	wcd939x->regmap = wcd939x->sdw_priv[AIF1_CAP]->regmap;
+	if (!wcd939x->regmap) {
 		dev_err(dev, "could not get TX device regmap\n");
-		ret = PTR_ERR(wcd939x->regmap);
+		ret = -ENODEV;
 		goto err_remove_rx_link;
 	}
 
@@ -3451,11 +3397,7 @@ static int wcd939x_bind(struct device *d
 	wcd939x->sdw_priv[AIF1_PB]->slave_irq = wcd939x->virq;
 	wcd939x->sdw_priv[AIF1_CAP]->slave_irq = wcd939x->virq;
 
-	ret = wcd939x_set_micbias_data(wcd939x);
-	if (ret < 0) {
-		dev_err(dev, "%s: bad micbias pdata\n", __func__);
-		goto err_remove_rx_link;
-	}
+	wcd939x_set_micbias_data(dev, wcd939x);
 
 	/* Check WCD9395 version */
 	regmap_read(wcd939x->regmap, WCD939X_DIGITAL_CHIP_ID1, &id1);
@@ -3620,6 +3562,8 @@ static int wcd939x_probe(struct platform
 
 	dev_set_drvdata(dev, wcd939x);
 	mutex_init(&wcd939x->micb_lock);
+	wcd939x->common.dev = dev;
+	wcd939x->common.max_bias = 4;
 
 	ret = wcd939x_populate_dt_data(wcd939x, dev);
 	if (ret) {
diff -Nrup linux-6.16.7/sound/soc/codecs/wcd939x.h linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd939x.h
--- linux-6.16.7/sound/soc/codecs/wcd939x.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd939x.h	2025-09-11 09:47:42.000000000 -0600
@@ -844,17 +844,6 @@
 
 #define WCD939X_MAX_SWR_CH_IDS		(15)
 
-struct wcd939x_sdw_ch_info {
-	int port_num;
-	unsigned int ch_mask;
-};
-
-#define WCD_SDW_CH(id, pn, cmask)	\
-	[id] = {			\
-		.port_num = pn,		\
-		.ch_mask = cmask,	\
-	}
-
 enum wcd939x_tx_sdw_ports {
 	WCD939X_ADC_1_4_PORT = 1,
 	WCD939X_ADC_DMIC_1_2_PORT,
@@ -909,7 +898,7 @@ struct wcd939x_sdw_priv {
 	struct sdw_stream_config sconfig;
 	struct sdw_stream_runtime *sruntime;
 	struct sdw_port_config port_config[WCD939X_MAX_SWR_PORTS];
-	const struct wcd939x_sdw_ch_info *ch_info;
+	const struct wcd_sdw_ch_info *ch_info;
 	bool port_enable[WCD939X_MAX_SWR_CH_IDS];
 	int active_ports;
 	bool is_tx;
@@ -929,11 +918,6 @@ int wcd939x_sdw_hw_params(struct wcd939x
 			  struct snd_pcm_substream *substream,
 			  struct snd_pcm_hw_params *params,
 			  struct snd_soc_dai *dai);
-
-struct device *wcd939x_sdw_device_get(struct device_node *np);
-unsigned int wcd939x_swr_get_current_bank(struct sdw_slave *sdev);
-
-struct regmap *wcd939x_swr_get_regmap(struct wcd939x_sdw_priv *wcd);
 #else
 
 static inline int wcd939x_sdw_free(struct wcd939x_sdw_priv *wcd,
@@ -958,20 +942,6 @@ static inline int wcd939x_sdw_hw_params(
 	return -EOPNOTSUPP;
 }
 
-static inline struct device *wcd939x_sdw_device_get(struct device_node *np)
-{
-	return NULL;
-}
-
-static inline unsigned int wcd939x_swr_get_current_bank(struct sdw_slave *sdev)
-{
-	return 0;
-}
-
-struct regmap *wcd939x_swr_get_regmap(struct wcd939x_sdw_priv *wcd)
-{
-	return PTR_ERR(-EINVAL);
-}
 #endif /* CONFIG_SND_SOC_WCD939X_SDW */
 
 #endif /* __WCD939X_H__ */
diff -Nrup linux-6.16.7/sound/soc/codecs/wcd939x-sdw.c linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd939x-sdw.c
--- linux-6.16.7/sound/soc/codecs/wcd939x-sdw.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd939x-sdw.c	2025-09-11 09:47:42.000000000 -0600
@@ -20,10 +20,9 @@
 #include <sound/soc.h>
 #include <sound/soc-dapm.h>
 #include "wcd939x.h"
+#include "wcd-common.h"
 
-#define SWRS_SCP_HOST_CLK_DIV2_CTL_BANK(m) (0xE0 + 0x10 * (m))
-
-static const struct wcd939x_sdw_ch_info wcd939x_sdw_rx_ch_info[] = {
+static const struct wcd_sdw_ch_info wcd939x_sdw_rx_ch_info[] = {
 	WCD_SDW_CH(WCD939X_HPH_L, WCD939X_HPH_PORT, BIT(0)),
 	WCD_SDW_CH(WCD939X_HPH_R, WCD939X_HPH_PORT, BIT(1)),
 	WCD_SDW_CH(WCD939X_CLSH, WCD939X_CLSH_PORT, BIT(0)),
@@ -36,7 +35,7 @@ static const struct wcd939x_sdw_ch_info
 	WCD_SDW_CH(WCD939X_HIFI_PCM_R, WCD939X_HIFI_PCM_PORT, BIT(1)),
 };
 
-static const struct wcd939x_sdw_ch_info wcd939x_sdw_tx_ch_info[] = {
+static const struct wcd_sdw_ch_info wcd939x_sdw_tx_ch_info[] = {
 	WCD_SDW_CH(WCD939X_ADC1, WCD939X_ADC_1_4_PORT, BIT(0)),
 	WCD_SDW_CH(WCD939X_ADC2, WCD939X_ADC_1_4_PORT, BIT(1)),
 	WCD_SDW_CH(WCD939X_ADC3, WCD939X_ADC_1_4_PORT, BIT(2)),
@@ -128,19 +127,6 @@ static struct sdw_dpn_prop wcd939x_tx_dp
 	}
 };
 
-struct device *wcd939x_sdw_device_get(struct device_node *np)
-{
-	return bus_find_device_by_of_node(&sdw_bus_type, np);
-}
-EXPORT_SYMBOL_GPL(wcd939x_sdw_device_get);
-
-unsigned int wcd939x_swr_get_current_bank(struct sdw_slave *sdev)
-{
-	return FIELD_GET(SDW_SCP_STAT_CURR_BANK,
-			 sdw_read(sdev, SDW_SCP_CTRL));
-}
-EXPORT_SYMBOL_GPL(wcd939x_swr_get_current_bank);
-
 int wcd939x_sdw_hw_params(struct wcd939x_sdw_priv *wcd,
 			  struct snd_pcm_substream *substream,
 			  struct snd_pcm_hw_params *params,
@@ -199,38 +185,6 @@ int wcd939x_sdw_set_sdw_stream(struct wc
 }
 EXPORT_SYMBOL_GPL(wcd939x_sdw_set_sdw_stream);
 
-struct regmap *wcd939x_swr_get_regmap(struct wcd939x_sdw_priv *wcd)
-{
-	if (wcd->regmap)
-		return wcd->regmap;
-
-	return ERR_PTR(-EINVAL);
-}
-EXPORT_SYMBOL_GPL(wcd939x_swr_get_regmap);
-
-static int wcd9390_update_status(struct sdw_slave *slave,
-				 enum sdw_slave_status status)
-{
-	struct wcd939x_sdw_priv *wcd = dev_get_drvdata(&slave->dev);
-
-	if (wcd->regmap && status == SDW_SLAVE_ATTACHED) {
-		/* Write out any cached changes that happened between probe and attach */
-		regcache_cache_only(wcd->regmap, false);
-		return regcache_sync(wcd->regmap);
-	}
-
-	return 0;
-}
-
-static int wcd9390_bus_config(struct sdw_slave *slave,
-			      struct sdw_bus_params *params)
-{
-	sdw_write(slave, SWRS_SCP_HOST_CLK_DIV2_CTL_BANK(params->next_bank),
-		  0x01);
-
-	return 0;
-}
-
 /*
  * Handle Soundwire out-of-band interrupt event by triggering
  * the first irq of the slave_irq irq domain, which then will
@@ -241,18 +195,9 @@ static int wcd9390_interrupt_callback(st
 				      struct sdw_slave_intr_status *status)
 {
 	struct wcd939x_sdw_priv *wcd = dev_get_drvdata(&slave->dev);
-	struct irq_domain *slave_irq = wcd->slave_irq;
-	u32 sts1, sts2, sts3;
-
-	do {
-		handle_nested_irq(irq_find_mapping(slave_irq, 0));
-		regmap_read(wcd->regmap, WCD939X_DIGITAL_INTR_STATUS_0, &sts1);
-		regmap_read(wcd->regmap, WCD939X_DIGITAL_INTR_STATUS_1, &sts2);
-		regmap_read(wcd->regmap, WCD939X_DIGITAL_INTR_STATUS_2, &sts3);
-
-	} while (sts1 || sts2 || sts3);
 
-	return IRQ_HANDLED;
+	return wcd_interrupt_callback(slave, wcd->slave_irq, WCD939X_DIGITAL_INTR_STATUS_0,
+			WCD939X_DIGITAL_INTR_STATUS_1, WCD939X_DIGITAL_INTR_STATUS_2);
 }
 
 static const struct reg_default wcd939x_defaults[] = {
@@ -1385,34 +1330,9 @@ static const struct regmap_config wcd939
 };
 
 static const struct sdw_slave_ops wcd9390_slave_ops = {
-	.update_status = wcd9390_update_status,
+	.update_status = wcd_update_status,
 	.interrupt_callback = wcd9390_interrupt_callback,
-	.bus_config = wcd9390_bus_config,
-};
-
-static int wcd939x_sdw_component_bind(struct device *dev, struct device *master,
-				      void *data)
-{
-	pm_runtime_set_autosuspend_delay(dev, 3000);
-	pm_runtime_use_autosuspend(dev);
-	pm_runtime_mark_last_busy(dev);
-	pm_runtime_set_active(dev);
-	pm_runtime_enable(dev);
-
-	return 0;
-}
-
-static void wcd939x_sdw_component_unbind(struct device *dev,
-					 struct device *master, void *data)
-{
-	pm_runtime_disable(dev);
-	pm_runtime_set_suspended(dev);
-	pm_runtime_dont_use_autosuspend(dev);
-}
-
-static const struct component_ops wcd939x_sdw_component_ops = {
-	.bind = wcd939x_sdw_component_bind,
-	.unbind = wcd939x_sdw_component_unbind,
+	.bus_config = wcd_bus_config,
 };
 
 static int wcd9390_probe(struct sdw_slave *pdev, const struct sdw_device_id *id)
@@ -1478,7 +1398,7 @@ static int wcd9390_probe(struct sdw_slav
 		regcache_cache_only(wcd->regmap, true);
 	}
 
-	ret = component_add(dev, &wcd939x_sdw_component_ops);
+	ret = component_add(dev, &wcd_sdw_component_ops);
 	if (ret)
 		return ret;
 
@@ -1493,7 +1413,7 @@ static int wcd9390_remove(struct sdw_sla
 	struct device *dev = &pdev->dev;
 	struct wcd939x_sdw_priv *wcd = dev_get_drvdata(dev);
 
-	component_del(dev, &wcd939x_sdw_component_ops);
+	component_del(dev, &wcd_sdw_component_ops);
 
 	if (wcd->regmap)
 		regmap_exit(wcd->regmap);
diff -Nrup linux-6.16.7/sound/soc/codecs/wcd-common.c linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd-common.c
--- linux-6.16.7/sound/soc/codecs/wcd-common.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd-common.c	2025-09-11 09:47:42.000000000 -0600
@@ -0,0 +1,143 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2025, Qualcomm Technologies, Inc. and/or its subsidiaries.
+
+#include <linux/export.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/of.h>
+#include <linux/printk.h>
+#include <linux/component.h>
+#include <linux/pm_runtime.h>
+#include <linux/soundwire/sdw.h>
+#include <linux/soundwire/sdw_type.h>
+#include <linux/regmap.h>
+
+#include "wcd-common.h"
+
+#define WCD_MIN_MICBIAS_MV	1000
+#define WCD_DEF_MICBIAS_MV	1800
+#define WCD_MAX_MICBIAS_MV	2850
+
+#define SWRS_SCP_HOST_CLK_DIV2_CTL_BANK(m) (0xE0 + 0x10 * (m))
+
+int wcd_get_micb_vout_ctl_val(struct device *dev, u32 micb_mv)
+{
+	/* min micbias voltage is 1V and maximum is 2.85V */
+	if (micb_mv < WCD_MIN_MICBIAS_MV || micb_mv > WCD_MAX_MICBIAS_MV) {
+		dev_err(dev, "Unsupported micbias voltage (%u mV)\n", micb_mv);
+		return -EINVAL;
+	}
+
+	return (micb_mv - WCD_MIN_MICBIAS_MV) / 50;
+}
+EXPORT_SYMBOL_GPL(wcd_get_micb_vout_ctl_val);
+
+static int wcd_get_micbias_val(struct device *dev, int micb_num, u32 *micb_mv)
+{
+	char micbias[64];
+	int mv;
+
+	sprintf(micbias, "qcom,micbias%d-microvolt", micb_num);
+
+	if (of_property_read_u32(dev->of_node, micbias, &mv)) {
+		dev_err(dev, "%s value not found, using default\n", micbias);
+		mv = WCD_DEF_MICBIAS_MV;
+	} else {
+		/* convert it to milli volts */
+		mv = mv/1000;
+	}
+	if (micb_mv)
+		*micb_mv = mv;
+
+	mv = wcd_get_micb_vout_ctl_val(dev, mv);
+	if (mv < 0) {
+		dev_err(dev, "Unsupported %s voltage (%d mV), falling back to default (%d mV)\n",
+				micbias, mv, WCD_DEF_MICBIAS_MV);
+		return wcd_get_micb_vout_ctl_val(dev, WCD_DEF_MICBIAS_MV);
+	}
+
+	return mv;
+}
+
+int wcd_dt_parse_micbias_info(struct wcd_common *common)
+{
+	int i;
+
+	for (i = 0; i < common->max_bias; i++) {
+		common->micb_vout[i] = wcd_get_micbias_val(common->dev, i + 1, &common->micb_mv[i]);
+		if (common->micb_vout[i] < 0)
+			return -EINVAL;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(wcd_dt_parse_micbias_info);
+
+static int wcd_sdw_component_bind(struct device *dev, struct device *master, void *data)
+{
+	pm_runtime_set_autosuspend_delay(dev, 3000);
+	pm_runtime_use_autosuspend(dev);
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+
+	return 0;
+}
+
+static void wcd_sdw_component_unbind(struct device *dev, struct device *master, void *data)
+{
+	pm_runtime_disable(dev);
+	pm_runtime_set_suspended(dev);
+	pm_runtime_dont_use_autosuspend(dev);
+}
+
+const struct component_ops wcd_sdw_component_ops = {
+	.bind = wcd_sdw_component_bind,
+	.unbind = wcd_sdw_component_unbind,
+};
+EXPORT_SYMBOL_GPL(wcd_sdw_component_ops);
+
+int wcd_update_status(struct sdw_slave *slave, enum sdw_slave_status status)
+{
+	struct regmap *regmap = dev_get_regmap(&slave->dev, NULL);
+
+	if (regmap && status == SDW_SLAVE_ATTACHED) {
+		/* Write out any cached changes that happened between probe and attach */
+		regcache_cache_only(regmap, false);
+		return regcache_sync(regmap);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(wcd_update_status);
+
+int wcd_bus_config(struct sdw_slave *slave, struct sdw_bus_params *params)
+{
+	sdw_write(slave, SWRS_SCP_HOST_CLK_DIV2_CTL_BANK(params->next_bank), 0x01);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(wcd_bus_config);
+
+int wcd_interrupt_callback(struct sdw_slave *slave, struct irq_domain *slave_irq,
+		unsigned int wcd_intr_status0, unsigned int wcd_intr_status1,
+		unsigned int wcd_intr_status2)
+{
+	struct regmap *regmap = dev_get_regmap(&slave->dev, NULL);
+	u32 sts1, sts2, sts3;
+
+	do {
+		handle_nested_irq(irq_find_mapping(slave_irq, 0));
+		regmap_read(regmap, wcd_intr_status0, &sts1);
+		regmap_read(regmap, wcd_intr_status1, &sts2);
+		regmap_read(regmap, wcd_intr_status2, &sts3);
+
+	} while (sts1 || sts2 || sts3);
+
+	return IRQ_HANDLED;
+}
+EXPORT_SYMBOL_GPL(wcd_interrupt_callback);
+
+MODULE_DESCRIPTION("Common Qualcomm WCD Codec helpers driver");
+MODULE_LICENSE("GPL");
diff -Nrup linux-6.16.7/sound/soc/codecs/wcd-common.h linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd-common.h
--- linux-6.16.7/sound/soc/codecs/wcd-common.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd-common.h	2025-09-11 09:47:42.000000000 -0600
@@ -0,0 +1,46 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2025, Qualcomm Technologies, Inc. and/or its subsidiaries.
+ */
+
+#ifndef __WCD_COMMON_H__
+#define __WCD_COMMON_H__
+
+struct device;
+struct sdw_slave;
+struct sdw_bus_params;
+struct irq_domain;
+enum sdw_slave_status;
+
+#define WCD_MAX_MICBIAS		4
+
+struct wcd_sdw_ch_info {
+	int port_num;
+	unsigned int ch_mask;
+	unsigned int master_ch_mask;
+};
+
+#define WCD_SDW_CH(id, pn, cmask)	\
+	[id] = {			\
+		.port_num = pn,		\
+		.ch_mask = cmask,	\
+		.master_ch_mask = cmask,	\
+	}
+
+struct wcd_common {
+	struct device *dev;
+	int max_bias;
+	u32 micb_mv[WCD_MAX_MICBIAS];
+	u32 micb_vout[WCD_MAX_MICBIAS];
+};
+
+extern const struct component_ops wcd_sdw_component_ops;
+int wcd_get_micb_vout_ctl_val(struct device *dev, u32 micb_mv);
+int wcd_dt_parse_micbias_info(struct wcd_common *common);
+int wcd_update_status(struct sdw_slave *slave, enum sdw_slave_status status);
+int wcd_bus_config(struct sdw_slave *slave, struct sdw_bus_params *params);
+int wcd_interrupt_callback(struct sdw_slave *slave, struct irq_domain *slave_irq,
+		unsigned int wcd_intr_status0, unsigned int wcd_intr_status1,
+		unsigned int wcd_intr_status2);
+
+#endif /* __WCD_COMMON_H__  */
diff -Nrup linux-6.16.7/sound/soc/qcom/qdsp6/audioreach.c linux-lenovo-x13s-linux-6.16.y/sound/soc/qcom/qdsp6/audioreach.c
--- linux-6.16.7/sound/soc/qcom/qdsp6/audioreach.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/qcom/qdsp6/audioreach.c	2025-09-11 09:47:42.000000000 -0600
@@ -202,6 +202,31 @@ struct apm_display_port_module_intf_cfg
 } __packed;
 #define APM_DP_INTF_CFG_PSIZE ALIGN(sizeof(struct apm_display_port_module_intf_cfg), 8)
 
+struct apm_module_sp_vi_op_mode_cfg {
+	struct apm_module_param_data param_data;
+	struct param_id_sp_vi_op_mode_cfg cfg;
+} __packed;
+
+#define APM_SP_VI_OP_MODE_CFG_PSIZE(ch) ALIGN( \
+				sizeof(struct apm_module_sp_vi_op_mode_cfg) + \
+				(ch) * sizeof(uint32_t), 8)
+
+struct apm_module_sp_vi_ex_mode_cfg {
+	struct apm_module_param_data param_data;
+	struct param_id_sp_vi_ex_mode_cfg cfg;
+} __packed;
+
+#define APM_SP_VI_EX_MODE_CFG_PSIZE ALIGN(sizeof(struct apm_module_sp_vi_ex_mode_cfg), 8)
+
+struct apm_module_sp_vi_channel_map_cfg {
+	struct apm_module_param_data param_data;
+	struct param_id_sp_vi_channel_map_cfg cfg;
+} __packed;
+
+#define APM_SP_VI_CH_MAP_CFG_PSIZE(ch) ALIGN( \
+				sizeof(struct apm_module_sp_vi_channel_map_cfg) + \
+				(ch) * sizeof(uint32_t), 8)
+
 static void *__audioreach_alloc_pkt(int payload_size, uint32_t opcode, uint32_t token,
 				    uint32_t src_port, uint32_t dest_port, bool has_cmd_hdr)
 {
@@ -811,6 +836,30 @@ static int audioreach_gapless_set_media_
 					 EARLY_EOS_DELAY_MS);
 }
 
+static int audioreach_set_module_config(struct q6apm_graph *graph,
+					struct audioreach_module *module,
+					struct audioreach_module_config *cfg)
+{
+	int payload_size = le32_to_cpu(module->data->size);
+	struct gpr_pkt *pkt;
+	int rc;
+	void *p;
+
+	pkt = audioreach_alloc_apm_cmd_pkt(payload_size, APM_CMD_SET_CFG, 0);
+	if (IS_ERR(pkt))
+		return PTR_ERR(pkt);
+
+	p = (void *)pkt + GPR_HDR_SIZE + APM_CMD_HDR_SIZE;
+
+	memcpy(p, module->data->data, payload_size);
+
+	rc = q6apm_send_cmd_sync(graph->apm, pkt, 0);
+
+	kfree(pkt);
+
+	return rc;
+}
+
 static int audioreach_mfc_set_media_format(struct q6apm_graph *graph,
 					   struct audioreach_module *module,
 					   struct audioreach_module_config *cfg)
@@ -1226,6 +1275,98 @@ static int audioreach_gain_set(struct q6
 	return rc;
 }
 
+static int audioreach_speaker_protection(struct q6apm_graph *graph,
+					 struct audioreach_module *module,
+					 uint32_t operation_mode)
+{
+	return audioreach_send_u32_param(graph, module, PARAM_ID_SP_OP_MODE,
+					 operation_mode);
+}
+
+static int audioreach_speaker_protection_vi(struct q6apm_graph *graph,
+					    struct audioreach_module *module,
+					    struct audioreach_module_config *mcfg)
+{
+	u32 num_channels = mcfg->num_channels;
+	struct apm_module_sp_vi_op_mode_cfg *op_cfg;
+	struct apm_module_sp_vi_channel_map_cfg *cm_cfg;
+	struct apm_module_sp_vi_ex_mode_cfg *ex_cfg;
+	int op_sz, cm_sz, ex_sz;
+	struct apm_module_param_data *param_data;
+	int rc, i, payload_size;
+	struct gpr_pkt *pkt;
+	void *p;
+
+	if (num_channels > 2) {
+		dev_err(graph->dev, "Error: Invalid channels (%d)!\n", num_channels);
+		return -EINVAL;
+	}
+
+	op_sz = APM_SP_VI_OP_MODE_CFG_PSIZE(num_channels);
+	/* Channel mapping for Isense and Vsense, thus twice number of speakers. */
+	cm_sz = APM_SP_VI_CH_MAP_CFG_PSIZE(num_channels * 2);
+	ex_sz = APM_SP_VI_EX_MODE_CFG_PSIZE;
+
+	payload_size = op_sz + cm_sz + ex_sz;
+
+	pkt = audioreach_alloc_apm_cmd_pkt(payload_size, APM_CMD_SET_CFG, 0);
+	if (IS_ERR(pkt))
+		return PTR_ERR(pkt);
+
+	p = (void *)pkt + GPR_HDR_SIZE + APM_CMD_HDR_SIZE;
+
+	op_cfg = p;
+	param_data = &op_cfg->param_data;
+	param_data->module_instance_id = module->instance_id;
+	param_data->error_code = 0;
+	param_data->param_id = PARAM_ID_SP_VI_OP_MODE_CFG;
+	param_data->param_size = op_sz - APM_MODULE_PARAM_DATA_SIZE;
+
+	op_cfg->cfg.num_channels = num_channels;
+	op_cfg->cfg.operation_mode = PARAM_ID_SP_VI_OP_MODE_NORMAL;
+	op_cfg->cfg.quick_calibration = 1;
+	/*
+	 * op_cfg->cfg.r0_t0_selection should be set only for normal mode, keep
+	 * as 0 for calibration
+	 */
+	p += op_sz;
+
+	cm_cfg = p;
+	param_data = &cm_cfg->param_data;
+	param_data->module_instance_id = module->instance_id;
+	param_data->error_code = 0;
+	param_data->param_id = PARAM_ID_SP_VI_CHANNEL_MAP_CFG;
+	param_data->param_size = cm_sz - APM_MODULE_PARAM_DATA_SIZE;
+
+	cm_cfg->cfg.num_channels = num_channels * 2;
+	for (i = 0; i < num_channels; i++) {
+		/*
+		 * Map speakers into Vsense and then Isense of each channel.
+		 * E.g. for PCM_CHANNEL_FL and PCM_CHANNEL_FR to:
+		 * [ 1, 2, 3, 4]
+		 */
+		cm_cfg->cfg.channel_mapping[2 * i] = (mcfg->channel_map[i] - 1) * 2 + 1;
+		cm_cfg->cfg.channel_mapping[2 * i + 1] = (mcfg->channel_map[i] - 1) * 2 + 2;
+	}
+
+	p += cm_sz;
+
+	ex_cfg = p;
+	param_data = &ex_cfg->param_data;
+	param_data->module_instance_id = module->instance_id;
+	param_data->error_code = 0;
+	param_data->param_id = PARAM_ID_SP_VI_EX_MODE_CFG;
+	param_data->param_size = ex_sz - APM_MODULE_PARAM_DATA_SIZE;
+
+	ex_cfg->cfg.factory_mode = 0;
+
+	rc = q6apm_send_cmd_sync(graph->apm, pkt, 0);
+
+	kfree(pkt);
+
+	return rc;
+}
+
 int audioreach_set_media_format(struct q6apm_graph *graph, struct audioreach_module *module,
 				struct audioreach_module_config *cfg)
 {
@@ -1247,6 +1388,9 @@ int audioreach_set_media_format(struct q
 	case MODULE_ID_DISPLAY_PORT_SINK:
 		rc = audioreach_display_port_set_media_format(graph, module, cfg);
 		break;
+	case  MODULE_ID_SMECNS_V2:
+		rc = audioreach_set_module_config(graph, module, cfg);
+		break;
 	case MODULE_ID_I2S_SOURCE:
 	case MODULE_ID_I2S_SINK:
 		rc = audioreach_i2s_set_media_format(graph, module, cfg);
@@ -1272,6 +1416,14 @@ int audioreach_set_media_format(struct q
 	case MODULE_ID_GAPLESS:
 		rc = audioreach_gapless_set_media_format(graph, module, cfg);
 		break;
+	case MODULE_ID_SPEAKER_PROTECTION:
+		rc = audioreach_speaker_protection(graph, module,
+						   PARAM_ID_SP_OP_MODE_NORMAL);
+		break;
+	case MODULE_ID_SPEAKER_PROTECTION_VI:
+		rc = audioreach_speaker_protection_vi(graph, module, cfg);
+		break;
+
 	default:
 		rc = 0;
 	}
diff -Nrup linux-6.16.7/sound/soc/qcom/qdsp6/audioreach.h linux-lenovo-x13s-linux-6.16.y/sound/soc/qcom/qdsp6/audioreach.h
--- linux-6.16.7/sound/soc/qcom/qdsp6/audioreach.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/qcom/qdsp6/audioreach.h	2025-09-11 09:47:42.000000000 -0600
@@ -4,6 +4,7 @@
 #define __AUDIOREACH_H__
 #include <linux/types.h>
 #include <linux/soc/qcom/apr.h>
+#include <uapi/sound/snd_ar_tokens.h>
 #include <sound/soc.h>
 struct q6apm;
 struct q6apm_graph;
@@ -17,18 +18,21 @@ struct q6apm_graph;
 #define MODULE_ID_PCM_DEC		0x07001005
 #define MODULE_ID_PLACEHOLDER_ENCODER	0x07001008
 #define MODULE_ID_PLACEHOLDER_DECODER	0x07001009
-#define MODULE_ID_SAL			0x07001010
-#define MODULE_ID_MFC			0x07001015
-#define MODULE_ID_CODEC_DMA_SINK	0x07001023
-#define MODULE_ID_CODEC_DMA_SOURCE	0x07001024
 #define MODULE_ID_I2S_SINK		0x0700100A
 #define MODULE_ID_I2S_SOURCE		0x0700100B
+#define MODULE_ID_SAL			0x07001010
+#define MODULE_ID_MFC			0x07001015
 #define MODULE_ID_DATA_LOGGING		0x0700101A
 #define MODULE_ID_AAC_DEC		0x0700101F
+#define MODULE_ID_CODEC_DMA_SINK	0x07001023
+#define MODULE_ID_CODEC_DMA_SOURCE	0x07001024
 #define MODULE_ID_FLAC_DEC		0x0700102F
+#define MODULE_ID_SMECNS_V2		0x07001031
 #define MODULE_ID_MP3_DECODE		0x0700103B
 #define MODULE_ID_GAPLESS		0x0700104D
 #define MODULE_ID_DISPLAY_PORT_SINK	0x07001069
+#define MODULE_ID_SPEAKER_PROTECTION	0x070010E2
+#define MODULE_ID_SPEAKER_PROTECTION_VI	0x070010E3
 
 #define APM_CMD_GET_SPF_STATE		0x01001021
 #define APM_CMD_RSP_GET_SPF_STATE	0x02001007
@@ -461,8 +465,8 @@ struct param_id_i2s_intf_cfg {
 } __packed;
 
 #define I2S_INTF_TYPE_PRIMARY		0
-#define I2S_INTF_TYPE_SECOINDARY	1
-#define I2S_INTF_TYPE_TERTINARY		2
+#define I2S_INTF_TYPE_SECONDARY		1
+#define I2S_INTF_TYPE_TERTIARY		2
 #define I2S_INTF_TYPE_QUATERNARY	3
 #define I2S_INTF_TYPE_QUINARY		4
 #define I2S_SD0				1
@@ -540,6 +544,43 @@ struct data_logging_config {
 	uint32_t mode;
 } __packed;
 
+/* Speaker Protection */
+#define PARAM_ID_SP_OP_MODE			0x080011e9
+#define PARAM_ID_SP_OP_MODE_NORMAL		0
+#define PARAM_ID_SP_OP_MODE_CALIBRATION		1
+#define PARAM_ID_SP_OP_MODE_FACTORY_TEST	2
+#define PARAM_ID_SP_OP_MODE_VALIDATION		3
+
+struct param_id_sp_op_mode {
+	uint32_t operation_mode;
+} __packed;
+
+/* Speaker Protection VI */
+
+#define PARAM_ID_SP_VI_OP_MODE_CFG		0x080011f4
+#define PARAM_ID_SP_VI_OP_MODE_NORMAL		0
+#define PARAM_ID_SP_VI_OP_MODE_CALIBRATION	1
+#define PARAM_ID_SP_VI_OP_MODE_FACTORY_TEST	2
+#define PARAM_ID_SP_VI_OP_MODE_VALIDATION	3
+struct param_id_sp_vi_op_mode_cfg {
+	uint32_t num_channels;
+	uint32_t operation_mode;
+	uint32_t quick_calibration;
+	uint32_t r0_t0_selection[];
+} __packed;
+
+#define PARAM_ID_SP_VI_EX_MODE_CFG		0x080011ff
+struct param_id_sp_vi_ex_mode_cfg {
+	uint32_t factory_mode;
+} __packed;
+
+#define PARAM_ID_SP_VI_CHANNEL_MAP_CFG		0x08001203
+struct param_id_sp_vi_channel_map_cfg {
+	uint32_t num_channels;
+	/* [ Vsense of ch 1, Isense of ch 1, Vsense of ch 2, Isense of ch 2, ... ] */
+	uint32_t channel_mapping[];
+} __packed;
+
 #define PARAM_ID_SAL_OUTPUT_CFG			0x08001016
 struct param_id_sal_output_config {
 	uint32_t bits_per_sample;
@@ -707,9 +748,6 @@ struct audioreach_module {
 	uint32_t max_ip_port;
 	uint32_t max_op_port;
 
-	uint32_t in_port;
-	uint32_t out_port;
-
 	uint32_t num_connections;
 	/* Connections */
 	uint32_t src_mod_inst_id;
@@ -745,6 +783,7 @@ struct audioreach_module {
 	struct list_head node;
 	struct audioreach_container *container;
 	struct snd_soc_dapm_widget *widget;
+	struct audioreach_module_priv_data *data;
 };
 
 struct audioreach_module_config {
diff -Nrup linux-6.16.7/sound/soc/qcom/qdsp6/q6apm-lpass-dais.c linux-lenovo-x13s-linux-6.16.y/sound/soc/qcom/qdsp6/q6apm-lpass-dais.c
--- linux-6.16.7/sound/soc/qcom/qdsp6/q6apm-lpass-dais.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/qcom/qdsp6/q6apm-lpass-dais.c	2025-09-11 09:47:42.000000000 -0600
@@ -213,8 +213,10 @@ static int q6apm_lpass_dai_prepare(struc
 
 	return 0;
 err:
-	q6apm_graph_close(dai_data->graph[dai->id]);
-	dai_data->graph[dai->id] = NULL;
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		q6apm_graph_close(dai_data->graph[dai->id]);
+		dai_data->graph[dai->id] = NULL;
+	}
 	return rc;
 }
 
diff -Nrup linux-6.16.7/sound/soc/qcom/qdsp6/topology.c linux-lenovo-x13s-linux-6.16.y/sound/soc/qcom/qdsp6/topology.c
--- linux-6.16.7/sound/soc/qcom/qdsp6/topology.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/qcom/qdsp6/topology.c	2025-09-11 09:47:42.000000000 -0600
@@ -305,6 +305,34 @@ static struct snd_soc_tplg_vendor_array
 	return NULL;
 }
 
+static struct audioreach_module_priv_data *audioreach_get_module_priv_data(
+		struct snd_soc_tplg_private *private)
+{
+	int sz;
+
+	for (sz = 0; sz < le32_to_cpu(private->size); ) {
+		struct snd_soc_tplg_vendor_array *mod_array;
+
+		mod_array = (struct snd_soc_tplg_vendor_array *)((u8 *)private->array + sz);
+		if (le32_to_cpu(mod_array->type) == SND_SOC_AR_TPLG_MODULE_CFG_TYPE) {
+			struct audioreach_module_priv_data *pdata;
+
+			pdata = kzalloc(struct_size(pdata, data, le32_to_cpu(mod_array->size)),
+				       GFP_KERNEL);
+			if (!pdata)
+				return ERR_PTR(-ENOMEM);
+
+			memcpy(pdata, ((u8 *)private->data + sz), struct_size(pdata, data,
+						le32_to_cpu(mod_array->size)));
+			return pdata;
+		}
+
+		sz = sz + le32_to_cpu(mod_array->size);
+	}
+
+	return NULL;
+}
+
 static struct audioreach_sub_graph *audioreach_parse_sg_tokens(struct q6apm *apm,
 						       struct snd_soc_tplg_private *private)
 {
@@ -412,7 +440,7 @@ static struct audioreach_module *audiore
 							struct snd_soc_tplg_private *private,
 							struct snd_soc_dapm_widget *w)
 {
-	uint32_t max_ip_port = 0, max_op_port = 0, in_port = 0, out_port = 0;
+	uint32_t max_ip_port = 0, max_op_port = 0;
 	uint32_t src_mod_op_port_id[AR_MAX_MOD_LINKS] = { 0, };
 	uint32_t dst_mod_inst_id[AR_MAX_MOD_LINKS] = { 0, };
 	uint32_t dst_mod_ip_port_id[AR_MAX_MOD_LINKS] = { 0, };
@@ -455,12 +483,6 @@ static struct audioreach_module *audiore
 		case AR_TKN_U32_MODULE_MAX_OP_PORTS:
 			max_op_port = le32_to_cpu(mod_elem->value);
 			break;
-		case AR_TKN_U32_MODULE_IN_PORTS:
-			in_port = le32_to_cpu(mod_elem->value);
-			break;
-		case AR_TKN_U32_MODULE_OUT_PORTS:
-			out_port = le32_to_cpu(mod_elem->value);
-			break;
 		case AR_TKN_U32_MODULE_SRC_INSTANCE_ID:
 			src_mod_inst_id = le32_to_cpu(mod_elem->value);
 			break;
@@ -550,8 +572,6 @@ static struct audioreach_module *audiore
 		mod->module_id = module_id;
 		mod->max_ip_port = max_ip_port;
 		mod->max_op_port = max_op_port;
-		mod->in_port = in_port;
-		mod->out_port = out_port;
 		mod->src_mod_inst_id = src_mod_inst_id;
 		for (pn = 0; pn < mod->max_op_port; pn++) {
 			if (src_mod_op_port_id[pn] && dst_mod_inst_id[pn] &&
@@ -587,8 +607,10 @@ static int audioreach_widget_load_module
 		return PTR_ERR(cont);
 
 	mod = audioreach_parse_common_tokens(apm, cont, &tplg_w->priv, w);
-	if (IS_ERR(mod))
-		return PTR_ERR(mod);
+	if (IS_ERR_OR_NULL(mod))
+		return mod ? PTR_ERR(mod) : -ENODEV;
+
+	mod->data = audioreach_get_module_priv_data(&tplg_w->priv);
 
 	dobj = &w->dobj;
 	dobj->private = mod;
@@ -947,6 +969,7 @@ static int audioreach_widget_unload(stru
 	cont->num_modules--;
 
 	list_del(&mod->node);
+	kfree(mod->data);
 	kfree(mod);
 	/* Graph Info has N sub-graphs, sub-graph has N containers, Container has N Modules */
 	if (list_empty(&cont->modules_list)) { /* if no modules in the container then remove it */
diff -Nrup linux-6.16.7/sound/soc/qcom/sc8280xp.c linux-lenovo-x13s-linux-6.16.y/sound/soc/qcom/sc8280xp.c
--- linux-6.16.7/sound/soc/qcom/sc8280xp.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/qcom/sc8280xp.c	2025-09-11 09:47:42.000000000 -0600
@@ -7,6 +7,7 @@
 #include <sound/soc.h>
 #include <sound/soc-dapm.h>
 #include <sound/pcm.h>
+#include <sound/pcm_params.h>
 #include <linux/soundwire/sdw.h>
 #include <sound/jack.h>
 #include <linux/input-event-codes.h>
@@ -82,8 +83,10 @@ static int sc8280xp_be_hw_params_fixup(s
 					SNDRV_PCM_HW_PARAM_RATE);
 	struct snd_interval *channels = hw_param_interval(params,
 					SNDRV_PCM_HW_PARAM_CHANNELS);
+	struct snd_mask *fmt = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);
 
 	rate->min = rate->max = 48000;
+	snd_mask_set_format(fmt, SNDRV_PCM_FORMAT_S16_LE);
 	channels->min = 2;
 	channels->max = 2;
 	switch (cpu_dai->id) {
diff -Nrup linux-6.16.7/tools/lib/bpf/elf.c linux-lenovo-x13s-linux-6.16.y/tools/lib/bpf/elf.c
--- linux-6.16.7/tools/lib/bpf/elf.c	2025-09-13 16:15:46.049768241 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/lib/bpf/elf.c	2025-09-11 09:47:42.000000000 -0600
@@ -370,11 +370,6 @@ out:
 	return ret;
 }
 
-#if !defined(__clang__)
-#pragma GCC diagnostic push
-/* https://gcc.gnu.org/PR114952 */
-#pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
-#endif
 /* Find offset of function name in ELF object specified by path. "name" matches
  * symbol name or name@@LIB for library functions.
  */
@@ -390,9 +385,6 @@ long elf_find_func_offset_from_file(cons
 	elf_close(&elf_fd);
 	return ret;
 }
-#if !defined(__clang__)
-#pragma GCC diagnostic pop
-#endif
 
 struct symbol {
 	const char *name;
diff -Nrup linux-6.16.7/tools/lib/bpf/elf.c.orig linux-lenovo-x13s-linux-6.16.y/tools/lib/bpf/elf.c.orig
--- linux-6.16.7/tools/lib/bpf/elf.c.orig	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/lib/bpf/elf.c.orig	1969-12-31 17:00:00.000000000 -0700
@@ -1,559 +0,0 @@
-// SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)
-
-#ifndef _GNU_SOURCE
-#define _GNU_SOURCE
-#endif
-#include <libelf.h>
-#include <gelf.h>
-#include <fcntl.h>
-#include <linux/kernel.h>
-
-#include "libbpf_internal.h"
-#include "str_error.h"
-
-/* A SHT_GNU_versym section holds 16-bit words. This bit is set if
- * the symbol is hidden and can only be seen when referenced using an
- * explicit version number. This is a GNU extension.
- */
-#define VERSYM_HIDDEN	0x8000
-
-/* This is the mask for the rest of the data in a word read from a
- * SHT_GNU_versym section.
- */
-#define VERSYM_VERSION	0x7fff
-
-int elf_open(const char *binary_path, struct elf_fd *elf_fd)
-{
-	int fd, ret;
-	Elf *elf;
-
-	elf_fd->elf = NULL;
-	elf_fd->fd = -1;
-
-	if (elf_version(EV_CURRENT) == EV_NONE) {
-		pr_warn("elf: failed to init libelf for %s\n", binary_path);
-		return -LIBBPF_ERRNO__LIBELF;
-	}
-	fd = open(binary_path, O_RDONLY | O_CLOEXEC);
-	if (fd < 0) {
-		ret = -errno;
-		pr_warn("elf: failed to open %s: %s\n", binary_path, errstr(ret));
-		return ret;
-	}
-	elf = elf_begin(fd, ELF_C_READ_MMAP, NULL);
-	if (!elf) {
-		pr_warn("elf: could not read elf from %s: %s\n", binary_path, elf_errmsg(-1));
-		close(fd);
-		return -LIBBPF_ERRNO__FORMAT;
-	}
-	elf_fd->fd = fd;
-	elf_fd->elf = elf;
-	return 0;
-}
-
-void elf_close(struct elf_fd *elf_fd)
-{
-	if (!elf_fd)
-		return;
-	elf_end(elf_fd->elf);
-	close(elf_fd->fd);
-}
-
-/* Return next ELF section of sh_type after scn, or first of that type if scn is NULL. */
-static Elf_Scn *elf_find_next_scn_by_type(Elf *elf, int sh_type, Elf_Scn *scn)
-{
-	while ((scn = elf_nextscn(elf, scn)) != NULL) {
-		GElf_Shdr sh;
-
-		if (!gelf_getshdr(scn, &sh))
-			continue;
-		if (sh.sh_type == sh_type)
-			return scn;
-	}
-	return NULL;
-}
-
-struct elf_sym {
-	const char *name;
-	GElf_Sym sym;
-	GElf_Shdr sh;
-	int ver;
-	bool hidden;
-};
-
-struct elf_sym_iter {
-	Elf *elf;
-	Elf_Data *syms;
-	Elf_Data *versyms;
-	Elf_Data *verdefs;
-	size_t nr_syms;
-	size_t strtabidx;
-	size_t verdef_strtabidx;
-	size_t next_sym_idx;
-	struct elf_sym sym;
-	int st_type;
-};
-
-static int elf_sym_iter_new(struct elf_sym_iter *iter,
-			    Elf *elf, const char *binary_path,
-			    int sh_type, int st_type)
-{
-	Elf_Scn *scn = NULL;
-	GElf_Ehdr ehdr;
-	GElf_Shdr sh;
-
-	memset(iter, 0, sizeof(*iter));
-
-	if (!gelf_getehdr(elf, &ehdr)) {
-		pr_warn("elf: failed to get ehdr from %s: %s\n", binary_path, elf_errmsg(-1));
-		return -EINVAL;
-	}
-
-	scn = elf_find_next_scn_by_type(elf, sh_type, NULL);
-	if (!scn) {
-		pr_debug("elf: failed to find symbol table ELF sections in '%s'\n",
-			 binary_path);
-		return -ENOENT;
-	}
-
-	if (!gelf_getshdr(scn, &sh))
-		return -EINVAL;
-
-	iter->strtabidx = sh.sh_link;
-	iter->syms = elf_getdata(scn, 0);
-	if (!iter->syms) {
-		pr_warn("elf: failed to get symbols for symtab section in '%s': %s\n",
-			binary_path, elf_errmsg(-1));
-		return -EINVAL;
-	}
-	iter->nr_syms = iter->syms->d_size / sh.sh_entsize;
-	iter->elf = elf;
-	iter->st_type = st_type;
-
-	/* Version symbol table is meaningful to dynsym only */
-	if (sh_type != SHT_DYNSYM)
-		return 0;
-
-	scn = elf_find_next_scn_by_type(elf, SHT_GNU_versym, NULL);
-	if (!scn)
-		return 0;
-	iter->versyms = elf_getdata(scn, 0);
-
-	scn = elf_find_next_scn_by_type(elf, SHT_GNU_verdef, NULL);
-	if (!scn)
-		return 0;
-
-	iter->verdefs = elf_getdata(scn, 0);
-	if (!iter->verdefs || !gelf_getshdr(scn, &sh)) {
-		pr_warn("elf: failed to get verdef ELF section in '%s'\n", binary_path);
-		return -EINVAL;
-	}
-	iter->verdef_strtabidx = sh.sh_link;
-
-	return 0;
-}
-
-static struct elf_sym *elf_sym_iter_next(struct elf_sym_iter *iter)
-{
-	struct elf_sym *ret = &iter->sym;
-	GElf_Sym *sym = &ret->sym;
-	const char *name = NULL;
-	GElf_Versym versym;
-	Elf_Scn *sym_scn;
-	size_t idx;
-
-	for (idx = iter->next_sym_idx; idx < iter->nr_syms; idx++) {
-		if (!gelf_getsym(iter->syms, idx, sym))
-			continue;
-		if (GELF_ST_TYPE(sym->st_info) != iter->st_type)
-			continue;
-		name = elf_strptr(iter->elf, iter->strtabidx, sym->st_name);
-		if (!name)
-			continue;
-		sym_scn = elf_getscn(iter->elf, sym->st_shndx);
-		if (!sym_scn)
-			continue;
-		if (!gelf_getshdr(sym_scn, &ret->sh))
-			continue;
-
-		iter->next_sym_idx = idx + 1;
-		ret->name = name;
-		ret->ver = 0;
-		ret->hidden = false;
-
-		if (iter->versyms) {
-			if (!gelf_getversym(iter->versyms, idx, &versym))
-				continue;
-			ret->ver = versym & VERSYM_VERSION;
-			ret->hidden = versym & VERSYM_HIDDEN;
-		}
-		return ret;
-	}
-
-	return NULL;
-}
-
-static const char *elf_get_vername(struct elf_sym_iter *iter, int ver)
-{
-	GElf_Verdaux verdaux;
-	GElf_Verdef verdef;
-	int offset;
-
-	if (!iter->verdefs)
-		return NULL;
-
-	offset = 0;
-	while (gelf_getverdef(iter->verdefs, offset, &verdef)) {
-		if (verdef.vd_ndx != ver) {
-			if (!verdef.vd_next)
-				break;
-
-			offset += verdef.vd_next;
-			continue;
-		}
-
-		if (!gelf_getverdaux(iter->verdefs, offset + verdef.vd_aux, &verdaux))
-			break;
-
-		return elf_strptr(iter->elf, iter->verdef_strtabidx, verdaux.vda_name);
-
-	}
-	return NULL;
-}
-
-static bool symbol_match(struct elf_sym_iter *iter, int sh_type, struct elf_sym *sym,
-			 const char *name, size_t name_len, const char *lib_ver)
-{
-	const char *ver_name;
-
-	/* Symbols are in forms of func, func@LIB_VER or func@@LIB_VER
-	 * make sure the func part matches the user specified name
-	 */
-	if (strncmp(sym->name, name, name_len) != 0)
-		return false;
-
-	/* ...but we don't want a search for "foo" to match 'foo2" also, so any
-	 * additional characters in sname should be of the form "@@LIB".
-	 */
-	if (sym->name[name_len] != '\0' && sym->name[name_len] != '@')
-		return false;
-
-	/* If user does not specify symbol version, then we got a match */
-	if (!lib_ver)
-		return true;
-
-	/* If user specifies symbol version, for dynamic symbols,
-	 * get version name from ELF verdef section for comparison.
-	 */
-	if (sh_type == SHT_DYNSYM) {
-		ver_name = elf_get_vername(iter, sym->ver);
-		if (!ver_name)
-			return false;
-		return strcmp(ver_name, lib_ver) == 0;
-	}
-
-	/* For normal symbols, it is already in form of func@LIB_VER */
-	return strcmp(sym->name, name) == 0;
-}
-
-/* Transform symbol's virtual address (absolute for binaries and relative
- * for shared libs) into file offset, which is what kernel is expecting
- * for uprobe/uretprobe attachment.
- * See Documentation/trace/uprobetracer.rst for more details. This is done
- * by looking up symbol's containing section's header and using iter's virtual
- * address (sh_addr) and corresponding file offset (sh_offset) to transform
- * sym.st_value (virtual address) into desired final file offset.
- */
-static unsigned long elf_sym_offset(struct elf_sym *sym)
-{
-	return sym->sym.st_value - sym->sh.sh_addr + sym->sh.sh_offset;
-}
-
-/* Find offset of function name in the provided ELF object. "binary_path" is
- * the path to the ELF binary represented by "elf", and only used for error
- * reporting matters. "name" matches symbol name or name@@LIB for library
- * functions.
- */
-long elf_find_func_offset(Elf *elf, const char *binary_path, const char *name)
-{
-	int i, sh_types[2] = { SHT_DYNSYM, SHT_SYMTAB };
-	const char *at_symbol, *lib_ver;
-	bool is_shared_lib;
-	long ret = -ENOENT;
-	size_t name_len;
-	GElf_Ehdr ehdr;
-
-	if (!gelf_getehdr(elf, &ehdr)) {
-		pr_warn("elf: failed to get ehdr from %s: %s\n", binary_path, elf_errmsg(-1));
-		ret = -LIBBPF_ERRNO__FORMAT;
-		goto out;
-	}
-	/* for shared lib case, we do not need to calculate relative offset */
-	is_shared_lib = ehdr.e_type == ET_DYN;
-
-	/* Does name specify "@@LIB_VER" or "@LIB_VER" ? */
-	at_symbol = strchr(name, '@');
-	if (at_symbol) {
-		name_len = at_symbol - name;
-		/* skip second @ if it's @@LIB_VER case */
-		if (at_symbol[1] == '@')
-			at_symbol++;
-		lib_ver = at_symbol + 1;
-	} else {
-		name_len = strlen(name);
-		lib_ver = NULL;
-	}
-
-	/* Search SHT_DYNSYM, SHT_SYMTAB for symbol. This search order is used because if
-	 * a binary is stripped, it may only have SHT_DYNSYM, and a fully-statically
-	 * linked binary may not have SHT_DYMSYM, so absence of a section should not be
-	 * reported as a warning/error.
-	 */
-	for (i = 0; i < ARRAY_SIZE(sh_types); i++) {
-		struct elf_sym_iter iter;
-		struct elf_sym *sym;
-		int last_bind = -1;
-		int cur_bind;
-
-		ret = elf_sym_iter_new(&iter, elf, binary_path, sh_types[i], STT_FUNC);
-		if (ret == -ENOENT)
-			continue;
-		if (ret)
-			goto out;
-
-		while ((sym = elf_sym_iter_next(&iter))) {
-			if (!symbol_match(&iter, sh_types[i], sym, name, name_len, lib_ver))
-				continue;
-
-			cur_bind = GELF_ST_BIND(sym->sym.st_info);
-
-			if (ret > 0) {
-				/* handle multiple matches */
-				if (elf_sym_offset(sym) == ret) {
-					/* same offset, no problem */
-					continue;
-				} else if (last_bind != STB_WEAK && cur_bind != STB_WEAK) {
-					/* Only accept one non-weak bind. */
-					pr_warn("elf: ambiguous match for '%s', '%s' in '%s'\n",
-						sym->name, name, binary_path);
-					ret = -LIBBPF_ERRNO__FORMAT;
-					goto out;
-				} else if (cur_bind == STB_WEAK) {
-					/* already have a non-weak bind, and
-					 * this is a weak bind, so ignore.
-					 */
-					continue;
-				}
-			}
-
-			ret = elf_sym_offset(sym);
-			last_bind = cur_bind;
-		}
-		if (ret > 0)
-			break;
-	}
-
-	if (ret > 0) {
-		pr_debug("elf: symbol address match for '%s' in '%s': 0x%lx\n", name, binary_path,
-			 ret);
-	} else {
-		if (ret == 0) {
-			pr_warn("elf: '%s' is 0 in symtab for '%s': %s\n", name, binary_path,
-				is_shared_lib ? "should not be 0 in a shared library" :
-						"try using shared library path instead");
-			ret = -ENOENT;
-		} else {
-			pr_warn("elf: failed to find symbol '%s' in '%s'\n", name, binary_path);
-		}
-	}
-out:
-	return ret;
-}
-
-/* Find offset of function name in ELF object specified by path. "name" matches
- * symbol name or name@@LIB for library functions.
- */
-long elf_find_func_offset_from_file(const char *binary_path, const char *name)
-{
-	struct elf_fd elf_fd;
-	long ret = -ENOENT;
-
-	ret = elf_open(binary_path, &elf_fd);
-	if (ret)
-		return ret;
-	ret = elf_find_func_offset(elf_fd.elf, binary_path, name);
-	elf_close(&elf_fd);
-	return ret;
-}
-
-struct symbol {
-	const char *name;
-	int bind;
-	int idx;
-};
-
-static int symbol_cmp(const void *a, const void *b)
-{
-	const struct symbol *sym_a = a;
-	const struct symbol *sym_b = b;
-
-	return strcmp(sym_a->name, sym_b->name);
-}
-
-/*
- * Return offsets in @poffsets for symbols specified in @syms array argument.
- * On success returns 0 and offsets are returned in allocated array with @cnt
- * size, that needs to be released by the caller.
- */
-int elf_resolve_syms_offsets(const char *binary_path, int cnt,
-			     const char **syms, unsigned long **poffsets,
-			     int st_type)
-{
-	int sh_types[2] = { SHT_DYNSYM, SHT_SYMTAB };
-	int err = 0, i, cnt_done = 0;
-	unsigned long *offsets;
-	struct symbol *symbols;
-	struct elf_fd elf_fd;
-
-	err = elf_open(binary_path, &elf_fd);
-	if (err)
-		return err;
-
-	offsets = calloc(cnt, sizeof(*offsets));
-	symbols = calloc(cnt, sizeof(*symbols));
-
-	if (!offsets || !symbols) {
-		err = -ENOMEM;
-		goto out;
-	}
-
-	for (i = 0; i < cnt; i++) {
-		symbols[i].name = syms[i];
-		symbols[i].idx = i;
-	}
-
-	qsort(symbols, cnt, sizeof(*symbols), symbol_cmp);
-
-	for (i = 0; i < ARRAY_SIZE(sh_types); i++) {
-		struct elf_sym_iter iter;
-		struct elf_sym *sym;
-
-		err = elf_sym_iter_new(&iter, elf_fd.elf, binary_path, sh_types[i], st_type);
-		if (err == -ENOENT)
-			continue;
-		if (err)
-			goto out;
-
-		while ((sym = elf_sym_iter_next(&iter))) {
-			unsigned long sym_offset = elf_sym_offset(sym);
-			int bind = GELF_ST_BIND(sym->sym.st_info);
-			struct symbol *found, tmp = {
-				.name = sym->name,
-			};
-			unsigned long *offset;
-
-			found = bsearch(&tmp, symbols, cnt, sizeof(*symbols), symbol_cmp);
-			if (!found)
-				continue;
-
-			offset = &offsets[found->idx];
-			if (*offset > 0) {
-				/* same offset, no problem */
-				if (*offset == sym_offset)
-					continue;
-				/* handle multiple matches */
-				if (found->bind != STB_WEAK && bind != STB_WEAK) {
-					/* Only accept one non-weak bind. */
-					pr_warn("elf: ambiguous match found '%s@%lu' in '%s' previous offset %lu\n",
-						sym->name, sym_offset, binary_path, *offset);
-					err = -ESRCH;
-					goto out;
-				} else if (bind == STB_WEAK) {
-					/* already have a non-weak bind, and
-					 * this is a weak bind, so ignore.
-					 */
-					continue;
-				}
-			} else {
-				cnt_done++;
-			}
-			*offset = sym_offset;
-			found->bind = bind;
-		}
-	}
-
-	if (cnt != cnt_done) {
-		err = -ENOENT;
-		goto out;
-	}
-
-	*poffsets = offsets;
-
-out:
-	free(symbols);
-	if (err)
-		free(offsets);
-	elf_close(&elf_fd);
-	return err;
-}
-
-/*
- * Return offsets in @poffsets for symbols specified by @pattern argument.
- * On success returns 0 and offsets are returned in allocated @poffsets
- * array with the @pctn size, that needs to be released by the caller.
- */
-int elf_resolve_pattern_offsets(const char *binary_path, const char *pattern,
-				unsigned long **poffsets, size_t *pcnt)
-{
-	int sh_types[2] = { SHT_SYMTAB, SHT_DYNSYM };
-	unsigned long *offsets = NULL;
-	size_t cap = 0, cnt = 0;
-	struct elf_fd elf_fd;
-	int err = 0, i;
-
-	err = elf_open(binary_path, &elf_fd);
-	if (err)
-		return err;
-
-	for (i = 0; i < ARRAY_SIZE(sh_types); i++) {
-		struct elf_sym_iter iter;
-		struct elf_sym *sym;
-
-		err = elf_sym_iter_new(&iter, elf_fd.elf, binary_path, sh_types[i], STT_FUNC);
-		if (err == -ENOENT)
-			continue;
-		if (err)
-			goto out;
-
-		while ((sym = elf_sym_iter_next(&iter))) {
-			if (!glob_match(sym->name, pattern))
-				continue;
-
-			err = libbpf_ensure_mem((void **) &offsets, &cap, sizeof(*offsets),
-						cnt + 1);
-			if (err)
-				goto out;
-
-			offsets[cnt++] = elf_sym_offset(sym);
-		}
-
-		/* If we found anything in the first symbol section,
-		 * do not search others to avoid duplicates.
-		 */
-		if (cnt)
-			break;
-	}
-
-	if (cnt) {
-		*poffsets = offsets;
-		*pcnt = cnt;
-	} else {
-		err = -ENOENT;
-	}
-
-out:
-	if (err)
-		free(offsets);
-	elf_close(&elf_fd);
-	return err;
-}
diff -Nrup linux-6.16.7/tools/lib/bpf/Makefile linux-lenovo-x13s-linux-6.16.y/tools/lib/bpf/Makefile
--- linux-6.16.7/tools/lib/bpf/Makefile	2025-09-13 16:15:46.052018566 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/lib/bpf/Makefile	2025-09-11 09:47:42.000000000 -0600
@@ -77,15 +77,10 @@ else
   CFLAGS := -g -O2
 endif
 
-# Treat warnings as errors unless directed not to
-ifneq ($(WERROR),0)
-  CFLAGS += -Werror
-endif
-
 # Append required CFLAGS
 override CFLAGS += -std=gnu89
 override CFLAGS += $(EXTRA_WARNINGS) -Wno-switch-enum
-override CFLAGS += -Wall
+override CFLAGS += -Werror -Wall
 override CFLAGS += $(INCLUDES)
 override CFLAGS += -fvisibility=hidden
 override CFLAGS += -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64
diff -Nrup linux-6.16.7/tools/perf/arch/arm64/entry/syscalls/syscall_64.tbl linux-lenovo-x13s-linux-6.16.y/tools/perf/arch/arm64/entry/syscalls/syscall_64.tbl
--- linux-6.16.7/tools/perf/arch/arm64/entry/syscalls/syscall_64.tbl	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/arch/arm64/entry/syscalls/syscall_64.tbl	2025-09-11 09:47:42.000000000 -0600
@@ -1,410 +1 @@
-# SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note
-#
-# This file contains the system call numbers for all of the
-# more recently added architectures.
-#
-# As a basic principle, no duplication of functionality
-# should be added, e.g. we don't use lseek when llseek
-# is present. New architectures should use this file
-# and implement the less feature-full calls in user space.
-#
-0	common	io_setup			sys_io_setup			compat_sys_io_setup
-1	common	io_destroy			sys_io_destroy
-2	common	io_submit			sys_io_submit			compat_sys_io_submit
-3	common	io_cancel			sys_io_cancel
-4	time32	io_getevents			sys_io_getevents_time32
-4	64	io_getevents			sys_io_getevents
-5	common	setxattr			sys_setxattr
-6	common	lsetxattr			sys_lsetxattr
-7	common	fsetxattr			sys_fsetxattr
-8	common	getxattr			sys_getxattr
-9	common	lgetxattr			sys_lgetxattr
-10	common	fgetxattr			sys_fgetxattr
-11	common	listxattr			sys_listxattr
-12	common	llistxattr			sys_llistxattr
-13	common	flistxattr			sys_flistxattr
-14	common	removexattr			sys_removexattr
-15	common	lremovexattr			sys_lremovexattr
-16	common	fremovexattr			sys_fremovexattr
-17	common	getcwd				sys_getcwd
-18	common	lookup_dcookie			sys_ni_syscall
-19	common	eventfd2			sys_eventfd2
-20	common	epoll_create1			sys_epoll_create1
-21	common	epoll_ctl			sys_epoll_ctl
-22	common	epoll_pwait			sys_epoll_pwait			compat_sys_epoll_pwait
-23	common	dup				sys_dup
-24	common	dup3				sys_dup3
-25	32	fcntl64				sys_fcntl64			compat_sys_fcntl64
-25	64	fcntl				sys_fcntl
-26	common	inotify_init1			sys_inotify_init1
-27	common	inotify_add_watch		sys_inotify_add_watch
-28	common	inotify_rm_watch		sys_inotify_rm_watch
-29	common	ioctl				sys_ioctl			compat_sys_ioctl
-30	common	ioprio_set			sys_ioprio_set
-31	common	ioprio_get			sys_ioprio_get
-32	common	flock				sys_flock
-33	common	mknodat				sys_mknodat
-34	common	mkdirat				sys_mkdirat
-35	common	unlinkat			sys_unlinkat
-36	common	symlinkat			sys_symlinkat
-37	common	linkat				sys_linkat
-# renameat is superseded with flags by renameat2
-38	renameat renameat			sys_renameat
-39	common	umount2				sys_umount
-40	common	mount				sys_mount
-41	common	pivot_root			sys_pivot_root
-42	common	nfsservctl			sys_ni_syscall
-43	32	statfs64			sys_statfs64			compat_sys_statfs64
-43	64	statfs				sys_statfs
-44	32	fstatfs64			sys_fstatfs64			compat_sys_fstatfs64
-44	64	fstatfs				sys_fstatfs
-45	32	truncate64			sys_truncate64			compat_sys_truncate64
-45	64	truncate			sys_truncate
-46	32	ftruncate64			sys_ftruncate64			compat_sys_ftruncate64
-46	64	ftruncate			sys_ftruncate
-47	common	fallocate			sys_fallocate			compat_sys_fallocate
-48	common	faccessat			sys_faccessat
-49	common	chdir				sys_chdir
-50	common	fchdir				sys_fchdir
-51	common	chroot				sys_chroot
-52	common	fchmod				sys_fchmod
-53	common	fchmodat			sys_fchmodat
-54	common	fchownat			sys_fchownat
-55	common	fchown				sys_fchown
-56	common	openat				sys_openat
-57	common	close				sys_close
-58	common	vhangup				sys_vhangup
-59	common	pipe2				sys_pipe2
-60	common	quotactl			sys_quotactl
-61	common	getdents64			sys_getdents64
-62	32	llseek				sys_llseek
-62	64	lseek				sys_lseek
-63	common	read				sys_read
-64	common	write				sys_write
-65	common	readv				sys_readv			sys_readv
-66	common	writev				sys_writev			sys_writev
-67	common	pread64				sys_pread64			compat_sys_pread64
-68	common	pwrite64			sys_pwrite64			compat_sys_pwrite64
-69	common	preadv				sys_preadv			compat_sys_preadv
-70	common	pwritev				sys_pwritev			compat_sys_pwritev
-71	32	sendfile64			sys_sendfile64
-71	64	sendfile			sys_sendfile64
-72	time32	pselect6			sys_pselect6_time32		compat_sys_pselect6_time32
-72	64	pselect6			sys_pselect6
-73	time32	ppoll				sys_ppoll_time32		compat_sys_ppoll_time32
-73	64	ppoll				sys_ppoll
-74	common	signalfd4			sys_signalfd4			compat_sys_signalfd4
-75	common	vmsplice			sys_vmsplice
-76	common	splice				sys_splice
-77	common	tee				sys_tee
-78	common	readlinkat			sys_readlinkat
-79	stat64	fstatat64			sys_fstatat64
-79	64	newfstatat			sys_newfstatat
-80	stat64	fstat64				sys_fstat64
-80	64	fstat				sys_newfstat
-81	common	sync				sys_sync
-82	common	fsync				sys_fsync
-83	common	fdatasync			sys_fdatasync
-84	common	sync_file_range			sys_sync_file_range		compat_sys_sync_file_range
-85	common	timerfd_create			sys_timerfd_create
-86	time32	timerfd_settime			sys_timerfd_settime32
-86	64	timerfd_settime			sys_timerfd_settime
-87	time32	timerfd_gettime			sys_timerfd_gettime32
-87	64	timerfd_gettime			sys_timerfd_gettime
-88	time32	utimensat			sys_utimensat_time32
-88	64	utimensat			sys_utimensat
-89	common	acct				sys_acct
-90	common	capget				sys_capget
-91	common	capset				sys_capset
-92	common	personality			sys_personality
-93	common	exit				sys_exit
-94	common	exit_group			sys_exit_group
-95	common	waitid				sys_waitid			compat_sys_waitid
-96	common	set_tid_address			sys_set_tid_address
-97	common	unshare				sys_unshare
-98	time32	futex				sys_futex_time32
-98	64	futex				sys_futex
-99	common	set_robust_list			sys_set_robust_list		compat_sys_set_robust_list
-100	common	get_robust_list			sys_get_robust_list		compat_sys_get_robust_list
-101	time32	nanosleep			sys_nanosleep_time32
-101	64	nanosleep			sys_nanosleep
-102	common	getitimer			sys_getitimer			compat_sys_getitimer
-103	common	setitimer			sys_setitimer			compat_sys_setitimer
-104	common	kexec_load			sys_kexec_load			compat_sys_kexec_load
-105	common	init_module			sys_init_module
-106	common	delete_module			sys_delete_module
-107	common	timer_create			sys_timer_create		compat_sys_timer_create
-108	time32	timer_gettime			sys_timer_gettime32
-108	64	timer_gettime			sys_timer_gettime
-109	common	timer_getoverrun		sys_timer_getoverrun
-110	time32	timer_settime			sys_timer_settime32
-110	64	timer_settime			sys_timer_settime
-111	common	timer_delete			sys_timer_delete
-112	time32	clock_settime			sys_clock_settime32
-112	64	clock_settime			sys_clock_settime
-113	time32	clock_gettime			sys_clock_gettime32
-113	64	clock_gettime			sys_clock_gettime
-114	time32	clock_getres			sys_clock_getres_time32
-114	64	clock_getres			sys_clock_getres
-115	time32	clock_nanosleep			sys_clock_nanosleep_time32
-115	64	clock_nanosleep			sys_clock_nanosleep
-116	common	syslog				sys_syslog
-117	common	ptrace				sys_ptrace			compat_sys_ptrace
-118	common	sched_setparam			sys_sched_setparam
-119	common	sched_setscheduler		sys_sched_setscheduler
-120	common	sched_getscheduler		sys_sched_getscheduler
-121	common	sched_getparam			sys_sched_getparam
-122	common	sched_setaffinity		sys_sched_setaffinity		compat_sys_sched_setaffinity
-123	common	sched_getaffinity		sys_sched_getaffinity		compat_sys_sched_getaffinity
-124	common	sched_yield			sys_sched_yield
-125	common	sched_get_priority_max		sys_sched_get_priority_max
-126	common	sched_get_priority_min		sys_sched_get_priority_min
-127	time32	sched_rr_get_interval		sys_sched_rr_get_interval_time32
-127	64	sched_rr_get_interval		sys_sched_rr_get_interval
-128	common	restart_syscall			sys_restart_syscall
-129	common	kill				sys_kill
-130	common	tkill				sys_tkill
-131	common	tgkill				sys_tgkill
-132	common	sigaltstack			sys_sigaltstack			compat_sys_sigaltstack
-133	common	rt_sigsuspend			sys_rt_sigsuspend		compat_sys_rt_sigsuspend
-134	common	rt_sigaction			sys_rt_sigaction		compat_sys_rt_sigaction
-135	common	rt_sigprocmask			sys_rt_sigprocmask		compat_sys_rt_sigprocmask
-136	common	rt_sigpending			sys_rt_sigpending		compat_sys_rt_sigpending
-137	time32	rt_sigtimedwait			sys_rt_sigtimedwait_time32	compat_sys_rt_sigtimedwait_time32
-137	64	rt_sigtimedwait			sys_rt_sigtimedwait
-138	common	rt_sigqueueinfo			sys_rt_sigqueueinfo		compat_sys_rt_sigqueueinfo
-139	common	rt_sigreturn			sys_rt_sigreturn		compat_sys_rt_sigreturn
-140	common	setpriority			sys_setpriority
-141	common	getpriority			sys_getpriority
-142	common	reboot				sys_reboot
-143	common	setregid			sys_setregid
-144	common	setgid				sys_setgid
-145	common	setreuid			sys_setreuid
-146	common	setuid				sys_setuid
-147	common	setresuid			sys_setresuid
-148	common	getresuid			sys_getresuid
-149	common	setresgid			sys_setresgid
-150	common	getresgid			sys_getresgid
-151	common	setfsuid			sys_setfsuid
-152	common	setfsgid			sys_setfsgid
-153	common	times				sys_times			compat_sys_times
-154	common	setpgid				sys_setpgid
-155	common	getpgid				sys_getpgid
-156	common	getsid				sys_getsid
-157	common	setsid				sys_setsid
-158	common	getgroups			sys_getgroups
-159	common	setgroups			sys_setgroups
-160	common	uname				sys_newuname
-161	common	sethostname			sys_sethostname
-162	common	setdomainname			sys_setdomainname
-# getrlimit and setrlimit are superseded with prlimit64
-163	rlimit	getrlimit			sys_getrlimit			compat_sys_getrlimit
-164	rlimit	setrlimit			sys_setrlimit			compat_sys_setrlimit
-165	common	getrusage			sys_getrusage			compat_sys_getrusage
-166	common	umask				sys_umask
-167	common	prctl				sys_prctl
-168	common	getcpu				sys_getcpu
-169	time32	gettimeofday			sys_gettimeofday		compat_sys_gettimeofday
-169	64	gettimeofday			sys_gettimeofday
-170	time32	settimeofday			sys_settimeofday		compat_sys_settimeofday
-170	64	settimeofday			sys_settimeofday
-171	time32	adjtimex			sys_adjtimex_time32
-171	64	adjtimex			sys_adjtimex
-172	common	getpid				sys_getpid
-173	common	getppid				sys_getppid
-174	common	getuid				sys_getuid
-175	common	geteuid				sys_geteuid
-176	common	getgid				sys_getgid
-177	common	getegid				sys_getegid
-178	common	gettid				sys_gettid
-179	common	sysinfo				sys_sysinfo			compat_sys_sysinfo
-180	common	mq_open				sys_mq_open			compat_sys_mq_open
-181	common	mq_unlink			sys_mq_unlink
-182	time32	mq_timedsend			sys_mq_timedsend_time32
-182	64	mq_timedsend			sys_mq_timedsend
-183	time32	mq_timedreceive			sys_mq_timedreceive_time32
-183	64	mq_timedreceive			sys_mq_timedreceive
-184	common	mq_notify			sys_mq_notify			compat_sys_mq_notify
-185	common	mq_getsetattr			sys_mq_getsetattr		compat_sys_mq_getsetattr
-186	common	msgget				sys_msgget
-187	common	msgctl				sys_msgctl			compat_sys_msgctl
-188	common	msgrcv				sys_msgrcv			compat_sys_msgrcv
-189	common	msgsnd				sys_msgsnd			compat_sys_msgsnd
-190	common	semget				sys_semget
-191	common	semctl				sys_semctl			compat_sys_semctl
-192	time32	semtimedop			sys_semtimedop_time32
-192	64	semtimedop			sys_semtimedop
-193	common	semop				sys_semop
-194	common	shmget				sys_shmget
-195	common	shmctl				sys_shmctl			compat_sys_shmctl
-196	common	shmat				sys_shmat			compat_sys_shmat
-197	common	shmdt				sys_shmdt
-198	common	socket				sys_socket
-199	common	socketpair			sys_socketpair
-200	common	bind				sys_bind
-201	common	listen				sys_listen
-202	common	accept				sys_accept
-203	common	connect				sys_connect
-204	common	getsockname			sys_getsockname
-205	common	getpeername			sys_getpeername
-206	common	sendto				sys_sendto
-207	common	recvfrom			sys_recvfrom			compat_sys_recvfrom
-208	common	setsockopt			sys_setsockopt			sys_setsockopt
-209	common	getsockopt			sys_getsockopt			sys_getsockopt
-210	common	shutdown			sys_shutdown
-211	common	sendmsg				sys_sendmsg			compat_sys_sendmsg
-212	common	recvmsg				sys_recvmsg			compat_sys_recvmsg
-213	common	readahead			sys_readahead			compat_sys_readahead
-214	common	brk				sys_brk
-215	common	munmap				sys_munmap
-216	common	mremap				sys_mremap
-217	common	add_key				sys_add_key
-218	common	request_key			sys_request_key
-219	common	keyctl				sys_keyctl			compat_sys_keyctl
-220	common	clone				sys_clone
-221	common	execve				sys_execve			compat_sys_execve
-222	32	mmap2				sys_mmap2
-222	64	mmap				sys_mmap
-223	32	fadvise64_64			sys_fadvise64_64		compat_sys_fadvise64_64
-223	64	fadvise64			sys_fadvise64_64
-224	common	swapon				sys_swapon
-225	common	swapoff				sys_swapoff
-226	common	mprotect			sys_mprotect
-227	common	msync				sys_msync
-228	common	mlock				sys_mlock
-229	common	munlock				sys_munlock
-230	common	mlockall			sys_mlockall
-231	common	munlockall			sys_munlockall
-232	common	mincore				sys_mincore
-233	common	madvise				sys_madvise
-234	common	remap_file_pages		sys_remap_file_pages
-235	common	mbind				sys_mbind
-236	common	get_mempolicy			sys_get_mempolicy
-237	common	set_mempolicy			sys_set_mempolicy
-238	common	migrate_pages			sys_migrate_pages
-239	common	move_pages			sys_move_pages
-240	common	rt_tgsigqueueinfo		sys_rt_tgsigqueueinfo		compat_sys_rt_tgsigqueueinfo
-241	common	perf_event_open			sys_perf_event_open
-242	common	accept4				sys_accept4
-243	time32	recvmmsg			sys_recvmmsg_time32		compat_sys_recvmmsg_time32
-243	64	recvmmsg			sys_recvmmsg
-# Architectures may provide up to 16 syscalls of their own between 244 and 259
-244	arc	cacheflush			sys_cacheflush
-245	arc	arc_settls			sys_arc_settls
-246	arc	arc_gettls			sys_arc_gettls
-247	arc	sysfs				sys_sysfs
-248	arc	arc_usr_cmpxchg			sys_arc_usr_cmpxchg
-
-244	csky	set_thread_area			sys_set_thread_area
-245	csky	cacheflush			sys_cacheflush
-
-244	nios2	cacheflush			sys_cacheflush
-
-244	or1k	or1k_atomic			sys_or1k_atomic
-
-258	riscv	riscv_hwprobe			sys_riscv_hwprobe
-259	riscv	riscv_flush_icache		sys_riscv_flush_icache
-
-260	time32	wait4				sys_wait4			compat_sys_wait4
-260	64	wait4				sys_wait4
-261	common	prlimit64			sys_prlimit64
-262	common	fanotify_init			sys_fanotify_init
-263	common	fanotify_mark			sys_fanotify_mark
-264	common	name_to_handle_at		sys_name_to_handle_at
-265	common	open_by_handle_at		sys_open_by_handle_at
-266	time32	clock_adjtime			sys_clock_adjtime32
-266	64	clock_adjtime			sys_clock_adjtime
-267	common	syncfs				sys_syncfs
-268	common	setns				sys_setns
-269	common	sendmmsg			sys_sendmmsg			compat_sys_sendmmsg
-270	common	process_vm_readv		sys_process_vm_readv
-271	common	process_vm_writev		sys_process_vm_writev
-272	common	kcmp				sys_kcmp
-273	common	finit_module			sys_finit_module
-274	common	sched_setattr			sys_sched_setattr
-275	common	sched_getattr			sys_sched_getattr
-276	common	renameat2			sys_renameat2
-277	common	seccomp				sys_seccomp
-278	common	getrandom			sys_getrandom
-279	common	memfd_create			sys_memfd_create
-280	common	bpf				sys_bpf
-281	common	execveat			sys_execveat			compat_sys_execveat
-282	common	userfaultfd			sys_userfaultfd
-283	common	membarrier			sys_membarrier
-284	common	mlock2				sys_mlock2
-285	common	copy_file_range			sys_copy_file_range
-286	common	preadv2				sys_preadv2			compat_sys_preadv2
-287	common	pwritev2			sys_pwritev2			compat_sys_pwritev2
-288	common	pkey_mprotect			sys_pkey_mprotect
-289	common	pkey_alloc			sys_pkey_alloc
-290	common	pkey_free			sys_pkey_free
-291	common	statx				sys_statx
-292	time32	io_pgetevents			sys_io_pgetevents_time32	compat_sys_io_pgetevents
-292	64	io_pgetevents			sys_io_pgetevents
-293	common	rseq				sys_rseq
-294	common	kexec_file_load			sys_kexec_file_load
-# 295 through 402 are unassigned to sync up with generic numbers don't use
-403	32	clock_gettime64			sys_clock_gettime
-404	32	clock_settime64			sys_clock_settime
-405	32	clock_adjtime64			sys_clock_adjtime
-406	32	clock_getres_time64		sys_clock_getres
-407	32	clock_nanosleep_time64		sys_clock_nanosleep
-408	32	timer_gettime64			sys_timer_gettime
-409	32	timer_settime64			sys_timer_settime
-410	32	timerfd_gettime64		sys_timerfd_gettime
-411	32	timerfd_settime64		sys_timerfd_settime
-412	32	utimensat_time64		sys_utimensat
-413	32	pselect6_time64			sys_pselect6			compat_sys_pselect6_time64
-414	32	ppoll_time64			sys_ppoll			compat_sys_ppoll_time64
-416	32	io_pgetevents_time64		sys_io_pgetevents		compat_sys_io_pgetevents_time64
-417	32	recvmmsg_time64			sys_recvmmsg			compat_sys_recvmmsg_time64
-418	32	mq_timedsend_time64		sys_mq_timedsend
-419	32	mq_timedreceive_time64		sys_mq_timedreceive
-420	32	semtimedop_time64		sys_semtimedop
-421	32	rt_sigtimedwait_time64		sys_rt_sigtimedwait		compat_sys_rt_sigtimedwait_time64
-422	32	futex_time64			sys_futex
-423	32	sched_rr_get_interval_time64	sys_sched_rr_get_interval
-424	common	pidfd_send_signal		sys_pidfd_send_signal
-425	common	io_uring_setup			sys_io_uring_setup
-426	common	io_uring_enter			sys_io_uring_enter
-427	common	io_uring_register		sys_io_uring_register
-428	common	open_tree			sys_open_tree
-429	common	move_mount			sys_move_mount
-430	common	fsopen				sys_fsopen
-431	common	fsconfig			sys_fsconfig
-432	common	fsmount				sys_fsmount
-433	common	fspick				sys_fspick
-434	common	pidfd_open			sys_pidfd_open
-435	common	clone3				sys_clone3
-436	common	close_range			sys_close_range
-437	common	openat2				sys_openat2
-438	common	pidfd_getfd			sys_pidfd_getfd
-439	common	faccessat2			sys_faccessat2
-440	common	process_madvise			sys_process_madvise
-441	common	epoll_pwait2			sys_epoll_pwait2		compat_sys_epoll_pwait2
-442	common	mount_setattr			sys_mount_setattr
-443	common	quotactl_fd			sys_quotactl_fd
-444	common	landlock_create_ruleset		sys_landlock_create_ruleset
-445	common	landlock_add_rule		sys_landlock_add_rule
-446	common	landlock_restrict_self		sys_landlock_restrict_self
-447	memfd_secret	memfd_secret		sys_memfd_secret
-448	common	process_mrelease		sys_process_mrelease
-449	common	futex_waitv			sys_futex_waitv
-450	common	set_mempolicy_home_node		sys_set_mempolicy_home_node
-451	common	cachestat			sys_cachestat
-452	common	fchmodat2			sys_fchmodat2
-453	common	map_shadow_stack		sys_map_shadow_stack
-454	common	futex_wake			sys_futex_wake
-455	common	futex_wait			sys_futex_wait
-456	common	futex_requeue			sys_futex_requeue
-457	common	statmount			sys_statmount
-458	common	listmount			sys_listmount
-459	common	lsm_get_self_attr		sys_lsm_get_self_attr
-460	common	lsm_set_self_attr		sys_lsm_set_self_attr
-461	common	lsm_list_modules		sys_lsm_list_modules
-462	common	mseal				sys_mseal
-463	common	setxattrat			sys_setxattrat
-464	common	getxattrat			sys_getxattrat
-465	common	listxattrat			sys_listxattrat
-466	common	removexattrat			sys_removexattrat
-467	common	open_tree_attr			sys_open_tree_attr
+../../../../../scripts/syscall.tbl
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/bullet-07/firmware.json linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-07/firmware.json
--- linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/bullet-07/firmware.json	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-07/firmware.json	2025-09-11 09:47:42.000000000 -0600
@@ -1,68 +1 @@
-[
-  {
-    "ArchStdEvent": "FW_MISALIGNED_LOAD"
-  },
-  {
-    "ArchStdEvent": "FW_MISALIGNED_STORE"
-  },
-  {
-    "ArchStdEvent": "FW_ACCESS_LOAD"
-  },
-  {
-    "ArchStdEvent": "FW_ACCESS_STORE"
-  },
-  {
-    "ArchStdEvent": "FW_ILLEGAL_INSN"
-  },
-  {
-    "ArchStdEvent": "FW_SET_TIMER"
-  },
-  {
-    "ArchStdEvent": "FW_IPI_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_IPI_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_FENCE_I_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_FENCE_I_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_ASID_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_ASID_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_VMID_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_VMID_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_ASID_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_ASID_RECEIVED"
-  }
-]
+../bullet/firmware.json
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/bullet-07/instruction.json linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-07/instruction.json
--- linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/bullet-07/instruction.json	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-07/instruction.json	2025-09-11 09:47:42.000000000 -0600
@@ -1,92 +1 @@
-[
-  {
-    "EventName": "EXCEPTION_TAKEN",
-    "EventCode": "0x100",
-    "BriefDescription": "Counts exceptions taken"
-  },
-  {
-    "EventName": "INTEGER_LOAD_RETIRED",
-    "EventCode": "0x200",
-    "BriefDescription": "Counts integer load instructions retired"
-  },
-  {
-    "EventName": "INTEGER_STORE_RETIRED",
-    "EventCode": "0x400",
-    "BriefDescription": "Counts integer store instructions retired"
-  },
-  {
-    "EventName": "ATOMIC_MEMORY_RETIRED",
-    "EventCode": "0x800",
-    "BriefDescription": "Counts atomic memory instructions retired"
-  },
-  {
-    "EventName": "SYSTEM_INSTRUCTION_RETIRED",
-    "EventCode": "0x1000",
-    "BriefDescription": "Counts system instructions retired (CSR, WFI, MRET, etc.)"
-  },
-  {
-    "EventName": "INTEGER_ARITHMETIC_RETIRED",
-    "EventCode": "0x2000",
-    "BriefDescription": "Counts integer arithmetic instructions retired"
-  },
-  {
-    "EventName": "CONDITIONAL_BRANCH_RETIRED",
-    "EventCode": "0x4000",
-    "BriefDescription": "Counts conditional branch instructions retired"
-  },
-  {
-    "EventName": "JAL_INSTRUCTION_RETIRED",
-    "EventCode": "0x8000",
-    "BriefDescription": "Counts jump-and-link instructions retired"
-  },
-  {
-    "EventName": "JALR_INSTRUCTION_RETIRED",
-    "EventCode": "0x10000",
-    "BriefDescription": "Counts indirect jump instructions (JALR) retired"
-  },
-  {
-    "EventName": "INTEGER_MULTIPLICATION_RETIRED",
-    "EventCode": "0x20000",
-    "BriefDescription": "Counts integer multiplication instructions retired"
-  },
-  {
-    "EventName": "INTEGER_DIVISION_RETIRED",
-    "EventCode": "0x40000",
-    "BriefDescription": "Counts integer division instructions retired"
-  },
-  {
-    "EventName": "FP_LOAD_RETIRED",
-    "EventCode": "0x80000",
-    "BriefDescription": "Counts floating-point load instructions retired"
-  },
-  {
-    "EventName": "FP_STORE_RETIRED",
-    "EventCode": "0x100000",
-    "BriefDescription": "Counts floating-point store instructions retired"
-  },
-  {
-    "EventName": "FP_ADD_RETIRED",
-    "EventCode": "0x200000",
-    "BriefDescription": "Counts floating-point add instructions retired"
-  },
-  {
-    "EventName": "FP_MUL_RETIRED",
-    "EventCode": "0x400000",
-    "BriefDescription": "Counts floating-point multiply instructions retired"
-  },
-  {
-    "EventName": "FP_MULADD_RETIRED",
-    "EventCode": "0x800000",
-    "BriefDescription": "Counts floating-point fused multiply-add instructions retired"
-  },
-  {
-    "EventName": "FP_DIV_SQRT_RETIRED",
-    "EventCode": "0x1000000",
-    "BriefDescription": "Counts floating point divide or square root instructions retired"
-  },
-  {
-    "EventName": "OTHER_FP_RETIRED",
-    "EventCode": "0x2000000",
-    "BriefDescription": "Counts other floating-point instructions retired"
-  }
-]
+../bullet/instruction.json
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/bullet-07/memory.json linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-07/memory.json
--- linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/bullet-07/memory.json	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-07/memory.json	2025-09-11 09:47:42.000000000 -0600
@@ -1,32 +1 @@
-[
-  {
-    "EventName": "ICACHE_MISS",
-    "EventCode": "0x102",
-    "BriefDescription": "Counts instruction cache misses"
-  },
-  {
-    "EventName": "DCACHE_MISS",
-    "EventCode": "0x202",
-    "BriefDescription": "Counts data cache misses"
-  },
-  {
-    "EventName": "DCACHE_RELEASE",
-    "EventCode": "0x402",
-    "BriefDescription": "Counts writeback requests from the data cache"
-  },
-  {
-    "EventName": "ITLB_MISS",
-    "EventCode": "0x802",
-    "BriefDescription": "Counts Instruction TLB misses caused by instruction address translation requests"
-  },
-  {
-    "EventName": "DTLB_MISS",
-    "EventCode": "0x1002",
-    "BriefDescription": "Counts Data TLB misses caused by data address translation requests"
-  },
-  {
-    "EventName": "UTLB_MISS",
-    "EventCode": "0x2002",
-    "BriefDescription": "Counts Unified TLB misses caused by address translation requests"
-  }
-]
+../bullet/memory.json
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/cycle-and-instruction-count.json linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/cycle-and-instruction-count.json
--- linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/cycle-and-instruction-count.json	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/cycle-and-instruction-count.json	2025-09-11 09:47:42.000000000 -0600
@@ -1,12 +1 @@
-[
-  {
-    "EventName": "CORE_CLOCK_CYCLES",
-    "EventCode": "0x165",
-    "BriefDescription": "Counts core clock cycles"
-  },
-  {
-    "EventName": "INSTRUCTIONS_RETIRED",
-    "EventCode": "0x265",
-    "BriefDescription": "Counts instructions retired"
-  }
-]
+../bullet-07/cycle-and-instruction-count.json
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/firmware.json linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/firmware.json
--- linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/firmware.json	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/firmware.json	2025-09-11 09:47:42.000000000 -0600
@@ -1,68 +1 @@
-[
-  {
-    "ArchStdEvent": "FW_MISALIGNED_LOAD"
-  },
-  {
-    "ArchStdEvent": "FW_MISALIGNED_STORE"
-  },
-  {
-    "ArchStdEvent": "FW_ACCESS_LOAD"
-  },
-  {
-    "ArchStdEvent": "FW_ACCESS_STORE"
-  },
-  {
-    "ArchStdEvent": "FW_ILLEGAL_INSN"
-  },
-  {
-    "ArchStdEvent": "FW_SET_TIMER"
-  },
-  {
-    "ArchStdEvent": "FW_IPI_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_IPI_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_FENCE_I_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_FENCE_I_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_ASID_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_ASID_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_VMID_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_VMID_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_ASID_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_ASID_RECEIVED"
-  }
-]
+../bullet/firmware.json
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/instruction.json linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/instruction.json
--- linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/instruction.json	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/instruction.json	2025-09-11 09:47:42.000000000 -0600
@@ -1,92 +1 @@
-[
-  {
-    "EventName": "EXCEPTION_TAKEN",
-    "EventCode": "0x100",
-    "BriefDescription": "Counts exceptions taken"
-  },
-  {
-    "EventName": "INTEGER_LOAD_RETIRED",
-    "EventCode": "0x200",
-    "BriefDescription": "Counts integer load instructions retired"
-  },
-  {
-    "EventName": "INTEGER_STORE_RETIRED",
-    "EventCode": "0x400",
-    "BriefDescription": "Counts integer store instructions retired"
-  },
-  {
-    "EventName": "ATOMIC_MEMORY_RETIRED",
-    "EventCode": "0x800",
-    "BriefDescription": "Counts atomic memory instructions retired"
-  },
-  {
-    "EventName": "SYSTEM_INSTRUCTION_RETIRED",
-    "EventCode": "0x1000",
-    "BriefDescription": "Counts system instructions retired (CSR, WFI, MRET, etc.)"
-  },
-  {
-    "EventName": "INTEGER_ARITHMETIC_RETIRED",
-    "EventCode": "0x2000",
-    "BriefDescription": "Counts integer arithmetic instructions retired"
-  },
-  {
-    "EventName": "CONDITIONAL_BRANCH_RETIRED",
-    "EventCode": "0x4000",
-    "BriefDescription": "Counts conditional branch instructions retired"
-  },
-  {
-    "EventName": "JAL_INSTRUCTION_RETIRED",
-    "EventCode": "0x8000",
-    "BriefDescription": "Counts jump-and-link instructions retired"
-  },
-  {
-    "EventName": "JALR_INSTRUCTION_RETIRED",
-    "EventCode": "0x10000",
-    "BriefDescription": "Counts indirect jump instructions (JALR) retired"
-  },
-  {
-    "EventName": "INTEGER_MULTIPLICATION_RETIRED",
-    "EventCode": "0x20000",
-    "BriefDescription": "Counts integer multiplication instructions retired"
-  },
-  {
-    "EventName": "INTEGER_DIVISION_RETIRED",
-    "EventCode": "0x40000",
-    "BriefDescription": "Counts integer division instructions retired"
-  },
-  {
-    "EventName": "FP_LOAD_RETIRED",
-    "EventCode": "0x80000",
-    "BriefDescription": "Counts floating-point load instructions retired"
-  },
-  {
-    "EventName": "FP_STORE_RETIRED",
-    "EventCode": "0x100000",
-    "BriefDescription": "Counts floating-point store instructions retired"
-  },
-  {
-    "EventName": "FP_ADD_RETIRED",
-    "EventCode": "0x200000",
-    "BriefDescription": "Counts floating-point add instructions retired"
-  },
-  {
-    "EventName": "FP_MUL_RETIRED",
-    "EventCode": "0x400000",
-    "BriefDescription": "Counts floating-point multiply instructions retired"
-  },
-  {
-    "EventName": "FP_MULADD_RETIRED",
-    "EventCode": "0x800000",
-    "BriefDescription": "Counts floating-point fused multiply-add instructions retired"
-  },
-  {
-    "EventName": "FP_DIV_SQRT_RETIRED",
-    "EventCode": "0x1000000",
-    "BriefDescription": "Counts floating point divide or square root instructions retired"
-  },
-  {
-    "EventName": "OTHER_FP_RETIRED",
-    "EventCode": "0x2000000",
-    "BriefDescription": "Counts other floating-point instructions retired"
-  }
-]
+../bullet/instruction.json
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/memory.json linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/memory.json
--- linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/memory.json	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/memory.json	2025-09-11 09:47:42.000000000 -0600
@@ -1,32 +1 @@
-[
-  {
-    "EventName": "ICACHE_MISS",
-    "EventCode": "0x102",
-    "BriefDescription": "Counts instruction cache misses"
-  },
-  {
-    "EventName": "DCACHE_MISS",
-    "EventCode": "0x202",
-    "BriefDescription": "Counts data cache misses"
-  },
-  {
-    "EventName": "DCACHE_RELEASE",
-    "EventCode": "0x402",
-    "BriefDescription": "Counts writeback requests from the data cache"
-  },
-  {
-    "EventName": "ITLB_MISS",
-    "EventCode": "0x802",
-    "BriefDescription": "Counts Instruction TLB misses caused by instruction address translation requests"
-  },
-  {
-    "EventName": "DTLB_MISS",
-    "EventCode": "0x1002",
-    "BriefDescription": "Counts Data TLB misses caused by data address translation requests"
-  },
-  {
-    "EventName": "UTLB_MISS",
-    "EventCode": "0x2002",
-    "BriefDescription": "Counts Unified TLB misses caused by address translation requests"
-  }
-]
+../bullet/memory.json
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/watchpoint.json linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/watchpoint.json
--- linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/watchpoint.json	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/watchpoint.json	2025-09-11 09:47:42.000000000 -0600
@@ -1,42 +1 @@
-[
-  {
-    "EventName": "WATCHPOINT_0",
-    "EventCode": "0x164",
-    "BriefDescription": "Counts occurrences of watchpoint 0 with action=8"
-  },
-  {
-    "EventName": "WATCHPOINT_1",
-    "EventCode": "0x264",
-    "BriefDescription": "Counts occurrences of watchpoint 1 with action=8"
-  },
-  {
-    "EventName": "WATCHPOINT_2",
-    "EventCode": "0x464",
-    "BriefDescription": "Counts occurrences of watchpoint 2 with action=8"
-  },
-  {
-    "EventName": "WATCHPOINT_3",
-    "EventCode": "0x864",
-    "BriefDescription": "Counts occurrences of watchpoint 3 with action=8"
-  },
-  {
-    "EventName": "WATCHPOINT_4",
-    "EventCode": "0x1064",
-    "BriefDescription": "Counts occurrences of watchpoint 4 with action=8"
-  },
-  {
-    "EventName": "WATCHPOINT_5",
-    "EventCode": "0x2064",
-    "BriefDescription": "Counts occurrences of watchpoint 5 with action=8"
-  },
-  {
-    "EventName": "WATCHPOINT_6",
-    "EventCode": "0x4064",
-    "BriefDescription": "Counts occurrences of watchpoint 6 with action=8"
-  },
-  {
-    "EventName": "WATCHPOINT_7",
-    "EventCode": "0x8064",
-    "BriefDescription": "Counts occurrences of watchpoint 7 with action=8"
-  }
-]
+../bullet-07/watchpoint.json
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/p550/firmware.json linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/p550/firmware.json
--- linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/p550/firmware.json	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/p550/firmware.json	2025-09-11 09:47:42.000000000 -0600
@@ -1,68 +1 @@
-[
-  {
-    "ArchStdEvent": "FW_MISALIGNED_LOAD"
-  },
-  {
-    "ArchStdEvent": "FW_MISALIGNED_STORE"
-  },
-  {
-    "ArchStdEvent": "FW_ACCESS_LOAD"
-  },
-  {
-    "ArchStdEvent": "FW_ACCESS_STORE"
-  },
-  {
-    "ArchStdEvent": "FW_ILLEGAL_INSN"
-  },
-  {
-    "ArchStdEvent": "FW_SET_TIMER"
-  },
-  {
-    "ArchStdEvent": "FW_IPI_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_IPI_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_FENCE_I_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_FENCE_I_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_ASID_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_ASID_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_VMID_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_VMID_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_ASID_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_ASID_RECEIVED"
-  }
-]
+../bullet/firmware.json
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/p550/instruction.json linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/p550/instruction.json
--- linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/p550/instruction.json	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/p550/instruction.json	2025-09-11 09:47:42.000000000 -0600
@@ -1,92 +1 @@
-[
-  {
-    "EventName": "EXCEPTION_TAKEN",
-    "EventCode": "0x100",
-    "BriefDescription": "Counts exceptions taken"
-  },
-  {
-    "EventName": "INTEGER_LOAD_RETIRED",
-    "EventCode": "0x200",
-    "BriefDescription": "Counts integer load instructions retired"
-  },
-  {
-    "EventName": "INTEGER_STORE_RETIRED",
-    "EventCode": "0x400",
-    "BriefDescription": "Counts integer store instructions retired"
-  },
-  {
-    "EventName": "ATOMIC_MEMORY_RETIRED",
-    "EventCode": "0x800",
-    "BriefDescription": "Counts atomic memory instructions retired"
-  },
-  {
-    "EventName": "SYSTEM_INSTRUCTION_RETIRED",
-    "EventCode": "0x1000",
-    "BriefDescription": "Counts system instructions retired (CSR, WFI, MRET, etc.)"
-  },
-  {
-    "EventName": "INTEGER_ARITHMETIC_RETIRED",
-    "EventCode": "0x2000",
-    "BriefDescription": "Counts integer arithmetic instructions retired"
-  },
-  {
-    "EventName": "CONDITIONAL_BRANCH_RETIRED",
-    "EventCode": "0x4000",
-    "BriefDescription": "Counts conditional branch instructions retired"
-  },
-  {
-    "EventName": "JAL_INSTRUCTION_RETIRED",
-    "EventCode": "0x8000",
-    "BriefDescription": "Counts jump-and-link instructions retired"
-  },
-  {
-    "EventName": "JALR_INSTRUCTION_RETIRED",
-    "EventCode": "0x10000",
-    "BriefDescription": "Counts indirect jump instructions (JALR) retired"
-  },
-  {
-    "EventName": "INTEGER_MULTIPLICATION_RETIRED",
-    "EventCode": "0x20000",
-    "BriefDescription": "Counts integer multiplication instructions retired"
-  },
-  {
-    "EventName": "INTEGER_DIVISION_RETIRED",
-    "EventCode": "0x40000",
-    "BriefDescription": "Counts integer division instructions retired"
-  },
-  {
-    "EventName": "FP_LOAD_RETIRED",
-    "EventCode": "0x80000",
-    "BriefDescription": "Counts floating-point load instructions retired"
-  },
-  {
-    "EventName": "FP_STORE_RETIRED",
-    "EventCode": "0x100000",
-    "BriefDescription": "Counts floating-point store instructions retired"
-  },
-  {
-    "EventName": "FP_ADD_RETIRED",
-    "EventCode": "0x200000",
-    "BriefDescription": "Counts floating-point add instructions retired"
-  },
-  {
-    "EventName": "FP_MUL_RETIRED",
-    "EventCode": "0x400000",
-    "BriefDescription": "Counts floating-point multiply instructions retired"
-  },
-  {
-    "EventName": "FP_MULADD_RETIRED",
-    "EventCode": "0x800000",
-    "BriefDescription": "Counts floating-point fused multiply-add instructions retired"
-  },
-  {
-    "EventName": "FP_DIV_SQRT_RETIRED",
-    "EventCode": "0x1000000",
-    "BriefDescription": "Counts floating point divide or square root instructions retired"
-  },
-  {
-    "EventName": "OTHER_FP_RETIRED",
-    "EventCode": "0x2000000",
-    "BriefDescription": "Counts other floating-point instructions retired"
-  }
-]
+../bullet/instruction.json
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/p550/microarch.json linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/p550/microarch.json
--- linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/p550/microarch.json	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/p550/microarch.json	2025-09-11 09:47:42.000000000 -0600
@@ -1,57 +1 @@
-[
-  {
-    "EventName": "ADDRESSGEN_INTERLOCK",
-    "EventCode": "0x101",
-    "BriefDescription": "Counts cycles with an address-generation interlock"
-  },
-  {
-    "EventName": "LONGLATENCY_INTERLOCK",
-    "EventCode": "0x201",
-    "BriefDescription": "Counts cycles with a long-latency interlock"
-  },
-  {
-    "EventName": "CSR_INTERLOCK",
-    "EventCode": "0x401",
-    "BriefDescription": "Counts cycles with a CSR interlock"
-  },
-  {
-    "EventName": "ICACHE_BLOCKED",
-    "EventCode": "0x801",
-    "BriefDescription": "Counts cycles in which the instruction cache was not able to provide an instruction"
-  },
-  {
-    "EventName": "DCACHE_BLOCKED",
-    "EventCode": "0x1001",
-    "BriefDescription": "Counts cycles in which the data cache blocked an instruction"
-  },
-  {
-    "EventName": "BRANCH_DIRECTION_MISPREDICTION",
-    "EventCode": "0x2001",
-    "BriefDescription": "Counts mispredictions of conditional branch direction (taken/not taken)"
-  },
-  {
-    "EventName": "BRANCH_TARGET_MISPREDICTION",
-    "EventCode": "0x4001",
-    "BriefDescription": "Counts mispredictions of the target PC of control-flow instructions"
-  },
-  {
-    "EventName": "PIPELINE_FLUSH",
-    "EventCode": "0x8001",
-    "BriefDescription": "Counts flushes of the core pipeline. Common causes include fence.i and CSR accesses"
-  },
-  {
-    "EventName": "REPLAY",
-    "EventCode": "0x10001",
-    "BriefDescription": "Counts instruction replays"
-  },
-  {
-    "EventName": "INTEGER_MUL_DIV_INTERLOCK",
-    "EventCode": "0x20001",
-    "BriefDescription": "Counts cycles with a multiply or divide interlock"
-  },
-  {
-    "EventName": "FP_INTERLOCK",
-    "EventCode": "0x40001",
-    "BriefDescription": "Counts cycles with a floating-point interlock"
-  }
-]
+../bullet/microarch.json
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/p650/cycle-and-instruction-count.json linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/p650/cycle-and-instruction-count.json
--- linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/p650/cycle-and-instruction-count.json	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/p650/cycle-and-instruction-count.json	2025-09-11 09:47:42.000000000 -0600
@@ -1,12 +1 @@
-[
-  {
-    "EventName": "CORE_CLOCK_CYCLES",
-    "EventCode": "0x165",
-    "BriefDescription": "Counts core clock cycles"
-  },
-  {
-    "EventName": "INSTRUCTIONS_RETIRED",
-    "EventCode": "0x265",
-    "BriefDescription": "Counts instructions retired"
-  }
-]
+../bullet-07/cycle-and-instruction-count.json
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/p650/firmware.json linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/p650/firmware.json
--- linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/p650/firmware.json	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/p650/firmware.json	2025-09-11 09:47:42.000000000 -0600
@@ -1,68 +1 @@
-[
-  {
-    "ArchStdEvent": "FW_MISALIGNED_LOAD"
-  },
-  {
-    "ArchStdEvent": "FW_MISALIGNED_STORE"
-  },
-  {
-    "ArchStdEvent": "FW_ACCESS_LOAD"
-  },
-  {
-    "ArchStdEvent": "FW_ACCESS_STORE"
-  },
-  {
-    "ArchStdEvent": "FW_ILLEGAL_INSN"
-  },
-  {
-    "ArchStdEvent": "FW_SET_TIMER"
-  },
-  {
-    "ArchStdEvent": "FW_IPI_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_IPI_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_FENCE_I_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_FENCE_I_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_ASID_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_ASID_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_VMID_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_VMID_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_ASID_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_ASID_RECEIVED"
-  }
-]
+../bullet/firmware.json
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/p650/instruction.json linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/p650/instruction.json
--- linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/p650/instruction.json	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/p650/instruction.json	2025-09-11 09:47:42.000000000 -0600
@@ -1,92 +1 @@
-[
-  {
-    "EventName": "EXCEPTION_TAKEN",
-    "EventCode": "0x100",
-    "BriefDescription": "Counts exceptions taken"
-  },
-  {
-    "EventName": "INTEGER_LOAD_RETIRED",
-    "EventCode": "0x200",
-    "BriefDescription": "Counts integer load instructions retired"
-  },
-  {
-    "EventName": "INTEGER_STORE_RETIRED",
-    "EventCode": "0x400",
-    "BriefDescription": "Counts integer store instructions retired"
-  },
-  {
-    "EventName": "ATOMIC_MEMORY_RETIRED",
-    "EventCode": "0x800",
-    "BriefDescription": "Counts atomic memory instructions retired"
-  },
-  {
-    "EventName": "SYSTEM_INSTRUCTION_RETIRED",
-    "EventCode": "0x1000",
-    "BriefDescription": "Counts system instructions retired (CSR, WFI, MRET, etc.)"
-  },
-  {
-    "EventName": "INTEGER_ARITHMETIC_RETIRED",
-    "EventCode": "0x2000",
-    "BriefDescription": "Counts integer arithmetic instructions retired"
-  },
-  {
-    "EventName": "CONDITIONAL_BRANCH_RETIRED",
-    "EventCode": "0x4000",
-    "BriefDescription": "Counts conditional branch instructions retired"
-  },
-  {
-    "EventName": "JAL_INSTRUCTION_RETIRED",
-    "EventCode": "0x8000",
-    "BriefDescription": "Counts jump-and-link instructions retired"
-  },
-  {
-    "EventName": "JALR_INSTRUCTION_RETIRED",
-    "EventCode": "0x10000",
-    "BriefDescription": "Counts indirect jump instructions (JALR) retired"
-  },
-  {
-    "EventName": "INTEGER_MULTIPLICATION_RETIRED",
-    "EventCode": "0x20000",
-    "BriefDescription": "Counts integer multiplication instructions retired"
-  },
-  {
-    "EventName": "INTEGER_DIVISION_RETIRED",
-    "EventCode": "0x40000",
-    "BriefDescription": "Counts integer division instructions retired"
-  },
-  {
-    "EventName": "FP_LOAD_RETIRED",
-    "EventCode": "0x80000",
-    "BriefDescription": "Counts floating-point load instructions retired"
-  },
-  {
-    "EventName": "FP_STORE_RETIRED",
-    "EventCode": "0x100000",
-    "BriefDescription": "Counts floating-point store instructions retired"
-  },
-  {
-    "EventName": "FP_ADD_RETIRED",
-    "EventCode": "0x200000",
-    "BriefDescription": "Counts floating-point add instructions retired"
-  },
-  {
-    "EventName": "FP_MUL_RETIRED",
-    "EventCode": "0x400000",
-    "BriefDescription": "Counts floating-point multiply instructions retired"
-  },
-  {
-    "EventName": "FP_MULADD_RETIRED",
-    "EventCode": "0x800000",
-    "BriefDescription": "Counts floating-point fused multiply-add instructions retired"
-  },
-  {
-    "EventName": "FP_DIV_SQRT_RETIRED",
-    "EventCode": "0x1000000",
-    "BriefDescription": "Counts floating point divide or square root instructions retired"
-  },
-  {
-    "EventName": "OTHER_FP_RETIRED",
-    "EventCode": "0x2000000",
-    "BriefDescription": "Counts other floating-point instructions retired"
-  }
-]
+../bullet/instruction.json
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/p650/watchpoint.json linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/p650/watchpoint.json
--- linux-6.16.7/tools/perf/pmu-events/arch/riscv/sifive/p650/watchpoint.json	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/p650/watchpoint.json	2025-09-11 09:47:42.000000000 -0600
@@ -1,42 +1 @@
-[
-  {
-    "EventName": "WATCHPOINT_0",
-    "EventCode": "0x164",
-    "BriefDescription": "Counts occurrences of watchpoint 0 with action=8"
-  },
-  {
-    "EventName": "WATCHPOINT_1",
-    "EventCode": "0x264",
-    "BriefDescription": "Counts occurrences of watchpoint 1 with action=8"
-  },
-  {
-    "EventName": "WATCHPOINT_2",
-    "EventCode": "0x464",
-    "BriefDescription": "Counts occurrences of watchpoint 2 with action=8"
-  },
-  {
-    "EventName": "WATCHPOINT_3",
-    "EventCode": "0x864",
-    "BriefDescription": "Counts occurrences of watchpoint 3 with action=8"
-  },
-  {
-    "EventName": "WATCHPOINT_4",
-    "EventCode": "0x1064",
-    "BriefDescription": "Counts occurrences of watchpoint 4 with action=8"
-  },
-  {
-    "EventName": "WATCHPOINT_5",
-    "EventCode": "0x2064",
-    "BriefDescription": "Counts occurrences of watchpoint 5 with action=8"
-  },
-  {
-    "EventName": "WATCHPOINT_6",
-    "EventCode": "0x4064",
-    "BriefDescription": "Counts occurrences of watchpoint 6 with action=8"
-  },
-  {
-    "EventName": "WATCHPOINT_7",
-    "EventCode": "0x8064",
-    "BriefDescription": "Counts occurrences of watchpoint 7 with action=8"
-  }
-]
+../bullet-07/watchpoint.json
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/bpf/disasm.c linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/bpf/disasm.c
--- linux-6.16.7/tools/testing/selftests/bpf/disasm.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/bpf/disasm.c	2025-09-11 09:47:42.000000000 -0600
@@ -1,390 +1 @@
-// SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
-/* Copyright (c) 2011-2014 PLUMgrid, http://plumgrid.com
- * Copyright (c) 2016 Facebook
- */
-
-#include <linux/bpf.h>
-
-#include "disasm.h"
-
-#define __BPF_FUNC_STR_FN(x) [BPF_FUNC_ ## x] = __stringify(bpf_ ## x)
-static const char * const func_id_str[] = {
-	__BPF_FUNC_MAPPER(__BPF_FUNC_STR_FN)
-};
-#undef __BPF_FUNC_STR_FN
-
-static const char *__func_get_name(const struct bpf_insn_cbs *cbs,
-				   const struct bpf_insn *insn,
-				   char *buff, size_t len)
-{
-	BUILD_BUG_ON(ARRAY_SIZE(func_id_str) != __BPF_FUNC_MAX_ID);
-
-	if (!insn->src_reg &&
-	    insn->imm >= 0 && insn->imm < __BPF_FUNC_MAX_ID &&
-	    func_id_str[insn->imm])
-		return func_id_str[insn->imm];
-
-	if (cbs && cbs->cb_call) {
-		const char *res;
-
-		res = cbs->cb_call(cbs->private_data, insn);
-		if (res)
-			return res;
-	}
-
-	if (insn->src_reg == BPF_PSEUDO_CALL)
-		snprintf(buff, len, "%+d", insn->imm);
-	else if (insn->src_reg == BPF_PSEUDO_KFUNC_CALL)
-		snprintf(buff, len, "kernel-function");
-
-	return buff;
-}
-
-static const char *__func_imm_name(const struct bpf_insn_cbs *cbs,
-				   const struct bpf_insn *insn,
-				   u64 full_imm, char *buff, size_t len)
-{
-	if (cbs && cbs->cb_imm)
-		return cbs->cb_imm(cbs->private_data, insn, full_imm);
-
-	snprintf(buff, len, "0x%llx", (unsigned long long)full_imm);
-	return buff;
-}
-
-const char *func_id_name(int id)
-{
-	if (id >= 0 && id < __BPF_FUNC_MAX_ID && func_id_str[id])
-		return func_id_str[id];
-	else
-		return "unknown";
-}
-
-const char *const bpf_class_string[8] = {
-	[BPF_LD]    = "ld",
-	[BPF_LDX]   = "ldx",
-	[BPF_ST]    = "st",
-	[BPF_STX]   = "stx",
-	[BPF_ALU]   = "alu",
-	[BPF_JMP]   = "jmp",
-	[BPF_JMP32] = "jmp32",
-	[BPF_ALU64] = "alu64",
-};
-
-const char *const bpf_alu_string[16] = {
-	[BPF_ADD >> 4]  = "+=",
-	[BPF_SUB >> 4]  = "-=",
-	[BPF_MUL >> 4]  = "*=",
-	[BPF_DIV >> 4]  = "/=",
-	[BPF_OR  >> 4]  = "|=",
-	[BPF_AND >> 4]  = "&=",
-	[BPF_LSH >> 4]  = "<<=",
-	[BPF_RSH >> 4]  = ">>=",
-	[BPF_NEG >> 4]  = "neg",
-	[BPF_MOD >> 4]  = "%=",
-	[BPF_XOR >> 4]  = "^=",
-	[BPF_MOV >> 4]  = "=",
-	[BPF_ARSH >> 4] = "s>>=",
-	[BPF_END >> 4]  = "endian",
-};
-
-static const char *const bpf_alu_sign_string[16] = {
-	[BPF_DIV >> 4]  = "s/=",
-	[BPF_MOD >> 4]  = "s%=",
-};
-
-static const char *const bpf_movsx_string[4] = {
-	[0] = "(s8)",
-	[1] = "(s16)",
-	[3] = "(s32)",
-};
-
-static const char *const bpf_atomic_alu_string[16] = {
-	[BPF_ADD >> 4]  = "add",
-	[BPF_AND >> 4]  = "and",
-	[BPF_OR >> 4]  = "or",
-	[BPF_XOR >> 4]  = "xor",
-};
-
-static const char *const bpf_ldst_string[] = {
-	[BPF_W >> 3]  = "u32",
-	[BPF_H >> 3]  = "u16",
-	[BPF_B >> 3]  = "u8",
-	[BPF_DW >> 3] = "u64",
-};
-
-static const char *const bpf_ldsx_string[] = {
-	[BPF_W >> 3]  = "s32",
-	[BPF_H >> 3]  = "s16",
-	[BPF_B >> 3]  = "s8",
-};
-
-static const char *const bpf_jmp_string[16] = {
-	[BPF_JA >> 4]   = "jmp",
-	[BPF_JEQ >> 4]  = "==",
-	[BPF_JGT >> 4]  = ">",
-	[BPF_JLT >> 4]  = "<",
-	[BPF_JGE >> 4]  = ">=",
-	[BPF_JLE >> 4]  = "<=",
-	[BPF_JSET >> 4] = "&",
-	[BPF_JNE >> 4]  = "!=",
-	[BPF_JSGT >> 4] = "s>",
-	[BPF_JSLT >> 4] = "s<",
-	[BPF_JSGE >> 4] = "s>=",
-	[BPF_JSLE >> 4] = "s<=",
-	[BPF_CALL >> 4] = "call",
-	[BPF_EXIT >> 4] = "exit",
-};
-
-static void print_bpf_end_insn(bpf_insn_print_t verbose,
-			       void *private_data,
-			       const struct bpf_insn *insn)
-{
-	verbose(private_data, "(%02x) r%d = %s%d r%d\n",
-		insn->code, insn->dst_reg,
-		BPF_SRC(insn->code) == BPF_TO_BE ? "be" : "le",
-		insn->imm, insn->dst_reg);
-}
-
-static void print_bpf_bswap_insn(bpf_insn_print_t verbose,
-			       void *private_data,
-			       const struct bpf_insn *insn)
-{
-	verbose(private_data, "(%02x) r%d = bswap%d r%d\n",
-		insn->code, insn->dst_reg,
-		insn->imm, insn->dst_reg);
-}
-
-static bool is_sdiv_smod(const struct bpf_insn *insn)
-{
-	return (BPF_OP(insn->code)  == BPF_DIV || BPF_OP(insn->code) == BPF_MOD) &&
-	       insn->off == 1;
-}
-
-static bool is_movsx(const struct bpf_insn *insn)
-{
-	return BPF_OP(insn->code) == BPF_MOV &&
-	       (insn->off == 8 || insn->off == 16 || insn->off == 32);
-}
-
-static bool is_addr_space_cast(const struct bpf_insn *insn)
-{
-	return insn->code == (BPF_ALU64 | BPF_MOV | BPF_X) &&
-		insn->off == BPF_ADDR_SPACE_CAST;
-}
-
-/* Special (internal-only) form of mov, used to resolve per-CPU addrs:
- * dst_reg = src_reg + <percpu_base_off>
- * BPF_ADDR_PERCPU is used as a special insn->off value.
- */
-#define BPF_ADDR_PERCPU	(-1)
-
-static inline bool is_mov_percpu_addr(const struct bpf_insn *insn)
-{
-	return insn->code == (BPF_ALU64 | BPF_MOV | BPF_X) && insn->off == BPF_ADDR_PERCPU;
-}
-
-void print_bpf_insn(const struct bpf_insn_cbs *cbs,
-		    const struct bpf_insn *insn,
-		    bool allow_ptr_leaks)
-{
-	const bpf_insn_print_t verbose = cbs->cb_print;
-	u8 class = BPF_CLASS(insn->code);
-
-	if (class == BPF_ALU || class == BPF_ALU64) {
-		if (BPF_OP(insn->code) == BPF_END) {
-			if (class == BPF_ALU64)
-				print_bpf_bswap_insn(verbose, cbs->private_data, insn);
-			else
-				print_bpf_end_insn(verbose, cbs->private_data, insn);
-		} else if (BPF_OP(insn->code) == BPF_NEG) {
-			verbose(cbs->private_data, "(%02x) %c%d = -%c%d\n",
-				insn->code, class == BPF_ALU ? 'w' : 'r',
-				insn->dst_reg, class == BPF_ALU ? 'w' : 'r',
-				insn->dst_reg);
-		} else if (is_addr_space_cast(insn)) {
-			verbose(cbs->private_data, "(%02x) r%d = addr_space_cast(r%d, %u, %u)\n",
-				insn->code, insn->dst_reg,
-				insn->src_reg, ((u32)insn->imm) >> 16, (u16)insn->imm);
-		} else if (is_mov_percpu_addr(insn)) {
-			verbose(cbs->private_data, "(%02x) r%d = &(void __percpu *)(r%d)\n",
-				insn->code, insn->dst_reg, insn->src_reg);
-		} else if (BPF_SRC(insn->code) == BPF_X) {
-			verbose(cbs->private_data, "(%02x) %c%d %s %s%c%d\n",
-				insn->code, class == BPF_ALU ? 'w' : 'r',
-				insn->dst_reg,
-				is_sdiv_smod(insn) ? bpf_alu_sign_string[BPF_OP(insn->code) >> 4]
-						   : bpf_alu_string[BPF_OP(insn->code) >> 4],
-				is_movsx(insn) ? bpf_movsx_string[(insn->off >> 3) - 1] : "",
-				class == BPF_ALU ? 'w' : 'r',
-				insn->src_reg);
-		} else {
-			verbose(cbs->private_data, "(%02x) %c%d %s %d\n",
-				insn->code, class == BPF_ALU ? 'w' : 'r',
-				insn->dst_reg,
-				is_sdiv_smod(insn) ? bpf_alu_sign_string[BPF_OP(insn->code) >> 4]
-						   : bpf_alu_string[BPF_OP(insn->code) >> 4],
-				insn->imm);
-		}
-	} else if (class == BPF_STX) {
-		if (BPF_MODE(insn->code) == BPF_MEM)
-			verbose(cbs->private_data, "(%02x) *(%s *)(r%d %+d) = r%d\n",
-				insn->code,
-				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
-				insn->dst_reg,
-				insn->off, insn->src_reg);
-		else if (BPF_MODE(insn->code) == BPF_ATOMIC &&
-			 (insn->imm == BPF_ADD || insn->imm == BPF_AND ||
-			  insn->imm == BPF_OR || insn->imm == BPF_XOR)) {
-			verbose(cbs->private_data, "(%02x) lock *(%s *)(r%d %+d) %s r%d\n",
-				insn->code,
-				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
-				insn->dst_reg, insn->off,
-				bpf_alu_string[BPF_OP(insn->imm) >> 4],
-				insn->src_reg);
-		} else if (BPF_MODE(insn->code) == BPF_ATOMIC &&
-			   (insn->imm == (BPF_ADD | BPF_FETCH) ||
-			    insn->imm == (BPF_AND | BPF_FETCH) ||
-			    insn->imm == (BPF_OR | BPF_FETCH) ||
-			    insn->imm == (BPF_XOR | BPF_FETCH))) {
-			verbose(cbs->private_data, "(%02x) r%d = atomic%s_fetch_%s((%s *)(r%d %+d), r%d)\n",
-				insn->code, insn->src_reg,
-				BPF_SIZE(insn->code) == BPF_DW ? "64" : "",
-				bpf_atomic_alu_string[BPF_OP(insn->imm) >> 4],
-				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
-				insn->dst_reg, insn->off, insn->src_reg);
-		} else if (BPF_MODE(insn->code) == BPF_ATOMIC &&
-			   insn->imm == BPF_CMPXCHG) {
-			verbose(cbs->private_data, "(%02x) r0 = atomic%s_cmpxchg((%s *)(r%d %+d), r0, r%d)\n",
-				insn->code,
-				BPF_SIZE(insn->code) == BPF_DW ? "64" : "",
-				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
-				insn->dst_reg, insn->off,
-				insn->src_reg);
-		} else if (BPF_MODE(insn->code) == BPF_ATOMIC &&
-			   insn->imm == BPF_XCHG) {
-			verbose(cbs->private_data, "(%02x) r%d = atomic%s_xchg((%s *)(r%d %+d), r%d)\n",
-				insn->code, insn->src_reg,
-				BPF_SIZE(insn->code) == BPF_DW ? "64" : "",
-				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
-				insn->dst_reg, insn->off, insn->src_reg);
-		} else if (BPF_MODE(insn->code) == BPF_ATOMIC &&
-			   insn->imm == BPF_LOAD_ACQ) {
-			verbose(cbs->private_data, "(%02x) r%d = load_acquire((%s *)(r%d %+d))\n",
-				insn->code, insn->dst_reg,
-				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
-				insn->src_reg, insn->off);
-		} else if (BPF_MODE(insn->code) == BPF_ATOMIC &&
-			   insn->imm == BPF_STORE_REL) {
-			verbose(cbs->private_data, "(%02x) store_release((%s *)(r%d %+d), r%d)\n",
-				insn->code,
-				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
-				insn->dst_reg, insn->off, insn->src_reg);
-		} else {
-			verbose(cbs->private_data, "BUG_%02x\n", insn->code);
-		}
-	} else if (class == BPF_ST) {
-		if (BPF_MODE(insn->code) == BPF_MEM) {
-			verbose(cbs->private_data, "(%02x) *(%s *)(r%d %+d) = %d\n",
-				insn->code,
-				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
-				insn->dst_reg,
-				insn->off, insn->imm);
-		} else if (BPF_MODE(insn->code) == 0xc0 /* BPF_NOSPEC, no UAPI */) {
-			verbose(cbs->private_data, "(%02x) nospec\n", insn->code);
-		} else {
-			verbose(cbs->private_data, "BUG_st_%02x\n", insn->code);
-		}
-	} else if (class == BPF_LDX) {
-		if (BPF_MODE(insn->code) != BPF_MEM && BPF_MODE(insn->code) != BPF_MEMSX) {
-			verbose(cbs->private_data, "BUG_ldx_%02x\n", insn->code);
-			return;
-		}
-		verbose(cbs->private_data, "(%02x) r%d = *(%s *)(r%d %+d)\n",
-			insn->code, insn->dst_reg,
-			BPF_MODE(insn->code) == BPF_MEM ?
-				 bpf_ldst_string[BPF_SIZE(insn->code) >> 3] :
-				 bpf_ldsx_string[BPF_SIZE(insn->code) >> 3],
-			insn->src_reg, insn->off);
-	} else if (class == BPF_LD) {
-		if (BPF_MODE(insn->code) == BPF_ABS) {
-			verbose(cbs->private_data, "(%02x) r0 = *(%s *)skb[%d]\n",
-				insn->code,
-				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
-				insn->imm);
-		} else if (BPF_MODE(insn->code) == BPF_IND) {
-			verbose(cbs->private_data, "(%02x) r0 = *(%s *)skb[r%d + %d]\n",
-				insn->code,
-				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
-				insn->src_reg, insn->imm);
-		} else if (BPF_MODE(insn->code) == BPF_IMM &&
-			   BPF_SIZE(insn->code) == BPF_DW) {
-			/* At this point, we already made sure that the second
-			 * part of the ldimm64 insn is accessible.
-			 */
-			u64 imm = ((u64)(insn + 1)->imm << 32) | (u32)insn->imm;
-			bool is_ptr = insn->src_reg == BPF_PSEUDO_MAP_FD ||
-				      insn->src_reg == BPF_PSEUDO_MAP_VALUE;
-			char tmp[64];
-
-			if (is_ptr && !allow_ptr_leaks)
-				imm = 0;
-
-			verbose(cbs->private_data, "(%02x) r%d = %s\n",
-				insn->code, insn->dst_reg,
-				__func_imm_name(cbs, insn, imm,
-						tmp, sizeof(tmp)));
-		} else {
-			verbose(cbs->private_data, "BUG_ld_%02x\n", insn->code);
-			return;
-		}
-	} else if (class == BPF_JMP32 || class == BPF_JMP) {
-		u8 opcode = BPF_OP(insn->code);
-
-		if (opcode == BPF_CALL) {
-			char tmp[64];
-
-			if (insn->src_reg == BPF_PSEUDO_CALL) {
-				verbose(cbs->private_data, "(%02x) call pc%s\n",
-					insn->code,
-					__func_get_name(cbs, insn,
-							tmp, sizeof(tmp)));
-			} else {
-				strcpy(tmp, "unknown");
-				verbose(cbs->private_data, "(%02x) call %s#%d\n", insn->code,
-					__func_get_name(cbs, insn,
-							tmp, sizeof(tmp)),
-					insn->imm);
-			}
-		} else if (insn->code == (BPF_JMP | BPF_JA)) {
-			verbose(cbs->private_data, "(%02x) goto pc%+d\n",
-				insn->code, insn->off);
-		} else if (insn->code == (BPF_JMP | BPF_JCOND) &&
-			   insn->src_reg == BPF_MAY_GOTO) {
-			verbose(cbs->private_data, "(%02x) may_goto pc%+d\n",
-				insn->code, insn->off);
-		} else if (insn->code == (BPF_JMP32 | BPF_JA)) {
-			verbose(cbs->private_data, "(%02x) gotol pc%+d\n",
-				insn->code, insn->imm);
-		} else if (insn->code == (BPF_JMP | BPF_EXIT)) {
-			verbose(cbs->private_data, "(%02x) exit\n", insn->code);
-		} else if (BPF_SRC(insn->code) == BPF_X) {
-			verbose(cbs->private_data,
-				"(%02x) if %c%d %s %c%d goto pc%+d\n",
-				insn->code, class == BPF_JMP32 ? 'w' : 'r',
-				insn->dst_reg,
-				bpf_jmp_string[BPF_OP(insn->code) >> 4],
-				class == BPF_JMP32 ? 'w' : 'r',
-				insn->src_reg, insn->off);
-		} else {
-			verbose(cbs->private_data,
-				"(%02x) if %c%d %s 0x%x goto pc%+d\n",
-				insn->code, class == BPF_JMP32 ? 'w' : 'r',
-				insn->dst_reg,
-				bpf_jmp_string[BPF_OP(insn->code) >> 4],
-				(u32)insn->imm, insn->off);
-		}
-	} else {
-		verbose(cbs->private_data, "(%02x) %s\n",
-			insn->code, bpf_class_string[class]);
-	}
-}
+../../../../kernel/bpf/disasm.c
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/bpf/disasm.h linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/bpf/disasm.h
--- linux-6.16.7/tools/testing/selftests/bpf/disasm.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/bpf/disasm.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,40 +1 @@
-/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */
-/* Copyright (c) 2011-2014 PLUMgrid, http://plumgrid.com
- * Copyright (c) 2016 Facebook
- */
-
-#ifndef __BPF_DISASM_H__
-#define __BPF_DISASM_H__
-
-#include <linux/bpf.h>
-#include <linux/kernel.h>
-#include <linux/stringify.h>
-#ifndef __KERNEL__
-#include <stdio.h>
-#include <string.h>
-#endif
-
-extern const char *const bpf_alu_string[16];
-extern const char *const bpf_class_string[8];
-
-const char *func_id_name(int id);
-
-typedef __printf(2, 3) void (*bpf_insn_print_t)(void *private_data,
-						const char *, ...);
-typedef const char *(*bpf_insn_revmap_call_t)(void *private_data,
-					      const struct bpf_insn *insn);
-typedef const char *(*bpf_insn_print_imm_t)(void *private_data,
-					    const struct bpf_insn *insn,
-					    __u64 full_imm);
-
-struct bpf_insn_cbs {
-	bpf_insn_print_t	cb_print;
-	bpf_insn_revmap_call_t	cb_call;
-	bpf_insn_print_imm_t	cb_imm;
-	void			*private_data;
-};
-
-void print_bpf_insn(const struct bpf_insn_cbs *cbs,
-		    const struct bpf_insn *insn,
-		    bool allow_ptr_leaks);
-#endif
+../../../../kernel/bpf/disasm.h
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/bpf/json_writer.c linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/bpf/json_writer.c
--- linux-6.16.7/tools/testing/selftests/bpf/json_writer.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/bpf/json_writer.c	2025-09-11 09:47:42.000000000 -0600
@@ -1,355 +1 @@
-// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-2-Clause)
-/*
- * Simple streaming JSON writer
- *
- * This takes care of the annoying bits of JSON syntax like the commas
- * after elements
- *
- * Authors:	Stephen Hemminger <stephen@networkplumber.org>
- */
-
-#include <stdio.h>
-#include <stdbool.h>
-#include <stdarg.h>
-#include <assert.h>
-#include <malloc.h>
-#include <inttypes.h>
-#include <stdint.h>
-
-#include "json_writer.h"
-
-struct json_writer {
-	FILE		*out;	/* output file */
-	unsigned	depth;  /* nesting */
-	bool		pretty; /* optional whitepace */
-	char		sep;	/* either nul or comma */
-};
-
-/* indentation for pretty print */
-static void jsonw_indent(json_writer_t *self)
-{
-	unsigned i;
-	for (i = 0; i < self->depth; ++i)
-		fputs("    ", self->out);
-}
-
-/* end current line and indent if pretty printing */
-static void jsonw_eol(json_writer_t *self)
-{
-	if (!self->pretty)
-		return;
-
-	putc('\n', self->out);
-	jsonw_indent(self);
-}
-
-/* If current object is not empty print a comma */
-static void jsonw_eor(json_writer_t *self)
-{
-	if (self->sep != '\0')
-		putc(self->sep, self->out);
-	self->sep = ',';
-}
-
-
-/* Output JSON encoded string */
-/* Handles C escapes, does not do Unicode */
-static void jsonw_puts(json_writer_t *self, const char *str)
-{
-	putc('"', self->out);
-	for (; *str; ++str)
-		switch (*str) {
-		case '\t':
-			fputs("\\t", self->out);
-			break;
-		case '\n':
-			fputs("\\n", self->out);
-			break;
-		case '\r':
-			fputs("\\r", self->out);
-			break;
-		case '\f':
-			fputs("\\f", self->out);
-			break;
-		case '\b':
-			fputs("\\b", self->out);
-			break;
-		case '\\':
-			fputs("\\\\", self->out);
-			break;
-		case '"':
-			fputs("\\\"", self->out);
-			break;
-		default:
-			putc(*str, self->out);
-		}
-	putc('"', self->out);
-}
-
-/* Create a new JSON stream */
-json_writer_t *jsonw_new(FILE *f)
-{
-	json_writer_t *self = malloc(sizeof(*self));
-	if (self) {
-		self->out = f;
-		self->depth = 0;
-		self->pretty = false;
-		self->sep = '\0';
-	}
-	return self;
-}
-
-/* End output to JSON stream */
-void jsonw_destroy(json_writer_t **self_p)
-{
-	json_writer_t *self = *self_p;
-
-	assert(self->depth == 0);
-	fputs("\n", self->out);
-	fflush(self->out);
-	free(self);
-	*self_p = NULL;
-}
-
-void jsonw_pretty(json_writer_t *self, bool on)
-{
-	self->pretty = on;
-}
-
-void jsonw_reset(json_writer_t *self)
-{
-	assert(self->depth == 0);
-	self->sep = '\0';
-}
-
-/* Basic blocks */
-static void jsonw_begin(json_writer_t *self, int c)
-{
-	jsonw_eor(self);
-	putc(c, self->out);
-	++self->depth;
-	self->sep = '\0';
-}
-
-static void jsonw_end(json_writer_t *self, int c)
-{
-	assert(self->depth > 0);
-
-	--self->depth;
-	if (self->sep != '\0')
-		jsonw_eol(self);
-	putc(c, self->out);
-	self->sep = ',';
-}
-
-
-/* Add a JSON property name */
-void jsonw_name(json_writer_t *self, const char *name)
-{
-	jsonw_eor(self);
-	jsonw_eol(self);
-	self->sep = '\0';
-	jsonw_puts(self, name);
-	putc(':', self->out);
-	if (self->pretty)
-		putc(' ', self->out);
-}
-
-void jsonw_vprintf_enquote(json_writer_t *self, const char *fmt, va_list ap)
-{
-	jsonw_eor(self);
-	putc('"', self->out);
-	vfprintf(self->out, fmt, ap);
-	putc('"', self->out);
-}
-
-void jsonw_printf(json_writer_t *self, const char *fmt, ...)
-{
-	va_list ap;
-
-	va_start(ap, fmt);
-	jsonw_eor(self);
-	vfprintf(self->out, fmt, ap);
-	va_end(ap);
-}
-
-/* Collections */
-void jsonw_start_object(json_writer_t *self)
-{
-	jsonw_begin(self, '{');
-}
-
-void jsonw_end_object(json_writer_t *self)
-{
-	jsonw_end(self, '}');
-}
-
-void jsonw_start_array(json_writer_t *self)
-{
-	jsonw_begin(self, '[');
-}
-
-void jsonw_end_array(json_writer_t *self)
-{
-	jsonw_end(self, ']');
-}
-
-/* JSON value types */
-void jsonw_string(json_writer_t *self, const char *value)
-{
-	jsonw_eor(self);
-	jsonw_puts(self, value);
-}
-
-void jsonw_bool(json_writer_t *self, bool val)
-{
-	jsonw_printf(self, "%s", val ? "true" : "false");
-}
-
-void jsonw_null(json_writer_t *self)
-{
-	jsonw_printf(self, "null");
-}
-
-void jsonw_float_fmt(json_writer_t *self, const char *fmt, double num)
-{
-	jsonw_printf(self, fmt, num);
-}
-
-#ifdef notused
-void jsonw_float(json_writer_t *self, double num)
-{
-	jsonw_printf(self, "%g", num);
-}
-#endif
-
-void jsonw_hu(json_writer_t *self, unsigned short num)
-{
-	jsonw_printf(self, "%hu", num);
-}
-
-void jsonw_uint(json_writer_t *self, uint64_t num)
-{
-	jsonw_printf(self, "%"PRIu64, num);
-}
-
-void jsonw_lluint(json_writer_t *self, unsigned long long int num)
-{
-	jsonw_printf(self, "%llu", num);
-}
-
-void jsonw_int(json_writer_t *self, int64_t num)
-{
-	jsonw_printf(self, "%"PRId64, num);
-}
-
-/* Basic name/value objects */
-void jsonw_string_field(json_writer_t *self, const char *prop, const char *val)
-{
-	jsonw_name(self, prop);
-	jsonw_string(self, val);
-}
-
-void jsonw_bool_field(json_writer_t *self, const char *prop, bool val)
-{
-	jsonw_name(self, prop);
-	jsonw_bool(self, val);
-}
-
-#ifdef notused
-void jsonw_float_field(json_writer_t *self, const char *prop, double val)
-{
-	jsonw_name(self, prop);
-	jsonw_float(self, val);
-}
-#endif
-
-void jsonw_float_field_fmt(json_writer_t *self,
-			   const char *prop,
-			   const char *fmt,
-			   double val)
-{
-	jsonw_name(self, prop);
-	jsonw_float_fmt(self, fmt, val);
-}
-
-void jsonw_uint_field(json_writer_t *self, const char *prop, uint64_t num)
-{
-	jsonw_name(self, prop);
-	jsonw_uint(self, num);
-}
-
-void jsonw_hu_field(json_writer_t *self, const char *prop, unsigned short num)
-{
-	jsonw_name(self, prop);
-	jsonw_hu(self, num);
-}
-
-void jsonw_lluint_field(json_writer_t *self,
-			const char *prop,
-			unsigned long long int num)
-{
-	jsonw_name(self, prop);
-	jsonw_lluint(self, num);
-}
-
-void jsonw_int_field(json_writer_t *self, const char *prop, int64_t num)
-{
-	jsonw_name(self, prop);
-	jsonw_int(self, num);
-}
-
-void jsonw_null_field(json_writer_t *self, const char *prop)
-{
-	jsonw_name(self, prop);
-	jsonw_null(self);
-}
-
-#ifdef TEST
-int main(int argc, char **argv)
-{
-	json_writer_t *wr = jsonw_new(stdout);
-
-	jsonw_start_object(wr);
-	jsonw_pretty(wr, true);
-	jsonw_name(wr, "Vyatta");
-	jsonw_start_object(wr);
-	jsonw_string_field(wr, "url", "http://vyatta.com");
-	jsonw_uint_field(wr, "downloads", 2000000ul);
-	jsonw_float_field(wr, "stock", 8.16);
-
-	jsonw_name(wr, "ARGV");
-	jsonw_start_array(wr);
-	while (--argc)
-		jsonw_string(wr, *++argv);
-	jsonw_end_array(wr);
-
-	jsonw_name(wr, "empty");
-	jsonw_start_array(wr);
-	jsonw_end_array(wr);
-
-	jsonw_name(wr, "NIL");
-	jsonw_start_object(wr);
-	jsonw_end_object(wr);
-
-	jsonw_null_field(wr, "my_null");
-
-	jsonw_name(wr, "special chars");
-	jsonw_start_array(wr);
-	jsonw_string_field(wr, "slash", "/");
-	jsonw_string_field(wr, "newline", "\n");
-	jsonw_string_field(wr, "tab", "\t");
-	jsonw_string_field(wr, "ff", "\f");
-	jsonw_string_field(wr, "quote", "\"");
-	jsonw_string_field(wr, "tick", "\'");
-	jsonw_string_field(wr, "backslash", "\\");
-	jsonw_end_array(wr);
-
-	jsonw_end_object(wr);
-
-	jsonw_end_object(wr);
-	jsonw_destroy(&wr);
-	return 0;
-}
-
-#endif
+../../../bpf/bpftool/json_writer.c
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/bpf/json_writer.h linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/bpf/json_writer.h
--- linux-6.16.7/tools/testing/selftests/bpf/json_writer.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/bpf/json_writer.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,74 +1 @@
-/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */
-/*
- * Simple streaming JSON writer
- *
- * This takes care of the annoying bits of JSON syntax like the commas
- * after elements
- *
- * Authors:	Stephen Hemminger <stephen@networkplumber.org>
- */
-
-#ifndef _JSON_WRITER_H_
-#define _JSON_WRITER_H_
-
-#include <stdbool.h>
-#include <stdint.h>
-#include <stdarg.h>
-#include <stdio.h>
-#include <linux/compiler.h>
-
-/* Opaque class structure */
-typedef struct json_writer json_writer_t;
-
-/* Create a new JSON stream */
-json_writer_t *jsonw_new(FILE *f);
-/* End output to JSON stream */
-void jsonw_destroy(json_writer_t **self_p);
-
-/* Cause output to have pretty whitespace */
-void jsonw_pretty(json_writer_t *self, bool on);
-
-/* Reset separator to create new JSON */
-void jsonw_reset(json_writer_t *self);
-
-/* Add property name */
-void jsonw_name(json_writer_t *self, const char *name);
-
-/* Add value  */
-void __printf(2, 0) jsonw_vprintf_enquote(json_writer_t *self, const char *fmt,
-					  va_list ap);
-void __printf(2, 3) jsonw_printf(json_writer_t *self, const char *fmt, ...);
-void jsonw_string(json_writer_t *self, const char *value);
-void jsonw_bool(json_writer_t *self, bool value);
-void jsonw_float(json_writer_t *self, double number);
-void jsonw_float_fmt(json_writer_t *self, const char *fmt, double num);
-void jsonw_uint(json_writer_t *self, uint64_t number);
-void jsonw_hu(json_writer_t *self, unsigned short number);
-void jsonw_int(json_writer_t *self, int64_t number);
-void jsonw_null(json_writer_t *self);
-void jsonw_lluint(json_writer_t *self, unsigned long long int num);
-
-/* Useful Combinations of name and value */
-void jsonw_string_field(json_writer_t *self, const char *prop, const char *val);
-void jsonw_bool_field(json_writer_t *self, const char *prop, bool value);
-void jsonw_float_field(json_writer_t *self, const char *prop, double num);
-void jsonw_uint_field(json_writer_t *self, const char *prop, uint64_t num);
-void jsonw_hu_field(json_writer_t *self, const char *prop, unsigned short num);
-void jsonw_int_field(json_writer_t *self, const char *prop, int64_t num);
-void jsonw_null_field(json_writer_t *self, const char *prop);
-void jsonw_lluint_field(json_writer_t *self, const char *prop,
-			unsigned long long int num);
-void jsonw_float_field_fmt(json_writer_t *self, const char *prop,
-			   const char *fmt, double val);
-
-/* Collections */
-void jsonw_start_object(json_writer_t *self);
-void jsonw_end_object(json_writer_t *self);
-
-void jsonw_start_array(json_writer_t *self);
-void jsonw_end_array(json_writer_t *self);
-
-/* Override default exception handling */
-typedef void (jsonw_err_handler_fn)(const char *);
-
-#endif /* _JSON_WRITER_H_ */
+../../../bpf/bpftool/json_writer.h
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/drivers/net/dsa/bridge_locked_port.sh linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/bridge_locked_port.sh
--- linux-6.16.7/tools/testing/selftests/drivers/net/dsa/bridge_locked_port.sh	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/bridge_locked_port.sh	2025-09-11 09:47:42.000000000 -0600
@@ -1,9 +1 @@
-#!/bin/bash
-# SPDX-License-Identifier: GPL-2.0
-
-libdir=$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")
-testname=$(basename "${BASH_SOURCE[0]}")
-
-source "$libdir"/forwarding.config
-cd "$libdir"/../../../net/forwarding/ || exit 1
-source "./$testname" "$@"
+run_net_forwarding_test.sh
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/drivers/net/dsa/bridge_mdb.sh linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/bridge_mdb.sh
--- linux-6.16.7/tools/testing/selftests/drivers/net/dsa/bridge_mdb.sh	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/bridge_mdb.sh	2025-09-11 09:47:42.000000000 -0600
@@ -1,9 +1 @@
-#!/bin/bash
-# SPDX-License-Identifier: GPL-2.0
-
-libdir=$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")
-testname=$(basename "${BASH_SOURCE[0]}")
-
-source "$libdir"/forwarding.config
-cd "$libdir"/../../../net/forwarding/ || exit 1
-source "./$testname" "$@"
+run_net_forwarding_test.sh
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/drivers/net/dsa/bridge_mld.sh linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/bridge_mld.sh
--- linux-6.16.7/tools/testing/selftests/drivers/net/dsa/bridge_mld.sh	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/bridge_mld.sh	2025-09-11 09:47:42.000000000 -0600
@@ -1,9 +1 @@
-#!/bin/bash
-# SPDX-License-Identifier: GPL-2.0
-
-libdir=$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")
-testname=$(basename "${BASH_SOURCE[0]}")
-
-source "$libdir"/forwarding.config
-cd "$libdir"/../../../net/forwarding/ || exit 1
-source "./$testname" "$@"
+run_net_forwarding_test.sh
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/drivers/net/dsa/bridge_vlan_aware.sh linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/bridge_vlan_aware.sh
--- linux-6.16.7/tools/testing/selftests/drivers/net/dsa/bridge_vlan_aware.sh	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/bridge_vlan_aware.sh	2025-09-11 09:47:42.000000000 -0600
@@ -1,9 +1 @@
-#!/bin/bash
-# SPDX-License-Identifier: GPL-2.0
-
-libdir=$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")
-testname=$(basename "${BASH_SOURCE[0]}")
-
-source "$libdir"/forwarding.config
-cd "$libdir"/../../../net/forwarding/ || exit 1
-source "./$testname" "$@"
+run_net_forwarding_test.sh
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/drivers/net/dsa/bridge_vlan_mcast.sh linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/bridge_vlan_mcast.sh
--- linux-6.16.7/tools/testing/selftests/drivers/net/dsa/bridge_vlan_mcast.sh	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/bridge_vlan_mcast.sh	2025-09-11 09:47:42.000000000 -0600
@@ -1,9 +1 @@
-#!/bin/bash
-# SPDX-License-Identifier: GPL-2.0
-
-libdir=$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")
-testname=$(basename "${BASH_SOURCE[0]}")
-
-source "$libdir"/forwarding.config
-cd "$libdir"/../../../net/forwarding/ || exit 1
-source "./$testname" "$@"
+run_net_forwarding_test.sh
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/drivers/net/dsa/bridge_vlan_unaware.sh linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/bridge_vlan_unaware.sh
--- linux-6.16.7/tools/testing/selftests/drivers/net/dsa/bridge_vlan_unaware.sh	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/bridge_vlan_unaware.sh	2025-09-11 09:47:42.000000000 -0600
@@ -1,9 +1 @@
-#!/bin/bash
-# SPDX-License-Identifier: GPL-2.0
-
-libdir=$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")
-testname=$(basename "${BASH_SOURCE[0]}")
-
-source "$libdir"/forwarding.config
-cd "$libdir"/../../../net/forwarding/ || exit 1
-source "./$testname" "$@"
+run_net_forwarding_test.sh
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/drivers/net/dsa/local_termination.sh linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/local_termination.sh
--- linux-6.16.7/tools/testing/selftests/drivers/net/dsa/local_termination.sh	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/local_termination.sh	2025-09-11 09:47:42.000000000 -0600
@@ -1,9 +1 @@
-#!/bin/bash
-# SPDX-License-Identifier: GPL-2.0
-
-libdir=$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")
-testname=$(basename "${BASH_SOURCE[0]}")
-
-source "$libdir"/forwarding.config
-cd "$libdir"/../../../net/forwarding/ || exit 1
-source "./$testname" "$@"
+run_net_forwarding_test.sh
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/drivers/net/dsa/no_forwarding.sh linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/no_forwarding.sh
--- linux-6.16.7/tools/testing/selftests/drivers/net/dsa/no_forwarding.sh	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/no_forwarding.sh	2025-09-11 09:47:42.000000000 -0600
@@ -1,9 +1 @@
-#!/bin/bash
-# SPDX-License-Identifier: GPL-2.0
-
-libdir=$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")
-testname=$(basename "${BASH_SOURCE[0]}")
-
-source "$libdir"/forwarding.config
-cd "$libdir"/../../../net/forwarding/ || exit 1
-source "./$testname" "$@"
+run_net_forwarding_test.sh
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/drivers/net/dsa/tc_actions.sh linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/tc_actions.sh
--- linux-6.16.7/tools/testing/selftests/drivers/net/dsa/tc_actions.sh	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/tc_actions.sh	2025-09-11 09:47:42.000000000 -0600
@@ -1,9 +1 @@
-#!/bin/bash
-# SPDX-License-Identifier: GPL-2.0
-
-libdir=$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")
-testname=$(basename "${BASH_SOURCE[0]}")
-
-source "$libdir"/forwarding.config
-cd "$libdir"/../../../net/forwarding/ || exit 1
-source "./$testname" "$@"
+run_net_forwarding_test.sh
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/drivers/net/dsa/tc_taprio.sh linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/tc_taprio.sh
--- linux-6.16.7/tools/testing/selftests/drivers/net/dsa/tc_taprio.sh	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/tc_taprio.sh	2025-09-11 09:47:42.000000000 -0600
@@ -1,9 +1 @@
-#!/bin/bash
-# SPDX-License-Identifier: GPL-2.0
-
-libdir=$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")
-testname=$(basename "${BASH_SOURCE[0]}")
-
-source "$libdir"/forwarding.config
-cd "$libdir"/../../../net/forwarding/ || exit 1
-source "./$testname" "$@"
+run_net_forwarding_test.sh
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/drivers/net/mlxsw/spectrum-2/port_range_scale.sh linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/mlxsw/spectrum-2/port_range_scale.sh
--- linux-6.16.7/tools/testing/selftests/drivers/net/mlxsw/spectrum-2/port_range_scale.sh	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/mlxsw/spectrum-2/port_range_scale.sh	2025-09-11 09:47:42.000000000 -0600
@@ -1,16 +1 @@
-# SPDX-License-Identifier: GPL-2.0
-source ../port_range_scale.sh
-
-port_range_get_target()
-{
-	local should_fail=$1; shift
-	local target
-
-	target=$(devlink_resource_size_get port_range_registers)
-
-	if ((! should_fail)); then
-		echo $target
-	else
-		echo $((target + 1))
-	fi
-}
+../spectrum/port_range_scale.sh
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/drivers/net/mlxsw/spectrum-2/rif_counter_scale.sh linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/mlxsw/spectrum-2/rif_counter_scale.sh
--- linux-6.16.7/tools/testing/selftests/drivers/net/mlxsw/spectrum-2/rif_counter_scale.sh	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/mlxsw/spectrum-2/rif_counter_scale.sh	2025-09-11 09:47:42.000000000 -0600
@@ -1,34 +1 @@
-# SPDX-License-Identifier: GPL-2.0
-source ../rif_counter_scale.sh
-
-rif_counter_get_target()
-{
-	local should_fail=$1; shift
-	local max_cnts
-	local max_rifs
-	local target
-
-	max_rifs=$(devlink_resource_size_get rifs)
-	max_cnts=$(devlink_resource_size_get counters rif)
-
-	# Remove already allocated RIFs.
-	((max_rifs -= $(devlink_resource_occ_get rifs)))
-
-	# 10 KVD slots per counter, ingress+egress counters per RIF
-	((max_cnts /= 20))
-
-	# Pointless to run the overflow test if we don't have enough RIFs to
-	# host all the counters.
-	if ((max_cnts > max_rifs && should_fail)); then
-		echo 0
-		return
-	fi
-
-	target=$((max_rifs < max_cnts ? max_rifs : max_cnts))
-
-	if ((! should_fail)); then
-		echo $target
-	else
-		echo $((target + 1))
-	fi
-}
+../spectrum/rif_counter_scale.sh
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/net/tcp_ao/icmps-accept.c linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/net/tcp_ao/icmps-accept.c
--- linux-6.16.7/tools/testing/selftests/net/tcp_ao/icmps-accept.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/net/tcp_ao/icmps-accept.c	2025-09-11 09:47:42.000000000 -0600
@@ -1,448 +1 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Selftest that verifies that incomping ICMPs are ignored,
- * the TCP connection stays alive, no hard or soft errors get reported
- * to the usespace and the counter for ignored ICMPs is updated.
- *
- * RFC5925, 7.8:
- * >> A TCP-AO implementation MUST default to ignore incoming ICMPv4
- * messages of Type 3 (destination unreachable), Codes 2-4 (protocol
- * unreachable, port unreachable, and fragmentation needed -- hard
- * errors), and ICMPv6 Type 1 (destination unreachable), Code 1
- * (administratively prohibited) and Code 4 (port unreachable) intended
- * for connections in synchronized states (ESTABLISHED, FIN-WAIT-1, FIN-
- * WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT) that match MKTs.
- *
- * Author: Dmitry Safonov <dima@arista.com>
- */
-#include <inttypes.h>
-#include <linux/icmp.h>
-#include <linux/icmpv6.h>
-#include <linux/ipv6.h>
-#include <netinet/in.h>
-#include <netinet/ip.h>
-#include <sys/socket.h>
-#include "aolib.h"
-#include "../../../../include/linux/compiler.h"
-
-const size_t packets_nr = 20;
-const size_t packet_size = 100;
-const char *tcpao_icmps	= "TCPAODroppedIcmps";
-
-#ifdef IPV6_TEST
-const char *dst_unreach	= "Icmp6InDestUnreachs";
-const int sk_ip_level	= SOL_IPV6;
-const int sk_recverr	= IPV6_RECVERR;
-#else
-const char *dst_unreach	= "InDestUnreachs";
-const int sk_ip_level	= SOL_IP;
-const int sk_recverr	= IP_RECVERR;
-#endif
-
-/* Server is expected to fail with hard error if ::accept_icmp is set */
-#ifdef TEST_ICMPS_ACCEPT
-# define test_icmps_fail test_ok
-# define test_icmps_ok test_fail
-#else
-# define test_icmps_fail test_fail
-# define test_icmps_ok test_ok
-#endif
-
-static void serve_interfered(int sk)
-{
-	ssize_t test_quota = packet_size * packets_nr * 10;
-	uint64_t dest_unreach_a, dest_unreach_b;
-	uint64_t icmp_ignored_a, icmp_ignored_b;
-	struct tcp_counters cnt1, cnt2;
-	bool counter_not_found;
-	struct netstat *ns_after, *ns_before;
-	ssize_t bytes;
-
-	ns_before = netstat_read();
-	dest_unreach_a = netstat_get(ns_before, dst_unreach, NULL);
-	icmp_ignored_a = netstat_get(ns_before, tcpao_icmps, NULL);
-	if (test_get_tcp_counters(sk, &cnt1))
-		test_error("test_get_tcp_counters()");
-	bytes = test_server_run(sk, test_quota, 0);
-	ns_after = netstat_read();
-	netstat_print_diff(ns_before, ns_after);
-	dest_unreach_b = netstat_get(ns_after, dst_unreach, NULL);
-	icmp_ignored_b = netstat_get(ns_after, tcpao_icmps,
-					&counter_not_found);
-	if (test_get_tcp_counters(sk, &cnt2))
-		test_error("test_get_tcp_counters()");
-
-	netstat_free(ns_before);
-	netstat_free(ns_after);
-
-	if (dest_unreach_a >= dest_unreach_b) {
-		test_fail("%s counter didn't change: %" PRIu64 " >= %" PRIu64,
-				dst_unreach, dest_unreach_a, dest_unreach_b);
-		return;
-	}
-	test_ok("%s delivered %" PRIu64,
-		dst_unreach, dest_unreach_b - dest_unreach_a);
-	if (bytes < 0)
-		test_icmps_fail("Server failed with %zd: %s", bytes, strerrordesc_np(-bytes));
-	else
-		test_icmps_ok("Server survived %zd bytes of traffic", test_quota);
-	if (counter_not_found) {
-		test_fail("Not found %s counter", tcpao_icmps);
-		return;
-	}
-#ifdef TEST_ICMPS_ACCEPT
-	test_assert_counters(NULL, &cnt1, &cnt2, TEST_CNT_GOOD);
-#else
-	test_assert_counters(NULL, &cnt1, &cnt2, TEST_CNT_GOOD | TEST_CNT_AO_DROPPED_ICMP);
-#endif
-	if (icmp_ignored_a >= icmp_ignored_b) {
-		test_icmps_fail("%s counter didn't change: %" PRIu64 " >= %" PRIu64,
-				tcpao_icmps, icmp_ignored_a, icmp_ignored_b);
-		return;
-	}
-	test_icmps_ok("ICMPs ignored %" PRIu64, icmp_ignored_b - icmp_ignored_a);
-}
-
-static void *server_fn(void *arg)
-{
-	int val, sk, lsk;
-	bool accept_icmps = false;
-
-	lsk = test_listen_socket(this_ip_addr, test_server_port, 1);
-
-#ifdef TEST_ICMPS_ACCEPT
-	accept_icmps = true;
-#endif
-
-	if (test_set_ao_flags(lsk, false, accept_icmps))
-		test_error("setsockopt(TCP_AO_INFO)");
-
-	if (test_add_key(lsk, DEFAULT_TEST_PASSWORD, this_ip_dest, -1, 100, 100))
-		test_error("setsockopt(TCP_AO_ADD_KEY)");
-	synchronize_threads();
-
-	if (test_wait_fd(lsk, TEST_TIMEOUT_SEC, 0))
-		test_error("test_wait_fd()");
-
-	sk = accept(lsk, NULL, NULL);
-	if (sk < 0)
-		test_error("accept()");
-
-	/* Fail on hard ip errors, such as dest unreachable (RFC1122) */
-	val = 1;
-	if (setsockopt(sk, sk_ip_level, sk_recverr, &val, sizeof(val)))
-		test_error("setsockopt()");
-
-	synchronize_threads();
-
-	serve_interfered(sk);
-	return NULL;
-}
-
-static size_t packets_sent;
-static size_t icmps_sent;
-
-static uint32_t checksum4_nofold(void *data, size_t len, uint32_t sum)
-{
-	uint16_t *words = data;
-	size_t i;
-
-	for (i = 0; i < len / sizeof(uint16_t); i++)
-		sum += words[i];
-	if (len & 1)
-		sum += ((char *)data)[len - 1];
-	return sum;
-}
-
-static uint16_t checksum4_fold(void *data, size_t len, uint32_t sum)
-{
-	sum = checksum4_nofold(data, len, sum);
-	while (sum > 0xFFFF)
-		sum = (sum & 0xFFFF) + (sum >> 16);
-	return ~sum;
-}
-
-static void set_ip4hdr(struct iphdr *iph, size_t packet_len, int proto,
-		struct sockaddr_in *src, struct sockaddr_in *dst)
-{
-	iph->version	= 4;
-	iph->ihl	= 5;
-	iph->tos	= 0;
-	iph->tot_len	= htons(packet_len);
-	iph->ttl	= 2;
-	iph->protocol	= proto;
-	iph->saddr	= src->sin_addr.s_addr;
-	iph->daddr	= dst->sin_addr.s_addr;
-	iph->check	= checksum4_fold((void *)iph, iph->ihl << 1, 0);
-}
-
-static void icmp_interfere4(uint8_t type, uint8_t code, uint32_t rcv_nxt,
-		struct sockaddr_in *src, struct sockaddr_in *dst)
-{
-	int sk = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
-	struct {
-		struct iphdr iph;
-		struct icmphdr icmph;
-		struct iphdr iphe;
-		struct {
-			uint16_t sport;
-			uint16_t dport;
-			uint32_t seq;
-		} tcph;
-	} packet = {};
-	size_t packet_len;
-	ssize_t bytes;
-
-	if (sk < 0)
-		test_error("socket(AF_INET, SOCK_RAW, IPPROTO_RAW)");
-
-	packet_len = sizeof(packet);
-	set_ip4hdr(&packet.iph, packet_len, IPPROTO_ICMP, src, dst);
-
-	packet.icmph.type = type;
-	packet.icmph.code = code;
-	if (code == ICMP_FRAG_NEEDED) {
-		randomize_buffer(&packet.icmph.un.frag.mtu,
-				sizeof(packet.icmph.un.frag.mtu));
-	}
-
-	packet_len = sizeof(packet.iphe) + sizeof(packet.tcph);
-	set_ip4hdr(&packet.iphe, packet_len, IPPROTO_TCP, dst, src);
-
-	packet.tcph.sport = dst->sin_port;
-	packet.tcph.dport = src->sin_port;
-	packet.tcph.seq = htonl(rcv_nxt);
-
-	packet_len = sizeof(packet) - sizeof(packet.iph);
-	packet.icmph.checksum = checksum4_fold((void *)&packet.icmph,
-						packet_len, 0);
-
-	bytes = sendto(sk, &packet, sizeof(packet), 0,
-		       (struct sockaddr *)dst, sizeof(*dst));
-	if (bytes != sizeof(packet))
-		test_error("send(): %zd", bytes);
-	icmps_sent++;
-
-	close(sk);
-}
-
-static void set_ip6hdr(struct ipv6hdr *iph, size_t packet_len, int proto,
-		struct sockaddr_in6 *src, struct sockaddr_in6 *dst)
-{
-	iph->version		= 6;
-	iph->payload_len	= htons(packet_len);
-	iph->nexthdr		= proto;
-	iph->hop_limit		= 2;
-	iph->saddr		= src->sin6_addr;
-	iph->daddr		= dst->sin6_addr;
-}
-
-static inline uint16_t csum_fold(uint32_t csum)
-{
-	uint32_t sum = csum;
-
-	sum = (sum & 0xffff) + (sum >> 16);
-	sum = (sum & 0xffff) + (sum >> 16);
-	return (uint16_t)~sum;
-}
-
-static inline uint32_t csum_add(uint32_t csum, uint32_t addend)
-{
-	uint32_t res = csum;
-
-	res += addend;
-	return res + (res < addend);
-}
-
-noinline uint32_t checksum6_nofold(void *data, size_t len, uint32_t sum)
-{
-	uint16_t *words = data;
-	size_t i;
-
-	for (i = 0; i < len / sizeof(uint16_t); i++)
-		sum = csum_add(sum, words[i]);
-	if (len & 1)
-		sum = csum_add(sum, ((char *)data)[len - 1]);
-	return sum;
-}
-
-noinline uint16_t icmp6_checksum(struct sockaddr_in6 *src,
-				 struct sockaddr_in6 *dst,
-				 void *ptr, size_t len, uint8_t proto)
-{
-	struct {
-		struct in6_addr saddr;
-		struct in6_addr daddr;
-		uint32_t payload_len;
-		uint8_t zero[3];
-		uint8_t nexthdr;
-	} pseudo_header = {};
-	uint32_t sum;
-
-	pseudo_header.saddr		= src->sin6_addr;
-	pseudo_header.daddr		= dst->sin6_addr;
-	pseudo_header.payload_len	= htonl(len);
-	pseudo_header.nexthdr		= proto;
-
-	sum = checksum6_nofold(&pseudo_header, sizeof(pseudo_header), 0);
-	sum = checksum6_nofold(ptr, len, sum);
-
-	return csum_fold(sum);
-}
-
-static void icmp6_interfere(int type, int code, uint32_t rcv_nxt,
-		struct sockaddr_in6 *src, struct sockaddr_in6 *dst)
-{
-	int sk = socket(AF_INET6, SOCK_RAW, IPPROTO_RAW);
-	struct sockaddr_in6 dst_raw = *dst;
-	struct {
-		struct ipv6hdr iph;
-		struct icmp6hdr icmph;
-		struct ipv6hdr iphe;
-		struct {
-			uint16_t sport;
-			uint16_t dport;
-			uint32_t seq;
-		} tcph;
-	} packet = {};
-	size_t packet_len;
-	ssize_t bytes;
-
-
-	if (sk < 0)
-		test_error("socket(AF_INET6, SOCK_RAW, IPPROTO_RAW)");
-
-	packet_len = sizeof(packet) - sizeof(packet.iph);
-	set_ip6hdr(&packet.iph, packet_len, IPPROTO_ICMPV6, src, dst);
-
-	packet.icmph.icmp6_type = type;
-	packet.icmph.icmp6_code = code;
-
-	packet_len = sizeof(packet.iphe) + sizeof(packet.tcph);
-	set_ip6hdr(&packet.iphe, packet_len, IPPROTO_TCP, dst, src);
-
-	packet.tcph.sport = dst->sin6_port;
-	packet.tcph.dport = src->sin6_port;
-	packet.tcph.seq = htonl(rcv_nxt);
-
-	packet_len = sizeof(packet) - sizeof(packet.iph);
-
-	packet.icmph.icmp6_cksum = icmp6_checksum(src, dst,
-			(void *)&packet.icmph, packet_len, IPPROTO_ICMPV6);
-
-	dst_raw.sin6_port = htons(IPPROTO_RAW);
-	bytes = sendto(sk, &packet, sizeof(packet), 0,
-		       (struct sockaddr *)&dst_raw, sizeof(dst_raw));
-	if (bytes != sizeof(packet))
-		test_error("send(): %zd", bytes);
-	icmps_sent++;
-
-	close(sk);
-}
-
-static uint32_t get_rcv_nxt(int sk)
-{
-	int val = TCP_REPAIR_ON;
-	uint32_t ret;
-	socklen_t sz = sizeof(ret);
-
-	if (setsockopt(sk, SOL_TCP, TCP_REPAIR, &val, sizeof(val)))
-		test_error("setsockopt(TCP_REPAIR)");
-	val = TCP_RECV_QUEUE;
-	if (setsockopt(sk, SOL_TCP, TCP_REPAIR_QUEUE, &val, sizeof(val)))
-		test_error("setsockopt(TCP_REPAIR_QUEUE)");
-	if (getsockopt(sk, SOL_TCP, TCP_QUEUE_SEQ, &ret, &sz))
-		test_error("getsockopt(TCP_QUEUE_SEQ)");
-	val = TCP_REPAIR_OFF_NO_WP;
-	if (setsockopt(sk, SOL_TCP, TCP_REPAIR, &val, sizeof(val)))
-		test_error("setsockopt(TCP_REPAIR)");
-	return ret;
-}
-
-static void icmp_interfere(const size_t nr, uint32_t rcv_nxt, void *src, void *dst)
-{
-	struct sockaddr_in *saddr4 = src;
-	struct sockaddr_in *daddr4 = dst;
-	struct sockaddr_in6 *saddr6 = src;
-	struct sockaddr_in6 *daddr6 = dst;
-	size_t i;
-
-	if (saddr4->sin_family != daddr4->sin_family)
-		test_error("Different address families");
-
-	for (i = 0; i < nr; i++) {
-		if (saddr4->sin_family == AF_INET) {
-			icmp_interfere4(ICMP_DEST_UNREACH, ICMP_PROT_UNREACH,
-					rcv_nxt, saddr4, daddr4);
-			icmp_interfere4(ICMP_DEST_UNREACH, ICMP_PORT_UNREACH,
-					rcv_nxt, saddr4, daddr4);
-			icmp_interfere4(ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED,
-					rcv_nxt, saddr4, daddr4);
-			icmps_sent += 3;
-		} else if (saddr4->sin_family == AF_INET6) {
-			icmp6_interfere(ICMPV6_DEST_UNREACH,
-					ICMPV6_ADM_PROHIBITED,
-					rcv_nxt, saddr6, daddr6);
-			icmp6_interfere(ICMPV6_DEST_UNREACH,
-					ICMPV6_PORT_UNREACH,
-					rcv_nxt, saddr6, daddr6);
-			icmps_sent += 2;
-		} else {
-			test_error("Not ip address family");
-		}
-	}
-}
-
-static void send_interfered(int sk)
-{
-	struct sockaddr_in6 src, dst;
-	socklen_t addr_sz;
-
-	addr_sz = sizeof(src);
-	if (getsockname(sk, &src, &addr_sz))
-		test_error("getsockname()");
-	addr_sz = sizeof(dst);
-	if (getpeername(sk, &dst, &addr_sz))
-		test_error("getpeername()");
-
-	while (1) {
-		uint32_t rcv_nxt;
-
-		if (test_client_verify(sk, packet_size, packets_nr)) {
-			test_fail("client: connection is broken");
-			return;
-		}
-		packets_sent += packets_nr;
-		rcv_nxt = get_rcv_nxt(sk);
-		icmp_interfere(packets_nr, rcv_nxt, (void *)&src, (void *)&dst);
-	}
-}
-
-static void *client_fn(void *arg)
-{
-	int sk = socket(test_family, SOCK_STREAM, IPPROTO_TCP);
-
-	if (sk < 0)
-		test_error("socket()");
-
-	if (test_add_key(sk, DEFAULT_TEST_PASSWORD, this_ip_dest, -1, 100, 100))
-		test_error("setsockopt(TCP_AO_ADD_KEY)");
-
-	synchronize_threads();
-	if (test_connect_socket(sk, this_ip_dest, test_server_port) <= 0)
-		test_error("failed to connect()");
-	synchronize_threads();
-
-	send_interfered(sk);
-
-	/* Not expecting client to quit */
-	test_fail("client disconnected");
-
-	return NULL;
-}
-
-int main(int argc, char *argv[])
-{
-	test_init(4, server_fn, client_fn);
-	return 0;
-}
+icmps-discard.c
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/powerpc/copyloops/copy_mc_64.S linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/copyloops/copy_mc_64.S
--- linux-6.16.7/tools/testing/selftests/powerpc/copyloops/copy_mc_64.S	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/copyloops/copy_mc_64.S	2025-09-11 09:47:42.000000000 -0600
@@ -1,242 +1 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Copyright (C) IBM Corporation, 2011
- * Derived from copyuser_power7.s by Anton Blanchard <anton@au.ibm.com>
- * Author - Balbir Singh <bsingharora@gmail.com>
- */
-#include <linux/export.h>
-#include <asm/ppc_asm.h>
-#include <asm/errno.h>
-
-	.macro err1
-100:
-	EX_TABLE(100b,.Ldo_err1)
-	.endm
-
-	.macro err2
-200:
-	EX_TABLE(200b,.Ldo_err2)
-	.endm
-
-	.macro err3
-300:	EX_TABLE(300b,.Ldone)
-	.endm
-
-.Ldo_err2:
-	ld	r22,STK_REG(R22)(r1)
-	ld	r21,STK_REG(R21)(r1)
-	ld	r20,STK_REG(R20)(r1)
-	ld	r19,STK_REG(R19)(r1)
-	ld	r18,STK_REG(R18)(r1)
-	ld	r17,STK_REG(R17)(r1)
-	ld	r16,STK_REG(R16)(r1)
-	ld	r15,STK_REG(R15)(r1)
-	ld	r14,STK_REG(R14)(r1)
-	addi	r1,r1,STACKFRAMESIZE
-.Ldo_err1:
-	/* Do a byte by byte copy to get the exact remaining size */
-	mtctr	r7
-46:
-err3;	lbz	r0,0(r4)
-	addi	r4,r4,1
-err3;	stb	r0,0(r3)
-	addi	r3,r3,1
-	bdnz	46b
-	li	r3,0
-	blr
-
-.Ldone:
-	mfctr	r3
-	blr
-
-
-_GLOBAL(copy_mc_generic)
-	mr	r7,r5
-	cmpldi	r5,16
-	blt	.Lshort_copy
-
-.Lcopy:
-	/* Get the source 8B aligned */
-	neg	r6,r4
-	mtocrf	0x01,r6
-	clrldi	r6,r6,(64-3)
-
-	bf	cr7*4+3,1f
-err1;	lbz	r0,0(r4)
-	addi	r4,r4,1
-err1;	stb	r0,0(r3)
-	addi	r3,r3,1
-	subi	r7,r7,1
-
-1:	bf	cr7*4+2,2f
-err1;	lhz	r0,0(r4)
-	addi	r4,r4,2
-err1;	sth	r0,0(r3)
-	addi	r3,r3,2
-	subi	r7,r7,2
-
-2:	bf	cr7*4+1,3f
-err1;	lwz	r0,0(r4)
-	addi	r4,r4,4
-err1;	stw	r0,0(r3)
-	addi	r3,r3,4
-	subi	r7,r7,4
-
-3:	sub	r5,r5,r6
-	cmpldi	r5,128
-
-	mflr	r0
-	stdu	r1,-STACKFRAMESIZE(r1)
-	std	r14,STK_REG(R14)(r1)
-	std	r15,STK_REG(R15)(r1)
-	std	r16,STK_REG(R16)(r1)
-	std	r17,STK_REG(R17)(r1)
-	std	r18,STK_REG(R18)(r1)
-	std	r19,STK_REG(R19)(r1)
-	std	r20,STK_REG(R20)(r1)
-	std	r21,STK_REG(R21)(r1)
-	std	r22,STK_REG(R22)(r1)
-	std	r0,STACKFRAMESIZE+16(r1)
-
-	blt	5f
-	srdi	r6,r5,7
-	mtctr	r6
-
-	/* Now do cacheline (128B) sized loads and stores. */
-	.align	5
-4:
-err2;	ld	r0,0(r4)
-err2;	ld	r6,8(r4)
-err2;	ld	r8,16(r4)
-err2;	ld	r9,24(r4)
-err2;	ld	r10,32(r4)
-err2;	ld	r11,40(r4)
-err2;	ld	r12,48(r4)
-err2;	ld	r14,56(r4)
-err2;	ld	r15,64(r4)
-err2;	ld	r16,72(r4)
-err2;	ld	r17,80(r4)
-err2;	ld	r18,88(r4)
-err2;	ld	r19,96(r4)
-err2;	ld	r20,104(r4)
-err2;	ld	r21,112(r4)
-err2;	ld	r22,120(r4)
-	addi	r4,r4,128
-err2;	std	r0,0(r3)
-err2;	std	r6,8(r3)
-err2;	std	r8,16(r3)
-err2;	std	r9,24(r3)
-err2;	std	r10,32(r3)
-err2;	std	r11,40(r3)
-err2;	std	r12,48(r3)
-err2;	std	r14,56(r3)
-err2;	std	r15,64(r3)
-err2;	std	r16,72(r3)
-err2;	std	r17,80(r3)
-err2;	std	r18,88(r3)
-err2;	std	r19,96(r3)
-err2;	std	r20,104(r3)
-err2;	std	r21,112(r3)
-err2;	std	r22,120(r3)
-	addi	r3,r3,128
-	subi	r7,r7,128
-	bdnz	4b
-
-	clrldi	r5,r5,(64-7)
-
-	/* Up to 127B to go */
-5:	srdi	r6,r5,4
-	mtocrf	0x01,r6
-
-6:	bf	cr7*4+1,7f
-err2;	ld	r0,0(r4)
-err2;	ld	r6,8(r4)
-err2;	ld	r8,16(r4)
-err2;	ld	r9,24(r4)
-err2;	ld	r10,32(r4)
-err2;	ld	r11,40(r4)
-err2;	ld	r12,48(r4)
-err2;	ld	r14,56(r4)
-	addi	r4,r4,64
-err2;	std	r0,0(r3)
-err2;	std	r6,8(r3)
-err2;	std	r8,16(r3)
-err2;	std	r9,24(r3)
-err2;	std	r10,32(r3)
-err2;	std	r11,40(r3)
-err2;	std	r12,48(r3)
-err2;	std	r14,56(r3)
-	addi	r3,r3,64
-	subi	r7,r7,64
-
-7:	ld	r14,STK_REG(R14)(r1)
-	ld	r15,STK_REG(R15)(r1)
-	ld	r16,STK_REG(R16)(r1)
-	ld	r17,STK_REG(R17)(r1)
-	ld	r18,STK_REG(R18)(r1)
-	ld	r19,STK_REG(R19)(r1)
-	ld	r20,STK_REG(R20)(r1)
-	ld	r21,STK_REG(R21)(r1)
-	ld	r22,STK_REG(R22)(r1)
-	addi	r1,r1,STACKFRAMESIZE
-
-	/* Up to 63B to go */
-	bf	cr7*4+2,8f
-err1;	ld	r0,0(r4)
-err1;	ld	r6,8(r4)
-err1;	ld	r8,16(r4)
-err1;	ld	r9,24(r4)
-	addi	r4,r4,32
-err1;	std	r0,0(r3)
-err1;	std	r6,8(r3)
-err1;	std	r8,16(r3)
-err1;	std	r9,24(r3)
-	addi	r3,r3,32
-	subi	r7,r7,32
-
-	/* Up to 31B to go */
-8:	bf	cr7*4+3,9f
-err1;	ld	r0,0(r4)
-err1;	ld	r6,8(r4)
-	addi	r4,r4,16
-err1;	std	r0,0(r3)
-err1;	std	r6,8(r3)
-	addi	r3,r3,16
-	subi	r7,r7,16
-
-9:	clrldi	r5,r5,(64-4)
-
-	/* Up to 15B to go */
-.Lshort_copy:
-	mtocrf	0x01,r5
-	bf	cr7*4+0,12f
-err1;	lwz	r0,0(r4)	/* Less chance of a reject with word ops */
-err1;	lwz	r6,4(r4)
-	addi	r4,r4,8
-err1;	stw	r0,0(r3)
-err1;	stw	r6,4(r3)
-	addi	r3,r3,8
-	subi	r7,r7,8
-
-12:	bf	cr7*4+1,13f
-err1;	lwz	r0,0(r4)
-	addi	r4,r4,4
-err1;	stw	r0,0(r3)
-	addi	r3,r3,4
-	subi	r7,r7,4
-
-13:	bf	cr7*4+2,14f
-err1;	lhz	r0,0(r4)
-	addi	r4,r4,2
-err1;	sth	r0,0(r3)
-	addi	r3,r3,2
-	subi	r7,r7,2
-
-14:	bf	cr7*4+3,15f
-err1;	lbz	r0,0(r4)
-err1;	stb	r0,0(r3)
-
-15:	li	r3,0
-	blr
-
-EXPORT_SYMBOL_GPL(copy_mc_generic);
+../../../../../arch/powerpc/lib/copy_mc_64.S
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/powerpc/copyloops/copyuser_64.S linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/copyloops/copyuser_64.S
--- linux-6.16.7/tools/testing/selftests/powerpc/copyloops/copyuser_64.S	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/copyloops/copyuser_64.S	2025-09-11 09:47:42.000000000 -0600
@@ -1,564 +1 @@
-/* SPDX-License-Identifier: GPL-2.0-or-later */
-/*
- * Copyright (C) 2002 Paul Mackerras, IBM Corp.
- */
-#include <linux/export.h>
-#include <asm/processor.h>
-#include <asm/ppc_asm.h>
-#include <asm/asm-compat.h>
-#include <asm/feature-fixups.h>
-
-#ifndef SELFTEST_CASE
-/* 0 == most CPUs, 1 == POWER6, 2 == Cell */
-#define SELFTEST_CASE	0
-#endif
-
-#ifdef __BIG_ENDIAN__
-#define sLd sld		/* Shift towards low-numbered address. */
-#define sHd srd		/* Shift towards high-numbered address. */
-#else
-#define sLd srd		/* Shift towards low-numbered address. */
-#define sHd sld		/* Shift towards high-numbered address. */
-#endif
-
-/*
- * These macros are used to generate exception table entries.
- * The exception handlers below use the original arguments
- * (stored on the stack) and the point where we're up to in
- * the destination buffer, i.e. the address of the first
- * unmodified byte.  Generally r3 points into the destination
- * buffer, but the first unmodified byte is at a variable
- * offset from r3.  In the code below, the symbol r3_offset
- * is set to indicate the current offset at each point in
- * the code.  This offset is then used as a negative offset
- * from the exception handler code, and those instructions
- * before the exception handlers are addi instructions that
- * adjust r3 to point to the correct place.
- */
-	.macro	lex		/* exception handler for load */
-100:	EX_TABLE(100b, .Lld_exc - r3_offset)
-	.endm
-
-	.macro	stex		/* exception handler for store */
-100:	EX_TABLE(100b, .Lst_exc - r3_offset)
-	.endm
-
-	.align	7
-_GLOBAL_TOC(__copy_tofrom_user)
-#ifdef CONFIG_PPC_BOOK3S_64
-BEGIN_FTR_SECTION
-	nop
-FTR_SECTION_ELSE
-	b	__copy_tofrom_user_power7
-ALT_FTR_SECTION_END_IFCLR(CPU_FTR_VMX_COPY)
-#endif
-_GLOBAL(__copy_tofrom_user_base)
-	/* first check for a 4kB copy on a 4kB boundary */
-	cmpldi	cr1,r5,16
-	cmpdi	cr6,r5,4096
-	or	r0,r3,r4
-	neg	r6,r3		/* LS 3 bits = # bytes to 8-byte dest bdry */
-	andi.	r0,r0,4095
-	std	r3,-24(r1)
-	crand	cr0*4+2,cr0*4+2,cr6*4+2
-	std	r4,-16(r1)
-	std	r5,-8(r1)
-	dcbt	0,r4
-	beq	.Lcopy_page_4K
-	andi.	r6,r6,7
-	PPC_MTOCRF(0x01,r5)
-	blt	cr1,.Lshort_copy
-/* Below we want to nop out the bne if we're on a CPU that has the
- * CPU_FTR_UNALIGNED_LD_STD bit set and the CPU_FTR_CP_USE_DCBTZ bit
- * cleared.
- * At the time of writing the only CPU that has this combination of bits
- * set is Power6.
- */
-test_feature = (SELFTEST_CASE == 1)
-BEGIN_FTR_SECTION
-	nop
-FTR_SECTION_ELSE
-	bne	.Ldst_unaligned
-ALT_FTR_SECTION_END(CPU_FTR_UNALIGNED_LD_STD | CPU_FTR_CP_USE_DCBTZ, \
-		    CPU_FTR_UNALIGNED_LD_STD)
-.Ldst_aligned:
-	addi	r3,r3,-16
-r3_offset = 16
-test_feature = (SELFTEST_CASE == 0)
-BEGIN_FTR_SECTION
-	andi.	r0,r4,7
-	bne	.Lsrc_unaligned
-END_FTR_SECTION_IFCLR(CPU_FTR_UNALIGNED_LD_STD)
-	blt	cr1,.Ldo_tail		/* if < 16 bytes to copy */
-	srdi	r0,r5,5
-	cmpdi	cr1,r0,0
-lex;	ld	r7,0(r4)
-lex;	ld	r6,8(r4)
-	addi	r4,r4,16
-	mtctr	r0
-	andi.	r0,r5,0x10
-	beq	22f
-	addi	r3,r3,16
-r3_offset = 0
-	addi	r4,r4,-16
-	mr	r9,r7
-	mr	r8,r6
-	beq	cr1,72f
-21:
-lex;	ld	r7,16(r4)
-lex;	ld	r6,24(r4)
-	addi	r4,r4,32
-stex;	std	r9,0(r3)
-r3_offset = 8
-stex;	std	r8,8(r3)
-r3_offset = 16
-22:
-lex;	ld	r9,0(r4)
-lex;	ld	r8,8(r4)
-stex;	std	r7,16(r3)
-r3_offset = 24
-stex;	std	r6,24(r3)
-	addi	r3,r3,32
-r3_offset = 0
-	bdnz	21b
-72:
-stex;	std	r9,0(r3)
-r3_offset = 8
-stex;	std	r8,8(r3)
-r3_offset = 16
-	andi.	r5,r5,0xf
-	beq+	3f
-	addi	r4,r4,16
-.Ldo_tail:
-	addi	r3,r3,16
-r3_offset = 0
-	bf	cr7*4+0,246f
-lex;	ld	r9,0(r4)
-	addi	r4,r4,8
-stex;	std	r9,0(r3)
-	addi	r3,r3,8
-246:	bf	cr7*4+1,1f
-lex;	lwz	r9,0(r4)
-	addi	r4,r4,4
-stex;	stw	r9,0(r3)
-	addi	r3,r3,4
-1:	bf	cr7*4+2,2f
-lex;	lhz	r9,0(r4)
-	addi	r4,r4,2
-stex;	sth	r9,0(r3)
-	addi	r3,r3,2
-2:	bf	cr7*4+3,3f
-lex;	lbz	r9,0(r4)
-stex;	stb	r9,0(r3)
-3:	li	r3,0
-	blr
-
-.Lsrc_unaligned:
-r3_offset = 16
-	srdi	r6,r5,3
-	addi	r5,r5,-16
-	subf	r4,r0,r4
-	srdi	r7,r5,4
-	sldi	r10,r0,3
-	cmpldi	cr6,r6,3
-	andi.	r5,r5,7
-	mtctr	r7
-	subfic	r11,r10,64
-	add	r5,r5,r0
-	bt	cr7*4+0,28f
-
-lex;	ld	r9,0(r4)	/* 3+2n loads, 2+2n stores */
-lex;	ld	r0,8(r4)
-	sLd	r6,r9,r10
-lex;	ldu	r9,16(r4)
-	sHd	r7,r0,r11
-	sLd	r8,r0,r10
-	or	r7,r7,r6
-	blt	cr6,79f
-lex;	ld	r0,8(r4)
-	b	2f
-
-28:
-lex;	ld	r0,0(r4)	/* 4+2n loads, 3+2n stores */
-lex;	ldu	r9,8(r4)
-	sLd	r8,r0,r10
-	addi	r3,r3,-8
-r3_offset = 24
-	blt	cr6,5f
-lex;	ld	r0,8(r4)
-	sHd	r12,r9,r11
-	sLd	r6,r9,r10
-lex;	ldu	r9,16(r4)
-	or	r12,r8,r12
-	sHd	r7,r0,r11
-	sLd	r8,r0,r10
-	addi	r3,r3,16
-r3_offset = 8
-	beq	cr6,78f
-
-1:	or	r7,r7,r6
-lex;	ld	r0,8(r4)
-stex;	std	r12,8(r3)
-r3_offset = 16
-2:	sHd	r12,r9,r11
-	sLd	r6,r9,r10
-lex;	ldu	r9,16(r4)
-	or	r12,r8,r12
-stex;	stdu	r7,16(r3)
-r3_offset = 8
-	sHd	r7,r0,r11
-	sLd	r8,r0,r10
-	bdnz	1b
-
-78:
-stex;	std	r12,8(r3)
-r3_offset = 16
-	or	r7,r7,r6
-79:
-stex;	std	r7,16(r3)
-r3_offset = 24
-5:	sHd	r12,r9,r11
-	or	r12,r8,r12
-stex;	std	r12,24(r3)
-r3_offset = 32
-	bne	6f
-	li	r3,0
-	blr
-6:	cmpwi	cr1,r5,8
-	addi	r3,r3,32
-r3_offset = 0
-	sLd	r9,r9,r10
-	ble	cr1,7f
-lex;	ld	r0,8(r4)
-	sHd	r7,r0,r11
-	or	r9,r7,r9
-7:
-	bf	cr7*4+1,1f
-#ifdef __BIG_ENDIAN__
-	rotldi	r9,r9,32
-#endif
-stex;	stw	r9,0(r3)
-#ifdef __LITTLE_ENDIAN__
-	rotrdi	r9,r9,32
-#endif
-	addi	r3,r3,4
-1:	bf	cr7*4+2,2f
-#ifdef __BIG_ENDIAN__
-	rotldi	r9,r9,16
-#endif
-stex;	sth	r9,0(r3)
-#ifdef __LITTLE_ENDIAN__
-	rotrdi	r9,r9,16
-#endif
-	addi	r3,r3,2
-2:	bf	cr7*4+3,3f
-#ifdef __BIG_ENDIAN__
-	rotldi	r9,r9,8
-#endif
-stex;	stb	r9,0(r3)
-#ifdef __LITTLE_ENDIAN__
-	rotrdi	r9,r9,8
-#endif
-3:	li	r3,0
-	blr
-
-.Ldst_unaligned:
-r3_offset = 0
-	PPC_MTOCRF(0x01,r6)		/* put #bytes to 8B bdry into cr7 */
-	subf	r5,r6,r5
-	li	r7,0
-	cmpldi	cr1,r5,16
-	bf	cr7*4+3,1f
-100:	EX_TABLE(100b, .Lld_exc_r7)
-	lbz	r0,0(r4)
-100:	EX_TABLE(100b, .Lst_exc_r7)
-	stb	r0,0(r3)
-	addi	r7,r7,1
-1:	bf	cr7*4+2,2f
-100:	EX_TABLE(100b, .Lld_exc_r7)
-	lhzx	r0,r7,r4
-100:	EX_TABLE(100b, .Lst_exc_r7)
-	sthx	r0,r7,r3
-	addi	r7,r7,2
-2:	bf	cr7*4+1,3f
-100:	EX_TABLE(100b, .Lld_exc_r7)
-	lwzx	r0,r7,r4
-100:	EX_TABLE(100b, .Lst_exc_r7)
-	stwx	r0,r7,r3
-3:	PPC_MTOCRF(0x01,r5)
-	add	r4,r6,r4
-	add	r3,r6,r3
-	b	.Ldst_aligned
-
-.Lshort_copy:
-r3_offset = 0
-	bf	cr7*4+0,1f
-lex;	lwz	r0,0(r4)
-lex;	lwz	r9,4(r4)
-	addi	r4,r4,8
-stex;	stw	r0,0(r3)
-stex;	stw	r9,4(r3)
-	addi	r3,r3,8
-1:	bf	cr7*4+1,2f
-lex;	lwz	r0,0(r4)
-	addi	r4,r4,4
-stex;	stw	r0,0(r3)
-	addi	r3,r3,4
-2:	bf	cr7*4+2,3f
-lex;	lhz	r0,0(r4)
-	addi	r4,r4,2
-stex;	sth	r0,0(r3)
-	addi	r3,r3,2
-3:	bf	cr7*4+3,4f
-lex;	lbz	r0,0(r4)
-stex;	stb	r0,0(r3)
-4:	li	r3,0
-	blr
-
-/*
- * exception handlers follow
- * we have to return the number of bytes not copied
- * for an exception on a load, we set the rest of the destination to 0
- * Note that the number of bytes of instructions for adjusting r3 needs
- * to equal the amount of the adjustment, due to the trick of using
- * .Lld_exc - r3_offset as the handler address.
- */
-
-.Lld_exc_r7:
-	add	r3,r3,r7
-	b	.Lld_exc
-
-	/* adjust by 24 */
-	addi	r3,r3,8
-	nop
-	/* adjust by 16 */
-	addi	r3,r3,8
-	nop
-	/* adjust by 8 */
-	addi	r3,r3,8
-	nop
-
-/*
- * Here we have had a fault on a load and r3 points to the first
- * unmodified byte of the destination.  We use the original arguments
- * and r3 to work out how much wasn't copied.  Since we load some
- * distance ahead of the stores, we continue copying byte-by-byte until
- * we hit the load fault again in order to copy as much as possible.
- */
-.Lld_exc:
-	ld	r6,-24(r1)
-	ld	r4,-16(r1)
-	ld	r5,-8(r1)
-	subf	r6,r6,r3
-	add	r4,r4,r6
-	subf	r5,r6,r5	/* #bytes left to go */
-
-/*
- * first see if we can copy any more bytes before hitting another exception
- */
-	mtctr	r5
-r3_offset = 0
-100:	EX_TABLE(100b, .Ldone)
-43:	lbz	r0,0(r4)
-	addi	r4,r4,1
-stex;	stb	r0,0(r3)
-	addi	r3,r3,1
-	bdnz	43b
-	li	r3,0		/* huh? all copied successfully this time? */
-	blr
-
-/*
- * here we have trapped again, amount remaining is in ctr.
- */
-.Ldone:
-	mfctr	r3
-	blr
-
-/*
- * exception handlers for stores: we need to work out how many bytes
- * weren't copied, and we may need to copy some more.
- * Note that the number of bytes of instructions for adjusting r3 needs
- * to equal the amount of the adjustment, due to the trick of using
- * .Lst_exc - r3_offset as the handler address.
- */
-.Lst_exc_r7:
-	add	r3,r3,r7
-	b	.Lst_exc
-
-	/* adjust by 24 */
-	addi	r3,r3,8
-	nop
-	/* adjust by 16 */
-	addi	r3,r3,8
-	nop
-	/* adjust by 8 */
-	addi	r3,r3,4
-	/* adjust by 4 */
-	addi	r3,r3,4
-.Lst_exc:
-	ld	r6,-24(r1)	/* original destination pointer */
-	ld	r4,-16(r1)	/* original source pointer */
-	ld	r5,-8(r1)	/* original number of bytes */
-	add	r7,r6,r5
-	/*
-	 * If the destination pointer isn't 8-byte aligned,
-	 * we may have got the exception as a result of a
-	 * store that overlapped a page boundary, so we may be
-	 * able to copy a few more bytes.
-	 */
-17:	andi.	r0,r3,7
-	beq	19f
-	subf	r8,r6,r3	/* #bytes copied */
-100:	EX_TABLE(100b,19f)
-	lbzx	r0,r8,r4
-100:	EX_TABLE(100b,19f)
-	stb	r0,0(r3)
-	addi	r3,r3,1
-	cmpld	r3,r7
-	blt	17b
-19:	subf	r3,r3,r7	/* #bytes not copied in r3 */
-	blr
-
-/*
- * Routine to copy a whole page of data, optimized for POWER4.
- * On POWER4 it is more than 50% faster than the simple loop
- * above (following the .Ldst_aligned label).
- */
-	.macro	exc
-100:	EX_TABLE(100b, .Labort)
-	.endm
-.Lcopy_page_4K:
-	std	r31,-32(1)
-	std	r30,-40(1)
-	std	r29,-48(1)
-	std	r28,-56(1)
-	std	r27,-64(1)
-	std	r26,-72(1)
-	std	r25,-80(1)
-	std	r24,-88(1)
-	std	r23,-96(1)
-	std	r22,-104(1)
-	std	r21,-112(1)
-	std	r20,-120(1)
-	li	r5,4096/32 - 1
-	addi	r3,r3,-8
-	li	r0,5
-0:	addi	r5,r5,-24
-	mtctr	r0
-exc;	ld	r22,640(4)
-exc;	ld	r21,512(4)
-exc;	ld	r20,384(4)
-exc;	ld	r11,256(4)
-exc;	ld	r9,128(4)
-exc;	ld	r7,0(4)
-exc;	ld	r25,648(4)
-exc;	ld	r24,520(4)
-exc;	ld	r23,392(4)
-exc;	ld	r10,264(4)
-exc;	ld	r8,136(4)
-exc;	ldu	r6,8(4)
-	cmpwi	r5,24
-1:
-exc;	std	r22,648(3)
-exc;	std	r21,520(3)
-exc;	std	r20,392(3)
-exc;	std	r11,264(3)
-exc;	std	r9,136(3)
-exc;	std	r7,8(3)
-exc;	ld	r28,648(4)
-exc;	ld	r27,520(4)
-exc;	ld	r26,392(4)
-exc;	ld	r31,264(4)
-exc;	ld	r30,136(4)
-exc;	ld	r29,8(4)
-exc;	std	r25,656(3)
-exc;	std	r24,528(3)
-exc;	std	r23,400(3)
-exc;	std	r10,272(3)
-exc;	std	r8,144(3)
-exc;	std	r6,16(3)
-exc;	ld	r22,656(4)
-exc;	ld	r21,528(4)
-exc;	ld	r20,400(4)
-exc;	ld	r11,272(4)
-exc;	ld	r9,144(4)
-exc;	ld	r7,16(4)
-exc;	std	r28,664(3)
-exc;	std	r27,536(3)
-exc;	std	r26,408(3)
-exc;	std	r31,280(3)
-exc;	std	r30,152(3)
-exc;	stdu	r29,24(3)
-exc;	ld	r25,664(4)
-exc;	ld	r24,536(4)
-exc;	ld	r23,408(4)
-exc;	ld	r10,280(4)
-exc;	ld	r8,152(4)
-exc;	ldu	r6,24(4)
-	bdnz	1b
-exc;	std	r22,648(3)
-exc;	std	r21,520(3)
-exc;	std	r20,392(3)
-exc;	std	r11,264(3)
-exc;	std	r9,136(3)
-exc;	std	r7,8(3)
-	addi	r4,r4,640
-	addi	r3,r3,648
-	bge	0b
-	mtctr	r5
-exc;	ld	r7,0(4)
-exc;	ld	r8,8(4)
-exc;	ldu	r9,16(4)
-3:
-exc;	ld	r10,8(4)
-exc;	std	r7,8(3)
-exc;	ld	r7,16(4)
-exc;	std	r8,16(3)
-exc;	ld	r8,24(4)
-exc;	std	r9,24(3)
-exc;	ldu	r9,32(4)
-exc;	stdu	r10,32(3)
-	bdnz	3b
-4:
-exc;	ld	r10,8(4)
-exc;	std	r7,8(3)
-exc;	std	r8,16(3)
-exc;	std	r9,24(3)
-exc;	std	r10,32(3)
-9:	ld	r20,-120(1)
-	ld	r21,-112(1)
-	ld	r22,-104(1)
-	ld	r23,-96(1)
-	ld	r24,-88(1)
-	ld	r25,-80(1)
-	ld	r26,-72(1)
-	ld	r27,-64(1)
-	ld	r28,-56(1)
-	ld	r29,-48(1)
-	ld	r30,-40(1)
-	ld	r31,-32(1)
-	li	r3,0
-	blr
-
-/*
- * on an exception, reset to the beginning and jump back into the
- * standard __copy_tofrom_user
- */
-.Labort:
-	ld	r20,-120(1)
-	ld	r21,-112(1)
-	ld	r22,-104(1)
-	ld	r23,-96(1)
-	ld	r24,-88(1)
-	ld	r25,-80(1)
-	ld	r26,-72(1)
-	ld	r27,-64(1)
-	ld	r28,-56(1)
-	ld	r29,-48(1)
-	ld	r30,-40(1)
-	ld	r31,-32(1)
-	ld	r3,-24(r1)
-	ld	r4,-16(r1)
-	li	r5,4096
-	b	.Ldst_aligned
-EXPORT_SYMBOL(__copy_tofrom_user)
+../../../../../arch/powerpc/lib/copyuser_64.S
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/powerpc/copyloops/copyuser_power7.S linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/copyloops/copyuser_power7.S
--- linux-6.16.7/tools/testing/selftests/powerpc/copyloops/copyuser_power7.S	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/copyloops/copyuser_power7.S	2025-09-11 09:47:42.000000000 -0600
@@ -1,685 +1 @@
-/* SPDX-License-Identifier: GPL-2.0-or-later */
-/*
- *
- * Copyright (C) IBM Corporation, 2011
- *
- * Author: Anton Blanchard <anton@au.ibm.com>
- */
-#include <asm/ppc_asm.h>
-
-#ifndef SELFTEST_CASE
-/* 0 == don't use VMX, 1 == use VMX */
-#define SELFTEST_CASE	0
-#endif
-
-#ifdef __BIG_ENDIAN__
-#define LVS(VRT,RA,RB)		lvsl	VRT,RA,RB
-#define VPERM(VRT,VRA,VRB,VRC)	vperm	VRT,VRA,VRB,VRC
-#else
-#define LVS(VRT,RA,RB)		lvsr	VRT,RA,RB
-#define VPERM(VRT,VRA,VRB,VRC)	vperm	VRT,VRB,VRA,VRC
-#endif
-
-	.macro err1
-100:
-	EX_TABLE(100b,.Ldo_err1)
-	.endm
-
-	.macro err2
-200:
-	EX_TABLE(200b,.Ldo_err2)
-	.endm
-
-#ifdef CONFIG_ALTIVEC
-	.macro err3
-300:
-	EX_TABLE(300b,.Ldo_err3)
-	.endm
-
-	.macro err4
-400:
-	EX_TABLE(400b,.Ldo_err4)
-	.endm
-
-
-.Ldo_err4:
-	ld	r16,STK_REG(R16)(r1)
-	ld	r15,STK_REG(R15)(r1)
-	ld	r14,STK_REG(R14)(r1)
-.Ldo_err3:
-	bl	CFUNC(exit_vmx_usercopy)
-	ld	r0,STACKFRAMESIZE+16(r1)
-	mtlr	r0
-	b	.Lexit
-#endif /* CONFIG_ALTIVEC */
-
-.Ldo_err2:
-	ld	r22,STK_REG(R22)(r1)
-	ld	r21,STK_REG(R21)(r1)
-	ld	r20,STK_REG(R20)(r1)
-	ld	r19,STK_REG(R19)(r1)
-	ld	r18,STK_REG(R18)(r1)
-	ld	r17,STK_REG(R17)(r1)
-	ld	r16,STK_REG(R16)(r1)
-	ld	r15,STK_REG(R15)(r1)
-	ld	r14,STK_REG(R14)(r1)
-.Lexit:
-	addi	r1,r1,STACKFRAMESIZE
-.Ldo_err1:
-	ld	r3,-STACKFRAMESIZE+STK_REG(R31)(r1)
-	ld	r4,-STACKFRAMESIZE+STK_REG(R30)(r1)
-	ld	r5,-STACKFRAMESIZE+STK_REG(R29)(r1)
-	b	__copy_tofrom_user_base
-
-
-_GLOBAL(__copy_tofrom_user_power7)
-	cmpldi	r5,16
-	cmpldi	cr1,r5,3328
-
-	std	r3,-STACKFRAMESIZE+STK_REG(R31)(r1)
-	std	r4,-STACKFRAMESIZE+STK_REG(R30)(r1)
-	std	r5,-STACKFRAMESIZE+STK_REG(R29)(r1)
-
-	blt	.Lshort_copy
-
-#ifdef CONFIG_ALTIVEC
-test_feature = SELFTEST_CASE
-BEGIN_FTR_SECTION
-	bgt	cr1,.Lvmx_copy
-END_FTR_SECTION_IFSET(CPU_FTR_ALTIVEC)
-#endif
-
-.Lnonvmx_copy:
-	/* Get the source 8B aligned */
-	neg	r6,r4
-	mtocrf	0x01,r6
-	clrldi	r6,r6,(64-3)
-
-	bf	cr7*4+3,1f
-err1;	lbz	r0,0(r4)
-	addi	r4,r4,1
-err1;	stb	r0,0(r3)
-	addi	r3,r3,1
-
-1:	bf	cr7*4+2,2f
-err1;	lhz	r0,0(r4)
-	addi	r4,r4,2
-err1;	sth	r0,0(r3)
-	addi	r3,r3,2
-
-2:	bf	cr7*4+1,3f
-err1;	lwz	r0,0(r4)
-	addi	r4,r4,4
-err1;	stw	r0,0(r3)
-	addi	r3,r3,4
-
-3:	sub	r5,r5,r6
-	cmpldi	r5,128
-	blt	5f
-
-	mflr	r0
-	stdu	r1,-STACKFRAMESIZE(r1)
-	std	r14,STK_REG(R14)(r1)
-	std	r15,STK_REG(R15)(r1)
-	std	r16,STK_REG(R16)(r1)
-	std	r17,STK_REG(R17)(r1)
-	std	r18,STK_REG(R18)(r1)
-	std	r19,STK_REG(R19)(r1)
-	std	r20,STK_REG(R20)(r1)
-	std	r21,STK_REG(R21)(r1)
-	std	r22,STK_REG(R22)(r1)
-	std	r0,STACKFRAMESIZE+16(r1)
-
-	srdi	r6,r5,7
-	mtctr	r6
-
-	/* Now do cacheline (128B) sized loads and stores. */
-	.align	5
-4:
-err2;	ld	r0,0(r4)
-err2;	ld	r6,8(r4)
-err2;	ld	r7,16(r4)
-err2;	ld	r8,24(r4)
-err2;	ld	r9,32(r4)
-err2;	ld	r10,40(r4)
-err2;	ld	r11,48(r4)
-err2;	ld	r12,56(r4)
-err2;	ld	r14,64(r4)
-err2;	ld	r15,72(r4)
-err2;	ld	r16,80(r4)
-err2;	ld	r17,88(r4)
-err2;	ld	r18,96(r4)
-err2;	ld	r19,104(r4)
-err2;	ld	r20,112(r4)
-err2;	ld	r21,120(r4)
-	addi	r4,r4,128
-err2;	std	r0,0(r3)
-err2;	std	r6,8(r3)
-err2;	std	r7,16(r3)
-err2;	std	r8,24(r3)
-err2;	std	r9,32(r3)
-err2;	std	r10,40(r3)
-err2;	std	r11,48(r3)
-err2;	std	r12,56(r3)
-err2;	std	r14,64(r3)
-err2;	std	r15,72(r3)
-err2;	std	r16,80(r3)
-err2;	std	r17,88(r3)
-err2;	std	r18,96(r3)
-err2;	std	r19,104(r3)
-err2;	std	r20,112(r3)
-err2;	std	r21,120(r3)
-	addi	r3,r3,128
-	bdnz	4b
-
-	clrldi	r5,r5,(64-7)
-
-	ld	r14,STK_REG(R14)(r1)
-	ld	r15,STK_REG(R15)(r1)
-	ld	r16,STK_REG(R16)(r1)
-	ld	r17,STK_REG(R17)(r1)
-	ld	r18,STK_REG(R18)(r1)
-	ld	r19,STK_REG(R19)(r1)
-	ld	r20,STK_REG(R20)(r1)
-	ld	r21,STK_REG(R21)(r1)
-	ld	r22,STK_REG(R22)(r1)
-	addi	r1,r1,STACKFRAMESIZE
-
-	/* Up to 127B to go */
-5:	srdi	r6,r5,4
-	mtocrf	0x01,r6
-
-6:	bf	cr7*4+1,7f
-err1;	ld	r0,0(r4)
-err1;	ld	r6,8(r4)
-err1;	ld	r7,16(r4)
-err1;	ld	r8,24(r4)
-err1;	ld	r9,32(r4)
-err1;	ld	r10,40(r4)
-err1;	ld	r11,48(r4)
-err1;	ld	r12,56(r4)
-	addi	r4,r4,64
-err1;	std	r0,0(r3)
-err1;	std	r6,8(r3)
-err1;	std	r7,16(r3)
-err1;	std	r8,24(r3)
-err1;	std	r9,32(r3)
-err1;	std	r10,40(r3)
-err1;	std	r11,48(r3)
-err1;	std	r12,56(r3)
-	addi	r3,r3,64
-
-	/* Up to 63B to go */
-7:	bf	cr7*4+2,8f
-err1;	ld	r0,0(r4)
-err1;	ld	r6,8(r4)
-err1;	ld	r7,16(r4)
-err1;	ld	r8,24(r4)
-	addi	r4,r4,32
-err1;	std	r0,0(r3)
-err1;	std	r6,8(r3)
-err1;	std	r7,16(r3)
-err1;	std	r8,24(r3)
-	addi	r3,r3,32
-
-	/* Up to 31B to go */
-8:	bf	cr7*4+3,9f
-err1;	ld	r0,0(r4)
-err1;	ld	r6,8(r4)
-	addi	r4,r4,16
-err1;	std	r0,0(r3)
-err1;	std	r6,8(r3)
-	addi	r3,r3,16
-
-9:	clrldi	r5,r5,(64-4)
-
-	/* Up to 15B to go */
-.Lshort_copy:
-	mtocrf	0x01,r5
-	bf	cr7*4+0,12f
-err1;	lwz	r0,0(r4)	/* Less chance of a reject with word ops */
-err1;	lwz	r6,4(r4)
-	addi	r4,r4,8
-err1;	stw	r0,0(r3)
-err1;	stw	r6,4(r3)
-	addi	r3,r3,8
-
-12:	bf	cr7*4+1,13f
-err1;	lwz	r0,0(r4)
-	addi	r4,r4,4
-err1;	stw	r0,0(r3)
-	addi	r3,r3,4
-
-13:	bf	cr7*4+2,14f
-err1;	lhz	r0,0(r4)
-	addi	r4,r4,2
-err1;	sth	r0,0(r3)
-	addi	r3,r3,2
-
-14:	bf	cr7*4+3,15f
-err1;	lbz	r0,0(r4)
-err1;	stb	r0,0(r3)
-
-15:	li	r3,0
-	blr
-
-.Lunwind_stack_nonvmx_copy:
-	addi	r1,r1,STACKFRAMESIZE
-	b	.Lnonvmx_copy
-
-.Lvmx_copy:
-#ifdef CONFIG_ALTIVEC
-	mflr	r0
-	std	r0,16(r1)
-	stdu	r1,-STACKFRAMESIZE(r1)
-	bl	CFUNC(enter_vmx_usercopy)
-	cmpwi	cr1,r3,0
-	ld	r0,STACKFRAMESIZE+16(r1)
-	ld	r3,STK_REG(R31)(r1)
-	ld	r4,STK_REG(R30)(r1)
-	ld	r5,STK_REG(R29)(r1)
-	mtlr	r0
-
-	/*
-	 * We prefetch both the source and destination using enhanced touch
-	 * instructions. We use a stream ID of 0 for the load side and
-	 * 1 for the store side.
-	 */
-	clrrdi	r6,r4,7
-	clrrdi	r9,r3,7
-	ori	r9,r9,1		/* stream=1 */
-
-	srdi	r7,r5,7		/* length in cachelines, capped at 0x3FF */
-	cmpldi	r7,0x3FF
-	ble	1f
-	li	r7,0x3FF
-1:	lis	r0,0x0E00	/* depth=7 */
-	sldi	r7,r7,7
-	or	r7,r7,r0
-	ori	r10,r7,1	/* stream=1 */
-
-	DCBT_SETUP_STREAMS(r6, r7, r9, r10, r8)
-
-	beq	cr1,.Lunwind_stack_nonvmx_copy
-
-	/*
-	 * If source and destination are not relatively aligned we use a
-	 * slower permute loop.
-	 */
-	xor	r6,r4,r3
-	rldicl.	r6,r6,0,(64-4)
-	bne	.Lvmx_unaligned_copy
-
-	/* Get the destination 16B aligned */
-	neg	r6,r3
-	mtocrf	0x01,r6
-	clrldi	r6,r6,(64-4)
-
-	bf	cr7*4+3,1f
-err3;	lbz	r0,0(r4)
-	addi	r4,r4,1
-err3;	stb	r0,0(r3)
-	addi	r3,r3,1
-
-1:	bf	cr7*4+2,2f
-err3;	lhz	r0,0(r4)
-	addi	r4,r4,2
-err3;	sth	r0,0(r3)
-	addi	r3,r3,2
-
-2:	bf	cr7*4+1,3f
-err3;	lwz	r0,0(r4)
-	addi	r4,r4,4
-err3;	stw	r0,0(r3)
-	addi	r3,r3,4
-
-3:	bf	cr7*4+0,4f
-err3;	ld	r0,0(r4)
-	addi	r4,r4,8
-err3;	std	r0,0(r3)
-	addi	r3,r3,8
-
-4:	sub	r5,r5,r6
-
-	/* Get the desination 128B aligned */
-	neg	r6,r3
-	srdi	r7,r6,4
-	mtocrf	0x01,r7
-	clrldi	r6,r6,(64-7)
-
-	li	r9,16
-	li	r10,32
-	li	r11,48
-
-	bf	cr7*4+3,5f
-err3;	lvx	v1,0,r4
-	addi	r4,r4,16
-err3;	stvx	v1,0,r3
-	addi	r3,r3,16
-
-5:	bf	cr7*4+2,6f
-err3;	lvx	v1,0,r4
-err3;	lvx	v0,r4,r9
-	addi	r4,r4,32
-err3;	stvx	v1,0,r3
-err3;	stvx	v0,r3,r9
-	addi	r3,r3,32
-
-6:	bf	cr7*4+1,7f
-err3;	lvx	v3,0,r4
-err3;	lvx	v2,r4,r9
-err3;	lvx	v1,r4,r10
-err3;	lvx	v0,r4,r11
-	addi	r4,r4,64
-err3;	stvx	v3,0,r3
-err3;	stvx	v2,r3,r9
-err3;	stvx	v1,r3,r10
-err3;	stvx	v0,r3,r11
-	addi	r3,r3,64
-
-7:	sub	r5,r5,r6
-	srdi	r6,r5,7
-
-	std	r14,STK_REG(R14)(r1)
-	std	r15,STK_REG(R15)(r1)
-	std	r16,STK_REG(R16)(r1)
-
-	li	r12,64
-	li	r14,80
-	li	r15,96
-	li	r16,112
-
-	mtctr	r6
-
-	/*
-	 * Now do cacheline sized loads and stores. By this stage the
-	 * cacheline stores are also cacheline aligned.
-	 */
-	.align	5
-8:
-err4;	lvx	v7,0,r4
-err4;	lvx	v6,r4,r9
-err4;	lvx	v5,r4,r10
-err4;	lvx	v4,r4,r11
-err4;	lvx	v3,r4,r12
-err4;	lvx	v2,r4,r14
-err4;	lvx	v1,r4,r15
-err4;	lvx	v0,r4,r16
-	addi	r4,r4,128
-err4;	stvx	v7,0,r3
-err4;	stvx	v6,r3,r9
-err4;	stvx	v5,r3,r10
-err4;	stvx	v4,r3,r11
-err4;	stvx	v3,r3,r12
-err4;	stvx	v2,r3,r14
-err4;	stvx	v1,r3,r15
-err4;	stvx	v0,r3,r16
-	addi	r3,r3,128
-	bdnz	8b
-
-	ld	r14,STK_REG(R14)(r1)
-	ld	r15,STK_REG(R15)(r1)
-	ld	r16,STK_REG(R16)(r1)
-
-	/* Up to 127B to go */
-	clrldi	r5,r5,(64-7)
-	srdi	r6,r5,4
-	mtocrf	0x01,r6
-
-	bf	cr7*4+1,9f
-err3;	lvx	v3,0,r4
-err3;	lvx	v2,r4,r9
-err3;	lvx	v1,r4,r10
-err3;	lvx	v0,r4,r11
-	addi	r4,r4,64
-err3;	stvx	v3,0,r3
-err3;	stvx	v2,r3,r9
-err3;	stvx	v1,r3,r10
-err3;	stvx	v0,r3,r11
-	addi	r3,r3,64
-
-9:	bf	cr7*4+2,10f
-err3;	lvx	v1,0,r4
-err3;	lvx	v0,r4,r9
-	addi	r4,r4,32
-err3;	stvx	v1,0,r3
-err3;	stvx	v0,r3,r9
-	addi	r3,r3,32
-
-10:	bf	cr7*4+3,11f
-err3;	lvx	v1,0,r4
-	addi	r4,r4,16
-err3;	stvx	v1,0,r3
-	addi	r3,r3,16
-
-	/* Up to 15B to go */
-11:	clrldi	r5,r5,(64-4)
-	mtocrf	0x01,r5
-	bf	cr7*4+0,12f
-err3;	ld	r0,0(r4)
-	addi	r4,r4,8
-err3;	std	r0,0(r3)
-	addi	r3,r3,8
-
-12:	bf	cr7*4+1,13f
-err3;	lwz	r0,0(r4)
-	addi	r4,r4,4
-err3;	stw	r0,0(r3)
-	addi	r3,r3,4
-
-13:	bf	cr7*4+2,14f
-err3;	lhz	r0,0(r4)
-	addi	r4,r4,2
-err3;	sth	r0,0(r3)
-	addi	r3,r3,2
-
-14:	bf	cr7*4+3,15f
-err3;	lbz	r0,0(r4)
-err3;	stb	r0,0(r3)
-
-15:	addi	r1,r1,STACKFRAMESIZE
-	b	CFUNC(exit_vmx_usercopy)	/* tail call optimise */
-
-.Lvmx_unaligned_copy:
-	/* Get the destination 16B aligned */
-	neg	r6,r3
-	mtocrf	0x01,r6
-	clrldi	r6,r6,(64-4)
-
-	bf	cr7*4+3,1f
-err3;	lbz	r0,0(r4)
-	addi	r4,r4,1
-err3;	stb	r0,0(r3)
-	addi	r3,r3,1
-
-1:	bf	cr7*4+2,2f
-err3;	lhz	r0,0(r4)
-	addi	r4,r4,2
-err3;	sth	r0,0(r3)
-	addi	r3,r3,2
-
-2:	bf	cr7*4+1,3f
-err3;	lwz	r0,0(r4)
-	addi	r4,r4,4
-err3;	stw	r0,0(r3)
-	addi	r3,r3,4
-
-3:	bf	cr7*4+0,4f
-err3;	lwz	r0,0(r4)	/* Less chance of a reject with word ops */
-err3;	lwz	r7,4(r4)
-	addi	r4,r4,8
-err3;	stw	r0,0(r3)
-err3;	stw	r7,4(r3)
-	addi	r3,r3,8
-
-4:	sub	r5,r5,r6
-
-	/* Get the desination 128B aligned */
-	neg	r6,r3
-	srdi	r7,r6,4
-	mtocrf	0x01,r7
-	clrldi	r6,r6,(64-7)
-
-	li	r9,16
-	li	r10,32
-	li	r11,48
-
-	LVS(v16,0,r4)		/* Setup permute control vector */
-err3;	lvx	v0,0,r4
-	addi	r4,r4,16
-
-	bf	cr7*4+3,5f
-err3;	lvx	v1,0,r4
-	VPERM(v8,v0,v1,v16)
-	addi	r4,r4,16
-err3;	stvx	v8,0,r3
-	addi	r3,r3,16
-	vor	v0,v1,v1
-
-5:	bf	cr7*4+2,6f
-err3;	lvx	v1,0,r4
-	VPERM(v8,v0,v1,v16)
-err3;	lvx	v0,r4,r9
-	VPERM(v9,v1,v0,v16)
-	addi	r4,r4,32
-err3;	stvx	v8,0,r3
-err3;	stvx	v9,r3,r9
-	addi	r3,r3,32
-
-6:	bf	cr7*4+1,7f
-err3;	lvx	v3,0,r4
-	VPERM(v8,v0,v3,v16)
-err3;	lvx	v2,r4,r9
-	VPERM(v9,v3,v2,v16)
-err3;	lvx	v1,r4,r10
-	VPERM(v10,v2,v1,v16)
-err3;	lvx	v0,r4,r11
-	VPERM(v11,v1,v0,v16)
-	addi	r4,r4,64
-err3;	stvx	v8,0,r3
-err3;	stvx	v9,r3,r9
-err3;	stvx	v10,r3,r10
-err3;	stvx	v11,r3,r11
-	addi	r3,r3,64
-
-7:	sub	r5,r5,r6
-	srdi	r6,r5,7
-
-	std	r14,STK_REG(R14)(r1)
-	std	r15,STK_REG(R15)(r1)
-	std	r16,STK_REG(R16)(r1)
-
-	li	r12,64
-	li	r14,80
-	li	r15,96
-	li	r16,112
-
-	mtctr	r6
-
-	/*
-	 * Now do cacheline sized loads and stores. By this stage the
-	 * cacheline stores are also cacheline aligned.
-	 */
-	.align	5
-8:
-err4;	lvx	v7,0,r4
-	VPERM(v8,v0,v7,v16)
-err4;	lvx	v6,r4,r9
-	VPERM(v9,v7,v6,v16)
-err4;	lvx	v5,r4,r10
-	VPERM(v10,v6,v5,v16)
-err4;	lvx	v4,r4,r11
-	VPERM(v11,v5,v4,v16)
-err4;	lvx	v3,r4,r12
-	VPERM(v12,v4,v3,v16)
-err4;	lvx	v2,r4,r14
-	VPERM(v13,v3,v2,v16)
-err4;	lvx	v1,r4,r15
-	VPERM(v14,v2,v1,v16)
-err4;	lvx	v0,r4,r16
-	VPERM(v15,v1,v0,v16)
-	addi	r4,r4,128
-err4;	stvx	v8,0,r3
-err4;	stvx	v9,r3,r9
-err4;	stvx	v10,r3,r10
-err4;	stvx	v11,r3,r11
-err4;	stvx	v12,r3,r12
-err4;	stvx	v13,r3,r14
-err4;	stvx	v14,r3,r15
-err4;	stvx	v15,r3,r16
-	addi	r3,r3,128
-	bdnz	8b
-
-	ld	r14,STK_REG(R14)(r1)
-	ld	r15,STK_REG(R15)(r1)
-	ld	r16,STK_REG(R16)(r1)
-
-	/* Up to 127B to go */
-	clrldi	r5,r5,(64-7)
-	srdi	r6,r5,4
-	mtocrf	0x01,r6
-
-	bf	cr7*4+1,9f
-err3;	lvx	v3,0,r4
-	VPERM(v8,v0,v3,v16)
-err3;	lvx	v2,r4,r9
-	VPERM(v9,v3,v2,v16)
-err3;	lvx	v1,r4,r10
-	VPERM(v10,v2,v1,v16)
-err3;	lvx	v0,r4,r11
-	VPERM(v11,v1,v0,v16)
-	addi	r4,r4,64
-err3;	stvx	v8,0,r3
-err3;	stvx	v9,r3,r9
-err3;	stvx	v10,r3,r10
-err3;	stvx	v11,r3,r11
-	addi	r3,r3,64
-
-9:	bf	cr7*4+2,10f
-err3;	lvx	v1,0,r4
-	VPERM(v8,v0,v1,v16)
-err3;	lvx	v0,r4,r9
-	VPERM(v9,v1,v0,v16)
-	addi	r4,r4,32
-err3;	stvx	v8,0,r3
-err3;	stvx	v9,r3,r9
-	addi	r3,r3,32
-
-10:	bf	cr7*4+3,11f
-err3;	lvx	v1,0,r4
-	VPERM(v8,v0,v1,v16)
-	addi	r4,r4,16
-err3;	stvx	v8,0,r3
-	addi	r3,r3,16
-
-	/* Up to 15B to go */
-11:	clrldi	r5,r5,(64-4)
-	addi	r4,r4,-16	/* Unwind the +16 load offset */
-	mtocrf	0x01,r5
-	bf	cr7*4+0,12f
-err3;	lwz	r0,0(r4)	/* Less chance of a reject with word ops */
-err3;	lwz	r6,4(r4)
-	addi	r4,r4,8
-err3;	stw	r0,0(r3)
-err3;	stw	r6,4(r3)
-	addi	r3,r3,8
-
-12:	bf	cr7*4+1,13f
-err3;	lwz	r0,0(r4)
-	addi	r4,r4,4
-err3;	stw	r0,0(r3)
-	addi	r3,r3,4
-
-13:	bf	cr7*4+2,14f
-err3;	lhz	r0,0(r4)
-	addi	r4,r4,2
-err3;	sth	r0,0(r3)
-	addi	r3,r3,2
-
-14:	bf	cr7*4+3,15f
-err3;	lbz	r0,0(r4)
-err3;	stb	r0,0(r3)
-
-15:	addi	r1,r1,STACKFRAMESIZE
-	b	CFUNC(exit_vmx_usercopy)	/* tail call optimise */
-#endif /* CONFIG_ALTIVEC */
+../../../../../arch/powerpc/lib/copyuser_power7.S
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/powerpc/copyloops/mem_64.S linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/copyloops/mem_64.S
--- linux-6.16.7/tools/testing/selftests/powerpc/copyloops/mem_64.S	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/copyloops/mem_64.S	2025-09-11 09:47:42.000000000 -0600
@@ -1,142 +1 @@
-/* SPDX-License-Identifier: GPL-2.0-or-later */
-/*
- * String handling functions for PowerPC.
- *
- * Copyright (C) 1996 Paul Mackerras.
- */
-#include <linux/export.h>
-#include <asm/processor.h>
-#include <asm/errno.h>
-#include <asm/ppc_asm.h>
-#include <asm/kasan.h>
-
-#ifndef CONFIG_KASAN
-_GLOBAL(__memset16)
-	rlwimi	r4,r4,16,0,15
-	/* fall through */
-
-_GLOBAL(__memset32)
-	rldimi	r4,r4,32,0
-	/* fall through */
-
-_GLOBAL(__memset64)
-	neg	r0,r3
-	andi.	r0,r0,7
-	cmplw	cr1,r5,r0
-	b	.Lms
-EXPORT_SYMBOL(__memset16)
-EXPORT_SYMBOL(__memset32)
-EXPORT_SYMBOL(__memset64)
-#endif
-
-_GLOBAL_KASAN(memset)
-	neg	r0,r3
-	rlwimi	r4,r4,8,16,23
-	andi.	r0,r0,7			/* # bytes to be 8-byte aligned */
-	rlwimi	r4,r4,16,0,15
-	cmplw	cr1,r5,r0		/* do we get that far? */
-	rldimi	r4,r4,32,0
-.Lms:	PPC_MTOCRF(1,r0)
-	mr	r6,r3
-	blt	cr1,8f
-	beq	3f			/* if already 8-byte aligned */
-	subf	r5,r0,r5
-	bf	31,1f
-	stb	r4,0(r6)
-	addi	r6,r6,1
-1:	bf	30,2f
-	sth	r4,0(r6)
-	addi	r6,r6,2
-2:	bf	29,3f
-	stw	r4,0(r6)
-	addi	r6,r6,4
-3:	srdi.	r0,r5,6
-	clrldi	r5,r5,58
-	mtctr	r0
-	beq	5f
-	.balign 16
-4:	std	r4,0(r6)
-	std	r4,8(r6)
-	std	r4,16(r6)
-	std	r4,24(r6)
-	std	r4,32(r6)
-	std	r4,40(r6)
-	std	r4,48(r6)
-	std	r4,56(r6)
-	addi	r6,r6,64
-	bdnz	4b
-5:	srwi.	r0,r5,3
-	clrlwi	r5,r5,29
-	PPC_MTOCRF(1,r0)
-	beq	8f
-	bf	29,6f
-	std	r4,0(r6)
-	std	r4,8(r6)
-	std	r4,16(r6)
-	std	r4,24(r6)
-	addi	r6,r6,32
-6:	bf	30,7f
-	std	r4,0(r6)
-	std	r4,8(r6)
-	addi	r6,r6,16
-7:	bf	31,8f
-	std	r4,0(r6)
-	addi	r6,r6,8
-8:	cmpwi	r5,0
-	PPC_MTOCRF(1,r5)
-	beqlr
-	bf	29,9f
-	stw	r4,0(r6)
-	addi	r6,r6,4
-9:	bf	30,10f
-	sth	r4,0(r6)
-	addi	r6,r6,2
-10:	bflr	31
-	stb	r4,0(r6)
-	blr
-EXPORT_SYMBOL(memset)
-EXPORT_SYMBOL_KASAN(memset)
-
-_GLOBAL_TOC_KASAN(memmove)
-	cmplw	0,r3,r4
-	bgt	backwards_memcpy
-	b	memcpy
-
-_GLOBAL(backwards_memcpy)
-	rlwinm.	r7,r5,32-3,3,31		/* r0 = r5 >> 3 */
-	add	r6,r3,r5
-	add	r4,r4,r5
-	beq	2f
-	andi.	r0,r6,3
-	mtctr	r7
-	bne	5f
-	.balign 16
-1:	lwz	r7,-4(r4)
-	lwzu	r8,-8(r4)
-	stw	r7,-4(r6)
-	stwu	r8,-8(r6)
-	bdnz	1b
-	andi.	r5,r5,7
-2:	cmplwi	0,r5,4
-	blt	3f
-	lwzu	r0,-4(r4)
-	subi	r5,r5,4
-	stwu	r0,-4(r6)
-3:	cmpwi	0,r5,0
-	beqlr
-	mtctr	r5
-4:	lbzu	r0,-1(r4)
-	stbu	r0,-1(r6)
-	bdnz	4b
-	blr
-5:	mtctr	r0
-6:	lbzu	r7,-1(r4)
-	stbu	r7,-1(r6)
-	bdnz	6b
-	subf	r5,r0,r5
-	rlwinm.	r7,r5,32-3,3,31
-	beq	2b
-	mtctr	r7
-	b	1b
-EXPORT_SYMBOL(memmove)
-EXPORT_SYMBOL_KASAN(memmove)
+../../../../../arch/powerpc/lib/mem_64.S
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/powerpc/copyloops/memcpy_64.S linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/copyloops/memcpy_64.S
--- linux-6.16.7/tools/testing/selftests/powerpc/copyloops/memcpy_64.S	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/copyloops/memcpy_64.S	2025-09-11 09:47:42.000000000 -0600
@@ -1,230 +1 @@
-/* SPDX-License-Identifier: GPL-2.0-or-later */
-/*
- * Copyright (C) 2002 Paul Mackerras, IBM Corp.
- */
-#include <linux/export.h>
-#include <asm/processor.h>
-#include <asm/ppc_asm.h>
-#include <asm/asm-compat.h>
-#include <asm/feature-fixups.h>
-#include <asm/kasan.h>
-
-#ifndef SELFTEST_CASE
-/* For big-endian, 0 == most CPUs, 1 == POWER6, 2 == Cell */
-#define SELFTEST_CASE	0
-#endif
-
-	.align	7
-_GLOBAL_TOC_KASAN(memcpy)
-BEGIN_FTR_SECTION
-#ifdef __LITTLE_ENDIAN__
-	cmpdi	cr7,r5,0
-#else
-	std	r3,-STACKFRAMESIZE+STK_REG(R31)(r1)	/* save destination pointer for return value */
-#endif
-FTR_SECTION_ELSE
-#ifdef CONFIG_PPC_BOOK3S_64
-	b	memcpy_power7
-#endif
-ALT_FTR_SECTION_END_IFCLR(CPU_FTR_VMX_COPY)
-#ifdef __LITTLE_ENDIAN__
-	/* dumb little-endian memcpy that will get replaced at runtime */
-	addi r9,r3,-1
-	addi r4,r4,-1
-	beqlr cr7
-	mtctr r5
-1:	lbzu r10,1(r4)
-	stbu r10,1(r9)
-	bdnz 1b
-	blr
-#else
-	PPC_MTOCRF(0x01,r5)
-	cmpldi	cr1,r5,16
-	neg	r6,r3		# LS 3 bits = # bytes to 8-byte dest bdry
-	andi.	r6,r6,7
-	dcbt	0,r4
-	blt	cr1,.Lshort_copy
-/* Below we want to nop out the bne if we're on a CPU that has the
-   CPU_FTR_UNALIGNED_LD_STD bit set and the CPU_FTR_CP_USE_DCBTZ bit
-   cleared.
-   At the time of writing the only CPU that has this combination of bits
-   set is Power6. */
-test_feature = (SELFTEST_CASE == 1)
-BEGIN_FTR_SECTION
-	nop
-FTR_SECTION_ELSE
-	bne	.Ldst_unaligned
-ALT_FTR_SECTION_END(CPU_FTR_UNALIGNED_LD_STD | CPU_FTR_CP_USE_DCBTZ, \
-                    CPU_FTR_UNALIGNED_LD_STD)
-.Ldst_aligned:
-	addi	r3,r3,-16
-test_feature = (SELFTEST_CASE == 0)
-BEGIN_FTR_SECTION
-	andi.	r0,r4,7
-	bne	.Lsrc_unaligned
-END_FTR_SECTION_IFCLR(CPU_FTR_UNALIGNED_LD_STD)
-	srdi	r7,r5,4
-	ld	r9,0(r4)
-	addi	r4,r4,-8
-	mtctr	r7
-	andi.	r5,r5,7
-	bf	cr7*4+0,2f
-	addi	r3,r3,8
-	addi	r4,r4,8
-	mr	r8,r9
-	blt	cr1,3f
-1:	ld	r9,8(r4)
-	std	r8,8(r3)
-2:	ldu	r8,16(r4)
-	stdu	r9,16(r3)
-	bdnz	1b
-3:	std	r8,8(r3)
-	beq	3f
-	addi	r3,r3,16
-.Ldo_tail:
-	bf	cr7*4+1,1f
-	lwz	r9,8(r4)
-	addi	r4,r4,4
-	stw	r9,0(r3)
-	addi	r3,r3,4
-1:	bf	cr7*4+2,2f
-	lhz	r9,8(r4)
-	addi	r4,r4,2
-	sth	r9,0(r3)
-	addi	r3,r3,2
-2:	bf	cr7*4+3,3f
-	lbz	r9,8(r4)
-	stb	r9,0(r3)
-3:	ld	r3,-STACKFRAMESIZE+STK_REG(R31)(r1)	/* return dest pointer */
-	blr
-
-.Lsrc_unaligned:
-	srdi	r6,r5,3
-	addi	r5,r5,-16
-	subf	r4,r0,r4
-	srdi	r7,r5,4
-	sldi	r10,r0,3
-	cmpdi	cr6,r6,3
-	andi.	r5,r5,7
-	mtctr	r7
-	subfic	r11,r10,64
-	add	r5,r5,r0
-
-	bt	cr7*4+0,0f
-
-	ld	r9,0(r4)	# 3+2n loads, 2+2n stores
-	ld	r0,8(r4)
-	sld	r6,r9,r10
-	ldu	r9,16(r4)
-	srd	r7,r0,r11
-	sld	r8,r0,r10
-	or	r7,r7,r6
-	blt	cr6,4f
-	ld	r0,8(r4)
-	# s1<< in r8, d0=(s0<<|s1>>) in r7, s3 in r0, s2 in r9, nix in r6 & r12
-	b	2f
-
-0:	ld	r0,0(r4)	# 4+2n loads, 3+2n stores
-	ldu	r9,8(r4)
-	sld	r8,r0,r10
-	addi	r3,r3,-8
-	blt	cr6,5f
-	ld	r0,8(r4)
-	srd	r12,r9,r11
-	sld	r6,r9,r10
-	ldu	r9,16(r4)
-	or	r12,r8,r12
-	srd	r7,r0,r11
-	sld	r8,r0,r10
-	addi	r3,r3,16
-	beq	cr6,3f
-
-	# d0=(s0<<|s1>>) in r12, s1<< in r6, s2>> in r7, s2<< in r8, s3 in r9
-1:	or	r7,r7,r6
-	ld	r0,8(r4)
-	std	r12,8(r3)
-2:	srd	r12,r9,r11
-	sld	r6,r9,r10
-	ldu	r9,16(r4)
-	or	r12,r8,r12
-	stdu	r7,16(r3)
-	srd	r7,r0,r11
-	sld	r8,r0,r10
-	bdnz	1b
-
-3:	std	r12,8(r3)
-	or	r7,r7,r6
-4:	std	r7,16(r3)
-5:	srd	r12,r9,r11
-	or	r12,r8,r12
-	std	r12,24(r3)
-	beq	4f
-	cmpwi	cr1,r5,8
-	addi	r3,r3,32
-	sld	r9,r9,r10
-	ble	cr1,6f
-	ld	r0,8(r4)
-	srd	r7,r0,r11
-	or	r9,r7,r9
-6:
-	bf	cr7*4+1,1f
-	rotldi	r9,r9,32
-	stw	r9,0(r3)
-	addi	r3,r3,4
-1:	bf	cr7*4+2,2f
-	rotldi	r9,r9,16
-	sth	r9,0(r3)
-	addi	r3,r3,2
-2:	bf	cr7*4+3,3f
-	rotldi	r9,r9,8
-	stb	r9,0(r3)
-3:	ld	r3,-STACKFRAMESIZE+STK_REG(R31)(r1)	/* return dest pointer */
-	blr
-
-.Ldst_unaligned:
-	PPC_MTOCRF(0x01,r6)		# put #bytes to 8B bdry into cr7
-	subf	r5,r6,r5
-	li	r7,0
-	cmpldi	cr1,r5,16
-	bf	cr7*4+3,1f
-	lbz	r0,0(r4)
-	stb	r0,0(r3)
-	addi	r7,r7,1
-1:	bf	cr7*4+2,2f
-	lhzx	r0,r7,r4
-	sthx	r0,r7,r3
-	addi	r7,r7,2
-2:	bf	cr7*4+1,3f
-	lwzx	r0,r7,r4
-	stwx	r0,r7,r3
-3:	PPC_MTOCRF(0x01,r5)
-	add	r4,r6,r4
-	add	r3,r6,r3
-	b	.Ldst_aligned
-
-.Lshort_copy:
-	bf	cr7*4+0,1f
-	lwz	r0,0(r4)
-	lwz	r9,4(r4)
-	addi	r4,r4,8
-	stw	r0,0(r3)
-	stw	r9,4(r3)
-	addi	r3,r3,8
-1:	bf	cr7*4+1,2f
-	lwz	r0,0(r4)
-	addi	r4,r4,4
-	stw	r0,0(r3)
-	addi	r3,r3,4
-2:	bf	cr7*4+2,3f
-	lhz	r0,0(r4)
-	addi	r4,r4,2
-	sth	r0,0(r3)
-	addi	r3,r3,2
-3:	bf	cr7*4+3,4f
-	lbz	r0,0(r4)
-	stb	r0,0(r3)
-4:	ld	r3,-STACKFRAMESIZE+STK_REG(R31)(r1)	/* return dest pointer */
-	blr
-#endif
-EXPORT_SYMBOL(memcpy)
-EXPORT_SYMBOL_KASAN(memcpy)
+../../../../../arch/powerpc/lib/memcpy_64.S
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/powerpc/copyloops/memcpy_power7.S linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/copyloops/memcpy_power7.S
--- linux-6.16.7/tools/testing/selftests/powerpc/copyloops/memcpy_power7.S	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/copyloops/memcpy_power7.S	2025-09-11 09:47:42.000000000 -0600
@@ -1,633 +1 @@
-/* SPDX-License-Identifier: GPL-2.0-or-later */
-/*
- *
- * Copyright (C) IBM Corporation, 2012
- *
- * Author: Anton Blanchard <anton@au.ibm.com>
- */
-#include <asm/ppc_asm.h>
-
-#ifndef SELFTEST_CASE
-/* 0 == don't use VMX, 1 == use VMX */
-#define SELFTEST_CASE	0
-#endif
-
-#ifdef __BIG_ENDIAN__
-#define LVS(VRT,RA,RB)		lvsl	VRT,RA,RB
-#define VPERM(VRT,VRA,VRB,VRC)	vperm	VRT,VRA,VRB,VRC
-#else
-#define LVS(VRT,RA,RB)		lvsr	VRT,RA,RB
-#define VPERM(VRT,VRA,VRB,VRC)	vperm	VRT,VRB,VRA,VRC
-#endif
-
-_GLOBAL(memcpy_power7)
-	cmpldi	r5,16
-	cmpldi	cr1,r5,4096
-	std	r3,-STACKFRAMESIZE+STK_REG(R31)(r1)
-	blt	.Lshort_copy
-
-#ifdef CONFIG_ALTIVEC
-test_feature = SELFTEST_CASE
-BEGIN_FTR_SECTION
-	bgt	cr1, .Lvmx_copy
-END_FTR_SECTION_IFSET(CPU_FTR_ALTIVEC)
-#endif
-
-.Lnonvmx_copy:
-	/* Get the source 8B aligned */
-	neg	r6,r4
-	mtocrf	0x01,r6
-	clrldi	r6,r6,(64-3)
-
-	bf	cr7*4+3,1f
-	lbz	r0,0(r4)
-	addi	r4,r4,1
-	stb	r0,0(r3)
-	addi	r3,r3,1
-
-1:	bf	cr7*4+2,2f
-	lhz	r0,0(r4)
-	addi	r4,r4,2
-	sth	r0,0(r3)
-	addi	r3,r3,2
-
-2:	bf	cr7*4+1,3f
-	lwz	r0,0(r4)
-	addi	r4,r4,4
-	stw	r0,0(r3)
-	addi	r3,r3,4
-
-3:	sub	r5,r5,r6
-	cmpldi	r5,128
-	blt	5f
-
-	mflr	r0
-	stdu	r1,-STACKFRAMESIZE(r1)
-	std	r14,STK_REG(R14)(r1)
-	std	r15,STK_REG(R15)(r1)
-	std	r16,STK_REG(R16)(r1)
-	std	r17,STK_REG(R17)(r1)
-	std	r18,STK_REG(R18)(r1)
-	std	r19,STK_REG(R19)(r1)
-	std	r20,STK_REG(R20)(r1)
-	std	r21,STK_REG(R21)(r1)
-	std	r22,STK_REG(R22)(r1)
-	std	r0,STACKFRAMESIZE+16(r1)
-
-	srdi	r6,r5,7
-	mtctr	r6
-
-	/* Now do cacheline (128B) sized loads and stores. */
-	.align	5
-4:
-	ld	r0,0(r4)
-	ld	r6,8(r4)
-	ld	r7,16(r4)
-	ld	r8,24(r4)
-	ld	r9,32(r4)
-	ld	r10,40(r4)
-	ld	r11,48(r4)
-	ld	r12,56(r4)
-	ld	r14,64(r4)
-	ld	r15,72(r4)
-	ld	r16,80(r4)
-	ld	r17,88(r4)
-	ld	r18,96(r4)
-	ld	r19,104(r4)
-	ld	r20,112(r4)
-	ld	r21,120(r4)
-	addi	r4,r4,128
-	std	r0,0(r3)
-	std	r6,8(r3)
-	std	r7,16(r3)
-	std	r8,24(r3)
-	std	r9,32(r3)
-	std	r10,40(r3)
-	std	r11,48(r3)
-	std	r12,56(r3)
-	std	r14,64(r3)
-	std	r15,72(r3)
-	std	r16,80(r3)
-	std	r17,88(r3)
-	std	r18,96(r3)
-	std	r19,104(r3)
-	std	r20,112(r3)
-	std	r21,120(r3)
-	addi	r3,r3,128
-	bdnz	4b
-
-	clrldi	r5,r5,(64-7)
-
-	ld	r14,STK_REG(R14)(r1)
-	ld	r15,STK_REG(R15)(r1)
-	ld	r16,STK_REG(R16)(r1)
-	ld	r17,STK_REG(R17)(r1)
-	ld	r18,STK_REG(R18)(r1)
-	ld	r19,STK_REG(R19)(r1)
-	ld	r20,STK_REG(R20)(r1)
-	ld	r21,STK_REG(R21)(r1)
-	ld	r22,STK_REG(R22)(r1)
-	addi	r1,r1,STACKFRAMESIZE
-
-	/* Up to 127B to go */
-5:	srdi	r6,r5,4
-	mtocrf	0x01,r6
-
-6:	bf	cr7*4+1,7f
-	ld	r0,0(r4)
-	ld	r6,8(r4)
-	ld	r7,16(r4)
-	ld	r8,24(r4)
-	ld	r9,32(r4)
-	ld	r10,40(r4)
-	ld	r11,48(r4)
-	ld	r12,56(r4)
-	addi	r4,r4,64
-	std	r0,0(r3)
-	std	r6,8(r3)
-	std	r7,16(r3)
-	std	r8,24(r3)
-	std	r9,32(r3)
-	std	r10,40(r3)
-	std	r11,48(r3)
-	std	r12,56(r3)
-	addi	r3,r3,64
-
-	/* Up to 63B to go */
-7:	bf	cr7*4+2,8f
-	ld	r0,0(r4)
-	ld	r6,8(r4)
-	ld	r7,16(r4)
-	ld	r8,24(r4)
-	addi	r4,r4,32
-	std	r0,0(r3)
-	std	r6,8(r3)
-	std	r7,16(r3)
-	std	r8,24(r3)
-	addi	r3,r3,32
-
-	/* Up to 31B to go */
-8:	bf	cr7*4+3,9f
-	ld	r0,0(r4)
-	ld	r6,8(r4)
-	addi	r4,r4,16
-	std	r0,0(r3)
-	std	r6,8(r3)
-	addi	r3,r3,16
-
-9:	clrldi	r5,r5,(64-4)
-
-	/* Up to 15B to go */
-.Lshort_copy:
-	mtocrf	0x01,r5
-	bf	cr7*4+0,12f
-	lwz	r0,0(r4)	/* Less chance of a reject with word ops */
-	lwz	r6,4(r4)
-	addi	r4,r4,8
-	stw	r0,0(r3)
-	stw	r6,4(r3)
-	addi	r3,r3,8
-
-12:	bf	cr7*4+1,13f
-	lwz	r0,0(r4)
-	addi	r4,r4,4
-	stw	r0,0(r3)
-	addi	r3,r3,4
-
-13:	bf	cr7*4+2,14f
-	lhz	r0,0(r4)
-	addi	r4,r4,2
-	sth	r0,0(r3)
-	addi	r3,r3,2
-
-14:	bf	cr7*4+3,15f
-	lbz	r0,0(r4)
-	stb	r0,0(r3)
-
-15:	ld	r3,-STACKFRAMESIZE+STK_REG(R31)(r1)
-	blr
-
-.Lunwind_stack_nonvmx_copy:
-	addi	r1,r1,STACKFRAMESIZE
-	b	.Lnonvmx_copy
-
-.Lvmx_copy:
-#ifdef CONFIG_ALTIVEC
-	mflr	r0
-	std	r4,-STACKFRAMESIZE+STK_REG(R30)(r1)
-	std	r5,-STACKFRAMESIZE+STK_REG(R29)(r1)
-	std	r0,16(r1)
-	stdu	r1,-STACKFRAMESIZE(r1)
-	bl	CFUNC(enter_vmx_ops)
-	cmpwi	cr1,r3,0
-	ld	r0,STACKFRAMESIZE+16(r1)
-	ld	r3,STK_REG(R31)(r1)
-	ld	r4,STK_REG(R30)(r1)
-	ld	r5,STK_REG(R29)(r1)
-	mtlr	r0
-
-	/*
-	 * We prefetch both the source and destination using enhanced touch
-	 * instructions. We use a stream ID of 0 for the load side and
-	 * 1 for the store side.
-	 */
-	clrrdi	r6,r4,7
-	clrrdi	r9,r3,7
-	ori	r9,r9,1		/* stream=1 */
-
-	srdi	r7,r5,7		/* length in cachelines, capped at 0x3FF */
-	cmpldi	r7,0x3FF
-	ble	1f
-	li	r7,0x3FF
-1:	lis	r0,0x0E00	/* depth=7 */
-	sldi	r7,r7,7
-	or	r7,r7,r0
-	ori	r10,r7,1	/* stream=1 */
-
-	DCBT_SETUP_STREAMS(r6, r7, r9, r10, r8)
-
-	beq	cr1,.Lunwind_stack_nonvmx_copy
-
-	/*
-	 * If source and destination are not relatively aligned we use a
-	 * slower permute loop.
-	 */
-	xor	r6,r4,r3
-	rldicl.	r6,r6,0,(64-4)
-	bne	.Lvmx_unaligned_copy
-
-	/* Get the destination 16B aligned */
-	neg	r6,r3
-	mtocrf	0x01,r6
-	clrldi	r6,r6,(64-4)
-
-	bf	cr7*4+3,1f
-	lbz	r0,0(r4)
-	addi	r4,r4,1
-	stb	r0,0(r3)
-	addi	r3,r3,1
-
-1:	bf	cr7*4+2,2f
-	lhz	r0,0(r4)
-	addi	r4,r4,2
-	sth	r0,0(r3)
-	addi	r3,r3,2
-
-2:	bf	cr7*4+1,3f
-	lwz	r0,0(r4)
-	addi	r4,r4,4
-	stw	r0,0(r3)
-	addi	r3,r3,4
-
-3:	bf	cr7*4+0,4f
-	ld	r0,0(r4)
-	addi	r4,r4,8
-	std	r0,0(r3)
-	addi	r3,r3,8
-
-4:	sub	r5,r5,r6
-
-	/* Get the desination 128B aligned */
-	neg	r6,r3
-	srdi	r7,r6,4
-	mtocrf	0x01,r7
-	clrldi	r6,r6,(64-7)
-
-	li	r9,16
-	li	r10,32
-	li	r11,48
-
-	bf	cr7*4+3,5f
-	lvx	v1,0,r4
-	addi	r4,r4,16
-	stvx	v1,0,r3
-	addi	r3,r3,16
-
-5:	bf	cr7*4+2,6f
-	lvx	v1,0,r4
-	lvx	v0,r4,r9
-	addi	r4,r4,32
-	stvx	v1,0,r3
-	stvx	v0,r3,r9
-	addi	r3,r3,32
-
-6:	bf	cr7*4+1,7f
-	lvx	v3,0,r4
-	lvx	v2,r4,r9
-	lvx	v1,r4,r10
-	lvx	v0,r4,r11
-	addi	r4,r4,64
-	stvx	v3,0,r3
-	stvx	v2,r3,r9
-	stvx	v1,r3,r10
-	stvx	v0,r3,r11
-	addi	r3,r3,64
-
-7:	sub	r5,r5,r6
-	srdi	r6,r5,7
-
-	std	r14,STK_REG(R14)(r1)
-	std	r15,STK_REG(R15)(r1)
-	std	r16,STK_REG(R16)(r1)
-
-	li	r12,64
-	li	r14,80
-	li	r15,96
-	li	r16,112
-
-	mtctr	r6
-
-	/*
-	 * Now do cacheline sized loads and stores. By this stage the
-	 * cacheline stores are also cacheline aligned.
-	 */
-	.align	5
-8:
-	lvx	v7,0,r4
-	lvx	v6,r4,r9
-	lvx	v5,r4,r10
-	lvx	v4,r4,r11
-	lvx	v3,r4,r12
-	lvx	v2,r4,r14
-	lvx	v1,r4,r15
-	lvx	v0,r4,r16
-	addi	r4,r4,128
-	stvx	v7,0,r3
-	stvx	v6,r3,r9
-	stvx	v5,r3,r10
-	stvx	v4,r3,r11
-	stvx	v3,r3,r12
-	stvx	v2,r3,r14
-	stvx	v1,r3,r15
-	stvx	v0,r3,r16
-	addi	r3,r3,128
-	bdnz	8b
-
-	ld	r14,STK_REG(R14)(r1)
-	ld	r15,STK_REG(R15)(r1)
-	ld	r16,STK_REG(R16)(r1)
-
-	/* Up to 127B to go */
-	clrldi	r5,r5,(64-7)
-	srdi	r6,r5,4
-	mtocrf	0x01,r6
-
-	bf	cr7*4+1,9f
-	lvx	v3,0,r4
-	lvx	v2,r4,r9
-	lvx	v1,r4,r10
-	lvx	v0,r4,r11
-	addi	r4,r4,64
-	stvx	v3,0,r3
-	stvx	v2,r3,r9
-	stvx	v1,r3,r10
-	stvx	v0,r3,r11
-	addi	r3,r3,64
-
-9:	bf	cr7*4+2,10f
-	lvx	v1,0,r4
-	lvx	v0,r4,r9
-	addi	r4,r4,32
-	stvx	v1,0,r3
-	stvx	v0,r3,r9
-	addi	r3,r3,32
-
-10:	bf	cr7*4+3,11f
-	lvx	v1,0,r4
-	addi	r4,r4,16
-	stvx	v1,0,r3
-	addi	r3,r3,16
-
-	/* Up to 15B to go */
-11:	clrldi	r5,r5,(64-4)
-	mtocrf	0x01,r5
-	bf	cr7*4+0,12f
-	ld	r0,0(r4)
-	addi	r4,r4,8
-	std	r0,0(r3)
-	addi	r3,r3,8
-
-12:	bf	cr7*4+1,13f
-	lwz	r0,0(r4)
-	addi	r4,r4,4
-	stw	r0,0(r3)
-	addi	r3,r3,4
-
-13:	bf	cr7*4+2,14f
-	lhz	r0,0(r4)
-	addi	r4,r4,2
-	sth	r0,0(r3)
-	addi	r3,r3,2
-
-14:	bf	cr7*4+3,15f
-	lbz	r0,0(r4)
-	stb	r0,0(r3)
-
-15:	addi	r1,r1,STACKFRAMESIZE
-	ld	r3,-STACKFRAMESIZE+STK_REG(R31)(r1)
-	b	CFUNC(exit_vmx_ops)		/* tail call optimise */
-
-.Lvmx_unaligned_copy:
-	/* Get the destination 16B aligned */
-	neg	r6,r3
-	mtocrf	0x01,r6
-	clrldi	r6,r6,(64-4)
-
-	bf	cr7*4+3,1f
-	lbz	r0,0(r4)
-	addi	r4,r4,1
-	stb	r0,0(r3)
-	addi	r3,r3,1
-
-1:	bf	cr7*4+2,2f
-	lhz	r0,0(r4)
-	addi	r4,r4,2
-	sth	r0,0(r3)
-	addi	r3,r3,2
-
-2:	bf	cr7*4+1,3f
-	lwz	r0,0(r4)
-	addi	r4,r4,4
-	stw	r0,0(r3)
-	addi	r3,r3,4
-
-3:	bf	cr7*4+0,4f
-	lwz	r0,0(r4)	/* Less chance of a reject with word ops */
-	lwz	r7,4(r4)
-	addi	r4,r4,8
-	stw	r0,0(r3)
-	stw	r7,4(r3)
-	addi	r3,r3,8
-
-4:	sub	r5,r5,r6
-
-	/* Get the desination 128B aligned */
-	neg	r6,r3
-	srdi	r7,r6,4
-	mtocrf	0x01,r7
-	clrldi	r6,r6,(64-7)
-
-	li	r9,16
-	li	r10,32
-	li	r11,48
-
-	LVS(v16,0,r4)		/* Setup permute control vector */
-	lvx	v0,0,r4
-	addi	r4,r4,16
-
-	bf	cr7*4+3,5f
-	lvx	v1,0,r4
-	VPERM(v8,v0,v1,v16)
-	addi	r4,r4,16
-	stvx	v8,0,r3
-	addi	r3,r3,16
-	vor	v0,v1,v1
-
-5:	bf	cr7*4+2,6f
-	lvx	v1,0,r4
-	VPERM(v8,v0,v1,v16)
-	lvx	v0,r4,r9
-	VPERM(v9,v1,v0,v16)
-	addi	r4,r4,32
-	stvx	v8,0,r3
-	stvx	v9,r3,r9
-	addi	r3,r3,32
-
-6:	bf	cr7*4+1,7f
-	lvx	v3,0,r4
-	VPERM(v8,v0,v3,v16)
-	lvx	v2,r4,r9
-	VPERM(v9,v3,v2,v16)
-	lvx	v1,r4,r10
-	VPERM(v10,v2,v1,v16)
-	lvx	v0,r4,r11
-	VPERM(v11,v1,v0,v16)
-	addi	r4,r4,64
-	stvx	v8,0,r3
-	stvx	v9,r3,r9
-	stvx	v10,r3,r10
-	stvx	v11,r3,r11
-	addi	r3,r3,64
-
-7:	sub	r5,r5,r6
-	srdi	r6,r5,7
-
-	std	r14,STK_REG(R14)(r1)
-	std	r15,STK_REG(R15)(r1)
-	std	r16,STK_REG(R16)(r1)
-
-	li	r12,64
-	li	r14,80
-	li	r15,96
-	li	r16,112
-
-	mtctr	r6
-
-	/*
-	 * Now do cacheline sized loads and stores. By this stage the
-	 * cacheline stores are also cacheline aligned.
-	 */
-	.align	5
-8:
-	lvx	v7,0,r4
-	VPERM(v8,v0,v7,v16)
-	lvx	v6,r4,r9
-	VPERM(v9,v7,v6,v16)
-	lvx	v5,r4,r10
-	VPERM(v10,v6,v5,v16)
-	lvx	v4,r4,r11
-	VPERM(v11,v5,v4,v16)
-	lvx	v3,r4,r12
-	VPERM(v12,v4,v3,v16)
-	lvx	v2,r4,r14
-	VPERM(v13,v3,v2,v16)
-	lvx	v1,r4,r15
-	VPERM(v14,v2,v1,v16)
-	lvx	v0,r4,r16
-	VPERM(v15,v1,v0,v16)
-	addi	r4,r4,128
-	stvx	v8,0,r3
-	stvx	v9,r3,r9
-	stvx	v10,r3,r10
-	stvx	v11,r3,r11
-	stvx	v12,r3,r12
-	stvx	v13,r3,r14
-	stvx	v14,r3,r15
-	stvx	v15,r3,r16
-	addi	r3,r3,128
-	bdnz	8b
-
-	ld	r14,STK_REG(R14)(r1)
-	ld	r15,STK_REG(R15)(r1)
-	ld	r16,STK_REG(R16)(r1)
-
-	/* Up to 127B to go */
-	clrldi	r5,r5,(64-7)
-	srdi	r6,r5,4
-	mtocrf	0x01,r6
-
-	bf	cr7*4+1,9f
-	lvx	v3,0,r4
-	VPERM(v8,v0,v3,v16)
-	lvx	v2,r4,r9
-	VPERM(v9,v3,v2,v16)
-	lvx	v1,r4,r10
-	VPERM(v10,v2,v1,v16)
-	lvx	v0,r4,r11
-	VPERM(v11,v1,v0,v16)
-	addi	r4,r4,64
-	stvx	v8,0,r3
-	stvx	v9,r3,r9
-	stvx	v10,r3,r10
-	stvx	v11,r3,r11
-	addi	r3,r3,64
-
-9:	bf	cr7*4+2,10f
-	lvx	v1,0,r4
-	VPERM(v8,v0,v1,v16)
-	lvx	v0,r4,r9
-	VPERM(v9,v1,v0,v16)
-	addi	r4,r4,32
-	stvx	v8,0,r3
-	stvx	v9,r3,r9
-	addi	r3,r3,32
-
-10:	bf	cr7*4+3,11f
-	lvx	v1,0,r4
-	VPERM(v8,v0,v1,v16)
-	addi	r4,r4,16
-	stvx	v8,0,r3
-	addi	r3,r3,16
-
-	/* Up to 15B to go */
-11:	clrldi	r5,r5,(64-4)
-	addi	r4,r4,-16	/* Unwind the +16 load offset */
-	mtocrf	0x01,r5
-	bf	cr7*4+0,12f
-	lwz	r0,0(r4)	/* Less chance of a reject with word ops */
-	lwz	r6,4(r4)
-	addi	r4,r4,8
-	stw	r0,0(r3)
-	stw	r6,4(r3)
-	addi	r3,r3,8
-
-12:	bf	cr7*4+1,13f
-	lwz	r0,0(r4)
-	addi	r4,r4,4
-	stw	r0,0(r3)
-	addi	r3,r3,4
-
-13:	bf	cr7*4+2,14f
-	lhz	r0,0(r4)
-	addi	r4,r4,2
-	sth	r0,0(r3)
-	addi	r3,r3,2
-
-14:	bf	cr7*4+3,15f
-	lbz	r0,0(r4)
-	stb	r0,0(r3)
-
-15:	addi	r1,r1,STACKFRAMESIZE
-	ld	r3,-STACKFRAMESIZE+STK_REG(R31)(r1)
-	b	CFUNC(exit_vmx_ops)		/* tail call optimise */
-#endif /* CONFIG_ALTIVEC */
+../../../../../arch/powerpc/lib/memcpy_power7.S
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/powerpc/mce/vas-api.h linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/mce/vas-api.h
--- linux-6.16.7/tools/testing/selftests/powerpc/mce/vas-api.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/mce/vas-api.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,28 +1 @@
-/* SPDX-License-Identifier: GPL-2.0+ WITH Linux-syscall-note */
-/*
- * Copyright 2019 IBM Corp.
- */
-
-#ifndef _UAPI_MISC_VAS_H
-#define _UAPI_MISC_VAS_H
-
-#include <linux/types.h>
-
-#include <asm/ioctl.h>
-
-#define VAS_MAGIC	'v'
-#define VAS_TX_WIN_OPEN	_IOW(VAS_MAGIC, 0x20, struct vas_tx_win_open_attr)
-
-/* Flags to VAS TX open window ioctl */
-/* To allocate a window with QoS credit, otherwise use default credit */
-#define VAS_TX_WIN_FLAG_QOS_CREDIT	0x0000000000000001
-
-struct vas_tx_win_open_attr {
-	__u32	version;
-	__s16	vas_id;	/* specific instance of vas or -1 for default */
-	__u16	reserved1;
-	__u64	flags;
-	__u64	reserved2[6];
-};
-
-#endif /* _UAPI_MISC_VAS_H */
+../../../../../arch/powerpc/include/uapi/asm/vas-api.h
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/powerpc/nx-gzip/include/vas-api.h linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/nx-gzip/include/vas-api.h
--- linux-6.16.7/tools/testing/selftests/powerpc/nx-gzip/include/vas-api.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/nx-gzip/include/vas-api.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,28 +1 @@
-/* SPDX-License-Identifier: GPL-2.0+ WITH Linux-syscall-note */
-/*
- * Copyright 2019 IBM Corp.
- */
-
-#ifndef _UAPI_MISC_VAS_H
-#define _UAPI_MISC_VAS_H
-
-#include <linux/types.h>
-
-#include <asm/ioctl.h>
-
-#define VAS_MAGIC	'v'
-#define VAS_TX_WIN_OPEN	_IOW(VAS_MAGIC, 0x20, struct vas_tx_win_open_attr)
-
-/* Flags to VAS TX open window ioctl */
-/* To allocate a window with QoS credit, otherwise use default credit */
-#define VAS_TX_WIN_FLAG_QOS_CREDIT	0x0000000000000001
-
-struct vas_tx_win_open_attr {
-	__u32	version;
-	__s16	vas_id;	/* specific instance of vas or -1 for default */
-	__u16	reserved1;
-	__u64	flags;
-	__u64	reserved2[6];
-};
-
-#endif /* _UAPI_MISC_VAS_H */
+../../../../../../arch/powerpc/include/uapi/asm/vas-api.h
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/powerpc/primitives/asm/asm-compat.h linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/primitives/asm/asm-compat.h
--- linux-6.16.7/tools/testing/selftests/powerpc/primitives/asm/asm-compat.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/primitives/asm/asm-compat.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,68 +1 @@
-#ifndef _ASM_POWERPC_ASM_COMPAT_H
-#define _ASM_POWERPC_ASM_COMPAT_H
-
-#include <asm/asm-const.h>
-#include <asm/types.h>
-#include <asm/ppc-opcode.h>
-
-#ifdef __powerpc64__
-
-/* operations for longs and pointers */
-#define PPC_LL		stringify_in_c(ld)
-#define PPC_STL		stringify_in_c(std)
-#define PPC_STLU	stringify_in_c(stdu)
-#define PPC_LCMPI	stringify_in_c(cmpdi)
-#define PPC_LCMPLI	stringify_in_c(cmpldi)
-#define PPC_LCMP	stringify_in_c(cmpd)
-#define PPC_LONG	stringify_in_c(.8byte)
-#define PPC_LONG_ALIGN	stringify_in_c(.balign 8)
-#define PPC_TLNEI	stringify_in_c(tdnei)
-#define PPC_LLARX	stringify_in_c(ldarx)
-#define PPC_STLCX	stringify_in_c(stdcx.)
-#define PPC_CNTLZL	stringify_in_c(cntlzd)
-#define PPC_MTOCRF(FXM, RS) MTOCRF((FXM), RS)
-#define PPC_SRL		stringify_in_c(srd)
-#define PPC_LR_STKOFF	16
-#define PPC_MIN_STKFRM	112
-
-#ifdef __BIG_ENDIAN__
-#define LWZX_BE	stringify_in_c(lwzx)
-#define LDX_BE	stringify_in_c(ldx)
-#define STWX_BE	stringify_in_c(stwx)
-#define STDX_BE	stringify_in_c(stdx)
-#else
-#define LWZX_BE	stringify_in_c(lwbrx)
-#define LDX_BE	stringify_in_c(ldbrx)
-#define STWX_BE	stringify_in_c(stwbrx)
-#define STDX_BE	stringify_in_c(stdbrx)
-#endif
-
-#ifdef CONFIG_CC_IS_CLANG
-#define DS_FORM_CONSTRAINT "Z<>"
-#else
-#define DS_FORM_CONSTRAINT "YZ<>"
-#endif
-
-#else /* 32-bit */
-
-/* operations for longs and pointers */
-#define PPC_LL		stringify_in_c(lwz)
-#define PPC_STL		stringify_in_c(stw)
-#define PPC_STLU	stringify_in_c(stwu)
-#define PPC_LCMPI	stringify_in_c(cmpwi)
-#define PPC_LCMPLI	stringify_in_c(cmplwi)
-#define PPC_LCMP	stringify_in_c(cmpw)
-#define PPC_LONG	stringify_in_c(.long)
-#define PPC_LONG_ALIGN	stringify_in_c(.balign 4)
-#define PPC_TLNEI	stringify_in_c(twnei)
-#define PPC_LLARX	stringify_in_c(lwarx)
-#define PPC_STLCX	stringify_in_c(stwcx.)
-#define PPC_CNTLZL	stringify_in_c(cntlzw)
-#define PPC_MTOCRF	stringify_in_c(mtcrf)
-#define PPC_SRL		stringify_in_c(srw)
-#define PPC_LR_STKOFF	4
-#define PPC_MIN_STKFRM	16
-
-#endif
-
-#endif /* _ASM_POWERPC_ASM_COMPAT_H */
+../.././../../../../arch/powerpc/include/asm/asm-compat.h
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/powerpc/primitives/asm/asm-const.h linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/primitives/asm/asm-const.h
--- linux-6.16.7/tools/testing/selftests/powerpc/primitives/asm/asm-const.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/primitives/asm/asm-const.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,15 +1 @@
-#ifndef _ASM_POWERPC_ASM_CONST_H
-#define _ASM_POWERPC_ASM_CONST_H
-
-#ifdef __ASSEMBLY__
-#  define stringify_in_c(...)	__VA_ARGS__
-#  define ASM_CONST(x)		x
-#else
-/* This version of stringify will deal with commas... */
-#  define __stringify_in_c(...)	#__VA_ARGS__
-#  define stringify_in_c(...)	__stringify_in_c(__VA_ARGS__) " "
-#  define __ASM_CONST(x)	x##UL
-#  define ASM_CONST(x)		__ASM_CONST(x)
-#endif
-
-#endif /* _ASM_POWERPC_ASM_CONST_H */
+../../../../../../arch/powerpc/include/asm/asm-const.h
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/powerpc/primitives/asm/extable.h linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/primitives/asm/extable.h
--- linux-6.16.7/tools/testing/selftests/powerpc/primitives/asm/extable.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/primitives/asm/extable.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,44 +1 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef _ARCH_POWERPC_EXTABLE_H
-#define _ARCH_POWERPC_EXTABLE_H
-
-/*
- * The exception table consists of pairs of relative addresses: the first is
- * the address of an instruction that is allowed to fault, and the second is
- * the address at which the program should continue.  No registers are
- * modified, so it is entirely up to the continuation code to figure out what
- * to do.
- *
- * All the routines below use bits of fixup code that are out of line with the
- * main instruction path.  This means when everything is well, we don't even
- * have to jump over them.  Further, they do not intrude on our cache or tlb
- * entries.
- */
-
-#define ARCH_HAS_RELATIVE_EXTABLE
-
-#ifndef __ASSEMBLY__
-
-struct exception_table_entry {
-	int insn;
-	int fixup;
-};
-
-static inline unsigned long extable_fixup(const struct exception_table_entry *x)
-{
-	return (unsigned long)&x->fixup + x->fixup;
-}
-
-#endif
-
-/*
- * Helper macro for exception table entries
- */
-#define EX_TABLE(_fault, _target)		\
-	stringify_in_c(.section __ex_table,"a";)\
-	stringify_in_c(.balign 4;)		\
-	stringify_in_c(.long (_fault) - . ;)	\
-	stringify_in_c(.long (_target) - . ;)	\
-	stringify_in_c(.previous)
-
-#endif
+../../../../../../arch/powerpc/include/asm/extable.h
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/powerpc/primitives/asm/feature-fixups.h linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/primitives/asm/feature-fixups.h
--- linux-6.16.7/tools/testing/selftests/powerpc/primitives/asm/feature-fixups.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/primitives/asm/feature-fixups.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,301 +1 @@
-/* SPDX-License-Identifier: GPL-2.0-or-later */
-#ifndef __ASM_POWERPC_FEATURE_FIXUPS_H
-#define __ASM_POWERPC_FEATURE_FIXUPS_H
-
-#include <asm/asm-const.h>
-
-/*
- */
-
-/*
- * Feature section common macros
- *
- * Note that the entries now contain offsets between the table entry
- * and the code rather than absolute code pointers in order to be
- * useable with the vdso shared library. There is also an assumption
- * that values will be negative, that is, the fixup table has to be
- * located after the code it fixes up.
- */
-#if defined(CONFIG_PPC64) && !defined(__powerpc64__)
-/* 64 bits kernel, 32 bits code (ie. vdso32) */
-#define FTR_ENTRY_LONG		.8byte
-#define FTR_ENTRY_OFFSET	.long 0xffffffff; .long
-#elif defined(CONFIG_PPC64)
-#define FTR_ENTRY_LONG		.8byte
-#define FTR_ENTRY_OFFSET	.8byte
-#else
-#define FTR_ENTRY_LONG		.long
-#define FTR_ENTRY_OFFSET	.long
-#endif
-
-#define START_FTR_SECTION(label)	label##1:
-
-#define FTR_SECTION_ELSE_NESTED(label)			\
-label##2:						\
-	.pushsection __ftr_alt_##label,"a";		\
-	.align 2;					\
-label##3:
-
-
-#ifndef CONFIG_CC_IS_CLANG
-#define CHECK_ALT_SIZE(else_size, body_size)			\
-	.ifgt (else_size) - (body_size);			\
-	.error "Feature section else case larger than body";	\
-	.endif;
-#else
-/*
- * If we use the ifgt syntax above, clang's assembler complains about the
- * expression being non-absolute when the code appears in an inline assembly
- * statement.
- * As a workaround use an .org directive that has no effect if the else case
- * instructions are smaller than the body, but fails otherwise.
- */
-#define CHECK_ALT_SIZE(else_size, body_size)			\
-	.org . + ((else_size) > (body_size));
-#endif
-
-#define MAKE_FTR_SECTION_ENTRY(msk, val, label, sect)		\
-label##4:							\
-	.popsection;						\
-	.pushsection sect,"a";					\
-	.align 3;						\
-label##5:							\
-	FTR_ENTRY_LONG msk;					\
-	FTR_ENTRY_LONG val;					\
-	FTR_ENTRY_OFFSET label##1b-label##5b;			\
-	FTR_ENTRY_OFFSET label##2b-label##5b;			\
-	FTR_ENTRY_OFFSET label##3b-label##5b;			\
-	FTR_ENTRY_OFFSET label##4b-label##5b;			\
-	CHECK_ALT_SIZE((label##4b-label##3b), (label##2b-label##1b)); \
-	.popsection;
-
-
-/* CPU feature dependent sections */
-#define BEGIN_FTR_SECTION_NESTED(label)	START_FTR_SECTION(label)
-#define BEGIN_FTR_SECTION		START_FTR_SECTION(97)
-
-#define END_FTR_SECTION_NESTED(msk, val, label) 		\
-	FTR_SECTION_ELSE_NESTED(label)				\
-	MAKE_FTR_SECTION_ENTRY(msk, val, label, __ftr_fixup)
-
-#define END_FTR_SECTION(msk, val)		\
-	END_FTR_SECTION_NESTED(msk, val, 97)
-
-#define END_FTR_SECTION_NESTED_IFSET(msk, label)	\
-	END_FTR_SECTION_NESTED((msk), (msk), label)
-
-#define END_FTR_SECTION_IFSET(msk)	END_FTR_SECTION((msk), (msk))
-#define END_FTR_SECTION_IFCLR(msk)	END_FTR_SECTION((msk), 0)
-
-/* CPU feature sections with alternatives, use BEGIN_FTR_SECTION to start */
-#define FTR_SECTION_ELSE	FTR_SECTION_ELSE_NESTED(97)
-#define ALT_FTR_SECTION_END_NESTED(msk, val, label)	\
-	MAKE_FTR_SECTION_ENTRY(msk, val, label, __ftr_fixup)
-#define ALT_FTR_SECTION_END_NESTED_IFSET(msk, label)	\
-	ALT_FTR_SECTION_END_NESTED(msk, msk, label)
-#define ALT_FTR_SECTION_END_NESTED_IFCLR(msk, label)	\
-	ALT_FTR_SECTION_END_NESTED(msk, 0, label)
-#define ALT_FTR_SECTION_END(msk, val)	\
-	ALT_FTR_SECTION_END_NESTED(msk, val, 97)
-#define ALT_FTR_SECTION_END_IFSET(msk)	\
-	ALT_FTR_SECTION_END_NESTED_IFSET(msk, 97)
-#define ALT_FTR_SECTION_END_IFCLR(msk)	\
-	ALT_FTR_SECTION_END_NESTED_IFCLR(msk, 97)
-
-/* MMU feature dependent sections */
-#define BEGIN_MMU_FTR_SECTION_NESTED(label)	START_FTR_SECTION(label)
-#define BEGIN_MMU_FTR_SECTION			START_FTR_SECTION(97)
-
-#define END_MMU_FTR_SECTION_NESTED(msk, val, label) 		\
-	FTR_SECTION_ELSE_NESTED(label)				\
-	MAKE_FTR_SECTION_ENTRY(msk, val, label, __mmu_ftr_fixup)
-
-#define END_MMU_FTR_SECTION(msk, val)		\
-	END_MMU_FTR_SECTION_NESTED(msk, val, 97)
-
-#define END_MMU_FTR_SECTION_NESTED_IFSET(msk, label)	\
-	END_MMU_FTR_SECTION_NESTED((msk), (msk), label)
-
-#define END_MMU_FTR_SECTION_NESTED_IFCLR(msk, label)	\
-	END_MMU_FTR_SECTION_NESTED((msk), 0, label)
-
-#define END_MMU_FTR_SECTION_IFSET(msk)	END_MMU_FTR_SECTION((msk), (msk))
-#define END_MMU_FTR_SECTION_IFCLR(msk)	END_MMU_FTR_SECTION((msk), 0)
-
-/* MMU feature sections with alternatives, use BEGIN_FTR_SECTION to start */
-#define MMU_FTR_SECTION_ELSE_NESTED(label)	FTR_SECTION_ELSE_NESTED(label)
-#define MMU_FTR_SECTION_ELSE	MMU_FTR_SECTION_ELSE_NESTED(97)
-#define ALT_MMU_FTR_SECTION_END_NESTED(msk, val, label)	\
-	MAKE_FTR_SECTION_ENTRY(msk, val, label, __mmu_ftr_fixup)
-#define ALT_MMU_FTR_SECTION_END_NESTED_IFSET(msk, label)	\
-	ALT_MMU_FTR_SECTION_END_NESTED(msk, msk, label)
-#define ALT_MMU_FTR_SECTION_END_NESTED_IFCLR(msk, label)	\
-	ALT_MMU_FTR_SECTION_END_NESTED(msk, 0, label)
-#define ALT_MMU_FTR_SECTION_END(msk, val)	\
-	ALT_MMU_FTR_SECTION_END_NESTED(msk, val, 97)
-#define ALT_MMU_FTR_SECTION_END_IFSET(msk)	\
-	ALT_MMU_FTR_SECTION_END_NESTED_IFSET(msk, 97)
-#define ALT_MMU_FTR_SECTION_END_IFCLR(msk)	\
-	ALT_MMU_FTR_SECTION_END_NESTED_IFCLR(msk, 97)
-
-/* Firmware feature dependent sections */
-#define BEGIN_FW_FTR_SECTION_NESTED(label)	START_FTR_SECTION(label)
-#define BEGIN_FW_FTR_SECTION			START_FTR_SECTION(97)
-
-#define END_FW_FTR_SECTION_NESTED(msk, val, label) 		\
-	FTR_SECTION_ELSE_NESTED(label)				\
-	MAKE_FTR_SECTION_ENTRY(msk, val, label, __fw_ftr_fixup)
-
-#define END_FW_FTR_SECTION(msk, val)		\
-	END_FW_FTR_SECTION_NESTED(msk, val, 97)
-
-#define END_FW_FTR_SECTION_IFSET(msk)	END_FW_FTR_SECTION((msk), (msk))
-#define END_FW_FTR_SECTION_IFCLR(msk)	END_FW_FTR_SECTION((msk), 0)
-
-/* Firmware feature sections with alternatives */
-#define FW_FTR_SECTION_ELSE_NESTED(label)	FTR_SECTION_ELSE_NESTED(label)
-#define FW_FTR_SECTION_ELSE	FTR_SECTION_ELSE_NESTED(97)
-#define ALT_FW_FTR_SECTION_END_NESTED(msk, val, label)	\
-	MAKE_FTR_SECTION_ENTRY(msk, val, label, __fw_ftr_fixup)
-#define ALT_FW_FTR_SECTION_END_NESTED_IFSET(msk, label)	\
-	ALT_FW_FTR_SECTION_END_NESTED(msk, msk, label)
-#define ALT_FW_FTR_SECTION_END_NESTED_IFCLR(msk, label)	\
-	ALT_FW_FTR_SECTION_END_NESTED(msk, 0, label)
-#define ALT_FW_FTR_SECTION_END(msk, val)	\
-	ALT_FW_FTR_SECTION_END_NESTED(msk, val, 97)
-#define ALT_FW_FTR_SECTION_END_IFSET(msk)	\
-	ALT_FW_FTR_SECTION_END_NESTED_IFSET(msk, 97)
-#define ALT_FW_FTR_SECTION_END_IFCLR(msk)	\
-	ALT_FW_FTR_SECTION_END_NESTED_IFCLR(msk, 97)
-
-#ifndef __ASSEMBLY__
-
-#define ASM_FTR_IF(section_if, section_else, msk, val)	\
-	stringify_in_c(BEGIN_FTR_SECTION)			\
-	section_if "; "						\
-	stringify_in_c(FTR_SECTION_ELSE)			\
-	section_else "; "					\
-	stringify_in_c(ALT_FTR_SECTION_END((msk), (val)))
-
-#define ASM_FTR_IFSET(section_if, section_else, msk)	\
-	ASM_FTR_IF(section_if, section_else, (msk), (msk))
-
-#define ASM_FTR_IFCLR(section_if, section_else, msk)	\
-	ASM_FTR_IF(section_if, section_else, (msk), 0)
-
-#define ASM_MMU_FTR_IF(section_if, section_else, msk, val)	\
-	stringify_in_c(BEGIN_MMU_FTR_SECTION)			\
-	section_if "; "						\
-	stringify_in_c(MMU_FTR_SECTION_ELSE)			\
-	section_else "; "					\
-	stringify_in_c(ALT_MMU_FTR_SECTION_END((msk), (val)))
-
-#define ASM_MMU_FTR_IFSET(section_if, section_else, msk)	\
-	ASM_MMU_FTR_IF(section_if, section_else, (msk), (msk))
-
-#define ASM_MMU_FTR_IFCLR(section_if, section_else, msk)	\
-	ASM_MMU_FTR_IF(section_if, section_else, (msk), 0)
-
-#endif /* __ASSEMBLY__ */
-
-/* LWSYNC feature sections */
-#define START_LWSYNC_SECTION(label)	label##1:
-#define MAKE_LWSYNC_SECTION_ENTRY(label, sect)		\
-label##2:						\
-	.pushsection sect,"a";				\
-	.align 2;					\
-label##3:					       	\
-	FTR_ENTRY_OFFSET label##1b-label##3b;		\
-	.popsection;
-
-#define STF_ENTRY_BARRIER_FIXUP_SECTION			\
-953:							\
-	.pushsection __stf_entry_barrier_fixup,"a";	\
-	.align 2;					\
-954:							\
-	FTR_ENTRY_OFFSET 953b-954b;			\
-	.popsection;
-
-#define STF_EXIT_BARRIER_FIXUP_SECTION			\
-955:							\
-	.pushsection __stf_exit_barrier_fixup,"a";	\
-	.align 2;					\
-956:							\
-	FTR_ENTRY_OFFSET 955b-956b;			\
-	.popsection;
-
-#define UACCESS_FLUSH_FIXUP_SECTION			\
-959:							\
-	.pushsection __uaccess_flush_fixup,"a";		\
-	.align 2;					\
-960:							\
-	FTR_ENTRY_OFFSET 959b-960b;			\
-	.popsection;
-
-#define ENTRY_FLUSH_FIXUP_SECTION			\
-957:							\
-	.pushsection __entry_flush_fixup,"a";		\
-	.align 2;					\
-958:							\
-	FTR_ENTRY_OFFSET 957b-958b;			\
-	.popsection;
-
-#define SCV_ENTRY_FLUSH_FIXUP_SECTION			\
-957:							\
-	.pushsection __scv_entry_flush_fixup,"a";	\
-	.align 2;					\
-958:							\
-	FTR_ENTRY_OFFSET 957b-958b;			\
-	.popsection;
-
-#define RFI_FLUSH_FIXUP_SECTION				\
-951:							\
-	.pushsection __rfi_flush_fixup,"a";		\
-	.align 2;					\
-952:							\
-	FTR_ENTRY_OFFSET 951b-952b;			\
-	.popsection;
-
-#define NOSPEC_BARRIER_FIXUP_SECTION			\
-953:							\
-	.pushsection __barrier_nospec_fixup,"a";	\
-	.align 2;					\
-954:							\
-	FTR_ENTRY_OFFSET 953b-954b;			\
-	.popsection;
-
-#define START_BTB_FLUSH_SECTION			\
-955:							\
-
-#define END_BTB_FLUSH_SECTION			\
-956:							\
-	.pushsection __btb_flush_fixup,"a";	\
-	.align 2;							\
-957:						\
-	FTR_ENTRY_OFFSET 955b-957b;			\
-	FTR_ENTRY_OFFSET 956b-957b;			\
-	.popsection;
-
-#ifndef __ASSEMBLY__
-#include <linux/types.h>
-
-extern long stf_barrier_fallback;
-extern long entry_flush_fallback;
-extern long scv_entry_flush_fallback;
-extern long __start___stf_entry_barrier_fixup, __stop___stf_entry_barrier_fixup;
-extern long __start___stf_exit_barrier_fixup, __stop___stf_exit_barrier_fixup;
-extern long __start___uaccess_flush_fixup, __stop___uaccess_flush_fixup;
-extern long __start___entry_flush_fixup, __stop___entry_flush_fixup;
-extern long __start___scv_entry_flush_fixup, __stop___scv_entry_flush_fixup;
-extern long __start___rfi_flush_fixup, __stop___rfi_flush_fixup;
-extern long __start___barrier_nospec_fixup, __stop___barrier_nospec_fixup;
-extern long __start__btb_flush_fixup, __stop__btb_flush_fixup;
-
-extern bool static_key_feature_checks_initialized;
-
-void apply_feature_fixups(void);
-void update_mmu_feature_fixups(unsigned long mask);
-void setup_feature_keys(void);
-#endif
-
-#endif /* __ASM_POWERPC_FEATURE_FIXUPS_H */
+../../../../../../arch/powerpc/include/asm/feature-fixups.h
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/powerpc/primitives/asm/ppc_asm.h linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/primitives/asm/ppc_asm.h
--- linux-6.16.7/tools/testing/selftests/powerpc/primitives/asm/ppc_asm.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/primitives/asm/ppc_asm.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,906 +1 @@
-/*
- * Copyright (C) 1995-1999 Gary Thomas, Paul Mackerras, Cort Dougan.
- */
-#ifndef _ASM_POWERPC_PPC_ASM_H
-#define _ASM_POWERPC_PPC_ASM_H
-
-#include <linux/stringify.h>
-#include <asm/asm-compat.h>
-#include <asm/processor.h>
-#include <asm/ppc-opcode.h>
-#include <asm/firmware.h>
-#include <asm/feature-fixups.h>
-#include <asm/extable.h>
-
-#ifdef __ASSEMBLY__
-
-#define SZL			(BITS_PER_LONG/8)
-
-/*
- * This expands to a sequence of operations with reg incrementing from
- * start to end inclusive, of this form:
- *
- *   op  reg, (offset + (width * reg))(base)
- *
- * Note that offset is not the offset of the first operation unless start
- * is zero (or width is zero).
- */
-.macro OP_REGS op, width, start, end, base, offset
-	.Lreg=\start
-	.rept (\end - \start + 1)
-	\op	.Lreg, \offset + \width * .Lreg(\base)
-	.Lreg=.Lreg+1
-	.endr
-.endm
-
-/*
- * This expands to a sequence of register clears for regs start to end
- * inclusive, of the form:
- *
- *   li rN, 0
- */
-.macro ZEROIZE_REGS start, end
-	.Lreg=\start
-	.rept (\end - \start + 1)
-	li	.Lreg, 0
-	.Lreg=.Lreg+1
-	.endr
-.endm
-
-/*
- * Macros for storing registers into and loading registers from
- * exception frames.
- */
-#ifdef __powerpc64__
-#define SAVE_GPRS(start, end, base)	OP_REGS std, 8, start, end, base, GPR0
-#define REST_GPRS(start, end, base)	OP_REGS ld, 8, start, end, base, GPR0
-#define SAVE_NVGPRS(base)		SAVE_GPRS(14, 31, base)
-#define REST_NVGPRS(base)		REST_GPRS(14, 31, base)
-#else
-#define SAVE_GPRS(start, end, base)	OP_REGS stw, 4, start, end, base, GPR0
-#define REST_GPRS(start, end, base)	OP_REGS lwz, 4, start, end, base, GPR0
-#define SAVE_NVGPRS(base)		SAVE_GPRS(13, 31, base)
-#define REST_NVGPRS(base)		REST_GPRS(13, 31, base)
-#endif
-
-#define	ZEROIZE_GPRS(start, end)	ZEROIZE_REGS start, end
-#ifdef __powerpc64__
-#define	ZEROIZE_NVGPRS()		ZEROIZE_GPRS(14, 31)
-#else
-#define	ZEROIZE_NVGPRS()		ZEROIZE_GPRS(13, 31)
-#endif
-#define	ZEROIZE_GPR(n)			ZEROIZE_GPRS(n, n)
-
-#define SAVE_GPR(n, base)		SAVE_GPRS(n, n, base)
-#define REST_GPR(n, base)		REST_GPRS(n, n, base)
-
-/* macros for handling user register sanitisation */
-#ifdef CONFIG_INTERRUPT_SANITIZE_REGISTERS
-#define SANITIZE_SYSCALL_GPRS()			ZEROIZE_GPR(0);		\
-						ZEROIZE_GPRS(5, 12);	\
-						ZEROIZE_NVGPRS()
-#define SANITIZE_GPR(n)				ZEROIZE_GPR(n)
-#define SANITIZE_GPRS(start, end)		ZEROIZE_GPRS(start, end)
-#define SANITIZE_NVGPRS()			ZEROIZE_NVGPRS()
-#define SANITIZE_RESTORE_NVGPRS()		REST_NVGPRS(r1)
-#define HANDLER_RESTORE_NVGPRS()
-#else
-#define SANITIZE_SYSCALL_GPRS()
-#define SANITIZE_GPR(n)
-#define SANITIZE_GPRS(start, end)
-#define SANITIZE_NVGPRS()
-#define SANITIZE_RESTORE_NVGPRS()
-#define HANDLER_RESTORE_NVGPRS()		REST_NVGPRS(r1)
-#endif /* CONFIG_INTERRUPT_SANITIZE_REGISTERS */
-
-#define SAVE_FPR(n, base)	stfd	n,8*TS_FPRWIDTH*(n)(base)
-#define SAVE_2FPRS(n, base)	SAVE_FPR(n, base); SAVE_FPR(n+1, base)
-#define SAVE_4FPRS(n, base)	SAVE_2FPRS(n, base); SAVE_2FPRS(n+2, base)
-#define SAVE_8FPRS(n, base)	SAVE_4FPRS(n, base); SAVE_4FPRS(n+4, base)
-#define SAVE_16FPRS(n, base)	SAVE_8FPRS(n, base); SAVE_8FPRS(n+8, base)
-#define SAVE_32FPRS(n, base)	SAVE_16FPRS(n, base); SAVE_16FPRS(n+16, base)
-#define REST_FPR(n, base)	lfd	n,8*TS_FPRWIDTH*(n)(base)
-#define REST_2FPRS(n, base)	REST_FPR(n, base); REST_FPR(n+1, base)
-#define REST_4FPRS(n, base)	REST_2FPRS(n, base); REST_2FPRS(n+2, base)
-#define REST_8FPRS(n, base)	REST_4FPRS(n, base); REST_4FPRS(n+4, base)
-#define REST_16FPRS(n, base)	REST_8FPRS(n, base); REST_8FPRS(n+8, base)
-#define REST_32FPRS(n, base)	REST_16FPRS(n, base); REST_16FPRS(n+16, base)
-
-#define SAVE_VR(n,b,base)	li b,16*(n);  stvx n,base,b
-#define SAVE_2VRS(n,b,base)	SAVE_VR(n,b,base); SAVE_VR(n+1,b,base)
-#define SAVE_4VRS(n,b,base)	SAVE_2VRS(n,b,base); SAVE_2VRS(n+2,b,base)
-#define SAVE_8VRS(n,b,base)	SAVE_4VRS(n,b,base); SAVE_4VRS(n+4,b,base)
-#define SAVE_16VRS(n,b,base)	SAVE_8VRS(n,b,base); SAVE_8VRS(n+8,b,base)
-#define SAVE_32VRS(n,b,base)	SAVE_16VRS(n,b,base); SAVE_16VRS(n+16,b,base)
-#define REST_VR(n,b,base)	li b,16*(n); lvx n,base,b
-#define REST_2VRS(n,b,base)	REST_VR(n,b,base); REST_VR(n+1,b,base)
-#define REST_4VRS(n,b,base)	REST_2VRS(n,b,base); REST_2VRS(n+2,b,base)
-#define REST_8VRS(n,b,base)	REST_4VRS(n,b,base); REST_4VRS(n+4,b,base)
-#define REST_16VRS(n,b,base)	REST_8VRS(n,b,base); REST_8VRS(n+8,b,base)
-#define REST_32VRS(n,b,base)	REST_16VRS(n,b,base); REST_16VRS(n+16,b,base)
-
-#ifdef __BIG_ENDIAN__
-#define STXVD2X_ROT(n,b,base)		STXVD2X(n,b,base)
-#define LXVD2X_ROT(n,b,base)		LXVD2X(n,b,base)
-#else
-#define STXVD2X_ROT(n,b,base)		XXSWAPD(n,n);		\
-					STXVD2X(n,b,base);	\
-					XXSWAPD(n,n)
-
-#define LXVD2X_ROT(n,b,base)		LXVD2X(n,b,base);	\
-					XXSWAPD(n,n)
-#endif
-/* Save the lower 32 VSRs in the thread VSR region */
-#define SAVE_VSR(n,b,base)	li b,16*(n);  STXVD2X_ROT(n,R##base,R##b)
-#define SAVE_2VSRS(n,b,base)	SAVE_VSR(n,b,base); SAVE_VSR(n+1,b,base)
-#define SAVE_4VSRS(n,b,base)	SAVE_2VSRS(n,b,base); SAVE_2VSRS(n+2,b,base)
-#define SAVE_8VSRS(n,b,base)	SAVE_4VSRS(n,b,base); SAVE_4VSRS(n+4,b,base)
-#define SAVE_16VSRS(n,b,base)	SAVE_8VSRS(n,b,base); SAVE_8VSRS(n+8,b,base)
-#define SAVE_32VSRS(n,b,base)	SAVE_16VSRS(n,b,base); SAVE_16VSRS(n+16,b,base)
-#define REST_VSR(n,b,base)	li b,16*(n); LXVD2X_ROT(n,R##base,R##b)
-#define REST_2VSRS(n,b,base)	REST_VSR(n,b,base); REST_VSR(n+1,b,base)
-#define REST_4VSRS(n,b,base)	REST_2VSRS(n,b,base); REST_2VSRS(n+2,b,base)
-#define REST_8VSRS(n,b,base)	REST_4VSRS(n,b,base); REST_4VSRS(n+4,b,base)
-#define REST_16VSRS(n,b,base)	REST_8VSRS(n,b,base); REST_8VSRS(n+8,b,base)
-#define REST_32VSRS(n,b,base)	REST_16VSRS(n,b,base); REST_16VSRS(n+16,b,base)
-
-/*
- * b = base register for addressing, o = base offset from register of 1st EVR
- * n = first EVR, s = scratch
- */
-#define SAVE_EVR(n,s,b,o)	evmergehi s,s,n; stw s,o+4*(n)(b)
-#define SAVE_2EVRS(n,s,b,o)	SAVE_EVR(n,s,b,o); SAVE_EVR(n+1,s,b,o)
-#define SAVE_4EVRS(n,s,b,o)	SAVE_2EVRS(n,s,b,o); SAVE_2EVRS(n+2,s,b,o)
-#define SAVE_8EVRS(n,s,b,o)	SAVE_4EVRS(n,s,b,o); SAVE_4EVRS(n+4,s,b,o)
-#define SAVE_16EVRS(n,s,b,o)	SAVE_8EVRS(n,s,b,o); SAVE_8EVRS(n+8,s,b,o)
-#define SAVE_32EVRS(n,s,b,o)	SAVE_16EVRS(n,s,b,o); SAVE_16EVRS(n+16,s,b,o)
-#define REST_EVR(n,s,b,o)	lwz s,o+4*(n)(b); evmergelo n,s,n
-#define REST_2EVRS(n,s,b,o)	REST_EVR(n,s,b,o); REST_EVR(n+1,s,b,o)
-#define REST_4EVRS(n,s,b,o)	REST_2EVRS(n,s,b,o); REST_2EVRS(n+2,s,b,o)
-#define REST_8EVRS(n,s,b,o)	REST_4EVRS(n,s,b,o); REST_4EVRS(n+4,s,b,o)
-#define REST_16EVRS(n,s,b,o)	REST_8EVRS(n,s,b,o); REST_8EVRS(n+8,s,b,o)
-#define REST_32EVRS(n,s,b,o)	REST_16EVRS(n,s,b,o); REST_16EVRS(n+16,s,b,o)
-
-/* Macros to adjust thread priority for hardware multithreading */
-#define HMT_VERY_LOW	or	31,31,31	# very low priority
-#define HMT_LOW		or	1,1,1
-#define HMT_MEDIUM_LOW  or	6,6,6		# medium low priority
-#define HMT_MEDIUM	or	2,2,2
-#define HMT_MEDIUM_HIGH or	5,5,5		# medium high priority
-#define HMT_HIGH	or	3,3,3
-#define HMT_EXTRA_HIGH	or	7,7,7		# power7 only
-
-#ifdef CONFIG_PPC64
-#define ULONG_SIZE 	8
-#else
-#define ULONG_SIZE	4
-#endif
-#define __VCPU_GPR(n)	(VCPU_GPRS + (n * ULONG_SIZE))
-#define VCPU_GPR(n)	__VCPU_GPR(__REG_##n)
-
-#ifdef __KERNEL__
-
-/*
- * Used to name C functions called from asm
- */
-#if defined(__powerpc64__) && defined(CONFIG_PPC_KERNEL_PCREL)
-#define CFUNC(name) name@notoc
-#else
-#define CFUNC(name) name
-#endif
-
-/*
- * We use __powerpc64__ here because we want the compat VDSO to use the 32-bit
- * version below in the else case of the ifdef.
- */
-#ifdef __powerpc64__
-
-#define STACKFRAMESIZE 256
-#define __STK_REG(i)   (112 + ((i)-14)*8)
-#define STK_REG(i)     __STK_REG(__REG_##i)
-
-#ifdef CONFIG_PPC64_ELF_ABI_V2
-#define STK_GOT		24
-#define STK_PARAM_AREA	32
-#else
-#define STK_GOT		40
-#define STK_PARAM_AREA	48
-#endif
-
-#define __STK_PARAM(i)	(STK_PARAM_AREA + ((i)-3)*8)
-#define STK_PARAM(i)	__STK_PARAM(__REG_##i)
-
-#ifdef CONFIG_PPC64_ELF_ABI_V2
-
-#define _GLOBAL(name) \
-	.align 2 ; \
-	.type name,@function; \
-	.globl name; \
-name:
-
-#ifdef CONFIG_PPC_KERNEL_PCREL
-#define _GLOBAL_TOC _GLOBAL
-#else
-#define _GLOBAL_TOC(name) \
-	.align 2 ; \
-	.type name,@function; \
-	.globl name; \
-name: \
-0:	addis r2,r12,(.TOC.-0b)@ha; \
-	addi r2,r2,(.TOC.-0b)@l; \
-	.localentry name,.-name
-#endif
-
-#define DOTSYM(a)	a
-
-#else
-
-#define XGLUE(a,b) a##b
-#define GLUE(a,b) XGLUE(a,b)
-
-#define _GLOBAL(name) \
-	.align 2 ; \
-	.globl name; \
-	.globl GLUE(.,name); \
-	.pushsection ".opd","aw"; \
-name: \
-	.quad GLUE(.,name); \
-	.quad .TOC.@tocbase; \
-	.quad 0; \
-	.popsection; \
-	.type GLUE(.,name),@function; \
-GLUE(.,name):
-
-#define _GLOBAL_TOC(name) _GLOBAL(name)
-
-#define DOTSYM(a)	GLUE(.,a)
-
-#endif
-
-#else /* 32-bit */
-
-#define _GLOBAL(n)	\
-	.globl n;	\
-n:
-
-#define _GLOBAL_TOC(name) _GLOBAL(name)
-
-#define DOTSYM(a)	a
-
-#endif
-
-/*
- * __kprobes (the C annotation) puts the symbol into the .kprobes.text
- * section, which gets emitted at the end of regular text.
- *
- * _ASM_NOKPROBE_SYMBOL and NOKPROBE_SYMBOL just adds the symbol to
- * a blacklist. The former is for core kprobe functions/data, the
- * latter is for those that incdentially must be excluded from probing
- * and allows them to be linked at more optimal location within text.
- */
-#ifdef CONFIG_KPROBES
-#define _ASM_NOKPROBE_SYMBOL(entry)			\
-	.pushsection "_kprobe_blacklist","aw";		\
-	PPC_LONG (entry) ;				\
-	.popsection
-#else
-#define _ASM_NOKPROBE_SYMBOL(entry)
-#endif
-
-#define FUNC_START(name)	_GLOBAL(name)
-#define FUNC_END(name)
-
-/* 
- * LOAD_REG_IMMEDIATE(rn, expr)
- *   Loads the value of the constant expression 'expr' into register 'rn'
- *   using immediate instructions only.  Use this when it's important not
- *   to reference other data (i.e. on ppc64 when the TOC pointer is not
- *   valid) and when 'expr' is a constant or absolute address.
- *
- * LOAD_REG_ADDR(rn, name)
- *   Loads the address of label 'name' into register 'rn'.  Use this when
- *   you don't particularly need immediate instructions only, but you need
- *   the whole address in one register (e.g. it's a structure address and
- *   you want to access various offsets within it).  On ppc32 this is
- *   identical to LOAD_REG_IMMEDIATE.
- *
- * LOAD_REG_ADDR_PIC(rn, name)
- *   Loads the address of label 'name' into register 'run'. Use this when
- *   the kernel doesn't run at the linked or relocated address. Please
- *   note that this macro will clobber the lr register.
- *
- * LOAD_REG_ADDRBASE(rn, name)
- * ADDROFF(name)
- *   LOAD_REG_ADDRBASE loads part of the address of label 'name' into
- *   register 'rn'.  ADDROFF(name) returns the remainder of the address as
- *   a constant expression.  ADDROFF(name) is a signed expression < 16 bits
- *   in size, so is suitable for use directly as an offset in load and store
- *   instructions.  Use this when loading/storing a single word or less as:
- *      LOAD_REG_ADDRBASE(rX, name)
- *      ld	rY,ADDROFF(name)(rX)
- */
-
-/* Be careful, this will clobber the lr register. */
-#define LOAD_REG_ADDR_PIC(reg, name)		\
-	bcl	20,31,$+4;			\
-0:	mflr	reg;				\
-	addis	reg,reg,(name - 0b)@ha;		\
-	addi	reg,reg,(name - 0b)@l;
-
-#if defined(__powerpc64__) && defined(HAVE_AS_ATHIGH)
-#define __AS_ATHIGH high
-#else
-#define __AS_ATHIGH h
-#endif
-
-.macro __LOAD_REG_IMMEDIATE_32 r, x
-	.if (\x) >= 0x8000 || (\x) < -0x8000
-		lis \r, (\x)@__AS_ATHIGH
-		.if (\x) & 0xffff != 0
-			ori \r, \r, (\x)@l
-		.endif
-	.else
-		li \r, (\x)@l
-	.endif
-.endm
-
-.macro __LOAD_REG_IMMEDIATE r, x
-	.if (\x) >= 0x80000000 || (\x) < -0x80000000
-		__LOAD_REG_IMMEDIATE_32 \r, (\x) >> 32
-		sldi	\r, \r, 32
-		.if (\x) & 0xffff0000 != 0
-			oris \r, \r, (\x)@__AS_ATHIGH
-		.endif
-		.if (\x) & 0xffff != 0
-			ori \r, \r, (\x)@l
-		.endif
-	.else
-		__LOAD_REG_IMMEDIATE_32 \r, \x
-	.endif
-.endm
-
-#ifdef __powerpc64__
-
-#ifdef CONFIG_PPC_KERNEL_PCREL
-#define __LOAD_PACA_TOC(reg)			\
-	li	reg,-1
-#else
-#define __LOAD_PACA_TOC(reg)			\
-	ld	reg,PACATOC(r13)
-#endif
-
-#define LOAD_PACA_TOC()				\
-	__LOAD_PACA_TOC(r2)
-
-#define LOAD_REG_IMMEDIATE(reg, expr) __LOAD_REG_IMMEDIATE reg, expr
-
-#define LOAD_REG_IMMEDIATE_SYM(reg, tmp, expr)	\
-	lis	tmp, (expr)@highest;		\
-	lis	reg, (expr)@__AS_ATHIGH;	\
-	ori	tmp, tmp, (expr)@higher;	\
-	ori	reg, reg, (expr)@l;		\
-	rldimi	reg, tmp, 32, 0
-
-#ifdef CONFIG_PPC_KERNEL_PCREL
-#define LOAD_REG_ADDR(reg,name)			\
-	pla	reg,name@pcrel
-
-#else
-#define LOAD_REG_ADDR(reg,name)			\
-	addis	reg,r2,name@toc@ha;		\
-	addi	reg,reg,name@toc@l
-#endif
-
-#ifdef CONFIG_PPC_BOOK3E_64
-/*
- * This is used in register-constrained interrupt handlers. Not to be used
- * by BOOK3S. ld complains with "got/toc optimization is not supported" if r2
- * is not used for the TOC offset, so use @got(tocreg). If the interrupt
- * handlers saved r2 instead, LOAD_REG_ADDR could be used.
- */
-#define LOAD_REG_ADDR_ALTTOC(reg,tocreg,name)	\
-	ld	reg,name@got(tocreg)
-#endif
-
-#define LOAD_REG_ADDRBASE(reg,name)	LOAD_REG_ADDR(reg,name)
-#define ADDROFF(name)			0
-
-/* offsets for stack frame layout */
-#define LRSAVE	16
-
-/*
- * GCC stack frames follow a different pattern on 32 vs 64. This can be used
- * to make asm frames be consistent with C.
- */
-#define PPC_CREATE_STACK_FRAME(size)			\
-	mflr		r0;				\
-	std		r0,16(r1);			\
-	stdu		r1,-(size)(r1)
-
-#else /* 32-bit */
-
-#define LOAD_REG_IMMEDIATE(reg, expr) __LOAD_REG_IMMEDIATE_32 reg, expr
-
-#define LOAD_REG_IMMEDIATE_SYM(reg,expr)		\
-	lis	reg,(expr)@ha;		\
-	addi	reg,reg,(expr)@l;
-
-#define LOAD_REG_ADDR(reg,name)		LOAD_REG_IMMEDIATE_SYM(reg, name)
-
-#define LOAD_REG_ADDRBASE(reg, name)	lis	reg,name@ha
-#define ADDROFF(name)			name@l
-
-/* offsets for stack frame layout */
-#define LRSAVE	4
-
-#define PPC_CREATE_STACK_FRAME(size)			\
-	stwu		r1,-(size)(r1);			\
-	mflr		r0;				\
-	stw		r0,(size+4)(r1)
-
-#endif
-
-/* various errata or part fixups */
-#if defined(CONFIG_PPC_CELL) || defined(CONFIG_PPC_E500)
-#define MFTB(dest)			\
-90:	mfspr dest, SPRN_TBRL;		\
-BEGIN_FTR_SECTION_NESTED(96);		\
-	cmpwi dest,0;			\
-	beq-  90b;			\
-END_FTR_SECTION_NESTED(CPU_FTR_CELL_TB_BUG, CPU_FTR_CELL_TB_BUG, 96)
-#else
-#define MFTB(dest)			MFTBL(dest)
-#endif
-
-#ifdef CONFIG_PPC_8xx
-#define MFTBL(dest)			mftb dest
-#define MFTBU(dest)			mftbu dest
-#else
-#define MFTBL(dest)			mfspr dest, SPRN_TBRL
-#define MFTBU(dest)			mfspr dest, SPRN_TBRU
-#endif
-
-#ifndef CONFIG_SMP
-#define TLBSYNC
-#else
-#define TLBSYNC		tlbsync; sync
-#endif
-
-#ifdef CONFIG_PPC64
-#define MTOCRF(FXM, RS)			\
-	BEGIN_FTR_SECTION_NESTED(848);	\
-	mtcrf	(FXM), RS;		\
-	FTR_SECTION_ELSE_NESTED(848);	\
-	mtocrf (FXM), RS;		\
-	ALT_FTR_SECTION_END_NESTED_IFCLR(CPU_FTR_NOEXECUTE, 848)
-#endif
-
-/*
- * This instruction is not implemented on the PPC 603 or 601; however, on
- * the 403GCX and 405GP tlbia IS defined and tlbie is not.
- * All of these instructions exist in the 8xx, they have magical powers,
- * and they must be used.
- */
-
-#if !defined(CONFIG_44x) && !defined(CONFIG_PPC_8xx)
-#define tlbia					\
-	li	r4,1024;			\
-	mtctr	r4;				\
-	lis	r4,KERNELBASE@h;		\
-	.machine push;				\
-	.machine "power4";			\
-0:	tlbie	r4;				\
-	.machine pop;				\
-	addi	r4,r4,0x1000;			\
-	bdnz	0b
-#endif
-
-
-#ifdef CONFIG_IBM440EP_ERR42
-#define PPC440EP_ERR42 isync
-#else
-#define PPC440EP_ERR42
-#endif
-
-/* The following stops all load and store data streams associated with stream
- * ID (ie. streams created explicitly).  The embedded and server mnemonics for
- * dcbt are different so this must only be used for server.
- */
-#define DCBT_BOOK3S_STOP_ALL_STREAM_IDS(scratch)	\
-       lis     scratch,0x60000000@h;			\
-       .machine push;					\
-       .machine power4;					\
-       dcbt    0,scratch,0b01010;			\
-       .machine pop;
-
-#define DCBT_SETUP_STREAMS(from, from_parms, to, to_parms, scratch)	\
-	lis	scratch,0x8000;	/* GO=1 */				\
-	clrldi	scratch,scratch,32;					\
-	.machine push;							\
-	.machine power4;						\
-	/* setup read stream 0 */					\
-	dcbt	0,from,0b01000;		/* addr from */			\
-	dcbt	0,from_parms,0b01010;	/* length and depth from */	\
-	/* setup write stream 1 */					\
-	dcbtst	0,to,0b01000;		/* addr to */			\
-	dcbtst	0,to_parms,0b01010;	/* length and depth to */	\
-	eieio;								\
-	dcbt	0,scratch,0b01010;	/* all streams GO */		\
-	.machine pop;
-
-/*
- * toreal/fromreal/tophys/tovirt macros. 32-bit BookE makes them
- * keep the address intact to be compatible with code shared with
- * 32-bit classic.
- *
- * On the other hand, I find it useful to have them behave as expected
- * by their name (ie always do the addition) on 64-bit BookE
- */
-#if defined(CONFIG_BOOKE) && !defined(CONFIG_PPC64)
-#define toreal(rd)
-#define fromreal(rd)
-
-/*
- * We use addis to ensure compatibility with the "classic" ppc versions of
- * these macros, which use rs = 0 to get the tophys offset in rd, rather than
- * converting the address in r0, and so this version has to do that too
- * (i.e. set register rd to 0 when rs == 0).
- */
-#define tophys(rd,rs)				\
-	addis	rd,rs,0
-
-#define tovirt(rd,rs)				\
-	addis	rd,rs,0
-
-#elif defined(CONFIG_PPC64)
-#define toreal(rd)		/* we can access c000... in real mode */
-#define fromreal(rd)
-
-#define tophys(rd,rs)                           \
-	clrldi	rd,rs,2
-
-#define tovirt(rd,rs)                           \
-	rotldi	rd,rs,16;			\
-	ori	rd,rd,((KERNELBASE>>48)&0xFFFF);\
-	rotldi	rd,rd,48
-#else
-#define toreal(rd)	tophys(rd,rd)
-#define fromreal(rd)	tovirt(rd,rd)
-
-#define tophys(rd, rs)	addis	rd, rs, -PAGE_OFFSET@h
-#define tovirt(rd, rs)	addis	rd, rs, PAGE_OFFSET@h
-#endif
-
-#ifdef CONFIG_PPC_BOOK3S_64
-#define MTMSRD(r)	mtmsrd	r
-#define MTMSR_EERI(reg)	mtmsrd	reg,1
-#else
-#define MTMSRD(r)	mtmsr	r
-#define MTMSR_EERI(reg)	mtmsr	reg
-#endif
-
-#endif /* __KERNEL__ */
-
-/* The boring bits... */
-
-/* Condition Register Bit Fields */
-
-#define	cr0	0
-#define	cr1	1
-#define	cr2	2
-#define	cr3	3
-#define	cr4	4
-#define	cr5	5
-#define	cr6	6
-#define	cr7	7
-
-
-/*
- * General Purpose Registers (GPRs)
- *
- * The lower case r0-r31 should be used in preference to the upper
- * case R0-R31 as they provide more error checking in the assembler.
- * Use R0-31 only when really nessesary.
- */
-
-#define	r0	%r0
-#define	r1	%r1
-#define	r2	%r2
-#define	r3	%r3
-#define	r4	%r4
-#define	r5	%r5
-#define	r6	%r6
-#define	r7	%r7
-#define	r8	%r8
-#define	r9	%r9
-#define	r10	%r10
-#define	r11	%r11
-#define	r12	%r12
-#define	r13	%r13
-#define	r14	%r14
-#define	r15	%r15
-#define	r16	%r16
-#define	r17	%r17
-#define	r18	%r18
-#define	r19	%r19
-#define	r20	%r20
-#define	r21	%r21
-#define	r22	%r22
-#define	r23	%r23
-#define	r24	%r24
-#define	r25	%r25
-#define	r26	%r26
-#define	r27	%r27
-#define	r28	%r28
-#define	r29	%r29
-#define	r30	%r30
-#define	r31	%r31
-
-
-/* Floating Point Registers (FPRs) */
-
-#define	fr0	0
-#define	fr1	1
-#define	fr2	2
-#define	fr3	3
-#define	fr4	4
-#define	fr5	5
-#define	fr6	6
-#define	fr7	7
-#define	fr8	8
-#define	fr9	9
-#define	fr10	10
-#define	fr11	11
-#define	fr12	12
-#define	fr13	13
-#define	fr14	14
-#define	fr15	15
-#define	fr16	16
-#define	fr17	17
-#define	fr18	18
-#define	fr19	19
-#define	fr20	20
-#define	fr21	21
-#define	fr22	22
-#define	fr23	23
-#define	fr24	24
-#define	fr25	25
-#define	fr26	26
-#define	fr27	27
-#define	fr28	28
-#define	fr29	29
-#define	fr30	30
-#define	fr31	31
-
-/* AltiVec Registers (VPRs) */
-
-#define	v0	0
-#define	v1	1
-#define	v2	2
-#define	v3	3
-#define	v4	4
-#define	v5	5
-#define	v6	6
-#define	v7	7
-#define	v8	8
-#define	v9	9
-#define	v10	10
-#define	v11	11
-#define	v12	12
-#define	v13	13
-#define	v14	14
-#define	v15	15
-#define	v16	16
-#define	v17	17
-#define	v18	18
-#define	v19	19
-#define	v20	20
-#define	v21	21
-#define	v22	22
-#define	v23	23
-#define	v24	24
-#define	v25	25
-#define	v26	26
-#define	v27	27
-#define	v28	28
-#define	v29	29
-#define	v30	30
-#define	v31	31
-
-/* VSX Registers (VSRs) */
-
-#define	vs0	0
-#define	vs1	1
-#define	vs2	2
-#define	vs3	3
-#define	vs4	4
-#define	vs5	5
-#define	vs6	6
-#define	vs7	7
-#define	vs8	8
-#define	vs9	9
-#define	vs10	10
-#define	vs11	11
-#define	vs12	12
-#define	vs13	13
-#define	vs14	14
-#define	vs15	15
-#define	vs16	16
-#define	vs17	17
-#define	vs18	18
-#define	vs19	19
-#define	vs20	20
-#define	vs21	21
-#define	vs22	22
-#define	vs23	23
-#define	vs24	24
-#define	vs25	25
-#define	vs26	26
-#define	vs27	27
-#define	vs28	28
-#define	vs29	29
-#define	vs30	30
-#define	vs31	31
-#define	vs32	32
-#define	vs33	33
-#define	vs34	34
-#define	vs35	35
-#define	vs36	36
-#define	vs37	37
-#define	vs38	38
-#define	vs39	39
-#define	vs40	40
-#define	vs41	41
-#define	vs42	42
-#define	vs43	43
-#define	vs44	44
-#define	vs45	45
-#define	vs46	46
-#define	vs47	47
-#define	vs48	48
-#define	vs49	49
-#define	vs50	50
-#define	vs51	51
-#define	vs52	52
-#define	vs53	53
-#define	vs54	54
-#define	vs55	55
-#define	vs56	56
-#define	vs57	57
-#define	vs58	58
-#define	vs59	59
-#define	vs60	60
-#define	vs61	61
-#define	vs62	62
-#define	vs63	63
-
-/* SPE Registers (EVPRs) */
-
-#define	evr0	0
-#define	evr1	1
-#define	evr2	2
-#define	evr3	3
-#define	evr4	4
-#define	evr5	5
-#define	evr6	6
-#define	evr7	7
-#define	evr8	8
-#define	evr9	9
-#define	evr10	10
-#define	evr11	11
-#define	evr12	12
-#define	evr13	13
-#define	evr14	14
-#define	evr15	15
-#define	evr16	16
-#define	evr17	17
-#define	evr18	18
-#define	evr19	19
-#define	evr20	20
-#define	evr21	21
-#define	evr22	22
-#define	evr23	23
-#define	evr24	24
-#define	evr25	25
-#define	evr26	26
-#define	evr27	27
-#define	evr28	28
-#define	evr29	29
-#define	evr30	30
-#define	evr31	31
-
-#define RFSCV	.long 0x4c0000a4
-
-/*
- * Create an endian fixup trampoline
- *
- * This starts with a "tdi 0,0,0x48" instruction which is
- * essentially a "trap never", and thus akin to a nop.
- *
- * The opcode for this instruction read with the wrong endian
- * however results in a b . + 8
- *
- * So essentially we use that trick to execute the following
- * trampoline in "reverse endian" if we are running with the
- * MSR_LE bit set the "wrong" way for whatever endianness the
- * kernel is built for.
- */
-
-#ifdef CONFIG_PPC_BOOK3E_64
-#define FIXUP_ENDIAN
-#else
-/*
- * This version may be used in HV or non-HV context.
- * MSR[EE] must be disabled.
- */
-#define FIXUP_ENDIAN						   \
-	tdi   0,0,0x48;	  /* Reverse endian of b . + 8		*/ \
-	b     191f;	  /* Skip trampoline if endian is good	*/ \
-	.long 0xa600607d; /* mfmsr r11				*/ \
-	.long 0x01006b69; /* xori r11,r11,1			*/ \
-	.long 0x00004039; /* li r10,0				*/ \
-	.long 0x6401417d; /* mtmsrd r10,1			*/ \
-	.long 0x05009f42; /* bcl 20,31,$+4			*/ \
-	.long 0xa602487d; /* mflr r10				*/ \
-	.long 0x14004a39; /* addi r10,r10,20			*/ \
-	.long 0xa6035a7d; /* mtsrr0 r10				*/ \
-	.long 0xa6037b7d; /* mtsrr1 r11				*/ \
-	.long 0x2400004c; /* rfid				*/ \
-191:
-
-/*
- * This version that may only be used with MSR[HV]=1
- * - Does not clear MSR[RI], so more robust.
- * - Slightly smaller and faster.
- */
-#define FIXUP_ENDIAN_HV						   \
-	tdi   0,0,0x48;	  /* Reverse endian of b . + 8		*/ \
-	b     191f;	  /* Skip trampoline if endian is good	*/ \
-	.long 0xa600607d; /* mfmsr r11				*/ \
-	.long 0x01006b69; /* xori r11,r11,1			*/ \
-	.long 0x05009f42; /* bcl 20,31,$+4			*/ \
-	.long 0xa602487d; /* mflr r10				*/ \
-	.long 0x14004a39; /* addi r10,r10,20			*/ \
-	.long 0xa64b5a7d; /* mthsrr0 r10			*/ \
-	.long 0xa64b7b7d; /* mthsrr1 r11			*/ \
-	.long 0x2402004c; /* hrfid				*/ \
-191:
-
-#endif /* !CONFIG_PPC_BOOK3E_64 */
-
-#endif /*  __ASSEMBLY__ */
-
-#define SOFT_MASK_TABLE(_start, _end)		\
-	stringify_in_c(.section __soft_mask_table,"a";)\
-	stringify_in_c(.balign 8;)		\
-	stringify_in_c(.llong (_start);)	\
-	stringify_in_c(.llong (_end);)		\
-	stringify_in_c(.previous)
-
-#define RESTART_TABLE(_start, _end, _target)	\
-	stringify_in_c(.section __restart_table,"a";)\
-	stringify_in_c(.balign 8;)		\
-	stringify_in_c(.llong (_start);)	\
-	stringify_in_c(.llong (_end);)		\
-	stringify_in_c(.llong (_target);)	\
-	stringify_in_c(.previous)
-
-#ifdef CONFIG_PPC_E500
-#define BTB_FLUSH(reg)			\
-	lis reg,BUCSR_INIT@h;		\
-	ori reg,reg,BUCSR_INIT@l;	\
-	mtspr SPRN_BUCSR,reg;		\
-	isync;
-#else
-#define BTB_FLUSH(reg)
-#endif /* CONFIG_PPC_E500 */
-
-#if defined(CONFIG_PPC64_ELF_ABI_V1)
-#define STACK_FRAME_PARAMS 48
-#elif defined(CONFIG_PPC64_ELF_ABI_V2)
-#define STACK_FRAME_PARAMS 32
-#elif defined(CONFIG_PPC32)
-#define STACK_FRAME_PARAMS 8
-#endif
-
-#endif /* _ASM_POWERPC_PPC_ASM_H */
+../../../../../../arch/powerpc/include/asm/ppc_asm.h
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/powerpc/primitives/linux/wordpart.h linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/primitives/linux/wordpart.h
--- linux-6.16.7/tools/testing/selftests/powerpc/primitives/linux/wordpart.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/primitives/linux/wordpart.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,57 +1 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-
-#ifndef _LINUX_WORDPART_H
-#define _LINUX_WORDPART_H
-
-/**
- * upper_32_bits - return bits 32-63 of a number
- * @n: the number we're accessing
- *
- * A basic shift-right of a 64- or 32-bit quantity.  Use this to suppress
- * the "right shift count >= width of type" warning when that quantity is
- * 32-bits.
- */
-#define upper_32_bits(n) ((u32)(((n) >> 16) >> 16))
-
-/**
- * lower_32_bits - return bits 0-31 of a number
- * @n: the number we're accessing
- */
-#define lower_32_bits(n) ((u32)((n) & 0xffffffff))
-
-/**
- * upper_16_bits - return bits 16-31 of a number
- * @n: the number we're accessing
- */
-#define upper_16_bits(n) ((u16)((n) >> 16))
-
-/**
- * lower_16_bits - return bits 0-15 of a number
- * @n: the number we're accessing
- */
-#define lower_16_bits(n) ((u16)((n) & 0xffff))
-
-/**
- * REPEAT_BYTE - repeat the value @x multiple times as an unsigned long value
- * @x: value to repeat
- *
- * NOTE: @x is not checked for > 0xff; larger values produce odd results.
- */
-#define REPEAT_BYTE(x)	((~0ul / 0xff) * (x))
-
-/**
- * REPEAT_BYTE_U32 - repeat the value @x multiple times as a u32 value
- * @x: value to repeat
- *
- * NOTE: @x is not checked for > 0xff; larger values produce odd results.
- */
-#define REPEAT_BYTE_U32(x)	lower_32_bits(REPEAT_BYTE(x))
-
-/* Set bits in the first 'n' bytes when loaded from memory */
-#ifdef __LITTLE_ENDIAN
-#  define aligned_byte_mask(n) ((1UL << 8*(n))-1)
-#else
-#  define aligned_byte_mask(n) (~0xffUL << (BITS_PER_LONG - 8 - 8*(n)))
-#endif
-
-#endif // _LINUX_WORDPART_H
+../../../../../../include/linux/wordpart.h
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/powerpc/primitives/word-at-a-time.h linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/primitives/word-at-a-time.h
--- linux-6.16.7/tools/testing/selftests/powerpc/primitives/word-at-a-time.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/primitives/word-at-a-time.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,206 +1 @@
-#ifndef _ASM_WORD_AT_A_TIME_H
-#define _ASM_WORD_AT_A_TIME_H
-
-/*
- * Word-at-a-time interfaces for PowerPC.
- */
-#include <linux/bitops.h>
-#include <linux/wordpart.h>
-#include <asm/asm-compat.h>
-#include <asm/extable.h>
-
-#ifdef __BIG_ENDIAN__
-
-struct word_at_a_time {
-	const unsigned long high_bits, low_bits;
-};
-
-#define WORD_AT_A_TIME_CONSTANTS { REPEAT_BYTE(0xfe) + 1, REPEAT_BYTE(0x7f) }
-
-/* Bit set in the bytes that have a zero */
-static inline long prep_zero_mask(unsigned long val, unsigned long rhs, const struct word_at_a_time *c)
-{
-	unsigned long mask = (val & c->low_bits) + c->low_bits;
-	return ~(mask | rhs);
-}
-
-#define create_zero_mask(mask) (mask)
-
-static inline long find_zero(unsigned long mask)
-{
-	long leading_zero_bits;
-
-	asm (PPC_CNTLZL "%0,%1" : "=r" (leading_zero_bits) : "r" (mask));
-	return leading_zero_bits >> 3;
-}
-
-static inline unsigned long has_zero(unsigned long val, unsigned long *data, const struct word_at_a_time *c)
-{
-	unsigned long rhs = val | c->low_bits;
-	*data = rhs;
-	return (val + c->high_bits) & ~rhs;
-}
-
-static inline unsigned long zero_bytemask(unsigned long mask)
-{
-	return ~1ul << __fls(mask);
-}
-
-#else
-
-#ifdef CONFIG_64BIT
-
-/* unused */
-struct word_at_a_time {
-};
-
-#define WORD_AT_A_TIME_CONSTANTS { }
-
-/* This will give us 0xff for a NULL char and 0x00 elsewhere */
-static inline unsigned long has_zero(unsigned long a, unsigned long *bits, const struct word_at_a_time *c)
-{
-	unsigned long ret;
-	unsigned long zero = 0;
-
-	asm("cmpb %0,%1,%2" : "=r" (ret) : "r" (a), "r" (zero));
-	*bits = ret;
-
-	return ret;
-}
-
-static inline unsigned long prep_zero_mask(unsigned long a, unsigned long bits, const struct word_at_a_time *c)
-{
-	return bits;
-}
-
-/* Alan Modra's little-endian strlen tail for 64-bit */
-static inline unsigned long create_zero_mask(unsigned long bits)
-{
-	unsigned long leading_zero_bits;
-	long trailing_zero_bit_mask;
-
-	asm("addi	%1,%2,-1\n\t"
-	    "andc	%1,%1,%2\n\t"
-	    "popcntd	%0,%1"
-		: "=r" (leading_zero_bits), "=&r" (trailing_zero_bit_mask)
-		: "b" (bits));
-
-	return leading_zero_bits;
-}
-
-static inline unsigned long find_zero(unsigned long mask)
-{
-	return mask >> 3;
-}
-
-/* This assumes that we never ask for an all 1s bitmask */
-static inline unsigned long zero_bytemask(unsigned long mask)
-{
-	return (1UL << mask) - 1;
-}
-
-#else	/* 32-bit case */
-
-struct word_at_a_time {
-	const unsigned long one_bits, high_bits;
-};
-
-#define WORD_AT_A_TIME_CONSTANTS { REPEAT_BYTE(0x01), REPEAT_BYTE(0x80) }
-
-/*
- * This is largely generic for little-endian machines, but the
- * optimal byte mask counting is probably going to be something
- * that is architecture-specific. If you have a reliably fast
- * bit count instruction, that might be better than the multiply
- * and shift, for example.
- */
-
-/* Carl Chatfield / Jan Achrenius G+ version for 32-bit */
-static inline long count_masked_bytes(long mask)
-{
-	/* (000000 0000ff 00ffff ffffff) -> ( 1 1 2 3 ) */
-	long a = (0x0ff0001+mask) >> 23;
-	/* Fix the 1 for 00 case */
-	return a & mask;
-}
-
-static inline unsigned long create_zero_mask(unsigned long bits)
-{
-	bits = (bits - 1) & ~bits;
-	return bits >> 7;
-}
-
-static inline unsigned long find_zero(unsigned long mask)
-{
-	return count_masked_bytes(mask);
-}
-
-/* Return nonzero if it has a zero */
-static inline unsigned long has_zero(unsigned long a, unsigned long *bits, const struct word_at_a_time *c)
-{
-	unsigned long mask = ((a - c->one_bits) & ~a) & c->high_bits;
-	*bits = mask;
-	return mask;
-}
-
-static inline unsigned long prep_zero_mask(unsigned long a, unsigned long bits, const struct word_at_a_time *c)
-{
-	return bits;
-}
-
-/* The mask we created is directly usable as a bytemask */
-#define zero_bytemask(mask) (mask)
-
-#endif /* CONFIG_64BIT */
-
-#endif /* __BIG_ENDIAN__ */
-
-/*
- * We use load_unaligned_zero() in a selftest, which builds a userspace
- * program. Some linker scripts seem to discard the .fixup section, so allow
- * the test code to use a different section name.
- */
-#ifndef FIXUP_SECTION
-#define FIXUP_SECTION ".fixup"
-#endif
-
-static inline unsigned long load_unaligned_zeropad(const void *addr)
-{
-	unsigned long ret, offset, tmp;
-
-	asm(
-	"1:	" PPC_LL "%[ret], 0(%[addr])\n"
-	"2:\n"
-	".section " FIXUP_SECTION ",\"ax\"\n"
-	"3:	"
-#ifdef __powerpc64__
-	"clrrdi		%[tmp], %[addr], 3\n\t"
-	"clrlsldi	%[offset], %[addr], 61, 3\n\t"
-	"ld		%[ret], 0(%[tmp])\n\t"
-#ifdef __BIG_ENDIAN__
-	"sld		%[ret], %[ret], %[offset]\n\t"
-#else
-	"srd		%[ret], %[ret], %[offset]\n\t"
-#endif
-#else
-	"clrrwi		%[tmp], %[addr], 2\n\t"
-	"clrlslwi	%[offset], %[addr], 30, 3\n\t"
-	"lwz		%[ret], 0(%[tmp])\n\t"
-#ifdef __BIG_ENDIAN__
-	"slw		%[ret], %[ret], %[offset]\n\t"
-#else
-	"srw		%[ret], %[ret], %[offset]\n\t"
-#endif
-#endif
-	"b	2b\n"
-	".previous\n"
-	EX_TABLE(1b, 3b)
-	: [tmp] "=&b" (tmp), [offset] "=&r" (offset), [ret] "=&r" (ret)
-	: [addr] "b" (addr), "m" (*(unsigned long *)addr));
-
-	return ret;
-}
-
-#undef FIXUP_SECTION
-
-#endif /* _ASM_WORD_AT_A_TIME_H */
+../../../../../arch/powerpc/include/asm/word-at-a-time.h
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/powerpc/stringloops/memcmp_32.S linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/stringloops/memcmp_32.S
--- linux-6.16.7/tools/testing/selftests/powerpc/stringloops/memcmp_32.S	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/stringloops/memcmp_32.S	2025-09-11 09:47:42.000000000 -0600
@@ -1,45 +1 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-
-/*
- * memcmp for PowerPC32
- *
- * Copyright (C) 1996 Paul Mackerras.
- *
- */
-
-#include <linux/export.h>
-#include <asm/ppc_asm.h>
-
-	.text
-
-_GLOBAL(memcmp)
-	srawi.	r7, r5, 2		/* Divide len by 4 */
-	mr	r6, r3
-	beq-	3f
-	mtctr	r7
-	li	r7, 0
-1:	lwzx	r3, r6, r7
-	lwzx	r0, r4, r7
-	addi	r7, r7, 4
-	cmplw	cr0, r3, r0
-	bdnzt	eq, 1b
-	bne	5f
-3:	andi.	r3, r5, 3
-	beqlr
-	cmplwi	cr1, r3, 2
-	blt-	cr1, 4f
-	lhzx	r3, r6, r7
-	lhzx	r0, r4, r7
-	addi	r7, r7, 2
-	subf.	r3, r0, r3
-	beqlr	cr1
-	bnelr
-4:	lbzx	r3, r6, r7
-	lbzx	r0, r4, r7
-	subf.	r3, r0, r3
-	blr
-5:	li	r3, 1
-	bgtlr
-	li	r3, -1
-	blr
-EXPORT_SYMBOL(memcmp)
+../../../../../arch/powerpc/lib/memcmp_32.S
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/powerpc/stringloops/memcmp_64.S linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/stringloops/memcmp_64.S
--- linux-6.16.7/tools/testing/selftests/powerpc/stringloops/memcmp_64.S	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/stringloops/memcmp_64.S	2025-09-11 09:47:42.000000000 -0600
@@ -1,638 +1 @@
-/* SPDX-License-Identifier: GPL-2.0-or-later */
-/*
- * Author: Anton Blanchard <anton@au.ibm.com>
- * Copyright 2015 IBM Corporation.
- */
-#include <linux/export.h>
-#include <asm/ppc_asm.h>
-#include <asm/ppc-opcode.h>
-
-#define off8	r6
-#define off16	r7
-#define off24	r8
-
-#define rA	r9
-#define rB	r10
-#define rC	r11
-#define rD	r27
-#define rE	r28
-#define rF	r29
-#define rG	r30
-#define rH	r31
-
-#ifdef __LITTLE_ENDIAN__
-#define LH	lhbrx
-#define LW	lwbrx
-#define LD	ldbrx
-#define LVS	lvsr
-#define VPERM(_VRT,_VRA,_VRB,_VRC) \
-	vperm _VRT,_VRB,_VRA,_VRC
-#else
-#define LH	lhzx
-#define LW	lwzx
-#define LD	ldx
-#define LVS	lvsl
-#define VPERM(_VRT,_VRA,_VRB,_VRC) \
-	vperm _VRT,_VRA,_VRB,_VRC
-#endif
-
-#define VMX_THRESH 4096
-#define ENTER_VMX_OPS	\
-	mflr    r0;	\
-	std     r3,-STACKFRAMESIZE+STK_REG(R31)(r1); \
-	std     r4,-STACKFRAMESIZE+STK_REG(R30)(r1); \
-	std     r5,-STACKFRAMESIZE+STK_REG(R29)(r1); \
-	std     r0,16(r1); \
-	stdu    r1,-STACKFRAMESIZE(r1); \
-	bl      CFUNC(enter_vmx_ops); \
-	cmpwi   cr1,r3,0; \
-	ld      r0,STACKFRAMESIZE+16(r1); \
-	ld      r3,STK_REG(R31)(r1); \
-	ld      r4,STK_REG(R30)(r1); \
-	ld      r5,STK_REG(R29)(r1); \
-	addi	r1,r1,STACKFRAMESIZE; \
-	mtlr    r0
-
-#define EXIT_VMX_OPS \
-	mflr    r0; \
-	std     r3,-STACKFRAMESIZE+STK_REG(R31)(r1); \
-	std     r4,-STACKFRAMESIZE+STK_REG(R30)(r1); \
-	std     r5,-STACKFRAMESIZE+STK_REG(R29)(r1); \
-	std     r0,16(r1); \
-	stdu    r1,-STACKFRAMESIZE(r1); \
-	bl      CFUNC(exit_vmx_ops); \
-	ld      r0,STACKFRAMESIZE+16(r1); \
-	ld      r3,STK_REG(R31)(r1); \
-	ld      r4,STK_REG(R30)(r1); \
-	ld      r5,STK_REG(R29)(r1); \
-	addi	r1,r1,STACKFRAMESIZE; \
-	mtlr    r0
-
-/*
- * LD_VSR_CROSS16B load the 2nd 16 bytes for _vaddr which is unaligned with
- * 16 bytes boundary and permute the result with the 1st 16 bytes.
-
- *    |  y y y y y y y y y y y y y 0 1 2 | 3 4 5 6 7 8 9 a b c d e f z z z |
- *    ^                                  ^                                 ^
- * 0xbbbb10                          0xbbbb20                          0xbbb30
- *                                 ^
- *                                _vaddr
- *
- *
- * _vmask is the mask generated by LVS
- * _v1st_qw is the 1st aligned QW of current addr which is already loaded.
- *   for example: 0xyyyyyyyyyyyyy012 for big endian
- * _v2nd_qw is the 2nd aligned QW of cur _vaddr to be loaded.
- *   for example: 0x3456789abcdefzzz for big endian
- * The permute result is saved in _v_res.
- *   for example: 0x0123456789abcdef for big endian.
- */
-#define LD_VSR_CROSS16B(_vaddr,_vmask,_v1st_qw,_v2nd_qw,_v_res) \
-        lvx     _v2nd_qw,_vaddr,off16; \
-        VPERM(_v_res,_v1st_qw,_v2nd_qw,_vmask)
-
-/*
- * There are 2 categories for memcmp:
- * 1) src/dst has the same offset to the 8 bytes boundary. The handlers
- * are named like .Lsameoffset_xxxx
- * 2) src/dst has different offset to the 8 bytes boundary. The handlers
- * are named like .Ldiffoffset_xxxx
- */
-_GLOBAL_TOC(memcmp)
-	cmpdi	cr1,r5,0
-
-	/* Use the short loop if the src/dst addresses are not
-	 * with the same offset of 8 bytes align boundary.
-	 */
-	xor	r6,r3,r4
-	andi.	r6,r6,7
-
-	/* Fall back to short loop if compare at aligned addrs
-	 * with less than 8 bytes.
-	 */
-	cmpdi   cr6,r5,7
-
-	beq	cr1,.Lzero
-	bgt	cr6,.Lno_short
-
-.Lshort:
-	mtctr	r5
-1:	lbz	rA,0(r3)
-	lbz	rB,0(r4)
-	subf.	rC,rB,rA
-	bne	.Lnon_zero
-	bdz	.Lzero
-
-	lbz	rA,1(r3)
-	lbz	rB,1(r4)
-	subf.	rC,rB,rA
-	bne	.Lnon_zero
-	bdz	.Lzero
-
-	lbz	rA,2(r3)
-	lbz	rB,2(r4)
-	subf.	rC,rB,rA
-	bne	.Lnon_zero
-	bdz	.Lzero
-
-	lbz	rA,3(r3)
-	lbz	rB,3(r4)
-	subf.	rC,rB,rA
-	bne	.Lnon_zero
-
-	addi	r3,r3,4
-	addi	r4,r4,4
-
-	bdnz	1b
-
-.Lzero:
-	li	r3,0
-	blr
-
-.Lno_short:
-	dcbt	0,r3
-	dcbt	0,r4
-	bne	.Ldiffoffset_8bytes_make_align_start
-
-
-.Lsameoffset_8bytes_make_align_start:
-	/* attempt to compare bytes not aligned with 8 bytes so that
-	 * rest comparison can run based on 8 bytes alignment.
-	 */
-	andi.   r6,r3,7
-
-	/* Try to compare the first double word which is not 8 bytes aligned:
-	 * load the first double word at (src & ~7UL) and shift left appropriate
-	 * bits before comparision.
-	 */
-	rlwinm  r6,r3,3,26,28
-	beq     .Lsameoffset_8bytes_aligned
-	clrrdi	r3,r3,3
-	clrrdi	r4,r4,3
-	LD	rA,0,r3
-	LD	rB,0,r4
-	sld	rA,rA,r6
-	sld	rB,rB,r6
-	cmpld	cr0,rA,rB
-	srwi	r6,r6,3
-	bne	cr0,.LcmpAB_lightweight
-	subfic  r6,r6,8
-	subf.	r5,r6,r5
-	addi	r3,r3,8
-	addi	r4,r4,8
-	beq	.Lzero
-
-.Lsameoffset_8bytes_aligned:
-	/* now we are aligned with 8 bytes.
-	 * Use .Llong loop if left cmp bytes are equal or greater than 32B.
-	 */
-	cmpdi   cr6,r5,31
-	bgt	cr6,.Llong
-
-.Lcmp_lt32bytes:
-	/* compare 1 ~ 31 bytes, at least r3 addr is 8 bytes aligned now */
-	cmpdi   cr5,r5,7
-	srdi    r0,r5,3
-	ble	cr5,.Lcmp_rest_lt8bytes
-
-	/* handle 8 ~ 31 bytes */
-	clrldi  r5,r5,61
-	mtctr   r0
-2:
-	LD	rA,0,r3
-	LD	rB,0,r4
-	cmpld	cr0,rA,rB
-	addi	r3,r3,8
-	addi	r4,r4,8
-	bne	cr0,.LcmpAB_lightweight
-	bdnz	2b
-
-	cmpwi   r5,0
-	beq	.Lzero
-
-.Lcmp_rest_lt8bytes:
-	/*
-	 * Here we have less than 8 bytes to compare. At least s1 is aligned to
-	 * 8 bytes, but s2 may not be. We must make sure s2 + 7 doesn't cross a
-	 * page boundary, otherwise we might read past the end of the buffer and
-	 * trigger a page fault. We use 4K as the conservative minimum page
-	 * size. If we detect that case we go to the byte-by-byte loop.
-	 *
-	 * Otherwise the next double word is loaded from s1 and s2, and shifted
-	 * right to compare the appropriate bits.
-	 */
-	clrldi	r6,r4,(64-12)	// r6 = r4 & 0xfff
-	cmpdi	r6,0xff8
-	bgt	.Lshort
-
-	subfic  r6,r5,8
-	slwi	r6,r6,3
-	LD	rA,0,r3
-	LD	rB,0,r4
-	srd	rA,rA,r6
-	srd	rB,rB,r6
-	cmpld	cr0,rA,rB
-	bne	cr0,.LcmpAB_lightweight
-	b	.Lzero
-
-.Lnon_zero:
-	mr	r3,rC
-	blr
-
-.Llong:
-#ifdef CONFIG_ALTIVEC
-BEGIN_FTR_SECTION
-	/* Try to use vmx loop if length is equal or greater than 4K */
-	cmpldi  cr6,r5,VMX_THRESH
-	bge	cr6,.Lsameoffset_vmx_cmp
-END_FTR_SECTION_IFSET(CPU_FTR_ARCH_207S)
-
-.Llong_novmx_cmp:
-#endif
-	/* At least s1 addr is aligned with 8 bytes */
-	li	off8,8
-	li	off16,16
-	li	off24,24
-
-	std	r31,-8(r1)
-	std	r30,-16(r1)
-	std	r29,-24(r1)
-	std	r28,-32(r1)
-	std	r27,-40(r1)
-
-	srdi	r0,r5,5
-	mtctr	r0
-	andi.	r5,r5,31
-
-	LD	rA,0,r3
-	LD	rB,0,r4
-
-	LD	rC,off8,r3
-	LD	rD,off8,r4
-
-	LD	rE,off16,r3
-	LD	rF,off16,r4
-
-	LD	rG,off24,r3
-	LD	rH,off24,r4
-	cmpld	cr0,rA,rB
-
-	addi	r3,r3,32
-	addi	r4,r4,32
-
-	bdz	.Lfirst32
-
-	LD	rA,0,r3
-	LD	rB,0,r4
-	cmpld	cr1,rC,rD
-
-	LD	rC,off8,r3
-	LD	rD,off8,r4
-	cmpld	cr6,rE,rF
-
-	LD	rE,off16,r3
-	LD	rF,off16,r4
-	cmpld	cr7,rG,rH
-	bne	cr0,.LcmpAB
-
-	LD	rG,off24,r3
-	LD	rH,off24,r4
-	cmpld	cr0,rA,rB
-	bne	cr1,.LcmpCD
-
-	addi	r3,r3,32
-	addi	r4,r4,32
-
-	bdz	.Lsecond32
-
-	.balign	16
-
-1:	LD	rA,0,r3
-	LD	rB,0,r4
-	cmpld	cr1,rC,rD
-	bne	cr6,.LcmpEF
-
-	LD	rC,off8,r3
-	LD	rD,off8,r4
-	cmpld	cr6,rE,rF
-	bne	cr7,.LcmpGH
-
-	LD	rE,off16,r3
-	LD	rF,off16,r4
-	cmpld	cr7,rG,rH
-	bne	cr0,.LcmpAB
-
-	LD	rG,off24,r3
-	LD	rH,off24,r4
-	cmpld	cr0,rA,rB
-	bne	cr1,.LcmpCD
-
-	addi	r3,r3,32
-	addi	r4,r4,32
-
-	bdnz	1b
-
-.Lsecond32:
-	cmpld	cr1,rC,rD
-	bne	cr6,.LcmpEF
-
-	cmpld	cr6,rE,rF
-	bne	cr7,.LcmpGH
-
-	cmpld	cr7,rG,rH
-	bne	cr0,.LcmpAB
-
-	bne	cr1,.LcmpCD
-	bne	cr6,.LcmpEF
-	bne	cr7,.LcmpGH
-
-.Ltail:
-	ld	r31,-8(r1)
-	ld	r30,-16(r1)
-	ld	r29,-24(r1)
-	ld	r28,-32(r1)
-	ld	r27,-40(r1)
-
-	cmpdi	r5,0
-	beq	.Lzero
-	b	.Lshort
-
-.Lfirst32:
-	cmpld	cr1,rC,rD
-	cmpld	cr6,rE,rF
-	cmpld	cr7,rG,rH
-
-	bne	cr0,.LcmpAB
-	bne	cr1,.LcmpCD
-	bne	cr6,.LcmpEF
-	bne	cr7,.LcmpGH
-
-	b	.Ltail
-
-.LcmpAB:
-	li	r3,1
-	bgt	cr0,.Lout
-	li	r3,-1
-	b	.Lout
-
-.LcmpCD:
-	li	r3,1
-	bgt	cr1,.Lout
-	li	r3,-1
-	b	.Lout
-
-.LcmpEF:
-	li	r3,1
-	bgt	cr6,.Lout
-	li	r3,-1
-	b	.Lout
-
-.LcmpGH:
-	li	r3,1
-	bgt	cr7,.Lout
-	li	r3,-1
-
-.Lout:
-	ld	r31,-8(r1)
-	ld	r30,-16(r1)
-	ld	r29,-24(r1)
-	ld	r28,-32(r1)
-	ld	r27,-40(r1)
-	blr
-
-.LcmpAB_lightweight:   /* skip NV GPRS restore */
-	li	r3,1
-	bgtlr
-	li	r3,-1
-	blr
-
-#ifdef CONFIG_ALTIVEC
-.Lsameoffset_vmx_cmp:
-	/* Enter with src/dst addrs has the same offset with 8 bytes
-	 * align boundary.
-	 *
-	 * There is an optimization based on following fact: memcmp()
-	 * prones to fail early at the first 32 bytes.
-	 * Before applying VMX instructions which will lead to 32x128bits
-	 * VMX regs load/restore penalty, we compare the first 32 bytes
-	 * so that we can catch the ~80% fail cases.
-	 */
-
-	li	r0,4
-	mtctr	r0
-.Lsameoffset_prechk_32B_loop:
-	LD	rA,0,r3
-	LD	rB,0,r4
-	cmpld	cr0,rA,rB
-	addi	r3,r3,8
-	addi	r4,r4,8
-	bne     cr0,.LcmpAB_lightweight
-	addi	r5,r5,-8
-	bdnz	.Lsameoffset_prechk_32B_loop
-
-	ENTER_VMX_OPS
-	beq     cr1,.Llong_novmx_cmp
-
-3:
-	/* need to check whether r4 has the same offset with r3
-	 * for 16 bytes boundary.
-	 */
-	xor	r0,r3,r4
-	andi.	r0,r0,0xf
-	bne	.Ldiffoffset_vmx_cmp_start
-
-	/* len is no less than 4KB. Need to align with 16 bytes further.
-	 */
-	andi.	rA,r3,8
-	LD	rA,0,r3
-	beq	4f
-	LD	rB,0,r4
-	cmpld	cr0,rA,rB
-	addi	r3,r3,8
-	addi	r4,r4,8
-	addi	r5,r5,-8
-
-	beq	cr0,4f
-	/* save and restore cr0 */
-	mfocrf  r5,128
-	EXIT_VMX_OPS
-	mtocrf  128,r5
-	b	.LcmpAB_lightweight
-
-4:
-	/* compare 32 bytes for each loop */
-	srdi	r0,r5,5
-	mtctr	r0
-	clrldi  r5,r5,59
-	li	off16,16
-
-.balign 16
-5:
-	lvx 	v0,0,r3
-	lvx 	v1,0,r4
-	VCMPEQUD_RC(v0,v0,v1)
-	bnl	cr6,7f
-	lvx 	v0,off16,r3
-	lvx 	v1,off16,r4
-	VCMPEQUD_RC(v0,v0,v1)
-	bnl	cr6,6f
-	addi	r3,r3,32
-	addi	r4,r4,32
-	bdnz	5b
-
-	EXIT_VMX_OPS
-	cmpdi	r5,0
-	beq	.Lzero
-	b	.Lcmp_lt32bytes
-
-6:
-	addi	r3,r3,16
-	addi	r4,r4,16
-
-7:
-	/* diff the last 16 bytes */
-	EXIT_VMX_OPS
-	LD	rA,0,r3
-	LD	rB,0,r4
-	cmpld	cr0,rA,rB
-	li	off8,8
-	bne	cr0,.LcmpAB_lightweight
-
-	LD	rA,off8,r3
-	LD	rB,off8,r4
-	cmpld	cr0,rA,rB
-	bne	cr0,.LcmpAB_lightweight
-	b	.Lzero
-#endif
-
-.Ldiffoffset_8bytes_make_align_start:
-	/* now try to align s1 with 8 bytes */
-	rlwinm  r6,r3,3,26,28
-	beq     .Ldiffoffset_align_s1_8bytes
-
-	clrrdi	r3,r3,3
-	LD	rA,0,r3
-	LD	rB,0,r4  /* unaligned load */
-	sld	rA,rA,r6
-	srd	rA,rA,r6
-	srd	rB,rB,r6
-	cmpld	cr0,rA,rB
-	srwi	r6,r6,3
-	bne	cr0,.LcmpAB_lightweight
-
-	subfic  r6,r6,8
-	subf.	r5,r6,r5
-	addi	r3,r3,8
-	add	r4,r4,r6
-
-	beq	.Lzero
-
-.Ldiffoffset_align_s1_8bytes:
-	/* now s1 is aligned with 8 bytes. */
-#ifdef CONFIG_ALTIVEC
-BEGIN_FTR_SECTION
-	/* only do vmx ops when the size equal or greater than 4K bytes */
-	cmpdi	cr5,r5,VMX_THRESH
-	bge	cr5,.Ldiffoffset_vmx_cmp
-END_FTR_SECTION_IFSET(CPU_FTR_ARCH_207S)
-
-.Ldiffoffset_novmx_cmp:
-#endif
-
-
-	cmpdi   cr5,r5,31
-	ble	cr5,.Lcmp_lt32bytes
-
-#ifdef CONFIG_ALTIVEC
-	b	.Llong_novmx_cmp
-#else
-	b	.Llong
-#endif
-
-#ifdef CONFIG_ALTIVEC
-.Ldiffoffset_vmx_cmp:
-	/* perform a 32 bytes pre-checking before
-	 * enable VMX operations.
-	 */
-	li	r0,4
-	mtctr	r0
-.Ldiffoffset_prechk_32B_loop:
-	LD	rA,0,r3
-	LD	rB,0,r4
-	cmpld	cr0,rA,rB
-	addi	r3,r3,8
-	addi	r4,r4,8
-	bne     cr0,.LcmpAB_lightweight
-	addi	r5,r5,-8
-	bdnz	.Ldiffoffset_prechk_32B_loop
-
-	ENTER_VMX_OPS
-	beq     cr1,.Ldiffoffset_novmx_cmp
-
-.Ldiffoffset_vmx_cmp_start:
-	/* Firstly try to align r3 with 16 bytes */
-	andi.   r6,r3,0xf
-	li	off16,16
-	beq     .Ldiffoffset_vmx_s1_16bytes_align
-
-	LVS	v3,0,r3
-	LVS	v4,0,r4
-
-	lvx     v5,0,r3
-	lvx     v6,0,r4
-	LD_VSR_CROSS16B(r3,v3,v5,v7,v9)
-	LD_VSR_CROSS16B(r4,v4,v6,v8,v10)
-
-	VCMPEQUB_RC(v7,v9,v10)
-	bnl	cr6,.Ldiffoffset_vmx_diff_found
-
-	subfic  r6,r6,16
-	subf    r5,r6,r5
-	add     r3,r3,r6
-	add     r4,r4,r6
-
-.Ldiffoffset_vmx_s1_16bytes_align:
-	/* now s1 is aligned with 16 bytes */
-	lvx     v6,0,r4
-	LVS	v4,0,r4
-	srdi	r6,r5,5  /* loop for 32 bytes each */
-	clrldi  r5,r5,59
-	mtctr	r6
-
-.balign	16
-.Ldiffoffset_vmx_32bytesloop:
-	/* the first qw of r4 was saved in v6 */
-	lvx	v9,0,r3
-	LD_VSR_CROSS16B(r4,v4,v6,v8,v10)
-	VCMPEQUB_RC(v7,v9,v10)
-	vor	v6,v8,v8
-	bnl	cr6,.Ldiffoffset_vmx_diff_found
-
-	addi	r3,r3,16
-	addi	r4,r4,16
-
-	lvx	v9,0,r3
-	LD_VSR_CROSS16B(r4,v4,v6,v8,v10)
-	VCMPEQUB_RC(v7,v9,v10)
-	vor	v6,v8,v8
-	bnl	cr6,.Ldiffoffset_vmx_diff_found
-
-	addi	r3,r3,16
-	addi	r4,r4,16
-
-	bdnz	.Ldiffoffset_vmx_32bytesloop
-
-	EXIT_VMX_OPS
-
-	cmpdi	r5,0
-	beq	.Lzero
-	b	.Lcmp_lt32bytes
-
-.Ldiffoffset_vmx_diff_found:
-	EXIT_VMX_OPS
-	/* anyway, the diff will appear in next 16 bytes */
-	li	r5,16
-	b	.Lcmp_lt32bytes
-
-#endif
-EXPORT_SYMBOL(memcmp)
+../../../../../arch/powerpc/lib/memcmp_64.S
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/powerpc/stringloops/strlen_32.S linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/stringloops/strlen_32.S
--- linux-6.16.7/tools/testing/selftests/powerpc/stringloops/strlen_32.S	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/stringloops/strlen_32.S	2025-09-11 09:47:42.000000000 -0600
@@ -1,78 +1 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * strlen() for PPC32
- *
- * Copyright (C) 2018 Christophe Leroy CS Systemes d'Information.
- *
- * Inspired from glibc implementation
- */
-#include <linux/export.h>
-#include <asm/ppc_asm.h>
-#include <asm/cache.h>
-
-	.text
-
-/*
- * Algorithm:
- *
- * 1) Given a word 'x', we can test to see if it contains any 0 bytes
- *    by subtracting 0x01010101, and seeing if any of the high bits of each
- *    byte changed from 0 to 1. This works because the least significant
- *    0 byte must have had no incoming carry (otherwise it's not the least
- *    significant), so it is 0x00 - 0x01 == 0xff. For all other
- *    byte values, either they have the high bit set initially, or when
- *    1 is subtracted you get a value in the range 0x00-0x7f, none of which
- *    have their high bit set. The expression here is
- *    (x - 0x01010101) & ~x & 0x80808080), which gives 0x00000000 when
- *    there were no 0x00 bytes in the word.  You get 0x80 in bytes that
- *    match, but possibly false 0x80 matches in the next more significant
- *    byte to a true match due to carries.  For little-endian this is
- *    of no consequence since the least significant match is the one
- *    we're interested in, but big-endian needs method 2 to find which
- *    byte matches.
- * 2) Given a word 'x', we can test to see _which_ byte was zero by
- *    calculating ~(((x & ~0x80808080) - 0x80808080 - 1) | x | ~0x80808080).
- *    This produces 0x80 in each byte that was zero, and 0x00 in all
- *    the other bytes. The '| ~0x80808080' clears the low 7 bits in each
- *    byte, and the '| x' part ensures that bytes with the high bit set
- *    produce 0x00. The addition will carry into the high bit of each byte
- *    iff that byte had one of its low 7 bits set. We can then just see
- *    which was the most significant bit set and divide by 8 to find how
- *    many to add to the index.
- *    This is from the book 'The PowerPC Compiler Writer's Guide',
- *    by Steve Hoxey, Faraydon Karim, Bill Hay and Hank Warren.
- */
-
-_GLOBAL(strlen)
-	andi.   r0, r3, 3
-	lis	r7, 0x0101
-	addi	r10, r3, -4
-	addic	r7, r7, 0x0101	/* r7 = 0x01010101 (lomagic) & clear XER[CA] */
-	rotlwi	r6, r7, 31 	/* r6 = 0x80808080 (himagic) */
-	bne-	3f
-	.balign IFETCH_ALIGN_BYTES
-1:	lwzu	r9, 4(r10)
-2:	subf	r8, r7, r9
-	and.	r8, r8, r6
-	beq+	1b
-	andc.	r8, r8, r9
-	beq+	1b
-	andc	r8, r9, r6
-	orc	r9, r9, r6
-	subfe	r8, r6, r8
-	nor	r8, r8, r9
-	cntlzw	r8, r8
-	subf	r3, r3, r10
-	srwi	r8, r8, 3
-	add	r3, r3, r8
-	blr
-
-	/* Missaligned string: make sure bytes before string are seen not 0 */
-3:	xor	r10, r10, r0
-	orc	r8, r8, r8
-	lwzu	r9, 4(r10)
-	slwi	r0, r0, 3
-	srw	r8, r8, r0
-	orc	r9, r9, r8
-	b	2b
-EXPORT_SYMBOL(strlen)
+../../../../../arch/powerpc/lib/strlen_32.S
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/powerpc/vphn/asm/vphn.h linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/vphn/asm/vphn.h
--- linux-6.16.7/tools/testing/selftests/powerpc/vphn/asm/vphn.h	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/vphn/asm/vphn.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,24 +1 @@
-/* SPDX-License-Identifier: GPL-2.0-or-later */
-#ifndef _ASM_POWERPC_VPHN_H
-#define _ASM_POWERPC_VPHN_H
-
-/* The H_HOME_NODE_ASSOCIATIVITY h_call returns 6 64-bit registers. */
-#define VPHN_REGISTER_COUNT 6
-
-/*
- * 6 64-bit registers unpacked into up to 24 be32 associativity values. To
- * form the complete property we have to add the length in the first cell.
- */
-#define VPHN_ASSOC_BUFSIZE (VPHN_REGISTER_COUNT*sizeof(u64)/sizeof(u16) + 1)
-
-/*
- * The H_HOME_NODE_ASSOCIATIVITY hcall takes two values for flags:
- * 1 for retrieving associativity information for a guest cpu
- * 2 for retrieving associativity information for a host/hypervisor cpu
- */
-#define VPHN_FLAG_VCPU	1
-#define VPHN_FLAG_PCPU	2
-
-long hcall_vphn(unsigned long cpu, u64 flags, __be32 *associativity);
-
-#endif // _ASM_POWERPC_VPHN_H
+../../../../../../arch/powerpc/include/asm/vphn.h
\ No newline at end of file
diff -Nrup linux-6.16.7/tools/testing/selftests/powerpc/vphn/vphn.c linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/vphn/vphn.c
--- linux-6.16.7/tools/testing/selftests/powerpc/vphn/vphn.c	2025-09-11 09:23:23.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/vphn/vphn.c	2025-09-11 09:47:42.000000000 -0600
@@ -1,90 +1 @@
-// SPDX-License-Identifier: GPL-2.0
-#include <asm/byteorder.h>
-#include <asm/vphn.h>
-
-/*
- * The associativity domain numbers are returned from the hypervisor as a
- * stream of mixed 16-bit and 32-bit fields. The stream is terminated by the
- * special value of "all ones" (aka. 0xffff) and its size may not exceed 48
- * bytes.
- *
- *    --- 16-bit fields -->
- *  _________________________
- *  |  0  |  1  |  2  |  3  |   be_packed[0]
- *  ------+-----+-----+------
- *  _________________________
- *  |  4  |  5  |  6  |  7  |   be_packed[1]
- *  -------------------------
- *            ...
- *  _________________________
- *  | 20  | 21  | 22  | 23  |   be_packed[5]
- *  -------------------------
- *
- * Convert to the sequence they would appear in the ibm,associativity property.
- */
-static int vphn_unpack_associativity(const long *packed, __be32 *unpacked)
-{
-	__be64 be_packed[VPHN_REGISTER_COUNT];
-	int i, nr_assoc_doms = 0;
-	const __be16 *field = (const __be16 *) be_packed;
-	u16 last = 0;
-	bool is_32bit = false;
-
-#define VPHN_FIELD_UNUSED	(0xffff)
-#define VPHN_FIELD_MSB		(0x8000)
-#define VPHN_FIELD_MASK		(~VPHN_FIELD_MSB)
-
-	/* Let's fix the values returned by plpar_hcall9() */
-	for (i = 0; i < VPHN_REGISTER_COUNT; i++)
-		be_packed[i] = cpu_to_be64(packed[i]);
-
-	for (i = 1; i < VPHN_ASSOC_BUFSIZE; i++) {
-		u16 new = be16_to_cpup(field++);
-
-		if (is_32bit) {
-			/*
-			 * Let's concatenate the 16 bits of this field to the
-			 * 15 lower bits of the previous field
-			 */
-			unpacked[++nr_assoc_doms] =
-				cpu_to_be32(last << 16 | new);
-			is_32bit = false;
-		} else if (new == VPHN_FIELD_UNUSED)
-			/* This is the list terminator */
-			break;
-		else if (new & VPHN_FIELD_MSB) {
-			/* Data is in the lower 15 bits of this field */
-			unpacked[++nr_assoc_doms] =
-				cpu_to_be32(new & VPHN_FIELD_MASK);
-		} else {
-			/*
-			 * Data is in the lower 15 bits of this field
-			 * concatenated with the next 16 bit field
-			 */
-			last = new;
-			is_32bit = true;
-		}
-	}
-
-	/* The first cell contains the length of the property */
-	unpacked[0] = cpu_to_be32(nr_assoc_doms);
-
-	return nr_assoc_doms;
-}
-
-/* NOTE: This file is included by a selftest and built in userspace. */
-#ifdef __KERNEL__
-#include <asm/hvcall.h>
-
-long hcall_vphn(unsigned long cpu, u64 flags, __be32 *associativity)
-{
-	long rc;
-	long retbuf[PLPAR_HCALL9_BUFSIZE] = {0};
-
-	rc = plpar_hcall9(H_HOME_NODE_ASSOCIATIVITY, retbuf, flags, cpu);
-	if (rc == H_SUCCESS)
-		vphn_unpack_associativity(retbuf, associativity);
-
-	return rc;
-}
-#endif
+../../../../../arch/powerpc/platforms/pseries/vphn.c
\ No newline at end of file
