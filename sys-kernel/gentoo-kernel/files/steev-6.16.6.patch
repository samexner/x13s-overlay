diff -Nrup linux-6.16.6/arch/arm/boot/dts/allwinner/sun8i-a23-ippo-q8h-v1.2.dts linux-lenovo-x13s-linux-6.16.y/arch/arm/boot/dts/allwinner/sun8i-a23-ippo-q8h-v1.2.dts
--- linux-6.16.6/arch/arm/boot/dts/allwinner/sun8i-a23-ippo-q8h-v1.2.dts	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm/boot/dts/allwinner/sun8i-a23-ippo-q8h-v1.2.dts	2025-09-11 09:47:42.000000000 -0600
@@ -1,73 +1 @@
-/*
- * Copyright 2015 Hans de Goede <hdegoede@redhat.com>
- *
- * This file is dual-licensed: you can use it either under the terms
- * of the GPL or the X11 license, at your option. Note that this dual
- * licensing only applies to this file, and not this project as a
- * whole.
- *
- *  a) This file is free software; you can redistribute it and/or
- *     modify it under the terms of the GNU General Public License as
- *     published by the Free Software Foundation; either version 2 of the
- *     License, or (at your option) any later version.
- *
- *     This file is distributed in the hope that it will be useful,
- *     but WITHOUT ANY WARRANTY; without even the implied warranty of
- *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *     GNU General Public License for more details.
- *
- * Or, alternatively,
- *
- *  b) Permission is hereby granted, free of charge, to any person
- *     obtaining a copy of this software and associated documentation
- *     files (the "Software"), to deal in the Software without
- *     restriction, including without limitation the rights to use,
- *     copy, modify, merge, publish, distribute, sublicense, and/or
- *     sell copies of the Software, and to permit persons to whom the
- *     Software is furnished to do so, subject to the following
- *     conditions:
- *
- *     The above copyright notice and this permission notice shall be
- *     included in all copies or substantial portions of the Software.
- *
- *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
- *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
- *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- *     OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/dts-v1/;
-#include "sun8i-a23.dtsi"
-#include "sun8i-q8-common.dtsi"
-
-/ {
-	model = "Q8 A23 Tablet";
-	compatible = "allwinner,q8-a23", "allwinner,sun8i-a23";
-};
-
-&codec {
-	allwinner,pa-gpios = <&pio 7 9 GPIO_ACTIVE_HIGH>; /* PH9 */
-	allwinner,audio-routing =
-		"Headphone", "HP",
-		"Headphone", "HPCOM",
-		"Speaker", "HP",
-		"MIC1", "Mic",
-		"MIC2", "Headset Mic",
-		"Mic",  "MBIAS",
-		"Headset Mic", "HBIAS";
-	status = "okay";
-};
-
-&panel {
-	compatible = "bananapi,s070wv20-ct16";
-};
-
-&tcon0_out {
-	tcon0_out_lcd: endpoint {
-		remote-endpoint = <&panel_input>;
-	};
-};
+sun8i-a23-q8-tablet.dts
\ No newline at end of file
diff -Nrup linux-6.16.6/arch/arm/boot/dts/allwinner/sun8i-a23-ippo-q8h-v5.dts linux-lenovo-x13s-linux-6.16.y/arch/arm/boot/dts/allwinner/sun8i-a23-ippo-q8h-v5.dts
--- linux-6.16.6/arch/arm/boot/dts/allwinner/sun8i-a23-ippo-q8h-v5.dts	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm/boot/dts/allwinner/sun8i-a23-ippo-q8h-v5.dts	2025-09-11 09:47:42.000000000 -0600
@@ -1,73 +1 @@
-/*
- * Copyright 2015 Hans de Goede <hdegoede@redhat.com>
- *
- * This file is dual-licensed: you can use it either under the terms
- * of the GPL or the X11 license, at your option. Note that this dual
- * licensing only applies to this file, and not this project as a
- * whole.
- *
- *  a) This file is free software; you can redistribute it and/or
- *     modify it under the terms of the GNU General Public License as
- *     published by the Free Software Foundation; either version 2 of the
- *     License, or (at your option) any later version.
- *
- *     This file is distributed in the hope that it will be useful,
- *     but WITHOUT ANY WARRANTY; without even the implied warranty of
- *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *     GNU General Public License for more details.
- *
- * Or, alternatively,
- *
- *  b) Permission is hereby granted, free of charge, to any person
- *     obtaining a copy of this software and associated documentation
- *     files (the "Software"), to deal in the Software without
- *     restriction, including without limitation the rights to use,
- *     copy, modify, merge, publish, distribute, sublicense, and/or
- *     sell copies of the Software, and to permit persons to whom the
- *     Software is furnished to do so, subject to the following
- *     conditions:
- *
- *     The above copyright notice and this permission notice shall be
- *     included in all copies or substantial portions of the Software.
- *
- *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
- *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
- *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- *     OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/dts-v1/;
-#include "sun8i-a23.dtsi"
-#include "sun8i-q8-common.dtsi"
-
-/ {
-	model = "Q8 A23 Tablet";
-	compatible = "allwinner,q8-a23", "allwinner,sun8i-a23";
-};
-
-&codec {
-	allwinner,pa-gpios = <&pio 7 9 GPIO_ACTIVE_HIGH>; /* PH9 */
-	allwinner,audio-routing =
-		"Headphone", "HP",
-		"Headphone", "HPCOM",
-		"Speaker", "HP",
-		"MIC1", "Mic",
-		"MIC2", "Headset Mic",
-		"Mic",  "MBIAS",
-		"Headset Mic", "HBIAS";
-	status = "okay";
-};
-
-&panel {
-	compatible = "bananapi,s070wv20-ct16";
-};
-
-&tcon0_out {
-	tcon0_out_lcd: endpoint {
-		remote-endpoint = <&panel_input>;
-	};
-};
+sun8i-a23-q8-tablet.dts
\ No newline at end of file
diff -Nrup linux-6.16.6/arch/arm/boot/dts/allwinner/sun8i-a33-et-q8-v1.6.dts linux-lenovo-x13s-linux-6.16.y/arch/arm/boot/dts/allwinner/sun8i-a33-et-q8-v1.6.dts
--- linux-6.16.6/arch/arm/boot/dts/allwinner/sun8i-a33-et-q8-v1.6.dts	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm/boot/dts/allwinner/sun8i-a33-et-q8-v1.6.dts	2025-09-11 09:47:42.000000000 -0600
@@ -1,57 +1 @@
-/*
- * Copyright 2015 Hans de Goede <hdegoede@redhat.com>
- *
- * This file is dual-licensed: you can use it either under the terms
- * of the GPL or the X11 license, at your option. Note that this dual
- * licensing only applies to this file, and not this project as a
- * whole.
- *
- *  a) This file is free software; you can redistribute it and/or
- *     modify it under the terms of the GNU General Public License as
- *     published by the Free Software Foundation; either version 2 of the
- *     License, or (at your option) any later version.
- *
- *     This file is distributed in the hope that it will be useful,
- *     but WITHOUT ANY WARRANTY; without even the implied warranty of
- *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *     GNU General Public License for more details.
- *
- * Or, alternatively,
- *
- *  b) Permission is hereby granted, free of charge, to any person
- *     obtaining a copy of this software and associated documentation
- *     files (the "Software"), to deal in the Software without
- *     restriction, including without limitation the rights to use,
- *     copy, modify, merge, publish, distribute, sublicense, and/or
- *     sell copies of the Software, and to permit persons to whom the
- *     Software is furnished to do so, subject to the following
- *     conditions:
- *
- *     The above copyright notice and this permission notice shall be
- *     included in all copies or substantial portions of the Software.
- *
- *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
- *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
- *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- *     OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/dts-v1/;
-#include "sun8i-a33.dtsi"
-#include "sun8i-q8-common.dtsi"
-
-/ {
-	model = "Q8 A33 Tablet";
-	compatible = "allwinner,q8-a33", "allwinner,sun8i-a33";
-};
-
-&tcon0_out {
-	tcon0_out_lcd: endpoint@0 {
-		reg = <0>;
-		remote-endpoint = <&panel_input>;
-	};
-};
+sun8i-a33-q8-tablet.dts
\ No newline at end of file
diff -Nrup linux-6.16.6/arch/arm/boot/dts/allwinner/sun8i-a33-ippo-q8h-v1.2.dts linux-lenovo-x13s-linux-6.16.y/arch/arm/boot/dts/allwinner/sun8i-a33-ippo-q8h-v1.2.dts
--- linux-6.16.6/arch/arm/boot/dts/allwinner/sun8i-a33-ippo-q8h-v1.2.dts	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm/boot/dts/allwinner/sun8i-a33-ippo-q8h-v1.2.dts	2025-09-11 09:47:42.000000000 -0600
@@ -1,57 +1 @@
-/*
- * Copyright 2015 Hans de Goede <hdegoede@redhat.com>
- *
- * This file is dual-licensed: you can use it either under the terms
- * of the GPL or the X11 license, at your option. Note that this dual
- * licensing only applies to this file, and not this project as a
- * whole.
- *
- *  a) This file is free software; you can redistribute it and/or
- *     modify it under the terms of the GNU General Public License as
- *     published by the Free Software Foundation; either version 2 of the
- *     License, or (at your option) any later version.
- *
- *     This file is distributed in the hope that it will be useful,
- *     but WITHOUT ANY WARRANTY; without even the implied warranty of
- *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *     GNU General Public License for more details.
- *
- * Or, alternatively,
- *
- *  b) Permission is hereby granted, free of charge, to any person
- *     obtaining a copy of this software and associated documentation
- *     files (the "Software"), to deal in the Software without
- *     restriction, including without limitation the rights to use,
- *     copy, modify, merge, publish, distribute, sublicense, and/or
- *     sell copies of the Software, and to permit persons to whom the
- *     Software is furnished to do so, subject to the following
- *     conditions:
- *
- *     The above copyright notice and this permission notice shall be
- *     included in all copies or substantial portions of the Software.
- *
- *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
- *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
- *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- *     OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/dts-v1/;
-#include "sun8i-a33.dtsi"
-#include "sun8i-q8-common.dtsi"
-
-/ {
-	model = "Q8 A33 Tablet";
-	compatible = "allwinner,q8-a33", "allwinner,sun8i-a33";
-};
-
-&tcon0_out {
-	tcon0_out_lcd: endpoint@0 {
-		reg = <0>;
-		remote-endpoint = <&panel_input>;
-	};
-};
+sun8i-a33-q8-tablet.dts
\ No newline at end of file
diff -Nrup linux-6.16.6/arch/arm/configs/qcom_defconfig linux-lenovo-x13s-linux-6.16.y/arch/arm/configs/qcom_defconfig
--- linux-6.16.6/arch/arm/configs/qcom_defconfig	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm/configs/qcom_defconfig	2025-09-11 09:47:42.000000000 -0600
@@ -57,7 +57,7 @@ CONFIG_MAC80211=m
 CONFIG_RFKILL=y
 CONFIG_PCI=y
 CONFIG_PCI_MSI=y
-CONFIG_PCIE_QCOM=y
+CONFIG_PCIE_QCOM=m
 CONFIG_DEVTMPFS=y
 CONFIG_DEVTMPFS_MOUNT=y
 CONFIG_MTD=y
diff -Nrup linux-6.16.6/arch/arm64/boot/dts/qcom/sa8295p-adp.dts linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sa8295p-adp.dts
--- linux-6.16.6/arch/arm64/boot/dts/qcom/sa8295p-adp.dts	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sa8295p-adp.dts	2025-09-11 09:47:42.000000000 -0600
@@ -631,12 +631,10 @@
 };
 
 &usb_0 {
-	status = "okay";
-};
-
-&usb_0_dwc3 {
 	/* TODO: Define USB-C connector properly */
 	dr_mode = "peripheral";
+
+	status = "okay";
 };
 
 &usb_0_hsphy {
@@ -655,12 +653,10 @@
 };
 
 &usb_1 {
-	status = "okay";
-};
-
-&usb_1_dwc3 {
 	/* TODO: Define USB-C connector properly */
 	dr_mode = "host";
+
+	status = "okay";
 };
 
 &usb_1_hsphy {
diff -Nrup linux-6.16.6/arch/arm64/boot/dts/qcom/sa8540p-ride.dts linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sa8540p-ride.dts
--- linux-6.16.6/arch/arm64/boot/dts/qcom/sa8540p-ride.dts	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sa8540p-ride.dts	2025-09-11 09:47:42.000000000 -0600
@@ -462,11 +462,8 @@
 };
 
 &usb_0 {
-	status = "okay";
-};
-
-&usb_0_dwc3 {
 	dr_mode = "peripheral";
+	status = "okay";
 };
 
 &usb_0_hsphy {
diff -Nrup linux-6.16.6/arch/arm64/boot/dts/qcom/sc8280xp-crd.dts linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sc8280xp-crd.dts
--- linux-6.16.6/arch/arm64/boot/dts/qcom/sc8280xp-crd.dts	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sc8280xp-crd.dts	2025-09-11 09:47:42.000000000 -0600
@@ -815,11 +815,9 @@
 };
 
 &usb_0 {
-	status = "okay";
-};
-
-&usb_0_dwc3 {
 	dr_mode = "host";
+
+	status = "okay";
 };
 
 &usb_0_dwc3_hs {
@@ -852,11 +850,9 @@
 };
 
 &usb_1 {
-	status = "okay";
-};
-
-&usb_1_dwc3 {
 	dr_mode = "host";
+
+	status = "okay";
 };
 
 &usb_1_dwc3_hs {
diff -Nrup linux-6.16.6/arch/arm64/boot/dts/qcom/sc8280xp.dtsi linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sc8280xp.dtsi
--- linux-6.16.6/arch/arm64/boot/dts/qcom/sc8280xp.dtsi	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sc8280xp.dtsi	2025-09-11 09:47:42.000000000 -0600
@@ -10,6 +10,7 @@
 #include <dt-bindings/clock/qcom,rpmh.h>
 #include <dt-bindings/clock/qcom,sc8280xp-camcc.h>
 #include <dt-bindings/clock/qcom,sc8280xp-lpasscc.h>
+#include <dt-bindings/clock/qcom,sm8350-videocc.h>
 #include <dt-bindings/interconnect/qcom,osm-l3.h>
 #include <dt-bindings/interconnect/qcom,sc8280xp.h>
 #include <dt-bindings/interrupt-controller/arm-gic.h>
@@ -390,6 +391,15 @@
 		reg = <0x0 0x80000000 0x0 0x0>;
 	};
 
+	cci_opp_table: opp-table-cci {
+		compatible = "operating-points-v2";
+
+		opp-37500000 {
+			opp-hz = /bits/ 64 <37500000>;
+			required-opps = <&rpmhpd_opp_low_svs>;
+		};
+	};
+
 	cpu0_opp_table: opp-table-cpu0 {
 		compatible = "operating-points-v2";
 		opp-shared;
@@ -690,6 +700,11 @@
 			no-map;
 		};
 
+		pil_video_mem: pil_video_region@86700000 {
+			reg = <0 0x86700000 0 0x500000>;
+			no-map;
+		};
+
 		pil_adsp_mem: adsp-region@86c00000 {
 			reg = <0 0x86c00000 0 0x2000000>;
 			no-map;
@@ -3556,12 +3571,9 @@
 			interrupts = <GIC_SPI 582 IRQ_TYPE_LEVEL_HIGH>;
 		};
 
-		usb_2: usb@a4f8800 {
-			compatible = "qcom,sc8280xp-dwc3-mp", "qcom,dwc3";
-			reg = <0 0x0a4f8800 0 0x400>;
-			#address-cells = <2>;
-			#size-cells = <2>;
-			ranges;
+		usb_2: usb@a400000 {
+			compatible = "qcom,sc8280xp-dwc3-mp", "qcom,snps-dwc3";
+			reg = <0 0x0a400000 0 0x10000>;
 
 			clocks = <&gcc GCC_CFG_NOC_USB3_MP_AXI_CLK>,
 				 <&gcc GCC_USB30_MP_MASTER_CLK>,
@@ -3579,7 +3591,8 @@
 					  <&gcc GCC_USB30_MP_MASTER_CLK>;
 			assigned-clock-rates = <19200000>, <200000000>;
 
-			interrupts-extended = <&intc GIC_SPI 130 IRQ_TYPE_LEVEL_HIGH>,
+			interrupts-extended = <&intc GIC_SPI 133 IRQ_TYPE_LEVEL_HIGH>,
+					      <&intc GIC_SPI 130 IRQ_TYPE_LEVEL_HIGH>,
 					      <&intc GIC_SPI 135 IRQ_TYPE_LEVEL_HIGH>,
 					      <&intc GIC_SPI 857 IRQ_TYPE_LEVEL_HIGH>,
 					      <&intc GIC_SPI 856 IRQ_TYPE_LEVEL_HIGH>,
@@ -3598,7 +3611,8 @@
 					      <&pdc 16 IRQ_TYPE_LEVEL_HIGH>,
 					      <&pdc 17 IRQ_TYPE_LEVEL_HIGH>;
 
-			interrupt-names = "pwr_event_1", "pwr_event_2",
+			interrupt-names = "dwc_usb3",
+					  "pwr_event_1", "pwr_event_2",
 					  "pwr_event_3", "pwr_event_4",
 					  "hs_phy_1",	 "hs_phy_2",
 					  "hs_phy_3",	 "hs_phy_4",
@@ -3608,6 +3622,7 @@
 					  "dp_hs_phy_4", "dm_hs_phy_4",
 					  "ss_phy_1",	 "ss_phy_2";
 
+			iommus = <&apps_smmu 0x800 0x0>;
 			power-domains = <&gcc USB30_MP_GDSC>;
 			required-opps = <&rpmhpd_opp_nom>;
 
@@ -3617,35 +3632,28 @@
 					<&gem_noc MASTER_APPSS_PROC 0 &config_noc SLAVE_USB3_MP 0>;
 			interconnect-names = "usb-ddr", "apps-usb";
 
+			phys = <&usb_2_hsphy0>, <&usb_2_qmpphy0>,
+			       <&usb_2_hsphy1>, <&usb_2_qmpphy1>,
+			       <&usb_2_hsphy2>,
+			       <&usb_2_hsphy3>;
+			phy-names = "usb2-0", "usb3-0",
+				    "usb2-1", "usb3-1",
+				    "usb2-2",
+				    "usb2-3";
+
 			wakeup-source;
 
-			status = "disabled";
+			dr_mode = "host";
 
-			usb_2_dwc3: usb@a400000 {
-				compatible = "snps,dwc3";
-				reg = <0 0x0a400000 0 0xcd00>;
-				interrupts = <GIC_SPI 133 IRQ_TYPE_LEVEL_HIGH>;
-				iommus = <&apps_smmu 0x800 0x0>;
-				phys = <&usb_2_hsphy0>, <&usb_2_qmpphy0>,
-				       <&usb_2_hsphy1>, <&usb_2_qmpphy1>,
-				       <&usb_2_hsphy2>,
-				       <&usb_2_hsphy3>;
-				phy-names = "usb2-0", "usb3-0",
-					    "usb2-1", "usb3-1",
-					    "usb2-2",
-					    "usb2-3";
-				dr_mode = "host";
-				snps,dis-u1-entry-quirk;
-				snps,dis-u2-entry-quirk;
-			};
+			snps,dis-u1-entry-quirk;
+			snps,dis-u2-entry-quirk;
+
+			status = "disabled";
 		};
 
-		usb_0: usb@a6f8800 {
-			compatible = "qcom,sc8280xp-dwc3", "qcom,dwc3";
-			reg = <0 0x0a6f8800 0 0x400>;
-			#address-cells = <2>;
-			#size-cells = <2>;
-			ranges;
+		usb_0: usb@a600000 {
+			compatible = "qcom,sc8280xp-dwc3", "qcom,snps-dwc3";
+			reg = <0 0x0a600000 0 0x10000>;
 
 			clocks = <&gcc GCC_CFG_NOC_USB3_PRIM_AXI_CLK>,
 				 <&gcc GCC_USB30_PRIM_MASTER_CLK>,
@@ -3663,17 +3671,20 @@
 					  <&gcc GCC_USB30_PRIM_MASTER_CLK>;
 			assigned-clock-rates = <19200000>, <200000000>;
 
-			interrupts-extended = <&intc GIC_SPI 804 IRQ_TYPE_LEVEL_HIGH>,
+			interrupts-extended = <&intc GIC_SPI 803 IRQ_TYPE_LEVEL_HIGH>,
+					      <&intc GIC_SPI 804 IRQ_TYPE_LEVEL_HIGH>,
 					      <&intc GIC_SPI 805 IRQ_TYPE_LEVEL_HIGH>,
 					      <&pdc 14 IRQ_TYPE_EDGE_BOTH>,
 					      <&pdc 15 IRQ_TYPE_EDGE_BOTH>,
 					      <&pdc 138 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "pwr_event",
+			interrupt-names = "dwc_usb3",
+					  "pwr_event",
 					  "hs_phy_irq",
 					  "dp_hs_phy_irq",
 					  "dm_hs_phy_irq",
 					  "ss_phy_irq";
 
+			iommus = <&apps_smmu 0x820 0x0>;
 			power-domains = <&gcc USB30_PRIM_GDSC>;
 			required-opps = <&rpmhpd_opp_nom>;
 
@@ -3683,45 +3694,40 @@
 					<&gem_noc MASTER_APPSS_PROC 0 &config_noc SLAVE_USB3_0 0>;
 			interconnect-names = "usb-ddr", "apps-usb";
 
+			phys = <&usb_0_hsphy>, <&usb_0_qmpphy QMP_USB43DP_USB3_PHY>;
+			phy-names = "usb2-phy", "usb3-phy";
+
 			wakeup-source;
 
-			status = "disabled";
+			snps,dis-u1-entry-quirk;
+			snps,dis-u2-entry-quirk;
 
-			usb_0_dwc3: usb@a600000 {
-				compatible = "snps,dwc3";
-				reg = <0 0x0a600000 0 0xcd00>;
-				interrupts = <GIC_SPI 803 IRQ_TYPE_LEVEL_HIGH>;
-				iommus = <&apps_smmu 0x820 0x0>;
-				phys = <&usb_0_hsphy>, <&usb_0_qmpphy QMP_USB43DP_USB3_PHY>;
-				phy-names = "usb2-phy", "usb3-phy";
-				snps,dis-u1-entry-quirk;
-				snps,dis-u2-entry-quirk;
+			status = "disabled";
 
-				ports {
-					#address-cells = <1>;
-					#size-cells = <0>;
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
 
-					port@0 {
-						reg = <0>;
+				port@0 {
+					reg = <0>;
 
-						usb_0_dwc3_hs: endpoint {
-						};
+					usb_0_dwc3_hs: endpoint {
 					};
+				};
 
-					port@1 {
-						reg = <1>;
+				port@1 {
+					reg = <1>;
 
-						usb_0_dwc3_ss: endpoint {
-							remote-endpoint = <&usb_0_qmpphy_usb_ss_in>;
-						};
+					usb_0_dwc3_ss: endpoint {
+						remote-endpoint = <&usb_0_qmpphy_usb_ss_in>;
 					};
 				};
 			};
 		};
 
-		usb_1: usb@a8f8800 {
-			compatible = "qcom,sc8280xp-dwc3", "qcom,dwc3";
-			reg = <0 0x0a8f8800 0 0x400>;
+		usb_1: usb@a800000 {
+			compatible = "qcom,sc8280xp-dwc3", "qcom,snps-dwc3";
+			reg = <0 0x0a800000 0 0x10000>;
 			#address-cells = <2>;
 			#size-cells = <2>;
 			ranges;
@@ -3742,17 +3748,20 @@
 					  <&gcc GCC_USB30_SEC_MASTER_CLK>;
 			assigned-clock-rates = <19200000>, <200000000>;
 
-			interrupts-extended = <&intc GIC_SPI 811 IRQ_TYPE_LEVEL_HIGH>,
+			interrupts-extended = <&intc GIC_SPI 810 IRQ_TYPE_LEVEL_HIGH>,
+					      <&intc GIC_SPI 811 IRQ_TYPE_LEVEL_HIGH>,
 					      <&intc GIC_SPI 790 IRQ_TYPE_LEVEL_HIGH>,
 					      <&pdc 12 IRQ_TYPE_EDGE_BOTH>,
 					      <&pdc 13 IRQ_TYPE_EDGE_BOTH>,
 					      <&pdc 136 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "pwr_event",
+			interrupt-names = "dwc_usb3",
+					  "pwr_event",
 					  "hs_phy_irq",
 					  "dp_hs_phy_irq",
 					  "dm_hs_phy_irq",
 					  "ss_phy_irq";
 
+			iommus = <&apps_smmu 0x860 0x0>;
 			power-domains = <&gcc USB30_SEC_GDSC>;
 			required-opps = <&rpmhpd_opp_nom>;
 
@@ -3762,42 +3771,109 @@
 					<&gem_noc MASTER_APPSS_PROC 0 &config_noc SLAVE_USB3_1 0>;
 			interconnect-names = "usb-ddr", "apps-usb";
 
+			phys = <&usb_1_hsphy>, <&usb_1_qmpphy QMP_USB43DP_USB3_PHY>;
+			phy-names = "usb2-phy", "usb3-phy";
+
 			wakeup-source;
 
-			status = "disabled";
+			snps,dis-u1-entry-quirk;
+			snps,dis-u2-entry-quirk;
 
-			usb_1_dwc3: usb@a800000 {
-				compatible = "snps,dwc3";
-				reg = <0 0x0a800000 0 0xcd00>;
-				interrupts = <GIC_SPI 810 IRQ_TYPE_LEVEL_HIGH>;
-				iommus = <&apps_smmu 0x860 0x0>;
-				phys = <&usb_1_hsphy>, <&usb_1_qmpphy QMP_USB43DP_USB3_PHY>;
-				phy-names = "usb2-phy", "usb3-phy";
-				snps,dis-u1-entry-quirk;
-				snps,dis-u2-entry-quirk;
+			status = "disabled";
 
-				ports {
-					#address-cells = <1>;
-					#size-cells = <0>;
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
 
-					port@0 {
-						reg = <0>;
+				port@0 {
+					reg = <0>;
 
-						usb_1_dwc3_hs: endpoint {
-						};
+					usb_1_dwc3_hs: endpoint {
 					};
+				};
 
-					port@1 {
-						reg = <1>;
+				port@1 {
+					reg = <1>;
 
-						usb_1_dwc3_ss: endpoint {
-							remote-endpoint = <&usb_1_qmpphy_usb_ss_in>;
-						};
+					usb_1_dwc3_ss: endpoint {
+						remote-endpoint = <&usb_1_qmpphy_usb_ss_in>;
 					};
 				};
 			};
 		};
 
+		venus: video-codec@aa00000 {
+			compatible = "qcom,sm8350-venus";
+			reg = <0 0x0aa00000 0 0x100000>;
+			interrupts = <GIC_SPI 174 IRQ_TYPE_LEVEL_HIGH>;
+
+			clocks = <&gcc GCC_VIDEO_AXI0_CLK>,
+				 <&videocc VIDEO_CC_MVS0C_CLK>,
+				 <&videocc VIDEO_CC_MVS0_CLK>;
+			clock-names = "iface",
+				      "core",
+				      "vcodec0_core";
+			power-domains = <&videocc MVS0C_GDSC>,
+					<&videocc MVS0_GDSC>,
+					<&rpmhpd SC8280XP_MX>;
+			power-domain-names = "venus",
+					     "vcodec0",
+					     "mx";
+
+			resets = <&gcc GCC_VIDEO_AXI0_CLK_ARES>;
+			reset-names = "core";
+
+			interconnects = <&gem_noc MASTER_APPSS_PROC 0 &config_noc SLAVE_VENUS_CFG 0>,
+					<&mmss_noc MASTER_VIDEO_P0 0 &mc_virt SLAVE_EBI1 0>,
+					<&mmss_noc MASTER_VIDEO_P0 0 &gem_noc SLAVE_LLCC 0>;
+			interconnect-names = "cpu-cfg",
+					     "video-mem",
+					     "video-llcc";
+
+			operating-points-v2 = <&venus_opp_table>;
+			iommus = <&apps_smmu 0x2e00 0x400>;
+			memory-region = <&pil_video_mem>;
+
+			status = "disabled";
+
+			venus_opp_table: opp-table {
+				compatible = "operating-points-v2";
+
+				opp-720000000 {
+					opp-hz = /bits/ 64 <720000000>;
+					required-opps = <&rpmhpd_opp_low_svs>;
+				};
+
+				opp-1014000000 {
+					opp-hz = /bits/ 64 <1014000000>;
+					required-opps = <&rpmhpd_opp_svs>;
+				};
+
+				opp-1098000000 {
+					opp-hz = /bits/ 64 <1098000000>;
+					required-opps = <&rpmhpd_opp_svs_l1>;
+				};
+
+				opp-1332000000 {
+					opp-hz = /bits/ 64 <1332000000>;
+					required-opps = <&rpmhpd_opp_nom>;
+				};
+			};
+		};
+
+		videocc: clock-controller@abf0000 {
+			compatible = "qcom,sc8280xp-videocc";
+			reg = <0 0x0abf0000 0 0x10000>;
+			clocks = <&rpmhcc RPMH_CXO_CLK>,
+				 <&rpmhcc RPMH_CXO_CLK_A>,
+				 <&sleep_clk>;
+			power-domains = <&rpmhpd SC8280XP_MMCX>;
+			required-opps = <&rpmhpd_opp_low_svs>;
+			#clock-cells = <1>;
+			#reset-cells = <1>;
+			#power-domain-cells = <1>;
+		};
+
 		cci0: cci@ac4a000 {
 			compatible = "qcom,sc8280xp-cci", "qcom,msm8996-cci";
 			reg = <0 0x0ac4a000 0 0x1000>;
@@ -3813,6 +3889,7 @@
 				      "cpas_ahb",
 				      "cci";
 
+			operating-points-v2 = <&cci_opp_table>;
 			power-domains = <&camcc TITAN_TOP_GDSC>;
 
 			pinctrl-0 = <&cci0_default>;
@@ -3854,6 +3931,7 @@
 				      "cpas_ahb",
 				      "cci";
 
+			operating-points-v2 = <&cci_opp_table>;
 			power-domains = <&camcc TITAN_TOP_GDSC>;
 
 			pinctrl-0 = <&cci1_default>;
@@ -3894,6 +3972,8 @@
 				      "slow_ahb_src",
 				      "cpas_ahb",
 				      "cci";
+
+			operating-points-v2 = <&cci_opp_table>;
 			power-domains = <&camcc TITAN_TOP_GDSC>;
 
 			pinctrl-0 = <&cci2_default>;
@@ -3924,7 +4004,7 @@
 			compatible = "qcom,sc8280xp-cci", "qcom,msm8996-cci";
 			reg = <0 0x0ac4d000 0 0x1000>;
 
-			interrupts = <GIC_SPI 650 IRQ_TYPE_EDGE_RISING>;
+			interrupts = <GIC_SPI 771 IRQ_TYPE_EDGE_RISING>;
 
 			clocks = <&camcc CAMCC_CAMNOC_AXI_CLK>,
 				 <&camcc CAMCC_SLOW_AHB_CLK_SRC>,
@@ -3935,6 +4015,7 @@
 				      "cpas_ahb",
 				      "cci";
 
+			operating-points-v2 = <&cci_opp_table>;
 			power-domains = <&camcc TITAN_TOP_GDSC>;
 
 			pinctrl-0 = <&cci3_default>;
diff -Nrup linux-6.16.6/arch/arm64/boot/dts/qcom/sc8280xp-huawei-gaokun3.dts linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sc8280xp-huawei-gaokun3.dts
--- linux-6.16.6/arch/arm64/boot/dts/qcom/sc8280xp-huawei-gaokun3.dts	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sc8280xp-huawei-gaokun3.dts	2025-09-11 09:47:42.000000000 -0600
@@ -1123,11 +1123,8 @@
 };
 
 &usb_0 {
-	status = "okay";
-};
-
-&usb_0_dwc3 {
 	dr_mode = "host";
+	status = "okay";
 };
 
 &usb_0_dwc3_hs {
@@ -1160,11 +1157,8 @@
 };
 
 &usb_1 {
-	status = "okay";
-};
-
-&usb_1_dwc3 {
 	dr_mode = "host";
+	status = "okay";
 };
 
 &usb_1_dwc3_hs {
diff -Nrup linux-6.16.6/arch/arm64/boot/dts/qcom/sc8280xp-lenovo-thinkpad-x13s.dts linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sc8280xp-lenovo-thinkpad-x13s.dts
--- linux-6.16.6/arch/arm64/boot/dts/qcom/sc8280xp-lenovo-thinkpad-x13s.dts	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sc8280xp-lenovo-thinkpad-x13s.dts	2025-09-11 09:47:42.000000000 -0600
@@ -83,14 +83,11 @@
 		pinctrl-names = "default";
 		pinctrl-0 = <&cam_indicator_en>;
 
-		led-camera-indicator {
-			label = "white:camera-indicator";
+		privacy_led: privacy-led {
 			function = LED_FUNCTION_INDICATOR;
 			color = <LED_COLOR_ID_WHITE>;
 			gpios = <&tlmm 28 GPIO_ACTIVE_HIGH>;
-			linux,default-trigger = "none";
 			default-state = "off";
-			/* Reuse as a panic indicator until we get a "camera on" trigger */
 			panic-indicator;
 		};
 	};
@@ -685,6 +682,9 @@
 		pinctrl-names = "default";
 		pinctrl-0 = <&cam_rgb_default>;
 
+		leds = <&privacy_led>;
+		led-names = "privacy";
+
 		clocks = <&camcc CAMCC_MCLK3_CLK>;
 
 		orientation = <0>;	/* Front facing */
@@ -726,7 +726,7 @@
 };
 
 &mdss0_dp0_out {
-	data-lanes = <0 1>;
+	data-lanes = <0 1 2 3>;
 	remote-endpoint = <&usb_0_qmpphy_dp_in>;
 };
 
@@ -735,7 +735,7 @@
 };
 
 &mdss0_dp1_out {
-	data-lanes = <0 1>;
+	data-lanes = <0 1 2 3>;
 	remote-endpoint = <&usb_1_qmpphy_dp_in>;
 };
 
@@ -1337,11 +1337,9 @@
 };
 
 &usb_0 {
-	status = "okay";
-};
-
-&usb_0_dwc3 {
 	dr_mode = "host";
+
+	status = "okay";
 };
 
 &usb_0_dwc3_hs {
@@ -1360,6 +1358,7 @@
 	vdda-phy-supply = <&vreg_l9d>;
 	vdda-pll-supply = <&vreg_l4d>;
 
+	mode-switch;
 	orientation-switch;
 
 	status = "okay";
@@ -1374,11 +1373,8 @@
 };
 
 &usb_1 {
-	status = "okay";
-};
-
-&usb_1_dwc3 {
 	dr_mode = "host";
+	status = "okay";
 };
 
 &usb_1_dwc3_hs {
@@ -1397,6 +1393,7 @@
 	vdda-phy-supply = <&vreg_l4b>;
 	vdda-pll-supply = <&vreg_l3b>;
 
+	mode-switch;
 	orientation-switch;
 
 	status = "okay";
@@ -1471,6 +1468,11 @@
 	status = "okay";
 };
 
+&venus {
+	firmware-name = "qcom/sc8280xp/LENOVO/21BX/qcvss8280.mbn";
+	status = "okay";
+};
+
 &wsamacro {
 	status = "okay";
 };
diff -Nrup linux-6.16.6/arch/arm64/boot/dts/qcom/sc8280xp-microsoft-arcata.dts linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sc8280xp-microsoft-arcata.dts
--- linux-6.16.6/arch/arm64/boot/dts/qcom/sc8280xp-microsoft-arcata.dts	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sc8280xp-microsoft-arcata.dts	2025-09-11 09:47:42.000000000 -0600
@@ -749,11 +749,8 @@
 };
 
 &usb_0 {
-	status = "okay";
-};
-
-&usb_0_dwc3 {
 	dr_mode = "host";
+	status = "okay";
 };
 
 &usb_0_dwc3_hs {
@@ -786,11 +783,8 @@
 };
 
 &usb_1 {
-	status = "okay";
-};
-
-&usb_1_dwc3 {
 	dr_mode = "host";
+	status = "okay";
 };
 
 &usb_1_dwc3_hs {
diff -Nrup linux-6.16.6/arch/arm64/boot/dts/qcom/sc8280xp-microsoft-blackrock.dts linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sc8280xp-microsoft-blackrock.dts
--- linux-6.16.6/arch/arm64/boot/dts/qcom/sc8280xp-microsoft-blackrock.dts	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/sc8280xp-microsoft-blackrock.dts	2025-09-11 09:47:42.000000000 -0600
@@ -982,11 +982,9 @@
 };
 
 &usb_0 {
-	status = "okay";
-};
-
-&usb_0_dwc3 {
 	dr_mode = "host";
+
+	status = "okay";
 };
 
 &usb_0_dwc3_hs {
@@ -1019,11 +1017,9 @@
 };
 
 &usb_1 {
-	status = "okay";
-};
-
-&usb_1_dwc3 {
 	dr_mode = "host";
+
+	status = "okay";
 };
 
 &usb_1_dwc3_hs {
@@ -1059,12 +1055,10 @@
 	pinctrl-0 = <&usb2_en_state>;
 	pinctrl-names = "default";
 
-	status = "okay";
-};
-
-&usb_2_dwc3 {
 	phys = <&usb_2_hsphy0>, <&usb_2_qmpphy0>;
 	phy-names = "usb2-0", "usb3-0";
+
+	status = "okay";
 };
 
 &usb_2_hsphy0 {
diff -Nrup linux-6.16.6/arch/arm64/boot/dts/qcom/x1-crd.dtsi linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/x1-crd.dtsi
--- linux-6.16.6/arch/arm64/boot/dts/qcom/x1-crd.dtsi	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/x1-crd.dtsi	2025-09-11 09:47:42.000000000 -0600
@@ -17,6 +17,7 @@
 
 	aliases {
 		serial0 = &uart21;
+		serial1 = &uart14;
 	};
 
 	wcd938x: audio-codec {
@@ -491,6 +492,48 @@
 		regulator-boot-on;
 	};
 
+	vreg_wcn_3p3: regulator-wcn-3p3 {
+		compatible = "regulator-fixed";
+
+		regulator-name = "VREG_WCN_3P3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+
+		gpio = <&tlmm 214 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		pinctrl-0 = <&wcn_sw_en>;
+		pinctrl-names = "default";
+
+		regulator-boot-on;
+	};
+
+	/*
+	 * TODO: These two regulators are actually part of the removable M.2
+	 * card and not the CRD mainboard. Need to describe this differently.
+	 * Functionally it works correctly, because all we need to do is to
+	 * turn on the actual 3.3V supply above.
+	 */
+	vreg_wcn_0p95: regulator-wcn-0p95 {
+		compatible = "regulator-fixed";
+
+		regulator-name = "VREG_WCN_0P95";
+		regulator-min-microvolt = <950000>;
+		regulator-max-microvolt = <950000>;
+
+		vin-supply = <&vreg_wcn_3p3>;
+	};
+
+	vreg_wcn_1p9: regulator-wcn-1p9 {
+		compatible = "regulator-fixed";
+
+		regulator-name = "VREG_WCN_1P9";
+		regulator-min-microvolt = <1900000>;
+		regulator-max-microvolt = <1900000>;
+
+		vin-supply = <&vreg_wcn_3p3>;
+	};
+
 	vreg_wwan: regulator-wwan {
 		compatible = "regulator-fixed";
 
@@ -506,6 +549,65 @@
 
 		regulator-boot-on;
 	};
+
+	wcn7850-pmu {
+		compatible = "qcom,wcn7850-pmu";
+
+		vdd-supply = <&vreg_wcn_0p95>;
+		vddio-supply = <&vreg_l15b_1p8>;
+		vddaon-supply = <&vreg_wcn_0p95>;
+		vdddig-supply = <&vreg_wcn_0p95>;
+		vddrfa1p2-supply = <&vreg_wcn_1p9>;
+		vddrfa1p8-supply = <&vreg_wcn_1p9>;
+
+		wlan-enable-gpios = <&tlmm 117 GPIO_ACTIVE_HIGH>;
+		bt-enable-gpios = <&tlmm 116 GPIO_ACTIVE_HIGH>;
+
+		pinctrl-0 = <&wcn_wlan_bt_en>;
+		pinctrl-names = "default";
+
+		regulators {
+			vreg_pmu_rfa_cmn: ldo0 {
+				regulator-name = "vreg_pmu_rfa_cmn";
+			};
+
+			vreg_pmu_aon_0p59: ldo1 {
+				regulator-name = "vreg_pmu_aon_0p59";
+			};
+
+			vreg_pmu_wlcx_0p8: ldo2 {
+				regulator-name = "vreg_pmu_wlcx_0p8";
+			};
+
+			vreg_pmu_wlmx_0p85: ldo3 {
+				regulator-name = "vreg_pmu_wlmx_0p85";
+			};
+
+			vreg_pmu_btcmx_0p85: ldo4 {
+				regulator-name = "vreg_pmu_btcmx_0p85";
+			};
+
+			vreg_pmu_rfa_0p8: ldo5 {
+				regulator-name = "vreg_pmu_rfa_0p8";
+			};
+
+			vreg_pmu_rfa_1p2: ldo6 {
+				regulator-name = "vreg_pmu_rfa_1p2";
+			};
+
+			vreg_pmu_rfa_1p8: ldo7 {
+				regulator-name = "vreg_pmu_rfa_1p8";
+			};
+
+			vreg_pmu_pcie_0p9: ldo8 {
+				regulator-name = "vreg_pmu_pcie_0p9";
+			};
+
+			vreg_pmu_pcie_1p8: ldo9 {
+				regulator-name = "vreg_pmu_pcie_1p8";
+			};
+		};
+	};
 };
 
 &apps_rsc {
@@ -1016,6 +1118,27 @@
 	};
 };
 
+&i2c5 {
+	clock-frequency = <400000>;
+
+	status = "okay";
+
+	eusb6_repeater: redriver@4f {
+		compatible = "nxp,ptn3222";
+		reg = <0x4f>;
+
+		vdd1v8-supply = <&vreg_l4b_1p8>;
+		vdd3v3-supply = <&vreg_l13b_3p0>;
+
+		reset-gpios = <&tlmm 184 GPIO_ACTIVE_LOW>;
+
+		pinctrl-0 = <&eusb6_reset_n>;
+		pinctrl-names = "default";
+
+		#phy-cells = <0>;
+	};
+};
+
 &i2c7 {
 	clock-frequency = <400000>;
 
@@ -1206,6 +1329,23 @@
 	status = "okay";
 };
 
+&pcie4_port0 {
+	wifi@0 {
+		compatible = "pci17cb,1107";
+		reg = <0x10000 0x0 0x0 0x0 0x0>;
+
+		vddaon-supply = <&vreg_pmu_aon_0p59>;
+		vddwlcx-supply = <&vreg_pmu_wlcx_0p8>;
+		vddwlmx-supply = <&vreg_pmu_wlmx_0p85>;
+		vddrfacmn-supply = <&vreg_pmu_rfa_cmn>;
+		vddrfa0p8-supply = <&vreg_pmu_rfa_0p8>;
+		vddrfa1p2-supply = <&vreg_pmu_rfa_1p2>;
+		vddrfa1p8-supply = <&vreg_pmu_rfa_1p8>;
+		vddpcie0p9-supply = <&vreg_pmu_pcie_0p9>;
+		vddpcie1p8-supply = <&vreg_pmu_pcie_1p8>;
+	};
+};
+
 &pcie5 {
 	perst-gpios = <&tlmm 149 GPIO_ACTIVE_LOW>;
 	wake-gpios = <&tlmm 151 GPIO_ACTIVE_LOW>;
@@ -1466,6 +1606,14 @@
 		bias-disable;
 	};
 
+	eusb6_reset_n: eusb6-reset-n-state {
+		pins = "gpio184";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+		output-low;
+	};
+
 	hall_int_n_default: hall-int-n-state {
 		pins = "gpio92";
 		function = "gpio";
@@ -1639,6 +1787,20 @@
 		output-low;
 	};
 
+	wcn_sw_en: wcn-sw-en-state {
+		pins = "gpio214";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	wcn_wlan_bt_en: wcn-wlan-bt-en-state {
+		pins = "gpio116", "gpio117";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
 	wwan_sw_en: wwan-sw-en-state {
 		pins = "gpio221";
 		function = "gpio";
@@ -1647,6 +1809,23 @@
 	};
 };
 
+&uart14 {
+	status = "okay";
+
+	bluetooth {
+		compatible = "qcom,wcn7850-bt";
+		max-speed = <3200000>;
+
+		vddaon-supply = <&vreg_pmu_aon_0p59>;
+		vddwlcx-supply = <&vreg_pmu_wlcx_0p8>;
+		vddwlmx-supply = <&vreg_pmu_wlmx_0p85>;
+		vddrfacmn-supply = <&vreg_pmu_rfa_cmn>;
+		vddrfa0p8-supply = <&vreg_pmu_rfa_0p8>;
+		vddrfa1p2-supply = <&vreg_pmu_rfa_1p2>;
+		vddrfa1p8-supply = <&vreg_pmu_rfa_1p8>;
+	};
+};
+
 &uart21 {
 	compatible = "qcom,geni-debug-uart";
 	status = "okay";
@@ -1747,3 +1926,38 @@
 &usb_1_ss2_qmpphy_out {
 	remote-endpoint = <&retimer_ss2_ss_in>;
 };
+
+&usb_mp {
+	/* Only second port is used with USB 2.0 maximum speed */
+	status = "okay";
+};
+
+&usb_mp_hsphy0 {
+	vdd-supply = <&vreg_l2e_0p8>;
+	vdda12-supply = <&vreg_l3e_1p2>;
+
+	status = "okay";
+};
+
+&usb_mp_hsphy1 {
+	vdd-supply = <&vreg_l2e_0p8>;
+	vdda12-supply = <&vreg_l3e_1p2>;
+
+	phys = <&eusb6_repeater>;
+
+	status = "okay";
+};
+
+&usb_mp_qmpphy0 {
+	vdda-phy-supply = <&vreg_l3e_1p2>;
+	vdda-pll-supply = <&vreg_l3c_0p8>;
+
+	status = "okay";
+};
+
+&usb_mp_qmpphy1 {
+	vdda-phy-supply = <&vreg_l3e_1p2>;
+	vdda-pll-supply = <&vreg_l3c_0p8>;
+
+	status = "okay";
+};
diff -Nrup linux-6.16.6/arch/arm64/boot/dts/qcom/x1e78100-lenovo-thinkpad-t14s.dtsi linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/x1e78100-lenovo-thinkpad-t14s.dtsi
--- linux-6.16.6/arch/arm64/boot/dts/qcom/x1e78100-lenovo-thinkpad-t14s.dtsi	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/x1e78100-lenovo-thinkpad-t14s.dtsi	2025-09-11 09:47:42.000000000 -0600
@@ -20,6 +20,10 @@
 	compatible = "lenovo,thinkpad-t14s", "qcom,x1e78100", "qcom,x1e80100";
 	chassis-type = "laptop";
 
+	aliases {
+		serial1 = &uart14;
+	};
+
 	wcd938x: audio-codec {
 		compatible = "qcom,wcd9385-codec";
 
@@ -321,6 +325,48 @@
 		regulator-boot-on;
 	};
 
+	vreg_wcn_3p3: regulator-wcn-3p3 {
+		compatible = "regulator-fixed";
+
+		regulator-name = "VREG_WCN_3P3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+
+		gpio = <&tlmm 214 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		pinctrl-0 = <&wcn_sw_en>;
+		pinctrl-names = "default";
+
+		regulator-boot-on;
+	};
+
+	/*
+	 * TODO: These two regulators are actually part of the removable M.2
+	 * card and not the CRD mainboard. Need to describe this differently.
+	 * Functionally it works correctly, because all we need to do is to
+	 * turn on the actual 3.3V supply above.
+	 */
+	vreg_wcn_0p95: regulator-wcn-0p95 {
+		compatible = "regulator-fixed";
+
+		regulator-name = "VREG_WCN_0P95";
+		regulator-min-microvolt = <950000>;
+		regulator-max-microvolt = <950000>;
+
+		vin-supply = <&vreg_wcn_3p3>;
+	};
+
+	vreg_wcn_1p9: regulator-wcn-1p9 {
+		compatible = "regulator-fixed";
+
+		regulator-name = "VREG_WCN_1P9";
+		regulator-min-microvolt = <1900000>;
+		regulator-max-microvolt = <1900000>;
+
+		vin-supply = <&vreg_wcn_3p3>;
+	};
+
 	vreg_wwan: regulator-wwan {
 		compatible = "regulator-fixed";
 
@@ -415,6 +461,65 @@
 			};
 		};
 	};
+
+	wcn7850-pmu {
+		compatible = "qcom,wcn7850-pmu";
+
+		vdd-supply = <&vreg_wcn_0p95>;
+		vddio-supply = <&vreg_l15b_1p8>;
+		vddaon-supply = <&vreg_wcn_0p95>;
+		vdddig-supply = <&vreg_wcn_0p95>;
+		vddrfa1p2-supply = <&vreg_wcn_1p9>;
+		vddrfa1p8-supply = <&vreg_wcn_1p9>;
+
+		wlan-enable-gpios = <&tlmm 117 GPIO_ACTIVE_HIGH>;
+		bt-enable-gpios = <&tlmm 116 GPIO_ACTIVE_HIGH>;
+
+		pinctrl-0 = <&wcn_wlan_bt_en>;
+		pinctrl-names = "default";
+
+		regulators {
+			vreg_pmu_rfa_cmn: ldo0 {
+				regulator-name = "vreg_pmu_rfa_cmn";
+			};
+
+			vreg_pmu_aon_0p59: ldo1 {
+				regulator-name = "vreg_pmu_aon_0p59";
+			};
+
+			vreg_pmu_wlcx_0p8: ldo2 {
+				regulator-name = "vreg_pmu_wlcx_0p8";
+			};
+
+			vreg_pmu_wlmx_0p85: ldo3 {
+				regulator-name = "vreg_pmu_wlmx_0p85";
+			};
+
+			vreg_pmu_btcmx_0p85: ldo4 {
+				regulator-name = "vreg_pmu_btcmx_0p85";
+			};
+
+			vreg_pmu_rfa_0p8: ldo5 {
+				regulator-name = "vreg_pmu_rfa_0p8";
+			};
+
+			vreg_pmu_rfa_1p2: ldo6 {
+				regulator-name = "vreg_pmu_rfa_1p2";
+			};
+
+			vreg_pmu_rfa_1p8: ldo7 {
+				regulator-name = "vreg_pmu_rfa_1p8";
+			};
+
+			vreg_pmu_pcie_0p9: ldo8 {
+				regulator-name = "vreg_pmu_pcie_0p9";
+			};
+
+			vreg_pmu_pcie_1p8: ldo9 {
+				regulator-name = "vreg_pmu_pcie_1p8";
+			};
+		};
+	};
 };
 
 &apps_rsc {
@@ -1061,6 +1166,23 @@
 	status = "okay";
 };
 
+&pcie4_port0 {
+	wifi@0 {
+		compatible = "pci17cb,1107";
+		reg = <0x10000 0x0 0x0 0x0 0x0>;
+
+		vddaon-supply = <&vreg_pmu_aon_0p59>;
+		vddwlcx-supply = <&vreg_pmu_wlcx_0p8>;
+		vddwlmx-supply = <&vreg_pmu_wlmx_0p85>;
+		vddrfacmn-supply = <&vreg_pmu_rfa_cmn>;
+		vddrfa0p8-supply = <&vreg_pmu_rfa_0p8>;
+		vddrfa1p2-supply = <&vreg_pmu_rfa_1p2>;
+		vddrfa1p8-supply = <&vreg_pmu_rfa_1p8>;
+		vddpcie0p9-supply = <&vreg_pmu_pcie_0p9>;
+		vddpcie1p8-supply = <&vreg_pmu_pcie_1p8>;
+	};
+};
+
 &pcie5 {
 	perst-gpios = <&tlmm 149 GPIO_ACTIVE_LOW>;
 	wake-gpios = <&tlmm 151 GPIO_ACTIVE_LOW>;
@@ -1450,6 +1572,20 @@
 		output-low;
 	};
 
+	wcn_sw_en: wcn-sw-en-state {
+		pins = "gpio214";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	wcn_wlan_bt_en: wcn-wlan-bt-en-state {
+		pins = "gpio116", "gpio117";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
 	wwan_sw_en: wwan-sw-en-state {
 		pins = "gpio221";
 		function = "gpio";
@@ -1458,6 +1594,23 @@
 	};
 };
 
+&uart14 {
+	status = "okay";
+
+	bluetooth {
+		compatible = "qcom,wcn7850-bt";
+		max-speed = <3200000>;
+
+		vddaon-supply = <&vreg_pmu_aon_0p59>;
+		vddwlcx-supply = <&vreg_pmu_wlcx_0p8>;
+		vddwlmx-supply = <&vreg_pmu_wlmx_0p85>;
+		vddrfacmn-supply = <&vreg_pmu_rfa_cmn>;
+		vddrfa0p8-supply = <&vreg_pmu_rfa_0p8>;
+		vddrfa1p2-supply = <&vreg_pmu_rfa_1p2>;
+		vddrfa1p8-supply = <&vreg_pmu_rfa_1p8>;
+	};
+};
+
 &usb_1_ss0_hsphy {
 	vdd-supply = <&vreg_l3j_0p8>;
 	vdda12-supply = <&vreg_l2j_1p2>;
diff -Nrup linux-6.16.6/arch/arm64/boot/dts/qcom/x1e78100-lenovo-thinkpad-t14s-oled.dts linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/x1e78100-lenovo-thinkpad-t14s-oled.dts
--- linux-6.16.6/arch/arm64/boot/dts/qcom/x1e78100-lenovo-thinkpad-t14s-oled.dts	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/x1e78100-lenovo-thinkpad-t14s-oled.dts	2025-09-11 09:47:42.000000000 -0600
@@ -10,3 +10,11 @@
 	compatible = "lenovo,thinkpad-t14s-oled", "lenovo,thinkpad-t14s",
 		     "qcom,x1e78100", "qcom,x1e80100";
 };
+
+&panel {
+	compatible = "samsung,atna40yk20", "samsung,atna33xc20";
+	enable-gpios = <&pmc8380_3_gpios 4 GPIO_ACTIVE_HIGH>;
+
+	pinctrl-0 = <&edp_bl_en>;
+	pinctrl-names = "default";
+};
diff -Nrup linux-6.16.6/arch/arm64/boot/dts/qcom/x1e80100-dell-xps13-9345.dts linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/x1e80100-dell-xps13-9345.dts
--- linux-6.16.6/arch/arm64/boot/dts/qcom/x1e80100-dell-xps13-9345.dts	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/x1e80100-dell-xps13-9345.dts	2025-09-11 09:47:42.000000000 -0600
@@ -22,6 +22,7 @@
 
 	aliases {
 		serial0 = &uart21;
+		serial1 = &uart14;
 	};
 
 	gpio-keys {
@@ -288,6 +289,101 @@
 		regulator-always-on;
 		regulator-boot-on;
 	};
+
+	vreg_wcn_0p95: regulator-wcn-0p95 {
+		compatible = "regulator-fixed";
+
+		regulator-name = "VREG_WCN_0P95";
+		regulator-min-microvolt = <950000>;
+		regulator-max-microvolt = <950000>;
+
+		vin-supply = <&vreg_wcn_3p3>;
+	};
+
+	vreg_wcn_1p9: regulator-wcn-1p9 {
+		compatible = "regulator-fixed";
+
+		regulator-name = "VREG_WCN_1P9";
+		regulator-min-microvolt = <1900000>;
+		regulator-max-microvolt = <1900000>;
+
+		vin-supply = <&vreg_wcn_3p3>;
+	};
+
+	vreg_wcn_3p3: regulator-wcn-3p3 {
+		compatible = "regulator-fixed";
+
+		regulator-name = "VREG_WCN_3P3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+
+		gpio = <&tlmm 214 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		pinctrl-0 = <&wcn_sw_en>;
+		pinctrl-names = "default";
+
+		regulator-boot-on;
+	};
+
+	wcn7850-pmu {
+		compatible = "qcom,wcn7850-pmu";
+
+		vdd-supply = <&vreg_wcn_0p95>;
+		vddio-supply = <&vreg_l15b_1p8>;
+		vddaon-supply = <&vreg_wcn_0p95>;
+		vdddig-supply = <&vreg_wcn_0p95>;
+		vddrfa1p2-supply = <&vreg_wcn_1p9>;
+		vddrfa1p8-supply = <&vreg_wcn_1p9>;
+
+		wlan-enable-gpios = <&tlmm 117 GPIO_ACTIVE_HIGH>;
+		bt-enable-gpios = <&tlmm 116 GPIO_ACTIVE_HIGH>;
+
+		pinctrl-0 = <&wcn_wlan_bt_en>;
+		pinctrl-names = "default";
+
+		regulators {
+			vreg_pmu_rfa_cmn: ldo0 {
+				regulator-name = "vreg_pmu_rfa_cmn";
+			};
+
+			vreg_pmu_aon_0p59: ldo1 {
+				regulator-name = "vreg_pmu_aon_0p59";
+			};
+
+			vreg_pmu_wlcx_0p8: ldo2 {
+				regulator-name = "vreg_pmu_wlcx_0p8";
+			};
+
+			vreg_pmu_wlmx_0p85: ldo3 {
+				regulator-name = "vreg_pmu_wlmx_0p85";
+			};
+
+			vreg_pmu_btcmx_0p85: ldo4 {
+				regulator-name = "vreg_pmu_btcmx_0p85";
+			};
+
+			vreg_pmu_rfa_0p8: ldo5 {
+				regulator-name = "vreg_pmu_rfa_0p8";
+			};
+
+			vreg_pmu_rfa_1p2: ldo6 {
+				regulator-name = "vreg_pmu_rfa_1p2";
+			};
+
+			vreg_pmu_rfa_1p8: ldo7 {
+				regulator-name = "vreg_pmu_rfa_1p8";
+			};
+
+			vreg_pmu_pcie_0p9: ldo8 {
+				regulator-name = "vreg_pmu_pcie_0p9";
+			};
+
+			vreg_pmu_pcie_1p8: ldo9 {
+				regulator-name = "vreg_pmu_pcie_1p8";
+			};
+		};
+	};
 };
 
 &apps_rsc {
@@ -848,6 +944,23 @@
 	status = "okay";
 };
 
+&pcie4_port0 {
+	wifi@0 {
+		compatible = "pci17cb,1107";
+		reg = <0x10000 0x0 0x0 0x0 0x0>;
+
+		vddaon-supply = <&vreg_pmu_aon_0p59>;
+		vddwlcx-supply = <&vreg_pmu_wlcx_0p8>;
+		vddwlmx-supply = <&vreg_pmu_wlmx_0p85>;
+		vddrfacmn-supply = <&vreg_pmu_rfa_cmn>;
+		vddrfa0p8-supply = <&vreg_pmu_rfa_0p8>;
+		vddrfa1p2-supply = <&vreg_pmu_rfa_1p2>;
+		vddrfa1p8-supply = <&vreg_pmu_rfa_1p8>;
+		vddpcie0p9-supply = <&vreg_pmu_pcie_0p9>;
+		vddpcie1p8-supply = <&vreg_pmu_pcie_1p8>;
+	};
+};
+
 &pcie6a {
 	perst-gpios = <&tlmm 152 GPIO_ACTIVE_LOW>;
 	wake-gpios = <&tlmm 154 GPIO_ACTIVE_LOW>;
@@ -1102,6 +1215,37 @@
 			drive-strength = <2>;
 		};
 	};
+
+	wcn_sw_en: wcn-sw-en-state {
+		pins = "gpio214";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	wcn_wlan_bt_en: wcn-wlan-bt-en-state {
+		pins = "gpio116", "gpio117";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+};
+
+&uart14 {
+	status = "okay";
+
+	bluetooth {
+		compatible = "qcom,wcn7850-bt";
+		max-speed = <3200000>;
+
+		vddaon-supply = <&vreg_pmu_aon_0p59>;
+		vddwlcx-supply = <&vreg_pmu_wlcx_0p8>;
+		vddwlmx-supply = <&vreg_pmu_wlmx_0p85>;
+		vddrfacmn-supply = <&vreg_pmu_rfa_cmn>;
+		vddrfa0p8-supply = <&vreg_pmu_rfa_0p8>;
+		vddrfa1p2-supply = <&vreg_pmu_rfa_1p2>;
+		vddrfa1p8-supply = <&vreg_pmu_rfa_1p8>;
+	};
 };
 
 &uart21 {
diff -Nrup linux-6.16.6/arch/arm64/boot/dts/qcom/x1e80100-pmics.dtsi linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/x1e80100-pmics.dtsi
--- linux-6.16.6/arch/arm64/boot/dts/qcom/x1e80100-pmics.dtsi	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/qcom/x1e80100-pmics.dtsi	2025-09-11 09:47:42.000000000 -0600
@@ -475,6 +475,8 @@
 		#address-cells = <1>;
 		#size-cells = <0>;
 
+		status = "disabled";
+
 		pm8010_temp_alarm: temp-alarm@2400 {
 			compatible = "qcom,spmi-temp-alarm";
 			reg = <0x2400>;
diff -Nrup linux-6.16.6/arch/arm64/boot/dts/renesas/r9a07g054l2-smarc-cru-csi-ov5645.dtso linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/renesas/r9a07g054l2-smarc-cru-csi-ov5645.dtso
--- linux-6.16.6/arch/arm64/boot/dts/renesas/r9a07g054l2-smarc-cru-csi-ov5645.dtso	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/boot/dts/renesas/r9a07g054l2-smarc-cru-csi-ov5645.dtso	2025-09-11 09:47:42.000000000 -0600
@@ -1,21 +1 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Device Tree overlay for the RZ/{G2L, V2L} SMARC EVK with OV5645 camera
- * connected to CSI and CRU enabled.
- *
- * Copyright (C) 2023 Renesas Electronics Corp.
- */
-
-/dts-v1/;
-/plugin/;
-
-#include <dt-bindings/gpio/gpio.h>
-#include <dt-bindings/pinctrl/rzg2l-pinctrl.h>
-
-#define OV5645_PARENT_I2C i2c0
-#include "rz-smarc-cru-csi-ov5645.dtsi"
-
-&ov5645 {
-	enable-gpios = <&pinctrl RZG2L_GPIO(2, 0) GPIO_ACTIVE_HIGH>;
-	reset-gpios = <&pinctrl RZG2L_GPIO(40, 2) GPIO_ACTIVE_LOW>;
-};
+r9a07g044l2-smarc-cru-csi-ov5645.dtso
\ No newline at end of file
diff -Nrup linux-6.16.6/arch/arm64/configs/defconfig linux-lenovo-x13s-linux-6.16.y/arch/arm64/configs/defconfig
--- linux-6.16.6/arch/arm64/configs/defconfig	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/configs/defconfig	2025-09-11 09:47:42.000000000 -0600
@@ -236,7 +236,7 @@ CONFIG_PCIE_HISI_STB=y
 CONFIG_PCIE_ARMADA_8K=y
 CONFIG_PCIE_TEGRA194_HOST=m
 CONFIG_PCIE_TEGRA194_EP=m
-CONFIG_PCIE_QCOM=y
+CONFIG_PCIE_QCOM=m
 CONFIG_PCIE_RCAR_GEN4_HOST=m
 CONFIG_PCIE_RCAR_GEN4_EP=m
 CONFIG_PCIE_ROCKCHIP_DW_HOST=y
diff -Nrup linux-6.16.6/arch/arm64/configs/johan_defconfig linux-lenovo-x13s-linux-6.16.y/arch/arm64/configs/johan_defconfig
--- linux-6.16.6/arch/arm64/configs/johan_defconfig	1969-12-31 17:00:00.000000000 -0700
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/configs/johan_defconfig	2025-09-11 09:47:42.000000000 -0600
@@ -0,0 +1,429 @@
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_AUDIT=y
+CONFIG_NO_HZ_IDLE=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_BPF_SYSCALL=y
+CONFIG_BPF_JIT=y
+CONFIG_PREEMPT=y
+CONFIG_IRQ_TIME_ACCOUNTING=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_NUMA_BALANCING=y
+CONFIG_MEMCG=y
+CONFIG_BLK_CGROUP=y
+CONFIG_CGROUP_PIDS=y
+CONFIG_CGROUP_HUGETLB=y
+CONFIG_CPUSETS=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_CGROUP_PERF=y
+CONFIG_CGROUP_BPF=y
+CONFIG_USER_NS=y
+CONFIG_SCHED_AUTOGROUP=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_PROFILING=y
+CONFIG_ARCH_QCOM=y
+# CONFIG_AMPERE_ERRATUM_AC04_CPU_23 is not set
+# CONFIG_ARM64_ERRATUM_2077057 is not set
+# CONFIG_ARM64_ERRATUM_3194386 is not set
+# CONFIG_ROCKCHIP_ERRATUM_3568002 is not set
+# CONFIG_ROCKCHIP_ERRATUM_3588001 is not set
+CONFIG_ARM64_VA_BITS_48=y
+CONFIG_SCHED_MC=y
+CONFIG_SCHED_SMT=y
+CONFIG_NUMA=y
+CONFIG_COMPAT=y
+# CONFIG_ARM64_POE is not set
+CONFIG_RANDOMIZE_BASE=y
+CONFIG_HIBERNATION=y
+CONFIG_WQ_POWER_EFFICIENT_DEFAULT=y
+CONFIG_ENERGY_MODEL=y
+CONFIG_CPU_IDLE=y
+CONFIG_ARM_PSCI_CPUIDLE=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=m
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=m
+CONFIG_CPUFREQ_DT_PLATDEV=y
+CONFIG_ARM_QCOM_CPUFREQ_HW=y
+CONFIG_ARM_SCMI_CPUFREQ=y
+CONFIG_JUMP_LABEL=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_BLOCK_LEGACY_AUTOLOAD is not set
+# CONFIG_IOSCHED_BFQ is not set
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_BINFMT_MISC=m
+CONFIG_KSM=y
+CONFIG_MEMORY_FAILURE=y
+CONFIG_TRANSPARENT_HUGEPAGE=y
+CONFIG_CMA=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IPV6=m
+CONFIG_IPV6_MULTIPLE_TABLES=y
+CONFIG_NETFILTER=y
+CONFIG_NF_CONNTRACK=m
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NETFILTER_XTABLES_COMPAT=y
+CONFIG_NETFILTER_XT_MARK=m
+CONFIG_NETFILTER_XT_TARGET_LOG=m
+CONFIG_NETFILTER_XT_MATCH_ADDRTYPE=m
+CONFIG_NETFILTER_XT_MATCH_COMMENT=m
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=m
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=m
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_IP_NF_RAW=m
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_TARGET_REJECT=m
+CONFIG_IP6_NF_MANGLE=m
+CONFIG_IP6_NF_RAW=m
+CONFIG_QRTR_SMD=m
+CONFIG_QRTR_TUN=m
+CONFIG_BT=m
+CONFIG_BT_RFCOMM=m
+CONFIG_BT_HIDP=m
+CONFIG_BT_HCIUART=m
+CONFIG_BT_HCIUART_QCA=y
+CONFIG_CFG80211=m
+CONFIG_MAC80211=m
+CONFIG_MAC80211_LEDS=y
+CONFIG_RFKILL=m
+CONFIG_PCI=y
+CONFIG_PCIEPORTBUS=y
+CONFIG_PCIEAER=y
+CONFIG_PCIE_QCOM=m
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_FW_LOADER_USER_HELPER=y
+CONFIG_FW_LOADER_COMPRESS=y
+CONFIG_FW_LOADER_COMPRESS_ZSTD=y
+# CONFIG_QCOM_EBI2 is not set
+CONFIG_MHI_BUS_PCI_GENERIC=m
+CONFIG_ARM_SCMI_PROTOCOL=y
+CONFIG_EFI_CAPSULE_LOADER=y
+CONFIG_QCOM_QSEECOM=y
+CONFIG_QCOM_QSEECOM_UEFISECAPP=y
+CONFIG_ZRAM=m
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_NVME=m
+CONFIG_QCOM_FASTRPC=m
+CONFIG_SCSI=y
+# CONFIG_SCSI_PROC_FS is not set
+CONFIG_BLK_DEV_SD=y
+# CONFIG_SCSI_LOWLEVEL is not set
+CONFIG_MD=y
+CONFIG_BLK_DEV_DM=m
+CONFIG_DM_CRYPT=m
+CONFIG_NETDEVICES=y
+CONFIG_WIREGUARD=m
+CONFIG_TUN=y
+CONFIG_VETH=m
+CONFIG_MHI_NET=m
+# CONFIG_ETHERNET is not set
+CONFIG_USB_NET_DRIVERS=m
+CONFIG_USB_RTL8152=m
+# CONFIG_WLAN_VENDOR_ADMTEK is not set
+CONFIG_ATH11K=m
+CONFIG_ATH11K_PCI=m
+CONFIG_ATH12K=m
+# CONFIG_WLAN_VENDOR_ATMEL is not set
+# CONFIG_WLAN_VENDOR_BROADCOM is not set
+# CONFIG_WLAN_VENDOR_INTEL is not set
+# CONFIG_WLAN_VENDOR_INTERSIL is not set
+# CONFIG_WLAN_VENDOR_MARVELL is not set
+# CONFIG_WLAN_VENDOR_MEDIATEK is not set
+# CONFIG_WLAN_VENDOR_MICROCHIP is not set
+# CONFIG_WLAN_VENDOR_PURELIFI is not set
+# CONFIG_WLAN_VENDOR_RALINK is not set
+# CONFIG_WLAN_VENDOR_REALTEK is not set
+# CONFIG_WLAN_VENDOR_RSI is not set
+# CONFIG_WLAN_VENDOR_SILABS is not set
+# CONFIG_WLAN_VENDOR_ST is not set
+# CONFIG_WLAN_VENDOR_TI is not set
+# CONFIG_WLAN_VENDOR_ZYDAS is not set
+# CONFIG_WLAN_VENDOR_QUANTENNA is not set
+CONFIG_WWAN=m
+CONFIG_MHI_WWAN_CTRL=m
+CONFIG_MHI_WWAN_MBIM=m
+CONFIG_INPUT_EVDEV=y
+# CONFIG_KEYBOARD_ATKBD is not set
+CONFIG_KEYBOARD_GPIO=y
+# CONFIG_INPUT_MOUSE is not set
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_PM8941_PWRKEY=y
+# CONFIG_SERIO is not set
+CONFIG_LEGACY_PTY_COUNT=16
+CONFIG_SERIAL_QCOM_GENI=y
+CONFIG_SERIAL_QCOM_GENI_CONSOLE=y
+CONFIG_SERIAL_DEV_BUS=y
+# CONFIG_DEVPORT is not set
+CONFIG_I2C_CHARDEV=m
+CONFIG_I2C_QCOM_CCI=m
+CONFIG_I2C_QCOM_GENI=m
+CONFIG_SPI=y
+CONFIG_SPI_QCOM_GENI=m
+CONFIG_SPMI=y
+CONFIG_PINCTRL_SINGLE=y
+CONFIG_PINCTRL_MSM=y
+CONFIG_PINCTRL_SC8280XP=y
+CONFIG_PINCTRL_X1E80100=y
+CONFIG_PINCTRL_QCOM_SPMI_PMIC=y
+CONFIG_PINCTRL_LPASS_LPI=m
+CONFIG_PINCTRL_SC8280XP_LPASS_LPI=m
+CONFIG_PINCTRL_SM8550_LPASS_LPI=m
+CONFIG_POWER_RESET_QCOM_PON=m
+CONFIG_BATTERY_QCOM_BATTMGR=m
+CONFIG_THERMAL=y
+CONFIG_THERMAL_GOV_POWER_ALLOCATOR=y
+CONFIG_CPU_THERMAL=y
+CONFIG_DEVFREQ_THERMAL=y
+CONFIG_THERMAL_EMULATION=y
+CONFIG_QCOM_TSENS=y
+CONFIG_QCOM_SPMI_ADC_TM5=m
+CONFIG_QCOM_SPMI_TEMP_ALARM=m
+CONFIG_QCOM_LMH=m
+CONFIG_WATCHDOG=y
+CONFIG_ARM_SBSA_WATCHDOG=y
+CONFIG_QCOM_WDT=m
+CONFIG_MFD_SPMI_PMIC=y
+CONFIG_MFD_QCOM_PM8008=m
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_REGULATOR_QCOM_PM8008=m
+CONFIG_REGULATOR_QCOM_RPMH=y
+CONFIG_MEDIA_SUPPORT=m
+CONFIG_MEDIA_CAMERA_SUPPORT=y
+CONFIG_MEDIA_PLATFORM_SUPPORT=y
+CONFIG_MEDIA_USB_SUPPORT=y
+CONFIG_USB_VIDEO_CLASS=m
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_V4L_MEM2MEM_DRIVERS=y
+CONFIG_VIDEO_QCOM_CAMSS=m
+CONFIG_VIDEO_QCOM_VENUS=m
+CONFIG_VIDEO_OV5675=m
+CONFIG_DRM=m
+CONFIG_DRM_MALI_DISPLAY=m
+CONFIG_DRM_MSM=m
+# CONFIG_DRM_MSM_MDP4 is not set
+# CONFIG_DRM_MSM_MDP5 is not set
+# CONFIG_DRM_MSM_DSI is not set
+# CONFIG_DRM_MSM_HDMI is not set
+CONFIG_DRM_PANEL_SAMSUNG_ATNA33XC20=m
+CONFIG_DRM_PANEL_EDP=m
+CONFIG_DRM_DISPLAY_CONNECTOR=m
+CONFIG_FB=y
+CONFIG_FB_EFI=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_PWM=m
+CONFIG_SOUND=m
+CONFIG_SND=m
+# CONFIG_SND_SUPPORT_OLD_API is not set
+# CONFIG_SND_DRIVERS is not set
+# CONFIG_SND_PCI is not set
+# CONFIG_SND_SPI is not set
+CONFIG_SND_USB_AUDIO=m
+CONFIG_SND_SOC=m
+CONFIG_SND_SOC_QCOM=m
+CONFIG_SND_SOC_SC8280XP=m
+CONFIG_SND_SOC_X1E80100=m
+CONFIG_SND_SOC_WCD938X_SDW=m
+CONFIG_SND_SOC_WSA883X=m
+CONFIG_SND_SOC_WSA884X=m
+CONFIG_SND_SOC_LPASS_WSA_MACRO=m
+CONFIG_SND_SOC_LPASS_VA_MACRO=m
+CONFIG_SND_SOC_LPASS_RX_MACRO=m
+CONFIG_SND_SOC_LPASS_TX_MACRO=m
+CONFIG_UHID=m
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_ITE is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_REDRAGON is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+CONFIG_HID_MULTITOUCH=m
+CONFIG_I2C_HID_OF=m
+CONFIG_I2C_HID_OF_ELAN=m
+CONFIG_USB=y
+# CONFIG_USB_PCI is not set
+CONFIG_USB_OTG=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_STORAGE=m
+CONFIG_USB_DWC3=y
+# CONFIG_USB_DWC3_OF_SIMPLE is not set
+CONFIG_USB_SERIAL=m
+CONFIG_USB_SERIAL_FTDI_SIO=m
+CONFIG_USB_GADGET=y
+CONFIG_USB_CONFIGFS=m
+CONFIG_USB_CONFIGFS_SERIAL=y
+CONFIG_TYPEC=m
+CONFIG_TYPEC_TCPM=m
+CONFIG_TYPEC_TCPCI=m
+CONFIG_TYPEC_UCSI=m
+CONFIG_UCSI_PMIC_GLINK=m
+CONFIG_TYPEC_MUX_GPIO_SBU=m
+CONFIG_TYPEC_MUX_PS883X=m
+CONFIG_MMC=m
+CONFIG_MMC_SDHCI=m
+CONFIG_MMC_SDHCI_PLTFM=m
+CONFIG_MMC_SDHCI_MSM=m
+CONFIG_SCSI_UFSHCD=y
+CONFIG_SCSI_UFSHCD_PLATFORM=y
+CONFIG_SCSI_UFS_QCOM=m
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=m
+CONFIG_LEDS_CLASS_MULTICOLOR=m
+CONFIG_LEDS_GPIO=m
+CONFIG_LEDS_QCOM_LPG=m
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_LEDS_TRIGGER_CPU=y
+CONFIG_LEDS_TRIGGER_DEFAULT_ON=y
+CONFIG_LEDS_TRIGGER_PANIC=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_PM8XXX=m
+CONFIG_DMADEVICES=y
+CONFIG_UDMABUF=y
+# CONFIG_VIRTIO_MENU is not set
+# CONFIG_VHOST_MENU is not set
+# CONFIG_SURFACE_PLATFORMS is not set
+CONFIG_COMMON_CLK_QCOM=y
+CONFIG_CLK_X1E80100_CAMCC=y
+CONFIG_CLK_X1E80100_DISPCC=m
+CONFIG_CLK_X1E80100_GPUCC=m
+CONFIG_CLK_X1E80100_TCSRCC=m
+CONFIG_QCOM_CLK_RPMH=y
+CONFIG_SC_CAMCC_8280XP=m
+CONFIG_SC_DISPCC_8280XP=m
+CONFIG_SC_GCC_8280XP=y
+CONFIG_SC_GPUCC_8280XP=m
+CONFIG_SC_LPASSCC_8280XP=m
+CONFIG_SM_VIDEOCC_8350=m
+CONFIG_HWSPINLOCK=y
+CONFIG_HWSPINLOCK_QCOM=y
+# CONFIG_FSL_ERRATUM_A008585 is not set
+# CONFIG_HISILICON_ERRATUM_161010101 is not set
+CONFIG_MAILBOX=y
+CONFIG_QCOM_CPUCP_MBOX=m
+CONFIG_QCOM_IPCC=y
+CONFIG_ARM_SMMU=y
+CONFIG_ARM_SMMU_V3=y
+CONFIG_QCOM_IOMMU=y
+CONFIG_REMOTEPROC=y
+CONFIG_QCOM_Q6V5_ADSP=m
+CONFIG_QCOM_Q6V5_PAS=m
+CONFIG_QCOM_SYSMON=m
+CONFIG_RPMSG_CHAR=m
+CONFIG_RPMSG_CTRL=m
+CONFIG_RPMSG_QCOM_GLINK_SMEM=m
+CONFIG_SOUNDWIRE=m
+CONFIG_SOUNDWIRE_QCOM=m
+CONFIG_QCOM_AOSS_QMP=y
+CONFIG_QCOM_COMMAND_DB=y
+CONFIG_QCOM_GENI_SE=y
+CONFIG_QCOM_LLCC=m
+CONFIG_QCOM_PMIC_GLINK=m
+CONFIG_QCOM_RPMH=y
+CONFIG_QCOM_SMEM=y
+CONFIG_QCOM_SMP2P=y
+CONFIG_QCOM_SOCINFO=m
+CONFIG_QCOM_STATS=m
+CONFIG_QCOM_APR=m
+CONFIG_QCOM_ICC_BWMON=m
+CONFIG_QCOM_RPMHPD=y
+CONFIG_IIO=m
+CONFIG_QCOM_SPMI_ADC5=m
+CONFIG_PWM=y
+CONFIG_QCOM_PDC=y
+CONFIG_RESET_GPIO=m
+CONFIG_RESET_QCOM_AOSS=y
+CONFIG_RESET_QCOM_PDC=m
+CONFIG_PHY_SNPS_EUSB2=m
+CONFIG_PHY_NXP_PTN3222=m
+CONFIG_PHY_QCOM_EDP=m
+CONFIG_PHY_QCOM_QMP=m
+# CONFIG_PHY_QCOM_QMP_PCIE_8996 is not set
+CONFIG_PHY_QCOM_EUSB2_REPEATER=m
+CONFIG_PHY_QCOM_USB_SNPS_FEMTO_V2=m
+CONFIG_NVMEM_QCOM_QFPROM=y
+CONFIG_NVMEM_SPMI_SDAM=m
+CONFIG_MUX_GPIO=m
+# CONFIG_SLIMBUS is not set
+CONFIG_INTERCONNECT_QCOM=y
+CONFIG_INTERCONNECT_QCOM_OSM_L3=m
+CONFIG_INTERCONNECT_QCOM_SC8280XP=y
+CONFIG_INTERCONNECT_QCOM_X1E80100=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_FANOTIFY=y
+CONFIG_QUOTA=y
+CONFIG_AUTOFS_FS=m
+CONFIG_FUSE_FS=m
+CONFIG_OVERLAY_FS=m
+CONFIG_VFAT_FS=y
+CONFIG_NTFS_FS=m
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_HUGETLBFS=y
+CONFIG_CONFIGFS_FS=y
+CONFIG_EFIVAR_FS=y
+# CONFIG_NETWORK_FILESYSTEMS is not set
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_SECURITY=y
+CONFIG_SECURITY_LANDLOCK=y
+# CONFIG_INTEGRITY is not set
+CONFIG_LSM="landlock,lockdown,yama,loadpin,safesetid,integrity,bpf"
+CONFIG_CRYPTO_NULL=y
+CONFIG_CRYPTO_DES=m
+CONFIG_CRYPTO_SHA256=y
+CONFIG_CRYPTO_CRC32C=y
+CONFIG_CRYPTO_ANSI_CPRNG=y
+CONFIG_CRYPTO_DRBG_MENU=y
+CONFIG_CRYPTO_USER_API_HASH=m
+CONFIG_CRYPTO_USER_API_SKCIPHER=m
+CONFIG_CRYPTO_GHASH_ARM64_CE=y
+CONFIG_CRYPTO_SHA1_ARM64_CE=y
+CONFIG_CRYPTO_SHA512_ARM64_CE=m
+CONFIG_CRYPTO_SHA3_ARM64=m
+CONFIG_CRYPTO_SM3_ARM64_CE=m
+CONFIG_CRYPTO_AES_ARM64_BS=m
+CONFIG_CRYPTO_AES_ARM64_CE_CCM=y
+CONFIG_CRYPTO_DEV_QCOM_RNG=m
+CONFIG_CRYPTO_DEV_CCREE=m
+CONFIG_DMA_CMA=y
+CONFIG_CMA_SIZE_MBYTES=128
+CONFIG_PRINTK_TIME=y
+CONFIG_DYNAMIC_DEBUG=y
+CONFIG_DEBUG_KERNEL=y
+CONFIG_DEBUG_FS=y
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_FTRACE is not set
+# CONFIG_RUNTIME_TESTING_MENU is not set
diff -Nrup linux-6.16.6/arch/arm64/tools/syscall_64.tbl linux-lenovo-x13s-linux-6.16.y/arch/arm64/tools/syscall_64.tbl
--- linux-6.16.6/arch/arm64/tools/syscall_64.tbl	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/arm64/tools/syscall_64.tbl	2025-09-11 09:47:42.000000000 -0600
@@ -1,410 +1 @@
-# SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note
-#
-# This file contains the system call numbers for all of the
-# more recently added architectures.
-#
-# As a basic principle, no duplication of functionality
-# should be added, e.g. we don't use lseek when llseek
-# is present. New architectures should use this file
-# and implement the less feature-full calls in user space.
-#
-0	common	io_setup			sys_io_setup			compat_sys_io_setup
-1	common	io_destroy			sys_io_destroy
-2	common	io_submit			sys_io_submit			compat_sys_io_submit
-3	common	io_cancel			sys_io_cancel
-4	time32	io_getevents			sys_io_getevents_time32
-4	64	io_getevents			sys_io_getevents
-5	common	setxattr			sys_setxattr
-6	common	lsetxattr			sys_lsetxattr
-7	common	fsetxattr			sys_fsetxattr
-8	common	getxattr			sys_getxattr
-9	common	lgetxattr			sys_lgetxattr
-10	common	fgetxattr			sys_fgetxattr
-11	common	listxattr			sys_listxattr
-12	common	llistxattr			sys_llistxattr
-13	common	flistxattr			sys_flistxattr
-14	common	removexattr			sys_removexattr
-15	common	lremovexattr			sys_lremovexattr
-16	common	fremovexattr			sys_fremovexattr
-17	common	getcwd				sys_getcwd
-18	common	lookup_dcookie			sys_ni_syscall
-19	common	eventfd2			sys_eventfd2
-20	common	epoll_create1			sys_epoll_create1
-21	common	epoll_ctl			sys_epoll_ctl
-22	common	epoll_pwait			sys_epoll_pwait			compat_sys_epoll_pwait
-23	common	dup				sys_dup
-24	common	dup3				sys_dup3
-25	32	fcntl64				sys_fcntl64			compat_sys_fcntl64
-25	64	fcntl				sys_fcntl
-26	common	inotify_init1			sys_inotify_init1
-27	common	inotify_add_watch		sys_inotify_add_watch
-28	common	inotify_rm_watch		sys_inotify_rm_watch
-29	common	ioctl				sys_ioctl			compat_sys_ioctl
-30	common	ioprio_set			sys_ioprio_set
-31	common	ioprio_get			sys_ioprio_get
-32	common	flock				sys_flock
-33	common	mknodat				sys_mknodat
-34	common	mkdirat				sys_mkdirat
-35	common	unlinkat			sys_unlinkat
-36	common	symlinkat			sys_symlinkat
-37	common	linkat				sys_linkat
-# renameat is superseded with flags by renameat2
-38	renameat renameat			sys_renameat
-39	common	umount2				sys_umount
-40	common	mount				sys_mount
-41	common	pivot_root			sys_pivot_root
-42	common	nfsservctl			sys_ni_syscall
-43	32	statfs64			sys_statfs64			compat_sys_statfs64
-43	64	statfs				sys_statfs
-44	32	fstatfs64			sys_fstatfs64			compat_sys_fstatfs64
-44	64	fstatfs				sys_fstatfs
-45	32	truncate64			sys_truncate64			compat_sys_truncate64
-45	64	truncate			sys_truncate
-46	32	ftruncate64			sys_ftruncate64			compat_sys_ftruncate64
-46	64	ftruncate			sys_ftruncate
-47	common	fallocate			sys_fallocate			compat_sys_fallocate
-48	common	faccessat			sys_faccessat
-49	common	chdir				sys_chdir
-50	common	fchdir				sys_fchdir
-51	common	chroot				sys_chroot
-52	common	fchmod				sys_fchmod
-53	common	fchmodat			sys_fchmodat
-54	common	fchownat			sys_fchownat
-55	common	fchown				sys_fchown
-56	common	openat				sys_openat
-57	common	close				sys_close
-58	common	vhangup				sys_vhangup
-59	common	pipe2				sys_pipe2
-60	common	quotactl			sys_quotactl
-61	common	getdents64			sys_getdents64
-62	32	llseek				sys_llseek
-62	64	lseek				sys_lseek
-63	common	read				sys_read
-64	common	write				sys_write
-65	common	readv				sys_readv			sys_readv
-66	common	writev				sys_writev			sys_writev
-67	common	pread64				sys_pread64			compat_sys_pread64
-68	common	pwrite64			sys_pwrite64			compat_sys_pwrite64
-69	common	preadv				sys_preadv			compat_sys_preadv
-70	common	pwritev				sys_pwritev			compat_sys_pwritev
-71	32	sendfile64			sys_sendfile64
-71	64	sendfile			sys_sendfile64
-72	time32	pselect6			sys_pselect6_time32		compat_sys_pselect6_time32
-72	64	pselect6			sys_pselect6
-73	time32	ppoll				sys_ppoll_time32		compat_sys_ppoll_time32
-73	64	ppoll				sys_ppoll
-74	common	signalfd4			sys_signalfd4			compat_sys_signalfd4
-75	common	vmsplice			sys_vmsplice
-76	common	splice				sys_splice
-77	common	tee				sys_tee
-78	common	readlinkat			sys_readlinkat
-79	stat64	fstatat64			sys_fstatat64
-79	64	newfstatat			sys_newfstatat
-80	stat64	fstat64				sys_fstat64
-80	64	fstat				sys_newfstat
-81	common	sync				sys_sync
-82	common	fsync				sys_fsync
-83	common	fdatasync			sys_fdatasync
-84	common	sync_file_range			sys_sync_file_range		compat_sys_sync_file_range
-85	common	timerfd_create			sys_timerfd_create
-86	time32	timerfd_settime			sys_timerfd_settime32
-86	64	timerfd_settime			sys_timerfd_settime
-87	time32	timerfd_gettime			sys_timerfd_gettime32
-87	64	timerfd_gettime			sys_timerfd_gettime
-88	time32	utimensat			sys_utimensat_time32
-88	64	utimensat			sys_utimensat
-89	common	acct				sys_acct
-90	common	capget				sys_capget
-91	common	capset				sys_capset
-92	common	personality			sys_personality
-93	common	exit				sys_exit
-94	common	exit_group			sys_exit_group
-95	common	waitid				sys_waitid			compat_sys_waitid
-96	common	set_tid_address			sys_set_tid_address
-97	common	unshare				sys_unshare
-98	time32	futex				sys_futex_time32
-98	64	futex				sys_futex
-99	common	set_robust_list			sys_set_robust_list		compat_sys_set_robust_list
-100	common	get_robust_list			sys_get_robust_list		compat_sys_get_robust_list
-101	time32	nanosleep			sys_nanosleep_time32
-101	64	nanosleep			sys_nanosleep
-102	common	getitimer			sys_getitimer			compat_sys_getitimer
-103	common	setitimer			sys_setitimer			compat_sys_setitimer
-104	common	kexec_load			sys_kexec_load			compat_sys_kexec_load
-105	common	init_module			sys_init_module
-106	common	delete_module			sys_delete_module
-107	common	timer_create			sys_timer_create		compat_sys_timer_create
-108	time32	timer_gettime			sys_timer_gettime32
-108	64	timer_gettime			sys_timer_gettime
-109	common	timer_getoverrun		sys_timer_getoverrun
-110	time32	timer_settime			sys_timer_settime32
-110	64	timer_settime			sys_timer_settime
-111	common	timer_delete			sys_timer_delete
-112	time32	clock_settime			sys_clock_settime32
-112	64	clock_settime			sys_clock_settime
-113	time32	clock_gettime			sys_clock_gettime32
-113	64	clock_gettime			sys_clock_gettime
-114	time32	clock_getres			sys_clock_getres_time32
-114	64	clock_getres			sys_clock_getres
-115	time32	clock_nanosleep			sys_clock_nanosleep_time32
-115	64	clock_nanosleep			sys_clock_nanosleep
-116	common	syslog				sys_syslog
-117	common	ptrace				sys_ptrace			compat_sys_ptrace
-118	common	sched_setparam			sys_sched_setparam
-119	common	sched_setscheduler		sys_sched_setscheduler
-120	common	sched_getscheduler		sys_sched_getscheduler
-121	common	sched_getparam			sys_sched_getparam
-122	common	sched_setaffinity		sys_sched_setaffinity		compat_sys_sched_setaffinity
-123	common	sched_getaffinity		sys_sched_getaffinity		compat_sys_sched_getaffinity
-124	common	sched_yield			sys_sched_yield
-125	common	sched_get_priority_max		sys_sched_get_priority_max
-126	common	sched_get_priority_min		sys_sched_get_priority_min
-127	time32	sched_rr_get_interval		sys_sched_rr_get_interval_time32
-127	64	sched_rr_get_interval		sys_sched_rr_get_interval
-128	common	restart_syscall			sys_restart_syscall
-129	common	kill				sys_kill
-130	common	tkill				sys_tkill
-131	common	tgkill				sys_tgkill
-132	common	sigaltstack			sys_sigaltstack			compat_sys_sigaltstack
-133	common	rt_sigsuspend			sys_rt_sigsuspend		compat_sys_rt_sigsuspend
-134	common	rt_sigaction			sys_rt_sigaction		compat_sys_rt_sigaction
-135	common	rt_sigprocmask			sys_rt_sigprocmask		compat_sys_rt_sigprocmask
-136	common	rt_sigpending			sys_rt_sigpending		compat_sys_rt_sigpending
-137	time32	rt_sigtimedwait			sys_rt_sigtimedwait_time32	compat_sys_rt_sigtimedwait_time32
-137	64	rt_sigtimedwait			sys_rt_sigtimedwait
-138	common	rt_sigqueueinfo			sys_rt_sigqueueinfo		compat_sys_rt_sigqueueinfo
-139	common	rt_sigreturn			sys_rt_sigreturn		compat_sys_rt_sigreturn
-140	common	setpriority			sys_setpriority
-141	common	getpriority			sys_getpriority
-142	common	reboot				sys_reboot
-143	common	setregid			sys_setregid
-144	common	setgid				sys_setgid
-145	common	setreuid			sys_setreuid
-146	common	setuid				sys_setuid
-147	common	setresuid			sys_setresuid
-148	common	getresuid			sys_getresuid
-149	common	setresgid			sys_setresgid
-150	common	getresgid			sys_getresgid
-151	common	setfsuid			sys_setfsuid
-152	common	setfsgid			sys_setfsgid
-153	common	times				sys_times			compat_sys_times
-154	common	setpgid				sys_setpgid
-155	common	getpgid				sys_getpgid
-156	common	getsid				sys_getsid
-157	common	setsid				sys_setsid
-158	common	getgroups			sys_getgroups
-159	common	setgroups			sys_setgroups
-160	common	uname				sys_newuname
-161	common	sethostname			sys_sethostname
-162	common	setdomainname			sys_setdomainname
-# getrlimit and setrlimit are superseded with prlimit64
-163	rlimit	getrlimit			sys_getrlimit			compat_sys_getrlimit
-164	rlimit	setrlimit			sys_setrlimit			compat_sys_setrlimit
-165	common	getrusage			sys_getrusage			compat_sys_getrusage
-166	common	umask				sys_umask
-167	common	prctl				sys_prctl
-168	common	getcpu				sys_getcpu
-169	time32	gettimeofday			sys_gettimeofday		compat_sys_gettimeofday
-169	64	gettimeofday			sys_gettimeofday
-170	time32	settimeofday			sys_settimeofday		compat_sys_settimeofday
-170	64	settimeofday			sys_settimeofday
-171	time32	adjtimex			sys_adjtimex_time32
-171	64	adjtimex			sys_adjtimex
-172	common	getpid				sys_getpid
-173	common	getppid				sys_getppid
-174	common	getuid				sys_getuid
-175	common	geteuid				sys_geteuid
-176	common	getgid				sys_getgid
-177	common	getegid				sys_getegid
-178	common	gettid				sys_gettid
-179	common	sysinfo				sys_sysinfo			compat_sys_sysinfo
-180	common	mq_open				sys_mq_open			compat_sys_mq_open
-181	common	mq_unlink			sys_mq_unlink
-182	time32	mq_timedsend			sys_mq_timedsend_time32
-182	64	mq_timedsend			sys_mq_timedsend
-183	time32	mq_timedreceive			sys_mq_timedreceive_time32
-183	64	mq_timedreceive			sys_mq_timedreceive
-184	common	mq_notify			sys_mq_notify			compat_sys_mq_notify
-185	common	mq_getsetattr			sys_mq_getsetattr		compat_sys_mq_getsetattr
-186	common	msgget				sys_msgget
-187	common	msgctl				sys_msgctl			compat_sys_msgctl
-188	common	msgrcv				sys_msgrcv			compat_sys_msgrcv
-189	common	msgsnd				sys_msgsnd			compat_sys_msgsnd
-190	common	semget				sys_semget
-191	common	semctl				sys_semctl			compat_sys_semctl
-192	time32	semtimedop			sys_semtimedop_time32
-192	64	semtimedop			sys_semtimedop
-193	common	semop				sys_semop
-194	common	shmget				sys_shmget
-195	common	shmctl				sys_shmctl			compat_sys_shmctl
-196	common	shmat				sys_shmat			compat_sys_shmat
-197	common	shmdt				sys_shmdt
-198	common	socket				sys_socket
-199	common	socketpair			sys_socketpair
-200	common	bind				sys_bind
-201	common	listen				sys_listen
-202	common	accept				sys_accept
-203	common	connect				sys_connect
-204	common	getsockname			sys_getsockname
-205	common	getpeername			sys_getpeername
-206	common	sendto				sys_sendto
-207	common	recvfrom			sys_recvfrom			compat_sys_recvfrom
-208	common	setsockopt			sys_setsockopt			sys_setsockopt
-209	common	getsockopt			sys_getsockopt			sys_getsockopt
-210	common	shutdown			sys_shutdown
-211	common	sendmsg				sys_sendmsg			compat_sys_sendmsg
-212	common	recvmsg				sys_recvmsg			compat_sys_recvmsg
-213	common	readahead			sys_readahead			compat_sys_readahead
-214	common	brk				sys_brk
-215	common	munmap				sys_munmap
-216	common	mremap				sys_mremap
-217	common	add_key				sys_add_key
-218	common	request_key			sys_request_key
-219	common	keyctl				sys_keyctl			compat_sys_keyctl
-220	common	clone				sys_clone
-221	common	execve				sys_execve			compat_sys_execve
-222	32	mmap2				sys_mmap2
-222	64	mmap				sys_mmap
-223	32	fadvise64_64			sys_fadvise64_64		compat_sys_fadvise64_64
-223	64	fadvise64			sys_fadvise64_64
-224	common	swapon				sys_swapon
-225	common	swapoff				sys_swapoff
-226	common	mprotect			sys_mprotect
-227	common	msync				sys_msync
-228	common	mlock				sys_mlock
-229	common	munlock				sys_munlock
-230	common	mlockall			sys_mlockall
-231	common	munlockall			sys_munlockall
-232	common	mincore				sys_mincore
-233	common	madvise				sys_madvise
-234	common	remap_file_pages		sys_remap_file_pages
-235	common	mbind				sys_mbind
-236	common	get_mempolicy			sys_get_mempolicy
-237	common	set_mempolicy			sys_set_mempolicy
-238	common	migrate_pages			sys_migrate_pages
-239	common	move_pages			sys_move_pages
-240	common	rt_tgsigqueueinfo		sys_rt_tgsigqueueinfo		compat_sys_rt_tgsigqueueinfo
-241	common	perf_event_open			sys_perf_event_open
-242	common	accept4				sys_accept4
-243	time32	recvmmsg			sys_recvmmsg_time32		compat_sys_recvmmsg_time32
-243	64	recvmmsg			sys_recvmmsg
-# Architectures may provide up to 16 syscalls of their own between 244 and 259
-244	arc	cacheflush			sys_cacheflush
-245	arc	arc_settls			sys_arc_settls
-246	arc	arc_gettls			sys_arc_gettls
-247	arc	sysfs				sys_sysfs
-248	arc	arc_usr_cmpxchg			sys_arc_usr_cmpxchg
-
-244	csky	set_thread_area			sys_set_thread_area
-245	csky	cacheflush			sys_cacheflush
-
-244	nios2	cacheflush			sys_cacheflush
-
-244	or1k	or1k_atomic			sys_or1k_atomic
-
-258	riscv	riscv_hwprobe			sys_riscv_hwprobe
-259	riscv	riscv_flush_icache		sys_riscv_flush_icache
-
-260	time32	wait4				sys_wait4			compat_sys_wait4
-260	64	wait4				sys_wait4
-261	common	prlimit64			sys_prlimit64
-262	common	fanotify_init			sys_fanotify_init
-263	common	fanotify_mark			sys_fanotify_mark
-264	common	name_to_handle_at		sys_name_to_handle_at
-265	common	open_by_handle_at		sys_open_by_handle_at
-266	time32	clock_adjtime			sys_clock_adjtime32
-266	64	clock_adjtime			sys_clock_adjtime
-267	common	syncfs				sys_syncfs
-268	common	setns				sys_setns
-269	common	sendmmsg			sys_sendmmsg			compat_sys_sendmmsg
-270	common	process_vm_readv		sys_process_vm_readv
-271	common	process_vm_writev		sys_process_vm_writev
-272	common	kcmp				sys_kcmp
-273	common	finit_module			sys_finit_module
-274	common	sched_setattr			sys_sched_setattr
-275	common	sched_getattr			sys_sched_getattr
-276	common	renameat2			sys_renameat2
-277	common	seccomp				sys_seccomp
-278	common	getrandom			sys_getrandom
-279	common	memfd_create			sys_memfd_create
-280	common	bpf				sys_bpf
-281	common	execveat			sys_execveat			compat_sys_execveat
-282	common	userfaultfd			sys_userfaultfd
-283	common	membarrier			sys_membarrier
-284	common	mlock2				sys_mlock2
-285	common	copy_file_range			sys_copy_file_range
-286	common	preadv2				sys_preadv2			compat_sys_preadv2
-287	common	pwritev2			sys_pwritev2			compat_sys_pwritev2
-288	common	pkey_mprotect			sys_pkey_mprotect
-289	common	pkey_alloc			sys_pkey_alloc
-290	common	pkey_free			sys_pkey_free
-291	common	statx				sys_statx
-292	time32	io_pgetevents			sys_io_pgetevents_time32	compat_sys_io_pgetevents
-292	64	io_pgetevents			sys_io_pgetevents
-293	common	rseq				sys_rseq
-294	common	kexec_file_load			sys_kexec_file_load
-# 295 through 402 are unassigned to sync up with generic numbers don't use
-403	32	clock_gettime64			sys_clock_gettime
-404	32	clock_settime64			sys_clock_settime
-405	32	clock_adjtime64			sys_clock_adjtime
-406	32	clock_getres_time64		sys_clock_getres
-407	32	clock_nanosleep_time64		sys_clock_nanosleep
-408	32	timer_gettime64			sys_timer_gettime
-409	32	timer_settime64			sys_timer_settime
-410	32	timerfd_gettime64		sys_timerfd_gettime
-411	32	timerfd_settime64		sys_timerfd_settime
-412	32	utimensat_time64		sys_utimensat
-413	32	pselect6_time64			sys_pselect6			compat_sys_pselect6_time64
-414	32	ppoll_time64			sys_ppoll			compat_sys_ppoll_time64
-416	32	io_pgetevents_time64		sys_io_pgetevents		compat_sys_io_pgetevents_time64
-417	32	recvmmsg_time64			sys_recvmmsg			compat_sys_recvmmsg_time64
-418	32	mq_timedsend_time64		sys_mq_timedsend
-419	32	mq_timedreceive_time64		sys_mq_timedreceive
-420	32	semtimedop_time64		sys_semtimedop
-421	32	rt_sigtimedwait_time64		sys_rt_sigtimedwait		compat_sys_rt_sigtimedwait_time64
-422	32	futex_time64			sys_futex
-423	32	sched_rr_get_interval_time64	sys_sched_rr_get_interval
-424	common	pidfd_send_signal		sys_pidfd_send_signal
-425	common	io_uring_setup			sys_io_uring_setup
-426	common	io_uring_enter			sys_io_uring_enter
-427	common	io_uring_register		sys_io_uring_register
-428	common	open_tree			sys_open_tree
-429	common	move_mount			sys_move_mount
-430	common	fsopen				sys_fsopen
-431	common	fsconfig			sys_fsconfig
-432	common	fsmount				sys_fsmount
-433	common	fspick				sys_fspick
-434	common	pidfd_open			sys_pidfd_open
-435	common	clone3				sys_clone3
-436	common	close_range			sys_close_range
-437	common	openat2				sys_openat2
-438	common	pidfd_getfd			sys_pidfd_getfd
-439	common	faccessat2			sys_faccessat2
-440	common	process_madvise			sys_process_madvise
-441	common	epoll_pwait2			sys_epoll_pwait2		compat_sys_epoll_pwait2
-442	common	mount_setattr			sys_mount_setattr
-443	common	quotactl_fd			sys_quotactl_fd
-444	common	landlock_create_ruleset		sys_landlock_create_ruleset
-445	common	landlock_add_rule		sys_landlock_add_rule
-446	common	landlock_restrict_self		sys_landlock_restrict_self
-447	memfd_secret	memfd_secret		sys_memfd_secret
-448	common	process_mrelease		sys_process_mrelease
-449	common	futex_waitv			sys_futex_waitv
-450	common	set_mempolicy_home_node		sys_set_mempolicy_home_node
-451	common	cachestat			sys_cachestat
-452	common	fchmodat2			sys_fchmodat2
-453	common	map_shadow_stack		sys_map_shadow_stack
-454	common	futex_wake			sys_futex_wake
-455	common	futex_wait			sys_futex_wait
-456	common	futex_requeue			sys_futex_requeue
-457	common	statmount			sys_statmount
-458	common	listmount			sys_listmount
-459	common	lsm_get_self_attr		sys_lsm_get_self_attr
-460	common	lsm_set_self_attr		sys_lsm_set_self_attr
-461	common	lsm_list_modules		sys_lsm_list_modules
-462	common	mseal				sys_mseal
-463	common	setxattrat			sys_setxattrat
-464	common	getxattrat			sys_getxattrat
-465	common	listxattrat			sys_listxattrat
-466	common	removexattrat			sys_removexattrat
-467	common	open_tree_attr			sys_open_tree_attr
+../../../scripts/syscall.tbl
\ No newline at end of file
diff -Nrup linux-6.16.6/arch/powerpc/configs/kvm_guest.config linux-lenovo-x13s-linux-6.16.y/arch/powerpc/configs/kvm_guest.config
--- linux-6.16.6/arch/powerpc/configs/kvm_guest.config	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/arch/powerpc/configs/kvm_guest.config	2025-09-11 09:47:42.000000000 -0600
@@ -1,35 +1 @@
-# Help: Bootable as a KVM guest
-CONFIG_NET=y
-CONFIG_NET_CORE=y
-CONFIG_NETDEVICES=y
-CONFIG_BLOCK=y
-CONFIG_BLK_DEV=y
-CONFIG_NETWORK_FILESYSTEMS=y
-CONFIG_INET=y
-CONFIG_TTY=y
-CONFIG_SERIAL_8250=y
-CONFIG_SERIAL_8250_CONSOLE=y
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-CONFIG_BINFMT_ELF=y
-CONFIG_PCI=y
-CONFIG_PCI_MSI=y
-CONFIG_DEBUG_KERNEL=y
-CONFIG_VIRTUALIZATION=y
-CONFIG_HYPERVISOR_GUEST=y
-CONFIG_PARAVIRT=y
-CONFIG_KVM_GUEST=y
-CONFIG_S390_GUEST=y
-CONFIG_VIRTIO=y
-CONFIG_VIRTIO_MENU=y
-CONFIG_VIRTIO_PCI=y
-CONFIG_VIRTIO_BLK=y
-CONFIG_VIRTIO_CONSOLE=y
-CONFIG_VIRTIO_NET=y
-CONFIG_9P_FS=y
-CONFIG_NET_9P=y
-CONFIG_NET_9P_VIRTIO=y
-CONFIG_SCSI_LOWLEVEL=y
-CONFIG_SCSI_VIRTIO=y
-CONFIG_VIRTIO_INPUT=y
-CONFIG_DRM_VIRTIO_GPU=y
+../../../kernel/configs/kvm_guest.config
\ No newline at end of file
diff -Nrup linux-6.16.6/Documentation/Changes linux-lenovo-x13s-linux-6.16.y/Documentation/Changes
--- linux-6.16.6/Documentation/Changes	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/Documentation/Changes	2025-09-11 09:47:42.000000000 -0600
@@ -1,575 +1 @@
-.. _changes:
-
-Minimal requirements to compile the Kernel
-++++++++++++++++++++++++++++++++++++++++++
-
-Intro
-=====
-
-This document is designed to provide a list of the minimum levels of
-software necessary to run the current kernel version.
-
-This document is originally based on my "Changes" file for 2.0.x kernels
-and therefore owes credit to the same people as that file (Jared Mauch,
-Axel Boldt, Alessandro Sigala, and countless other users all over the
-'net).
-
-Current Minimal Requirements
-****************************
-
-Upgrade to at **least** these software revisions before thinking you've
-encountered a bug!  If you're unsure what version you're currently
-running, the suggested command should tell you.
-
-Again, keep in mind that this list assumes you are already functionally
-running a Linux kernel.  Also, not all tools are necessary on all
-systems; obviously, if you don't have any PC Card hardware, for example,
-you probably needn't concern yourself with pcmciautils.
-
-====================== ===============  ========================================
-        Program        Minimal version       Command to check the version
-====================== ===============  ========================================
-GNU C                  8.1              gcc --version
-Clang/LLVM (optional)  13.0.1           clang --version
-Rust (optional)        1.78.0           rustc --version
-bindgen (optional)     0.65.1           bindgen --version
-GNU make               4.0              make --version
-bash                   4.2              bash --version
-binutils               2.30             ld -v
-flex                   2.5.35           flex --version
-bison                  2.0              bison --version
-pahole                 1.16             pahole --version
-util-linux             2.10o            mount --version
-kmod                   13               depmod -V
-e2fsprogs              1.41.4           e2fsck -V
-jfsutils               1.1.3            fsck.jfs -V
-reiserfsprogs          3.6.3            reiserfsck -V
-xfsprogs               2.6.0            xfs_db -V
-squashfs-tools         4.0              mksquashfs -version
-btrfs-progs            0.18             btrfs --version
-pcmciautils            004              pccardctl -V
-quota-tools            3.09             quota -V
-PPP                    2.4.0            pppd --version
-nfs-utils              1.0.5            showmount --version
-procps                 3.2.0            ps --version
-udev                   081              udevd --version
-grub                   0.93             grub --version || grub-install --version
-mcelog                 0.6              mcelog --version
-iptables               1.4.2            iptables -V
-openssl & libcrypto    1.0.0            openssl version
-bc                     1.06.95          bc --version
-Sphinx\ [#f1]_         3.4.3            sphinx-build --version
-GNU tar                1.28             tar --version
-gtags (optional)       6.6.5            gtags --version
-mkimage (optional)     2017.01          mkimage --version
-Python (optional)      3.9.x            python3 --version
-GNU AWK (optional)     5.1.0            gawk --version
-====================== ===============  ========================================
-
-.. [#f1] Sphinx is needed only to build the Kernel documentation
-
-Kernel compilation
-******************
-
-GCC
----
-
-The gcc version requirements may vary depending on the type of CPU in your
-computer.
-
-Clang/LLVM (optional)
----------------------
-
-The latest formal release of clang and LLVM utils (according to
-`releases.llvm.org <https://releases.llvm.org>`_) are supported for building
-kernels. Older releases aren't guaranteed to work, and we may drop workarounds
-from the kernel that were used to support older versions. Please see additional
-docs on :ref:`Building Linux with Clang/LLVM <kbuild_llvm>`.
-
-Rust (optional)
----------------
-
-A recent version of the Rust compiler is required.
-
-Please see Documentation/rust/quick-start.rst for instructions on how to
-satisfy the build requirements of Rust support. In particular, the ``Makefile``
-target ``rustavailable`` is useful to check why the Rust toolchain may not
-be detected.
-
-bindgen (optional)
-------------------
-
-``bindgen`` is used to generate the Rust bindings to the C side of the kernel.
-It depends on ``libclang``.
-
-Make
-----
-
-You will need GNU make 4.0 or later to build the kernel.
-
-Bash
-----
-
-Some bash scripts are used for the kernel build.
-Bash 4.2 or newer is needed.
-
-Binutils
---------
-
-Binutils 2.30 or newer is needed to build the kernel.
-
-pkg-config
-----------
-
-The build system, as of 4.18, requires pkg-config to check for installed
-kconfig tools and to determine flags settings for use in
-'make {g,x}config'.  Previously pkg-config was being used but not
-verified or documented.
-
-Flex
-----
-
-Since Linux 4.16, the build system generates lexical analyzers
-during build.  This requires flex 2.5.35 or later.
-
-
-Bison
------
-
-Since Linux 4.16, the build system generates parsers
-during build.  This requires bison 2.0 or later.
-
-pahole
-------
-
-Since Linux 5.2, if CONFIG_DEBUG_INFO_BTF is selected, the build system
-generates BTF (BPF Type Format) from DWARF in vmlinux, a bit later from kernel
-modules as well.  This requires pahole v1.16 or later.
-
-It is found in the 'dwarves' or 'pahole' distro packages or from
-https://fedorapeople.org/~acme/dwarves/.
-
-Perl
-----
-
-You will need perl 5 and the following modules: ``Getopt::Long``,
-``Getopt::Std``, ``File::Basename``, and ``File::Find`` to build the kernel.
-
-BC
---
-
-You will need bc to build kernels 3.10 and higher
-
-
-OpenSSL
--------
-
-Module signing and external certificate handling use the OpenSSL program and
-crypto library to do key creation and signature generation.
-
-You will need openssl to build kernels 3.7 and higher if module signing is
-enabled.  You will also need openssl development packages to build kernels 4.3
-and higher.
-
-Tar
----
-
-GNU tar is needed if you want to enable access to the kernel headers via sysfs
-(CONFIG_IKHEADERS).
-
-gtags / GNU GLOBAL (optional)
------------------------------
-
-The kernel build requires GNU GLOBAL version 6.6.5 or later to generate
-tag files through ``make gtags``.  This is due to its use of the gtags
-``-C (--directory)`` flag.
-
-mkimage
--------
-
-This tool is used when building a Flat Image Tree (FIT), commonly used on ARM
-platforms. The tool is available via the ``u-boot-tools`` package or can be
-built from the U-Boot source code. See the instructions at
-https://docs.u-boot.org/en/latest/build/tools.html#building-tools-for-linux
-
-GNU AWK
--------
-
-GNU AWK is needed if you want kernel builds to generate address range data for
-builtin modules (CONFIG_BUILTIN_MODULE_RANGES).
-
-System utilities
-****************
-
-Architectural changes
----------------------
-
-DevFS has been obsoleted in favour of udev
-(https://www.kernel.org/pub/linux/utils/kernel/hotplug/)
-
-32-bit UID support is now in place.  Have fun!
-
-Linux documentation for functions is transitioning to inline
-documentation via specially-formatted comments near their
-definitions in the source.  These comments can be combined with ReST
-files the Documentation/ directory to make enriched documentation, which can
-then be converted to PostScript, HTML, LaTex, ePUB and PDF files.
-In order to convert from ReST format to a format of your choice, you'll need
-Sphinx.
-
-Util-linux
-----------
-
-New versions of util-linux provide ``fdisk`` support for larger disks,
-support new options to mount, recognize more supported partition
-types, and similar goodies.
-You'll probably want to upgrade.
-
-Ksymoops
---------
-
-If the unthinkable happens and your kernel oopses, you may need the
-ksymoops tool to decode it, but in most cases you don't.
-It is generally preferred to build the kernel with ``CONFIG_KALLSYMS`` so
-that it produces readable dumps that can be used as-is (this also
-produces better output than ksymoops).  If for some reason your kernel
-is not build with ``CONFIG_KALLSYMS`` and you have no way to rebuild and
-reproduce the Oops with that option, then you can still decode that Oops
-with ksymoops.
-
-Mkinitrd
---------
-
-These changes to the ``/lib/modules`` file tree layout also require that
-mkinitrd be upgraded.
-
-E2fsprogs
----------
-
-The latest version of ``e2fsprogs`` fixes several bugs in fsck and
-debugfs.  Obviously, it's a good idea to upgrade.
-
-JFSutils
---------
-
-The ``jfsutils`` package contains the utilities for the file system.
-The following utilities are available:
-
-- ``fsck.jfs`` - initiate replay of the transaction log, and check
-  and repair a JFS formatted partition.
-
-- ``mkfs.jfs`` - create a JFS formatted partition.
-
-- other file system utilities are also available in this package.
-
-Reiserfsprogs
--------------
-
-The reiserfsprogs package should be used for reiserfs-3.6.x
-(Linux kernels 2.4.x). It is a combined package and contains working
-versions of ``mkreiserfs``, ``resize_reiserfs``, ``debugreiserfs`` and
-``reiserfsck``. These utils work on both i386 and alpha platforms.
-
-Xfsprogs
---------
-
-The latest version of ``xfsprogs`` contains ``mkfs.xfs``, ``xfs_db``, and the
-``xfs_repair`` utilities, among others, for the XFS filesystem.  It is
-architecture independent and any version from 2.0.0 onward should
-work correctly with this version of the XFS kernel code (2.6.0 or
-later is recommended, due to some significant improvements).
-
-PCMCIAutils
------------
-
-PCMCIAutils replaces ``pcmcia-cs``. It properly sets up
-PCMCIA sockets at system startup and loads the appropriate modules
-for 16-bit PCMCIA devices if the kernel is modularized and the hotplug
-subsystem is used.
-
-Quota-tools
------------
-
-Support for 32 bit uid's and gid's is required if you want to use
-the newer version 2 quota format.  Quota-tools version 3.07 and
-newer has this support.  Use the recommended version or newer
-from the table above.
-
-Intel IA32 microcode
---------------------
-
-A driver has been added to allow updating of Intel IA32 microcode,
-accessible as a normal (misc) character device.  If you are not using
-udev you may need to::
-
-  mkdir /dev/cpu
-  mknod /dev/cpu/microcode c 10 184
-  chmod 0644 /dev/cpu/microcode
-
-as root before you can use this.  You'll probably also want to
-get the user-space microcode_ctl utility to use with this.
-
-udev
-----
-
-``udev`` is a userspace application for populating ``/dev`` dynamically with
-only entries for devices actually present. ``udev`` replaces the basic
-functionality of devfs, while allowing persistent device naming for
-devices.
-
-FUSE
-----
-
-Needs libfuse 2.4.0 or later.  Absolute minimum is 2.3.0 but mount
-options ``direct_io`` and ``kernel_cache`` won't work.
-
-Networking
-**********
-
-General changes
----------------
-
-If you have advanced network configuration needs, you should probably
-consider using the network tools from ip-route2.
-
-Packet Filter / NAT
--------------------
-The packet filtering and NAT code uses the same tools like the previous 2.4.x
-kernel series (iptables).  It still includes backwards-compatibility modules
-for 2.2.x-style ipchains and 2.0.x-style ipfwadm.
-
-PPP
----
-
-The PPP driver has been restructured to support multilink and to
-enable it to operate over diverse media layers.  If you use PPP,
-upgrade pppd to at least 2.4.0.
-
-If you are not using udev, you must have the device file /dev/ppp
-which can be made by::
-
-  mknod /dev/ppp c 108 0
-
-as root.
-
-NFS-utils
----------
-
-In ancient (2.4 and earlier) kernels, the nfs server needed to know
-about any client that expected to be able to access files via NFS.  This
-information would be given to the kernel by ``mountd`` when the client
-mounted the filesystem, or by ``exportfs`` at system startup.  exportfs
-would take information about active clients from ``/var/lib/nfs/rmtab``.
-
-This approach is quite fragile as it depends on rmtab being correct
-which is not always easy, particularly when trying to implement
-fail-over.  Even when the system is working well, ``rmtab`` suffers from
-getting lots of old entries that never get removed.
-
-With modern kernels we have the option of having the kernel tell mountd
-when it gets a request from an unknown host, and mountd can give
-appropriate export information to the kernel.  This removes the
-dependency on ``rmtab`` and means that the kernel only needs to know about
-currently active clients.
-
-To enable this new functionality, you need to::
-
-  mount -t nfsd nfsd /proc/fs/nfsd
-
-before running exportfs or mountd.  It is recommended that all NFS
-services be protected from the internet-at-large by a firewall where
-that is possible.
-
-mcelog
-------
-
-On x86 kernels the mcelog utility is needed to process and log machine check
-events when ``CONFIG_X86_MCE`` is enabled. Machine check events are errors
-reported by the CPU. Processing them is strongly encouraged.
-
-Kernel documentation
-********************
-
-Sphinx
-------
-
-Please see :ref:`sphinx_install` in :ref:`Documentation/doc-guide/sphinx.rst <sphinxdoc>`
-for details about Sphinx requirements.
-
-rustdoc
--------
-
-``rustdoc`` is used to generate the documentation for Rust code. Please see
-Documentation/rust/general-information.rst for more information.
-
-Getting updated software
-========================
-
-Kernel compilation
-******************
-
-gcc
----
-
-- <ftp://ftp.gnu.org/gnu/gcc/>
-
-Clang/LLVM
-----------
-
-- :ref:`Getting LLVM <getting_llvm>`.
-
-Rust
-----
-
-- Documentation/rust/quick-start.rst.
-
-bindgen
--------
-
-- Documentation/rust/quick-start.rst.
-
-Make
-----
-
-- <ftp://ftp.gnu.org/gnu/make/>
-
-Bash
-----
-
-- <ftp://ftp.gnu.org/gnu/bash/>
-
-Binutils
---------
-
-- <https://www.kernel.org/pub/linux/devel/binutils/>
-
-Flex
-----
-
-- <https://github.com/westes/flex/releases>
-
-Bison
------
-
-- <ftp://ftp.gnu.org/gnu/bison/>
-
-OpenSSL
--------
-
-- <https://www.openssl.org/>
-
-System utilities
-****************
-
-Util-linux
-----------
-
-- <https://www.kernel.org/pub/linux/utils/util-linux/>
-
-Kmod
-----
-
-- <https://www.kernel.org/pub/linux/utils/kernel/kmod/>
-- <https://git.kernel.org/pub/scm/utils/kernel/kmod/kmod.git>
-
-Ksymoops
---------
-
-- <https://www.kernel.org/pub/linux/utils/kernel/ksymoops/v2.4/>
-
-Mkinitrd
---------
-
-- <https://code.launchpad.net/initrd-tools/main>
-
-E2fsprogs
----------
-
-- <https://www.kernel.org/pub/linux/kernel/people/tytso/e2fsprogs/>
-- <https://git.kernel.org/pub/scm/fs/ext2/e2fsprogs.git/>
-
-JFSutils
---------
-
-- <https://jfs.sourceforge.net/>
-
-Reiserfsprogs
--------------
-
-- <https://git.kernel.org/pub/scm/linux/kernel/git/jeffm/reiserfsprogs.git/>
-
-Xfsprogs
---------
-
-- <https://git.kernel.org/pub/scm/fs/xfs/xfsprogs-dev.git>
-- <https://www.kernel.org/pub/linux/utils/fs/xfs/xfsprogs/>
-
-Pcmciautils
------------
-
-- <https://www.kernel.org/pub/linux/utils/kernel/pcmcia/>
-
-Quota-tools
------------
-
-- <https://sourceforge.net/projects/linuxquota/>
-
-
-Intel P6 microcode
-------------------
-
-- <https://downloadcenter.intel.com/>
-
-udev
-----
-
-- <https://www.freedesktop.org/software/systemd/man/udev.html>
-
-FUSE
-----
-
-- <https://github.com/libfuse/libfuse/releases>
-
-mcelog
-------
-
-- <https://www.mcelog.org/>
-
-Networking
-**********
-
-PPP
----
-
-- <https://download.samba.org/pub/ppp/>
-- <https://git.ozlabs.org/?p=ppp.git>
-- <https://github.com/paulusmack/ppp/>
-
-NFS-utils
----------
-
-- <https://sourceforge.net/project/showfiles.php?group_id=14>
-- <https://nfs.sourceforge.net/>
-
-Iptables
---------
-
-- <https://netfilter.org/projects/iptables/index.html>
-
-Ip-route2
----------
-
-- <https://www.kernel.org/pub/linux/utils/net/iproute2/>
-
-OProfile
---------
-
-- <https://oprofile.sf.net/download/>
-
-Kernel documentation
-********************
-
-Sphinx
-------
-
-- <https://www.sphinx-doc.org/>
+process/changes.rst
\ No newline at end of file
diff -Nrup linux-6.16.6/Documentation/devicetree/bindings/arm/psci.yaml linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/arm/psci.yaml
--- linux-6.16.6/Documentation/devicetree/bindings/arm/psci.yaml	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/arm/psci.yaml	2025-09-11 09:47:42.000000000 -0600
@@ -98,6 +98,12 @@ properties:
       [1] Kernel documentation - ARM idle states bindings
         Documentation/devicetree/bindings/cpu/idle-states.yaml
 
+  arm,psci-s2ram-param:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      power_state parameter denoting the S2RAM/S3-like system suspend state
+    maxItems: 1
+
 patternProperties:
   "^power-domain-":
     $ref: /schemas/power/power-domain.yaml#
diff -Nrup linux-6.16.6/Documentation/devicetree/bindings/i2c/qcom,i2c-cci.yaml linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/i2c/qcom,i2c-cci.yaml
--- linux-6.16.6/Documentation/devicetree/bindings/i2c/qcom,i2c-cci.yaml	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/i2c/qcom,i2c-cci.yaml	2025-09-11 09:47:42.000000000 -0600
@@ -54,6 +54,8 @@ properties:
   interrupts:
     maxItems: 1
 
+  operating-points-v2: true
+
   power-domains:
     maxItems: 1
 
diff -Nrup linux-6.16.6/Documentation/devicetree/bindings/leds/backlight/led-backlight.yaml linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/leds/backlight/led-backlight.yaml
--- linux-6.16.6/Documentation/devicetree/bindings/leds/backlight/led-backlight.yaml	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/leds/backlight/led-backlight.yaml	2025-09-11 09:47:42.000000000 -0600
@@ -23,11 +23,7 @@ properties:
   compatible:
     const: led-backlight
 
-  leds:
-    description: A list of LED nodes
-    $ref: /schemas/types.yaml#/definitions/phandle-array
-    items:
-      maxItems: 1
+  leds: true
 
 required:
   - compatible
diff -Nrup linux-6.16.6/Documentation/devicetree/bindings/leds/leds-consumer.yaml linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/leds/leds-consumer.yaml
--- linux-6.16.6/Documentation/devicetree/bindings/leds/leds-consumer.yaml	1969-12-31 17:00:00.000000000 -0700
+++ linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/leds/leds-consumer.yaml	2025-09-11 09:47:42.000000000 -0600
@@ -0,0 +1,67 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/leds/leds-consumer.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Common leds consumer
+
+maintainers:
+  - Aleksandrs Vinarskis <alex@vinarskis.com>
+
+description:
+  Some LED defined in DT are required by other DT consumers, for example
+  v4l2 subnode may require privacy or flash LED. Unlike trigger-source
+  approach which is typically used as 'soft' binding, referencing LED
+  devices by phandle makes things simpler when 'hard' binding is desired.
+
+  Document LED properties that its consumers may define.
+
+select: true
+
+properties:
+  leds:
+    oneOf:
+      - type: object
+      - $ref: /schemas/types.yaml#/definitions/phandle-array
+        description:
+          A list of LED device(s) required by a particular consumer.
+        items:
+          maxItems: 1
+
+  led-names:
+    description:
+      A list of device name(s). Used to map LED devices to their respective
+      functions, when consumer requires more than one LED.
+
+additionalProperties: true
+
+examples:
+  - |
+    #include <dt-bindings/gpio/gpio.h>
+    #include <dt-bindings/leds/common.h>
+
+    leds {
+        compatible = "gpio-leds";
+
+        privacy_led: privacy-led {
+            color = <LED_COLOR_ID_RED>;
+            default-state = "off";
+            function = LED_FUNCTION_INDICATOR;
+            gpios = <&tlmm 110 GPIO_ACTIVE_HIGH>;
+        };
+    };
+
+    i2c {
+      #address-cells = <1>;
+      #size-cells = <0>;
+
+      v4l2_node: camera@36 {
+        reg = <0x36>;
+
+        leds = <&privacy_led>;
+        led-names = "privacy";
+      };
+    };
+
+...
diff -Nrup linux-6.16.6/Documentation/devicetree/bindings/leds/leds-group-multicolor.yaml linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/leds/leds-group-multicolor.yaml
--- linux-6.16.6/Documentation/devicetree/bindings/leds/leds-group-multicolor.yaml	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/leds/leds-group-multicolor.yaml	2025-09-11 09:47:42.000000000 -0600
@@ -17,10 +17,7 @@ properties:
   compatible:
     const: leds-group-multicolor
 
-  leds:
-    description:
-      An aray of monochromatic leds
-    $ref: /schemas/types.yaml#/definitions/phandle-array
+  leds: true
 
 required:
   - leds
diff -Nrup linux-6.16.6/Documentation/devicetree/bindings/media/qcom,sm8350-venus.yaml linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/media/qcom,sm8350-venus.yaml
--- linux-6.16.6/Documentation/devicetree/bindings/media/qcom,sm8350-venus.yaml	1969-12-31 17:00:00.000000000 -0700
+++ linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/media/qcom,sm8350-venus.yaml	2025-09-11 09:47:42.000000000 -0600
@@ -0,0 +1,149 @@
+# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/media/qcom,sm8350-venus.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Qualcomm SM8350 Venus video encode and decode accelerators
+
+maintainers:
+  - Konrad Dybcio <konradybcio@kernel.org>
+
+description: |
+  The Venus Iris2 IP is a video encode and decode accelerator present
+  on Qualcomm platforms
+
+allOf:
+  - $ref: qcom,venus-common.yaml#
+
+properties:
+  compatible:
+    enum:
+      - qcom,sc8280xp-venus
+      - qcom,sm8350-venus
+
+  clocks:
+    maxItems: 3
+
+  clock-names:
+    items:
+      - const: iface
+      - const: core
+      - const: vcodec0_core
+
+  resets:
+    maxItems: 1
+
+  reset-names:
+    items:
+      - const: core
+
+  power-domains:
+    maxItems: 3
+
+  power-domain-names:
+    items:
+      - const: venus
+      - const: vcodec0
+      - const: mx
+
+  interconnects:
+    maxItems: 3
+
+  interconnect-names:
+    items:
+      - const: cpu-cfg
+      - const: video-mem
+      - const: video-llcc
+
+  operating-points-v2: true
+  opp-table:
+    type: object
+
+  iommus:
+    maxItems: 1
+
+  video-decoder:
+    type: object
+
+    properties:
+      compatible:
+        const: venus-decoder
+
+    required:
+      - compatible
+
+    additionalProperties: false
+
+  video-encoder:
+    type: object
+
+    properties:
+      compatible:
+        const: venus-encoder
+
+    required:
+      - compatible
+
+    additionalProperties: false
+
+required:
+  - compatible
+  - power-domain-names
+  - iommus
+  - video-decoder
+  - video-encoder
+
+unevaluatedProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/interrupt-controller/arm-gic.h>
+    #include <dt-bindings/clock/qcom,gcc-sm8350.h>
+    #include <dt-bindings/clock/qcom,sm8350-videocc.h>
+    #include <dt-bindings/interconnect/qcom,sm8350.h>
+    #include <dt-bindings/power/qcom-rpmpd.h>
+
+    venus: video-codec@aa00000 {
+        compatible = "qcom,sm8350-venus";
+        reg = <0x0aa00000 0x100000>;
+        interrupts = <GIC_SPI 174 IRQ_TYPE_LEVEL_HIGH>;
+
+        clocks = <&gcc GCC_VIDEO_AXI0_CLK>,
+                 <&videocc VIDEO_CC_MVS0C_CLK>,
+                 <&videocc VIDEO_CC_MVS0_CLK>;
+        clock-names = "iface",
+                      "core",
+                      "vcodec0_core";
+
+        resets = <&gcc GCC_VIDEO_AXI0_CLK_ARES>;
+        reset-names = "core";
+
+        power-domains = <&videocc MVS0C_GDSC>,
+                        <&videocc MVS0_GDSC>,
+                        <&rpmhpd SM8350_MX>;
+        power-domain-names = "venus",
+                             "vcodec0",
+                             "mx";
+
+        interconnects = <&gem_noc MASTER_APPSS_PROC 0 &config_noc SLAVE_VENUS_CFG 0>,
+                        <&mmss_noc MASTER_VIDEO_P0 0 &mc_virt SLAVE_EBI1 0>,
+                        <&mmss_noc MASTER_VIDEO_P0 0 &gem_noc SLAVE_LLCC 0>;
+        interconnect-names = "cpu-cfg",
+                             "video-mem",
+                             "video-llcc";
+
+        operating-points-v2 = <&venus_opp_table>;
+        iommus = <&apps_smmu 0x2100 0x400>;
+        memory-region = <&pil_video_mem>;
+
+        status = "disabled";
+
+        video-decoder {
+            compatible = "venus-decoder";
+        };
+
+        video-encoder {
+            compatible = "venus-encoder";
+        };
+    };
diff -Nrup linux-6.16.6/Documentation/devicetree/bindings/media/video-interface-devices.yaml linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/media/video-interface-devices.yaml
--- linux-6.16.6/Documentation/devicetree/bindings/media/video-interface-devices.yaml	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/media/video-interface-devices.yaml	2025-09-11 09:47:42.000000000 -0600
@@ -17,6 +17,14 @@ properties:
       An array of phandles, each referring to a flash LED, a sub-node of the LED
       driver device node.
 
+  leds:
+    minItems: 1
+    maxItems: 1
+
+  led-names:
+    enum:
+      - privacy
+
   lens-focus:
     $ref: /schemas/types.yaml#/definitions/phandle
     description:
diff -Nrup linux-6.16.6/Documentation/devicetree/bindings/phy/qcom,sc8280xp-qmp-usb43dp-phy.yaml linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/phy/qcom,sc8280xp-qmp-usb43dp-phy.yaml
--- linux-6.16.6/Documentation/devicetree/bindings/phy/qcom,sc8280xp-qmp-usb43dp-phy.yaml	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/Documentation/devicetree/bindings/phy/qcom,sc8280xp-qmp-usb43dp-phy.yaml	2025-09-11 09:47:42.000000000 -0600
@@ -72,10 +72,8 @@ properties:
     description:
       See include/dt-bindings/phy/phy-qcom-qmp.h
 
-  orientation-switch:
-    description:
-      Flag the PHY as possible handler of USB Type-C orientation switching
-    type: boolean
+  mode-switch: true
+  orientation-switch: true
 
   ports:
     $ref: /schemas/graph.yaml#/properties/ports
@@ -105,6 +103,7 @@ required:
   - "#phy-cells"
 
 allOf:
+  - $ref: /schemas/usb/usb-switch.yaml#
   - if:
       properties:
         compatible:
diff -Nrup linux-6.16.6/drivers/bluetooth/hci_qca.c linux-lenovo-x13s-linux-6.16.y/drivers/bluetooth/hci_qca.c
--- linux-6.16.6/drivers/bluetooth/hci_qca.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/bluetooth/hci_qca.c	2025-09-11 09:47:42.000000000 -0600
@@ -1220,7 +1220,14 @@ static int qca_recv_event(struct hci_dev
 		 * vendor command).
 		 */
 
-		if (hdr->evt == HCI_EV_VENDOR)
+		/* For the WCN6750/WCN6855/WCN7850, like the WCN3990, the
+		 * vendor command for a baudrate change command isn't sent as
+		 * synchronous HCI command, the controller sends the corresponding
+		 * command complete event with the new baudrate. The event is
+		 * received and properly decoded after changing the baudrate of
+		 * the host port. It needs to be dropped.
+		 */
+		if (hdr->evt == HCI_EV_VENDOR || hdr->evt == HCI_EV_CMD_COMPLETE)
 			complete(&qca->drop_ev_comp);
 
 		kfree_skb(skb);
@@ -1514,6 +1521,9 @@ static int qca_set_speed(struct hci_uart
 
 		switch (soc_type) {
 		case QCA_WCN3990:
+		case QCA_WCN6750:
+		case QCA_WCN6855:
+		case QCA_WCN7850:
 			reinit_completion(&qca->drop_ev_comp);
 			set_bit(QCA_DROP_VENDOR_EVENT, &qca->flags);
 			break;
@@ -1549,6 +1559,9 @@ error:
 
 		switch (soc_type) {
 		case QCA_WCN3990:
+		case QCA_WCN6750:
+		case QCA_WCN6855:
+		case QCA_WCN7850:
 			/* Wait for the controller to send the vendor event
 			 * for the baudrate change command.
 			 */
diff -Nrup linux-6.16.6/drivers/cpuidle/cpuidle-qcom-spm.c linux-lenovo-x13s-linux-6.16.y/drivers/cpuidle/cpuidle-qcom-spm.c
--- linux-6.16.6/drivers/cpuidle/cpuidle-qcom-spm.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/cpuidle/cpuidle-qcom-spm.c	2025-09-11 09:47:42.000000000 -0600
@@ -86,9 +86,9 @@ static const struct of_device_id qcom_id
 
 static int spm_cpuidle_register(struct device *cpuidle_dev, int cpu)
 {
-	struct platform_device *pdev = NULL;
+	struct platform_device *pdev;
 	struct device_node *cpu_node, *saw_node;
-	struct cpuidle_qcom_spm_data *data = NULL;
+	struct cpuidle_qcom_spm_data *data;
 	int ret;
 
 	cpu_node = of_cpu_device_node_get(cpu);
@@ -96,20 +96,23 @@ static int spm_cpuidle_register(struct d
 		return -ENODEV;
 
 	saw_node = of_parse_phandle(cpu_node, "qcom,saw", 0);
+	of_node_put(cpu_node);
 	if (!saw_node)
 		return -ENODEV;
 
 	pdev = of_find_device_by_node(saw_node);
 	of_node_put(saw_node);
-	of_node_put(cpu_node);
 	if (!pdev)
 		return -ENODEV;
 
 	data = devm_kzalloc(cpuidle_dev, sizeof(*data), GFP_KERNEL);
-	if (!data)
+	if (!data) {
+		put_device(&pdev->dev);
 		return -ENOMEM;
+	}
 
 	data->spm = dev_get_drvdata(&pdev->dev);
+	put_device(&pdev->dev);
 	if (!data->spm)
 		return -EINVAL;
 
diff -Nrup linux-6.16.6/drivers/firmware/efi/libstub/efistub.h linux-lenovo-x13s-linux-6.16.y/drivers/firmware/efi/libstub/efistub.h
--- linux-6.16.6/drivers/firmware/efi/libstub/efistub.h	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/firmware/efi/libstub/efistub.h	2025-09-11 09:47:42.000000000 -0600
@@ -272,7 +272,7 @@ union efi_boot_services {
 		efi_status_t (__efiapi *wait_for_event)(unsigned long,
 							efi_event_t *,
 							unsigned long *);
-		void *signal_event;
+		efi_status_t (__efiapi *signal_event)(efi_event_t);
 		efi_status_t (__efiapi *close_event)(efi_event_t);
 		void *check_event;
 		void *install_protocol_interface;
@@ -324,7 +324,7 @@ union efi_boot_services {
 		void *calculate_crc32;
 		void (__efiapi *copy_mem)(void *, const void *, unsigned long);
 		void (__efiapi *set_mem)(void *, unsigned long, unsigned char);
-		void *create_event_ex;
+		efi_status_t (__efiapi *create_event_ex)(u32, int, void *, void *, void *, efi_event_t *);
 	};
 	struct {
 		efi_table_hdr_t hdr;
diff -Nrup linux-6.16.6/drivers/firmware/efi/libstub/efi-stub-helper.c linux-lenovo-x13s-linux-6.16.y/drivers/firmware/efi/libstub/efi-stub-helper.c
--- linux-6.16.6/drivers/firmware/efi/libstub/efi-stub-helper.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/firmware/efi/libstub/efi-stub-helper.c	2025-09-11 09:47:42.000000000 -0600
@@ -407,6 +407,13 @@ char *efi_convert_cmdline(efi_loaded_ima
 	return (char *)cmdline_addr;
 }
 
+#define EFI_EVENT_GROUP_BEFORE_EXIT_BOOT_SERVICES \
+	EFI_GUID(0x8be0e274, 0x3970, 0x4b44,  0x80, 0xc5, 0x1a, 0xb9, 0x50, 0x2f, 0x3b, 0xfc)
+
+static void efi_before_ebs_notify(efi_event_t event, void *context)
+{
+}
+
 /**
  * efi_exit_boot_services() - Exit boot services
  * @handle:	handle of the exiting image
@@ -427,10 +434,27 @@ efi_status_t efi_exit_boot_services(void
 {
 	struct efi_boot_memmap *map;
 	efi_status_t status;
+	efi_guid_t guid = EFI_EVENT_GROUP_BEFORE_EXIT_BOOT_SERVICES;
+	efi_event_t event;
 
 	if (efi_disable_pci_dma)
 		efi_pci_disable_bridge_busmaster();
 
+	status = efi_bs_call(create_event_ex, EFI_EVT_NOTIFY_SIGNAL,
+			     EFI_TPL_CALLBACK, efi_before_ebs_notify, NULL,
+			     &guid, &event);
+	if (status == EFI_SUCCESS) {
+		status = efi_bs_call(signal_event, event);
+		if (status != EFI_SUCCESS)
+			efi_err("%s - signal event failed: %02lx\n", __func__, status);
+
+		status = efi_bs_call(close_event, event);
+		if (status != EFI_SUCCESS)
+			efi_err("%s - close event failed: %02lx\n", __func__, status);
+	} else {
+		efi_err("%s - create event ex failed: %02lx\n", __func__, status);
+	}
+
 	status = efi_get_memory_map(&map, true);
 	if (status != EFI_SUCCESS)
 		return status;
diff -Nrup linux-6.16.6/drivers/firmware/psci/psci.c linux-lenovo-x13s-linux-6.16.y/drivers/firmware/psci/psci.c
--- linux-6.16.6/drivers/firmware/psci/psci.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/firmware/psci/psci.c	2025-09-11 09:47:42.000000000 -0600
@@ -79,6 +79,7 @@ struct psci_0_1_function_ids get_psci_0_
 static u32 psci_cpu_suspend_feature;
 static bool psci_system_reset2_supported;
 static bool psci_system_off2_hibernate_supported;
+static u32 psci_s2ram_suspend_param;
 
 static inline bool psci_has_ext_power_state(void)
 {
@@ -539,12 +540,22 @@ static int psci_system_suspend(unsigned
 
 static int psci_system_suspend_enter(suspend_state_t state)
 {
+	pm_set_resume_via_firmware();
+
 	return cpu_suspend(0, psci_system_suspend);
 }
 
-static const struct platform_suspend_ops psci_suspend_ops = {
-	.valid          = suspend_valid_only_mem,
-	.enter          = psci_system_suspend_enter,
+static int psci_system_suspend_begin(suspend_state_t state)
+{
+	pm_set_suspend_via_firmware();
+
+	return 0;
+}
+
+static const struct platform_suspend_ops psci_system_suspend_ops = {
+	.valid = suspend_valid_only_mem,
+	.enter = psci_system_suspend_enter,
+	.begin = psci_system_suspend_begin,
 };
 
 static void __init psci_init_system_reset2(void)
@@ -579,7 +590,7 @@ static void __init psci_init_system_susp
 	ret = psci_features(PSCI_FN_NATIVE(1_0, SYSTEM_SUSPEND));
 
 	if (ret != PSCI_RET_NOT_SUPPORTED)
-		suspend_set_ops(&psci_suspend_ops);
+		suspend_set_ops(&psci_system_suspend_ops);
 }
 
 static void __init psci_init_cpu_suspend(void)
@@ -708,6 +719,17 @@ static int __init psci_probe(void)
 
 typedef int (*psci_initcall_t)(const struct device_node *);
 
+static int psci_cpu_suspend_s2ram_enter(suspend_state_t state)
+{
+	return psci_cpu_suspend_enter(psci_s2ram_suspend_param);
+}
+
+static const struct platform_suspend_ops psci_cpu_suspend_s2ram_ops = {
+	.valid = suspend_valid_only_mem,
+	.enter = psci_cpu_suspend_s2ram_enter,
+	.begin = psci_system_suspend_begin,
+};
+
 /*
  * PSCI init function for PSCI versions >=0.2
  *
@@ -722,6 +744,20 @@ static int __init psci_0_2_init(const st
 		return err;
 
 	/*
+	 * Some firmwares expose S2RAM entry through a custom suspend param.
+	 *
+	 * If found, register a suspend handler instead of registering the
+	 * idle state with cpuidle.
+	 */
+	err = of_property_read_u32(np, "arm,psci-s2ram-param", &psci_s2ram_suspend_param);
+	if (!err) {
+		suspend_set_ops(&psci_cpu_suspend_s2ram_ops);
+	} else if (err != -EINVAL) {
+		pr_err("Couldn't read the S2RAM PSCI suspend param: %d\n",
+		       psci_s2ram_suspend_param);
+	}
+
+	/*
 	 * Starting with v0.2, the PSCI specification introduced a call
 	 * (PSCI_VERSION) that allows probing the firmware version, so
 	 * that PSCI function IDs and version specific initialization
diff -Nrup linux-6.16.6/drivers/gpu/drm/display/drm_dp_helper.c linux-lenovo-x13s-linux-6.16.y/drivers/gpu/drm/display/drm_dp_helper.c
--- linux-6.16.6/drivers/gpu/drm/display/drm_dp_helper.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/gpu/drm/display/drm_dp_helper.c	2025-09-11 09:47:42.000000000 -0600
@@ -28,6 +28,7 @@
 #include <linux/init.h>
 #include <linux/iopoll.h>
 #include <linux/kernel.h>
+#include <linux/minmax.h>
 #include <linux/module.h>
 #include <linux/sched.h>
 #include <linux/seq_file.h>
@@ -4111,6 +4112,32 @@ drm_edp_backlight_probe_max(struct drm_d
 	}
 
 	pn &= DP_EDP_PWMGEN_BIT_COUNT_MASK;
+
+	ret = drm_dp_dpcd_read_byte(aux, DP_EDP_PWMGEN_BIT_COUNT_CAP_MIN, &pn_min);
+	if (ret < 0) {
+		drm_dbg_kms(aux->drm_dev, "%s: Failed to read pwmgen bit count cap min: %d\n",
+			    aux->name, ret);
+		return -ENODEV;
+	}
+	pn_min &= DP_EDP_PWMGEN_BIT_COUNT_MASK;
+
+	ret = drm_dp_dpcd_read_byte(aux, DP_EDP_PWMGEN_BIT_COUNT_CAP_MAX, &pn_max);
+	if (ret < 0) {
+		drm_dbg_kms(aux->drm_dev, "%s: Failed to read pwmgen bit count cap max: %d\n",
+			    aux->name, ret);
+		return -ENODEV;
+	}
+	pn_max &= DP_EDP_PWMGEN_BIT_COUNT_MASK;
+
+	/*
+	 * Per VESA eDP Spec v1.4b, section 3.3.10.2:
+	 * If DP_EDP_PWMGEN_BIT_COUNT is less than DP_EDP_PWMGEN_BIT_COUNT_CAP_MIN,
+	 * the sink must use the MIN value as the effective PWM bit count.
+	 * Clamp the reported value to the [MIN, MAX] capability range to ensure
+	 * correct brightness scaling on compliant eDP panels.
+	 */
+	pn = clamp(pn, pn_min, pn_max);
+
 	bl->max = (1 << pn) - 1;
 	if (!driver_pwm_freq_hz)
 		return 0;
@@ -4137,20 +4164,6 @@ drm_edp_backlight_probe_max(struct drm_d
 	 * - FxP is within 25% of desired value.
 	 *   Note: 25% is arbitrary value and may need some tweak.
 	 */
-	ret = drm_dp_dpcd_read_byte(aux, DP_EDP_PWMGEN_BIT_COUNT_CAP_MIN, &pn_min);
-	if (ret < 0) {
-		drm_dbg_kms(aux->drm_dev, "%s: Failed to read pwmgen bit count cap min: %d\n",
-			    aux->name, ret);
-		return 0;
-	}
-	ret = drm_dp_dpcd_read_byte(aux, DP_EDP_PWMGEN_BIT_COUNT_CAP_MAX, &pn_max);
-	if (ret < 0) {
-		drm_dbg_kms(aux->drm_dev, "%s: Failed to read pwmgen bit count cap max: %d\n",
-			    aux->name, ret);
-		return 0;
-	}
-	pn_min &= DP_EDP_PWMGEN_BIT_COUNT_MASK;
-	pn_max &= DP_EDP_PWMGEN_BIT_COUNT_MASK;
 
 	/* Ensure frequency is within 25% of desired value */
 	fxp_min = DIV_ROUND_CLOSEST(fxp * 3, 4);
diff -Nrup linux-6.16.6/drivers/gpu/drm/panel/panel-edp.c linux-lenovo-x13s-linux-6.16.y/drivers/gpu/drm/panel/panel-edp.c
--- linux-6.16.6/drivers/gpu/drm/panel/panel-edp.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/gpu/drm/panel/panel-edp.c	2025-09-11 09:47:42.000000000 -0600
@@ -1923,6 +1923,7 @@ static const struct edp_panel_entry edp_
 	EDP_PANEL_ENTRY('B', 'O', 'E', 0x094b, &delay_200_500_e50, "NT116WHM-N21"),
 	EDP_PANEL_ENTRY('B', 'O', 'E', 0x0951, &delay_200_500_e80, "NV116WHM-N47"),
 	EDP_PANEL_ENTRY('B', 'O', 'E', 0x095f, &delay_200_500_e50, "NE135FBM-N41 v8.1"),
+	EDP_PANEL_ENTRY('B', 'O', 'E', 0x0964, &delay_200_500_e50, "NV116WUM-N61"),
 	EDP_PANEL_ENTRY('B', 'O', 'E', 0x096e, &delay_200_500_e50_po2e200, "NV116WHM-T07 V8.0"),
 	EDP_PANEL_ENTRY('B', 'O', 'E', 0x0979, &delay_200_500_e50, "NV116WHM-N49 V8.0"),
 	EDP_PANEL_ENTRY('B', 'O', 'E', 0x098d, &boe_nv110wtm_n61.delay, "NV110WTM-N61"),
@@ -1935,6 +1936,7 @@ static const struct edp_panel_entry edp_
 	EDP_PANEL_ENTRY('B', 'O', 'E', 0x0a3e, &delay_200_500_e80, "NV116WHM-N49"),
 	EDP_PANEL_ENTRY('B', 'O', 'E', 0x0a5d, &delay_200_500_e50, "NV116WHM-N45"),
 	EDP_PANEL_ENTRY('B', 'O', 'E', 0x0ac5, &delay_200_500_e50, "NV116WHM-N4C"),
+	EDP_PANEL_ENTRY('B', 'O', 'E', 0x0a84, &delay_200_500_e50, "NV133WUM-T01"),
 	EDP_PANEL_ENTRY('B', 'O', 'E', 0x0ae8, &delay_200_500_e50_p2e80, "NV140WUM-N41"),
 	EDP_PANEL_ENTRY('B', 'O', 'E', 0x0b09, &delay_200_500_e50_po2e200, "NV140FHM-NZ"),
 	EDP_PANEL_ENTRY('B', 'O', 'E', 0x0b34, &delay_200_500_e80, "NV122WUM-N41"),
diff -Nrup linux-6.16.6/drivers/i2c/busses/i2c-qcom-cci.c linux-lenovo-x13s-linux-6.16.y/drivers/i2c/busses/i2c-qcom-cci.c
--- linux-6.16.6/drivers/i2c/busses/i2c-qcom-cci.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/i2c/busses/i2c-qcom-cci.c	2025-09-11 09:47:42.000000000 -0600
@@ -10,6 +10,7 @@
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/platform_device.h>
+#include <linux/pm_opp.h>
 #include <linux/pm_runtime.h>
 
 #define CCI_HW_VERSION				0x0
@@ -121,6 +122,7 @@ struct cci_data {
 	struct i2c_adapter_quirks quirks;
 	u16 queue_size[NUM_QUEUES];
 	struct hw_params params[3];
+	bool fast_mode_plus_supported;
 };
 
 struct cci {
@@ -466,21 +468,25 @@ static const struct i2c_algorithm cci_al
 	.functionality = cci_func,
 };
 
-static int cci_enable_clocks(struct cci *cci)
+static unsigned long cci_desired_clk_rate(struct cci *cci)
 {
-	return clk_bulk_prepare_enable(cci->nclocks, cci->clocks);
-}
+	if (cci->data->fast_mode_plus_supported)
+		return 37500000ULL;
 
-static void cci_disable_clocks(struct cci *cci)
-{
-	clk_bulk_disable_unprepare(cci->nclocks, cci->clocks);
+	return 19200000ULL;
 }
 
 static int __maybe_unused cci_suspend_runtime(struct device *dev)
 {
 	struct cci *cci = dev_get_drvdata(dev);
+	int ret;
+
+	ret = dev_pm_opp_set_rate(dev, 0);
+	if (ret)
+		return ret;
+
+	clk_bulk_disable_unprepare(cci->nclocks, cci->clocks);
 
-	cci_disable_clocks(cci);
 	return 0;
 }
 
@@ -489,11 +495,16 @@ static int __maybe_unused cci_resume_run
 	struct cci *cci = dev_get_drvdata(dev);
 	int ret;
 
-	ret = cci_enable_clocks(cci);
+	ret = clk_bulk_prepare_enable(cci->nclocks, cci->clocks);
+	if (ret)
+		return ret;
+
+	ret = dev_pm_opp_set_rate(dev, cci_desired_clk_rate(cci));
 	if (ret)
 		return ret;
 
 	cci_init(cci);
+
 	return 0;
 }
 
@@ -592,10 +603,23 @@ static int cci_probe(struct platform_dev
 		return dev_err_probe(dev, -EINVAL, "not enough clocks in DT\n");
 	cci->nclocks = ret;
 
-	ret = cci_enable_clocks(cci);
+	ret = clk_bulk_prepare_enable(cci->nclocks, cci->clocks);
 	if (ret < 0)
 		return ret;
 
+	ret = devm_pm_opp_set_clkname(dev, "cci");
+	if (ret)
+		return ret;
+
+	/* OPP table is optional */
+	ret = devm_pm_opp_of_add_table(dev);
+	if (ret && ret != -ENODEV)
+		return dev_err_probe(dev, ret, "invalid OPP table in device tree\n");
+
+	ret = dev_pm_opp_set_rate(dev, cci_desired_clk_rate(cci));
+	if (ret)
+		return ret;
+
 	/* Interrupt */
 
 	ret = platform_get_irq(pdev, 0);
@@ -651,7 +675,7 @@ error_i2c:
 error:
 	disable_irq(cci->irq);
 disable_clocks:
-	cci_disable_clocks(cci);
+	clk_bulk_disable_unprepare(cci->nclocks, cci->clocks);
 
 	return ret;
 }
@@ -783,6 +807,7 @@ static const struct cci_data cci_v2_data
 		.trdhld = 3,
 		.tsp = 3
 	},
+	.fast_mode_plus_supported = true,
 };
 
 static const struct of_device_id cci_dt_match[] = {
diff -Nrup linux-6.16.6/drivers/leds/led-class.c linux-lenovo-x13s-linux-6.16.y/drivers/leds/led-class.c
--- linux-6.16.6/drivers/leds/led-class.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/leds/led-class.c	2025-09-11 09:47:42.000000000 -0600
@@ -252,15 +252,23 @@ static const struct class leds_class = {
  * of_led_get() - request a LED device via the LED framework
  * @np: device node to get the LED device from
  * @index: the index of the LED
+ * @name: the name of the LED used to map it to its function, if present
  *
  * Returns the LED device parsed from the phandle specified in the "leds"
  * property of a device tree node or a negative error-code on failure.
  */
-struct led_classdev *of_led_get(struct device_node *np, int index)
+static struct led_classdev *of_led_get(struct device_node *np, int index,
+				       const char *name)
 {
 	struct device *led_dev;
 	struct device_node *led_node;
 
+	/*
+	 * For named LEDs, first look up the name in the "led-names" property.
+	 * If it cannot be found, then of_parse_phandle() will propagate the error.
+	 */
+	if (name)
+		index = of_property_match_string(np, "led-names", name);
 	led_node = of_parse_phandle(np, "leds", index);
 	if (!led_node)
 		return ERR_PTR(-ENOENT);
@@ -270,7 +278,6 @@ struct led_classdev *of_led_get(struct d
 
 	return led_module_get(led_dev);
 }
-EXPORT_SYMBOL_GPL(of_led_get);
 
 /**
  * led_put() - release a LED device
@@ -325,7 +332,7 @@ struct led_classdev *__must_check devm_o
 	if (!dev)
 		return ERR_PTR(-EINVAL);
 
-	led = of_led_get(dev->of_node, index);
+	led = of_led_get(dev->of_node, index, NULL);
 	if (IS_ERR(led))
 		return led;
 
@@ -343,9 +350,14 @@ EXPORT_SYMBOL_GPL(devm_of_led_get);
 struct led_classdev *led_get(struct device *dev, char *con_id)
 {
 	struct led_lookup_data *lookup;
+	struct led_classdev *led_cdev;
 	const char *provider = NULL;
 	struct device *led_dev;
 
+	led_cdev = of_led_get(dev->of_node, -1, con_id);
+	if (!IS_ERR(led_cdev) || PTR_ERR(led_cdev) != -ENOENT)
+		return led_cdev;
+
 	mutex_lock(&leds_lookup_lock);
 	list_for_each_entry(lookup, &leds_lookup_list, list) {
 		if (!strcmp(lookup->dev_id, dev_name(dev)) &&
diff -Nrup linux-6.16.6/drivers/media/platform/qcom/camss/camss.c linux-lenovo-x13s-linux-6.16.y/drivers/media/platform/qcom/camss/camss.c
--- linux-6.16.6/drivers/media/platform/qcom/camss/camss.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/media/platform/qcom/camss/camss.c	2025-09-11 09:47:42.000000000 -0600
@@ -2845,6 +2845,14 @@ struct media_pad *camss_find_sensor_pad(
 
 	while (1) {
 		pad = &entity->pads[0];
+
+		/*
+		 * Work around unresolved bug in camss (or v4l2) which can
+		 * result in pad being NULL here.
+		 */
+		if (WARN_ON(!pad))
+			return NULL;
+
 		if (!(pad->flags & MEDIA_PAD_FL_SINK))
 			return NULL;
 
diff -Nrup linux-6.16.6/drivers/media/platform/qcom/camss/camss-vfe.c linux-lenovo-x13s-linux-6.16.y/drivers/media/platform/qcom/camss/camss-vfe.c
--- linux-6.16.6/drivers/media/platform/qcom/camss/camss-vfe.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/media/platform/qcom/camss/camss-vfe.c	2025-09-11 09:47:42.000000000 -0600
@@ -871,7 +871,7 @@ void vfe_isr_reset_ack(struct vfe_device
  */
 void vfe_pm_domain_off(struct vfe_device *vfe)
 {
-	if (!vfe->genpd)
+	if (!vfe->genpd_link)
 		return;
 
 	device_link_del(vfe->genpd_link);
diff -Nrup linux-6.16.6/drivers/media/platform/qcom/camss/camss-video.c linux-lenovo-x13s-linux-6.16.y/drivers/media/platform/qcom/camss/camss-video.c
--- linux-6.16.6/drivers/media/platform/qcom/camss/camss-video.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/media/platform/qcom/camss/camss-video.c	2025-09-11 09:47:42.000000000 -0600
@@ -225,6 +225,21 @@ static int video_check_format(struct cam
 	return 0;
 }
 
+static int video_prepare_streaming(struct vb2_queue *q)
+{
+	struct camss_video *video = vb2_get_drv_priv(q);
+	struct video_device *vdev = &video->vdev;
+	int ret;
+
+	ret = v4l2_pipeline_pm_get(&vdev->entity);
+	if (ret < 0) {
+		dev_err(video->camss->dev, "Failed to power up pipeline: %d\n",
+			ret);
+	}
+
+	return ret;
+}
+
 static int video_start_streaming(struct vb2_queue *q, unsigned int count)
 {
 	struct camss_video *video = vb2_get_drv_priv(q);
@@ -308,13 +323,23 @@ static void video_stop_streaming(struct
 	video->ops->flush_buffers(video, VB2_BUF_STATE_ERROR);
 }
 
+static void video_unprepare_streaming(struct vb2_queue *q)
+{
+	struct camss_video *video = vb2_get_drv_priv(q);
+	struct video_device *vdev = &video->vdev;
+
+	v4l2_pipeline_pm_put(&vdev->entity);
+}
+
 static const struct vb2_ops msm_video_vb2_q_ops = {
 	.queue_setup     = video_queue_setup,
 	.buf_init        = video_buf_init,
 	.buf_prepare     = video_buf_prepare,
 	.buf_queue       = video_buf_queue,
+	.prepare_streaming = video_prepare_streaming,
 	.start_streaming = video_start_streaming,
 	.stop_streaming  = video_stop_streaming,
+	.unprepare_streaming = video_unprepare_streaming,
 };
 
 /* -----------------------------------------------------------------------------
@@ -599,20 +624,10 @@ static int video_open(struct file *file)
 
 	file->private_data = vfh;
 
-	ret = v4l2_pipeline_pm_get(&vdev->entity);
-	if (ret < 0) {
-		dev_err(video->camss->dev, "Failed to power up pipeline: %d\n",
-			ret);
-		goto error_pm_use;
-	}
-
 	mutex_unlock(&video->lock);
 
 	return 0;
 
-error_pm_use:
-	v4l2_fh_release(file);
-
 error_alloc:
 	mutex_unlock(&video->lock);
 
@@ -621,12 +636,8 @@ error_alloc:
 
 static int video_release(struct file *file)
 {
-	struct video_device *vdev = video_devdata(file);
-
 	vb2_fop_release(file);
 
-	v4l2_pipeline_pm_put(&vdev->entity);
-
 	file->private_data = NULL;
 
 	return 0;
diff -Nrup linux-6.16.6/drivers/media/platform/qcom/venus/core.c linux-lenovo-x13s-linux-6.16.y/drivers/media/platform/qcom/venus/core.c
--- linux-6.16.6/drivers/media/platform/qcom/venus/core.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/media/platform/qcom/venus/core.c	2025-09-11 09:47:42.000000000 -0600
@@ -393,6 +393,15 @@ static int venus_probe(struct platform_d
 	if (IS_ERR(core->cpucfg_path))
 		return PTR_ERR(core->cpucfg_path);
 
+	core->llcc_path = devm_of_icc_get(dev, "video-llcc");
+	if (IS_ERR(core->llcc_path)) {
+		/* LLCC path is optional */
+		if (PTR_ERR(core->llcc_path) == -ENODATA)
+			core->llcc_path = NULL;
+		else
+			return PTR_ERR(core->llcc_path);
+	}
+
 	core->irq = platform_get_irq(pdev, 0);
 	if (core->irq < 0)
 		return core->irq;
@@ -581,12 +590,18 @@ static __maybe_unused int venus_runtime_
 	if (ret)
 		goto err_cpucfg_path;
 
+	ret = icc_set_bw(core->llcc_path, 0, 0);
+	if (ret)
+		goto err_llcc_path;
+
 	ret = icc_set_bw(core->video_path, 0, 0);
 	if (ret)
 		goto err_video_path;
 
 	return ret;
 
+err_llcc_path:
+	icc_set_bw(core->video_path, kbps_to_icc(20000), 0);
 err_video_path:
 	icc_set_bw(core->cpucfg_path, kbps_to_icc(1000), 0);
 err_cpucfg_path:
@@ -626,6 +641,10 @@ static __maybe_unused int venus_runtime_
 	if (ret)
 		return ret;
 
+	ret = icc_set_bw(core->llcc_path, kbps_to_icc(20000), 0);
+	if (ret)
+		return ret;
+
 	ret = icc_set_bw(core->cpucfg_path, kbps_to_icc(1000), 0);
 	if (ret)
 		return ret;
@@ -993,6 +1012,46 @@ static const struct venus_resources sm82
 	.enc_nodename = "video-encoder",
 };
 
+static const struct reg_val sm8350_reg_preset[] = {
+	{ 0xb0088, 0, 0x11 },
+};
+
+static const struct venus_resources sm8350_res = {
+	.freq_tbl = sm8250_freq_table,
+	.freq_tbl_size = ARRAY_SIZE(sm8250_freq_table),
+	.reg_tbl = sm8350_reg_preset,
+	.reg_tbl_size = ARRAY_SIZE(sm8350_reg_preset),
+	.bw_tbl_enc = sm8250_bw_table_enc,
+	.bw_tbl_enc_size = ARRAY_SIZE(sm8250_bw_table_enc),
+	.bw_tbl_dec = sm8250_bw_table_dec,
+	.bw_tbl_dec_size = ARRAY_SIZE(sm8250_bw_table_dec),
+	.clks = { "core", "iface" },
+	.clks_num = 2,
+	.resets = { "core" },
+	.resets_num = 1,
+	.vcodec0_clks = { "vcodec0_core" },
+	.vcodec_clks_num = 1,
+	.vcodec_pmdomains = (const char *[]) { "venus", "vcodec0" },
+	.vcodec_pmdomains_num = 2,
+	.opp_pmdomain = (const char *[]) { "mx", NULL },
+	.vcodec_num = 1,
+	.max_load = 7833600, /* 7680x4320@60fps */
+	.hfi_version = HFI_VERSION_6XX,
+	.vpu_version = VPU_VERSION_IRIS2,
+	.num_vpp_pipes = 4,
+	.vmem_id = VIDC_RESOURCE_NONE,
+	.vmem_size = 0,
+	.vmem_addr = 0,
+	.dma_mask = GENMASK(31, 29) - 1,
+	.cp_start = 0,
+	.cp_size = 0x25800000,
+	.cp_nonpixel_start = 0x1000000,
+	.cp_nonpixel_size = 0x24800000,
+	.fwname = "qcom/vpu-2.0/venus.mbn",
+	.dec_nodename = "video-decoder",
+	.enc_nodename = "video-encoder",
+};
+
 static const struct freq_tbl sc7280_freq_table[] = {
 	{ 0, 460000000 },
 	{ 0, 424000000 },
@@ -1057,16 +1116,62 @@ static const struct venus_resources sc72
 	.enc_nodename = "video-encoder",
 };
 
+static const struct freq_tbl sc8280xp_freq_table[] = {
+	{ 0, 239999999 },
+	{ 0, 338000000 },
+	{ 0, 366000000 },
+	{ 0, 444000000 },
+	{ 0, 533000000 },
+	{ 0, 560000000 },
+};
+
+static const struct venus_resources sc8280xp_res = {
+	.freq_tbl = sc8280xp_freq_table,
+	.freq_tbl_size = ARRAY_SIZE(sc8280xp_freq_table),
+	.reg_tbl = sm8350_reg_preset,
+	.reg_tbl_size = ARRAY_SIZE(sm8350_reg_preset),
+	.bw_tbl_enc = sm8250_bw_table_enc,
+	.bw_tbl_enc_size = ARRAY_SIZE(sm8250_bw_table_enc),
+	.bw_tbl_dec = sm8250_bw_table_dec,
+	.bw_tbl_dec_size = ARRAY_SIZE(sm8250_bw_table_dec),
+	.clks = { "core", "iface" },
+	.clks_num = 2,
+	.resets = { "core" },
+	.resets_num = 1,
+	.vcodec0_clks = { "vcodec0_core" },
+	.vcodec_clks_num = 1,
+	.vcodec_pmdomains = (const char *[]) { "venus", "vcodec0" },
+	.vcodec_pmdomains_num = 2,
+	.opp_pmdomain = (const char *[]) { "mx", NULL },
+	.vcodec_num = 1,
+	.max_load = 7833600, /* 7680x4320@60fps */
+	.hfi_version = HFI_VERSION_6XX,
+	.vpu_version = VPU_VERSION_IRIS2,
+	.num_vpp_pipes = 4,
+	.vmem_id = VIDC_RESOURCE_NONE,
+	.vmem_size = 0,
+	.vmem_addr = 0,
+	.dma_mask = GENMASK(31, 29) - 1,
+	.cp_start = 0,
+	.cp_size = 0x25800000,
+	.cp_nonpixel_start = 0x1000000,
+	.cp_nonpixel_size = 0x24800000,
+	.fwname = "qcom/vpu-2.0/venus.mbn",
+};
+
+
 static const struct of_device_id venus_dt_match[] = {
-	{ .compatible = "qcom,msm8916-venus", .data = &msm8916_res, },
-	{ .compatible = "qcom,msm8996-venus", .data = &msm8996_res, },
-	{ .compatible = "qcom,msm8998-venus", .data = &msm8998_res, },
-	{ .compatible = "qcom,sdm660-venus", .data = &sdm660_res, },
-	{ .compatible = "qcom,sdm845-venus", .data = &sdm845_res, },
-	{ .compatible = "qcom,sdm845-venus-v2", .data = &sdm845_res_v2, },
-	{ .compatible = "qcom,sc7180-venus", .data = &sc7180_res, },
-	{ .compatible = "qcom,sc7280-venus", .data = &sc7280_res, },
-	{ .compatible = "qcom,sm8250-venus", .data = &sm8250_res, },
+	{ .compatible = "qcom,msm8916-venus", .data = &msm8916_res },
+	{ .compatible = "qcom,msm8996-venus", .data = &msm8996_res },
+	{ .compatible = "qcom,msm8998-venus", .data = &msm8998_res },
+	{ .compatible = "qcom,sdm660-venus", .data = &sdm660_res },
+	{ .compatible = "qcom,sdm845-venus", .data = &sdm845_res },
+	{ .compatible = "qcom,sdm845-venus-v2", .data = &sdm845_res_v2 },
+	{ .compatible = "qcom,sc7180-venus", .data = &sc7180_res },
+	{ .compatible = "qcom,sc7280-venus", .data = &sc7280_res },
+	{ .compatible = "qcom,sc8280xp-venus", .data = &sc8280xp_res },
+	{ .compatible = "qcom,sm8250-venus", .data = &sm8250_res },
+	{ .compatible = "qcom,sm8350-venus", .data = &sm8350_res },
 	{ }
 };
 MODULE_DEVICE_TABLE(of, venus_dt_match);
diff -Nrup linux-6.16.6/drivers/media/platform/qcom/venus/core.h linux-lenovo-x13s-linux-6.16.y/drivers/media/platform/qcom/venus/core.h
--- linux-6.16.6/drivers/media/platform/qcom/venus/core.h	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/media/platform/qcom/venus/core.h	2025-09-11 09:47:42.000000000 -0600
@@ -40,6 +40,7 @@ struct freq_tbl {
 struct reg_val {
 	u32 reg;
 	u32 value;
+	u32 mask;
 };
 
 struct bw_tbl {
@@ -66,6 +67,7 @@ struct venus_resources {
 	unsigned int bw_tbl_enc_size;
 	const struct bw_tbl *bw_tbl_dec;
 	unsigned int bw_tbl_dec_size;
+	bool has_llcc_path;
 	const struct reg_val *reg_tbl;
 	unsigned int reg_tbl_size;
 	const struct hfi_ubwc_config *ubwc_conf;
@@ -137,6 +139,7 @@ struct venus_format {
  * @vcodec1_clks: an array of vcodec1 struct clk pointers
  * @video_path: an interconnect handle to video to/from memory path
  * @cpucfg_path: an interconnect handle to cpu configuration path
+ * @llcc_path: an interconnect handle to video to/from llcc path
  * @pmdomains:	a pointer to a list of pmdomains
  * @opp_pmdomain: an OPP power-domain
  * @resets: an array of reset signals
@@ -191,6 +194,7 @@ struct venus_core {
 	struct clk *vcodec1_clks[VIDC_VCODEC_CLKS_NUM_MAX];
 	struct icc_path *video_path;
 	struct icc_path *cpucfg_path;
+	struct icc_path *llcc_path;
 	struct dev_pm_domain_list *pmdomains;
 	struct dev_pm_domain_list *opp_pmdomain;
 	struct reset_control *resets[VIDC_RESETS_NUM_MAX];
diff -Nrup linux-6.16.6/drivers/media/platform/qcom/venus/hfi_venus.c linux-lenovo-x13s-linux-6.16.y/drivers/media/platform/qcom/venus/hfi_venus.c
--- linux-6.16.6/drivers/media/platform/qcom/venus/hfi_venus.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/media/platform/qcom/venus/hfi_venus.c	2025-09-11 09:47:42.000000000 -0600
@@ -369,10 +369,19 @@ static void venus_set_registers(struct v
 	const struct venus_resources *res = hdev->core->res;
 	const struct reg_val *tbl = res->reg_tbl;
 	unsigned int count = res->reg_tbl_size;
-	unsigned int i;
+	unsigned int i, val;
 
-	for (i = 0; i < count; i++)
-		writel(tbl[i].value, hdev->core->base + tbl[i].reg);
+	for (i = 0; i < count; i++) {
+		val = tbl[i].value;
+
+		/* In some cases, we only want to update certain bits */
+		if (tbl[i].mask) {
+			val = readl(hdev->core->base + tbl[i].reg);
+			val = (val & ~tbl[i].mask) | (tbl[i].value & tbl[i].mask);
+		}
+
+		writel(val, hdev->core->base + tbl[i].reg);
+	}
 }
 
 static void venus_soft_int(struct venus_hfi_device *hdev)
diff -Nrup linux-6.16.6/drivers/media/platform/qcom/venus/pm_helpers.c linux-lenovo-x13s-linux-6.16.y/drivers/media/platform/qcom/venus/pm_helpers.c
--- linux-6.16.6/drivers/media/platform/qcom/venus/pm_helpers.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/media/platform/qcom/venus/pm_helpers.c	2025-09-11 09:47:42.000000000 -0600
@@ -237,6 +237,9 @@ static int load_scale_bw(struct venus_co
 	dev_dbg(core->dev, VDBGL "total: avg_bw: %u, peak_bw: %u\n",
 		total_avg, total_peak);
 
+	if (core->res->has_llcc_path)
+		icc_set_bw(core->llcc_path, total_avg, total_peak);
+
 	return icc_set_bw(core->video_path, total_avg, total_peak);
 }
 
diff -Nrup linux-6.16.6/drivers/media/v4l2-core/v4l2-subdev.c linux-lenovo-x13s-linux-6.16.y/drivers/media/v4l2-core/v4l2-subdev.c
--- linux-6.16.6/drivers/media/v4l2-core/v4l2-subdev.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/media/v4l2-core/v4l2-subdev.c	2025-09-11 09:47:42.000000000 -0600
@@ -2563,7 +2563,7 @@ EXPORT_SYMBOL_GPL(v4l2_subdev_is_streami
 int v4l2_subdev_get_privacy_led(struct v4l2_subdev *sd)
 {
 #if IS_REACHABLE(CONFIG_LEDS_CLASS)
-	sd->privacy_led = led_get(sd->dev, "privacy-led");
+	sd->privacy_led = led_get(sd->dev, "privacy");
 	if (IS_ERR(sd->privacy_led) && PTR_ERR(sd->privacy_led) != -ENOENT)
 		return dev_err_probe(sd->dev, PTR_ERR(sd->privacy_led),
 				     "getting privacy LED\n");
diff -Nrup linux-6.16.6/drivers/net/wireless/ath/ath11k/core.c linux-lenovo-x13s-linux-6.16.y/drivers/net/wireless/ath/ath11k/core.c
--- linux-6.16.6/drivers/net/wireless/ath/ath11k/core.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/net/wireless/ath/ath11k/core.c	2025-09-11 09:47:42.000000000 -0600
@@ -2581,10 +2581,15 @@ int ath11k_core_init(struct ath11k_base
 	ret = ath11k_core_soc_create(ab);
 	if (ret) {
 		ath11k_err(ab, "failed to create soc core: %d\n", ret);
-		return ret;
+		goto err_unregister_pm_notifier;
 	}
 
 	return 0;
+
+err_unregister_pm_notifier:
+	ath11k_core_pm_notifier_unregister(ab);
+
+	return ret;
 }
 EXPORT_SYMBOL(ath11k_core_init);
 
diff -Nrup linux-6.16.6/drivers/net/wireless/ath/ath11k/dp_rx.c linux-lenovo-x13s-linux-6.16.y/drivers/net/wireless/ath/ath11k/dp_rx.c
--- linux-6.16.6/drivers/net/wireless/ath/ath11k/dp_rx.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/net/wireless/ath/ath11k/dp_rx.c	2025-09-11 09:47:42.000000000 -0600
@@ -2537,7 +2537,7 @@ static int ath11k_dp_rx_process_msdu(str
 	lrx_desc = (struct hal_rx_desc *)last_buf->data;
 	rx_attention = ath11k_dp_rx_get_attention(ab, lrx_desc);
 	if (!ath11k_dp_rx_h_attn_msdu_done(rx_attention)) {
-		ath11k_warn(ab, "msdu_done bit in attention is not set\n");
+		/* ath11k_warn(ab, "msdu_done bit in attention is not set\n"); */
 		ret = -EIO;
 		goto free_out;
 	}
@@ -2637,7 +2637,7 @@ int ath11k_dp_process_rx(struct ath11k_b
 	struct ath11k *ar;
 	struct hal_reo_dest_ring *desc;
 	enum hal_reo_dest_ring_push_reason push_reason;
-	u32 cookie, info0, rx_msdu_info0, rx_mpdu_info0;
+	u32 cookie;
 	int i;
 
 	for (i = 0; i < MAX_RADIOS; i++)
@@ -2654,7 +2654,7 @@ try_again:
 	      (struct hal_reo_dest_ring *)ath11k_hal_srng_dst_get_next_entry(ab,
 									     srng))) {
 		cookie = FIELD_GET(BUFFER_ADDR_INFO1_SW_COOKIE,
-				   READ_ONCE(desc->buf_addr_info.info1));
+				   desc->buf_addr_info.info1);
 		buf_id = FIELD_GET(DP_RXDMA_BUF_COOKIE_BUF_ID,
 				   cookie);
 		mac_id = FIELD_GET(DP_RXDMA_BUF_COOKIE_PDEV_ID, cookie);
@@ -2683,9 +2683,8 @@ try_again:
 
 		num_buffs_reaped[mac_id]++;
 
-		info0 = READ_ONCE(desc->info0);
 		push_reason = FIELD_GET(HAL_REO_DEST_RING_INFO0_PUSH_REASON,
-					info0);
+					desc->info0);
 		if (unlikely(push_reason !=
 			     HAL_REO_DEST_RING_PUSH_REASON_ROUTING_INSTRUCTION)) {
 			dev_kfree_skb_any(msdu);
@@ -2693,21 +2692,18 @@ try_again:
 			continue;
 		}
 
-		rx_msdu_info0 = READ_ONCE(desc->rx_msdu_info.info0);
-		rx_mpdu_info0 = READ_ONCE(desc->rx_mpdu_info.info0);
-
-		rxcb->is_first_msdu = !!(rx_msdu_info0 &
+		rxcb->is_first_msdu = !!(desc->rx_msdu_info.info0 &
 					 RX_MSDU_DESC_INFO0_FIRST_MSDU_IN_MPDU);
-		rxcb->is_last_msdu = !!(rx_msdu_info0 &
+		rxcb->is_last_msdu = !!(desc->rx_msdu_info.info0 &
 					RX_MSDU_DESC_INFO0_LAST_MSDU_IN_MPDU);
-		rxcb->is_continuation = !!(rx_msdu_info0 &
+		rxcb->is_continuation = !!(desc->rx_msdu_info.info0 &
 					   RX_MSDU_DESC_INFO0_MSDU_CONTINUATION);
 		rxcb->peer_id = FIELD_GET(RX_MPDU_DESC_META_DATA_PEER_ID,
-					  READ_ONCE(desc->rx_mpdu_info.meta_data));
+					  desc->rx_mpdu_info.meta_data);
 		rxcb->seq_no = FIELD_GET(RX_MPDU_DESC_INFO0_SEQ_NUM,
-					 rx_mpdu_info0);
+					 desc->rx_mpdu_info.info0);
 		rxcb->tid = FIELD_GET(HAL_REO_DEST_RING_INFO0_RX_QUEUE_NUM,
-				      info0);
+				      desc->info0);
 
 		rxcb->mac_id = mac_id;
 		__skb_queue_tail(&msdu_list[mac_id], msdu);
diff -Nrup linux-6.16.6/drivers/net/wireless/ath/ath11k/hal.c linux-lenovo-x13s-linux-6.16.y/drivers/net/wireless/ath/ath11k/hal.c
--- linux-6.16.6/drivers/net/wireless/ath/ath11k/hal.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/net/wireless/ath/ath11k/hal.c	2025-09-11 09:47:42.000000000 -0600
@@ -599,7 +599,7 @@ u32 ath11k_hal_ce_dst_status_get_length(
 	struct hal_ce_srng_dst_status_desc *desc = buf;
 	u32 len;
 
-	len = FIELD_GET(HAL_CE_DST_STATUS_DESC_FLAGS_LEN, READ_ONCE(desc->flags));
+	len = FIELD_GET(HAL_CE_DST_STATUS_DESC_FLAGS_LEN, desc->flags);
 	desc->flags &= ~HAL_CE_DST_STATUS_DESC_FLAGS_LEN;
 
 	return len;
diff -Nrup linux-6.16.6/drivers/net/wireless/ath/ath12k/hal.c linux-lenovo-x13s-linux-6.16.y/drivers/net/wireless/ath/ath12k/hal.c
--- linux-6.16.6/drivers/net/wireless/ath/ath12k/hal.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/net/wireless/ath/ath12k/hal.c	2025-09-11 09:47:42.000000000 -0600
@@ -1950,7 +1950,7 @@ u32 ath12k_hal_ce_dst_status_get_length(
 {
 	u32 len;
 
-	len = le32_get_bits(READ_ONCE(desc->flags), HAL_CE_DST_STATUS_DESC_FLAGS_LEN);
+	len = le32_get_bits(desc->flags, HAL_CE_DST_STATUS_DESC_FLAGS_LEN);
 	desc->flags &= ~cpu_to_le32(HAL_CE_DST_STATUS_DESC_FLAGS_LEN);
 
 	return len;
diff -Nrup linux-6.16.6/drivers/net/wireless/ath/ath12k/mac.c linux-lenovo-x13s-linux-6.16.y/drivers/net/wireless/ath/ath12k/mac.c
--- linux-6.16.6/drivers/net/wireless/ath/ath12k/mac.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/net/wireless/ath/ath12k/mac.c	2025-09-11 09:47:42.000000000 -0600
@@ -4955,9 +4955,9 @@ static int ath12k_mac_set_key(struct ath
 	}
 
 	if (key->flags & IEEE80211_KEY_FLAG_PAIRWISE)
-		flags |= WMI_KEY_PAIRWISE;
+		flags = WMI_KEY_PAIRWISE;
 	else
-		flags |= WMI_KEY_GROUP;
+		flags = WMI_KEY_GROUP;
 
 	ret = ath12k_install_key(arvif, key, cmd, peer_addr, flags);
 	if (ret) {
diff -Nrup linux-6.16.6/drivers/pci/controller/dwc/Kconfig linux-lenovo-x13s-linux-6.16.y/drivers/pci/controller/dwc/Kconfig
--- linux-6.16.6/drivers/pci/controller/dwc/Kconfig	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/pci/controller/dwc/Kconfig	2025-09-11 09:47:42.000000000 -0600
@@ -290,7 +290,7 @@ config PCIE_QCOM_COMMON
 	bool
 
 config PCIE_QCOM
-	bool "Qualcomm PCIe controller (host mode)"
+	tristate "Qualcomm PCIe controller (host mode)"
 	depends on OF && (ARCH_QCOM || COMPILE_TEST)
 	depends on PCI_MSI
 	select PCIE_DW_HOST
diff -Nrup linux-6.16.6/drivers/pci/controller/dwc/pcie-qcom.c linux-lenovo-x13s-linux-6.16.y/drivers/pci/controller/dwc/pcie-qcom.c
--- linux-6.16.6/drivers/pci/controller/dwc/pcie-qcom.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/pci/controller/dwc/pcie-qcom.c	2025-09-11 09:47:42.000000000 -0600
@@ -20,6 +20,8 @@
 #include <linux/kernel.h>
 #include <linux/limits.h>
 #include <linux/init.h>
+#include <linux/module.h>
+#include <linux/notifier.h>
 #include <linux/of.h>
 #include <linux/pci.h>
 #include <linux/pm_opp.h>
@@ -244,7 +246,6 @@ struct qcom_pcie_ops {
 	int (*get_resources)(struct qcom_pcie *pcie);
 	int (*init)(struct qcom_pcie *pcie);
 	int (*post_init)(struct qcom_pcie *pcie);
-	void (*host_post_init)(struct qcom_pcie *pcie);
 	void (*deinit)(struct qcom_pcie *pcie);
 	void (*ltssm_enable)(struct qcom_pcie *pcie);
 	int (*config_sid)(struct qcom_pcie *pcie);
@@ -274,6 +275,7 @@ struct qcom_pcie {
 	struct icc_path *icc_cpu;
 	const struct qcom_pcie_cfg *cfg;
 	struct dentry *debugfs;
+	struct notifier_block nb;
 	bool suspended;
 	bool use_pm_opp;
 };
@@ -1016,25 +1018,6 @@ static int qcom_pcie_post_init_2_7_0(str
 	return 0;
 }
 
-static int qcom_pcie_enable_aspm(struct pci_dev *pdev, void *userdata)
-{
-	/*
-	 * Downstream devices need to be in D0 state before enabling PCI PM
-	 * substates.
-	 */
-	pci_set_power_state_locked(pdev, PCI_D0);
-	pci_enable_link_state_locked(pdev, PCIE_LINK_STATE_ALL);
-
-	return 0;
-}
-
-static void qcom_pcie_host_post_init_2_7_0(struct qcom_pcie *pcie)
-{
-	struct dw_pcie_rp *pp = &pcie->pci->pp;
-
-	pci_walk_bus(pp->bridge->bus, qcom_pcie_enable_aspm, NULL);
-}
-
 static void qcom_pcie_deinit_2_7_0(struct qcom_pcie *pcie)
 {
 	struct qcom_pcie_resources_2_7_0 *res = &pcie->res.v2_7_0;
@@ -1285,19 +1268,9 @@ static void qcom_pcie_host_deinit(struct
 	pcie->cfg->ops->deinit(pcie);
 }
 
-static void qcom_pcie_host_post_init(struct dw_pcie_rp *pp)
-{
-	struct dw_pcie *pci = to_dw_pcie_from_pp(pp);
-	struct qcom_pcie *pcie = to_qcom_pcie(pci);
-
-	if (pcie->cfg->ops->host_post_init)
-		pcie->cfg->ops->host_post_init(pcie);
-}
-
 static const struct dw_pcie_host_ops qcom_pcie_dw_ops = {
 	.init		= qcom_pcie_host_init,
 	.deinit		= qcom_pcie_host_deinit,
-	.post_init	= qcom_pcie_host_post_init,
 };
 
 /* Qcom IP rev.: 2.1.0	Synopsys IP rev.: 4.01a */
@@ -1359,7 +1332,6 @@ static const struct qcom_pcie_ops ops_1_
 	.get_resources = qcom_pcie_get_resources_2_7_0,
 	.init = qcom_pcie_init_2_7_0,
 	.post_init = qcom_pcie_post_init_2_7_0,
-	.host_post_init = qcom_pcie_host_post_init_2_7_0,
 	.deinit = qcom_pcie_deinit_2_7_0,
 	.ltssm_enable = qcom_pcie_2_3_2_ltssm_enable,
 	.config_sid = qcom_pcie_config_sid_1_9_0,
@@ -1370,7 +1342,6 @@ static const struct qcom_pcie_ops ops_1_
 	.get_resources = qcom_pcie_get_resources_2_7_0,
 	.init = qcom_pcie_init_2_7_0,
 	.post_init = qcom_pcie_post_init_2_7_0,
-	.host_post_init = qcom_pcie_host_post_init_2_7_0,
 	.deinit = qcom_pcie_deinit_2_7_0,
 	.ltssm_enable = qcom_pcie_2_3_2_ltssm_enable,
 };
@@ -1580,6 +1551,38 @@ static irqreturn_t qcom_pcie_global_irq_
 	return IRQ_HANDLED;
 }
 
+static int qcom_pcie_enable_aspm(struct pci_dev *pdev)
+{
+	/*
+	 * Downstream devices need to be in D0 state before enabling PCI PM
+	 * substates.
+	 */
+	pci_set_power_state(pdev, PCI_D0);
+	pci_enable_link_state(pdev, PCIE_LINK_STATE_ALL);
+
+	return 0;
+}
+
+static int pcie_qcom_notify(struct notifier_block *nb, unsigned long action,
+		void *data)
+{
+	struct device *dev = data;
+	struct pci_dev *pdev = to_pci_dev(dev);
+
+	switch (action) {
+	case BUS_NOTIFY_BIND_DRIVER:
+		qcom_pcie_enable_aspm(pdev);
+		break;
+	}
+
+	return NOTIFY_DONE;
+}
+
+static void qcom_pcie_deinit_debugfs(struct qcom_pcie *pcie)
+{
+	debugfs_remove(pcie->debugfs);
+}
+
 static int qcom_pcie_probe(struct platform_device *pdev)
 {
 	const struct qcom_pcie_cfg *pcie_cfg;
@@ -1710,10 +1713,15 @@ static int qcom_pcie_probe(struct platfo
 	if (irq > 0)
 		pp->use_linkup_irq = true;
 
+	pcie->nb.notifier_call = pcie_qcom_notify;
+	ret = bus_register_notifier(&pci_bus_type, &pcie->nb);
+	if (ret)
+		goto err_phy_exit;
+
 	ret = dw_pcie_host_init(pp);
 	if (ret) {
 		dev_err(dev, "cannot initialize host\n");
-		goto err_phy_exit;
+		goto err_unregister_notifier;
 	}
 
 	name = devm_kasprintf(dev, GFP_KERNEL, "qcom_pcie_global_irq%d",
@@ -1746,6 +1754,8 @@ static int qcom_pcie_probe(struct platfo
 
 err_host_deinit:
 	dw_pcie_host_deinit(pp);
+err_unregister_notifier:
+	bus_unregister_notifier(&pci_bus_type, &pcie->nb);
 err_phy_exit:
 	phy_exit(pcie->phy);
 err_pm_runtime_put:
@@ -1755,6 +1765,23 @@ err_pm_runtime_put:
 	return ret;
 }
 
+static void qcom_pcie_remove(struct platform_device *pdev)
+{
+	struct qcom_pcie *pcie = platform_get_drvdata(pdev);
+	struct device *dev = &pdev->dev;
+
+	qcom_pcie_deinit_debugfs(pcie);
+
+	dw_pcie_host_deinit(&pcie->pci->pp);
+
+	bus_unregister_notifier(&pci_bus_type, &pcie->nb);
+
+	phy_exit(pcie->phy);
+
+	pm_runtime_put_sync(dev);
+	pm_runtime_disable(dev);
+}
+
 static int qcom_pcie_suspend_noirq(struct device *dev)
 {
 	struct qcom_pcie *pcie = dev_get_drvdata(dev);
@@ -1866,6 +1893,7 @@ static const struct of_device_id qcom_pc
 	{ .compatible = "qcom,pcie-x1e80100", .data = &cfg_sc8280xp },
 	{ }
 };
+MODULE_DEVICE_TABLE(of, qcom_pcie_match);
 
 static void qcom_fixup_class(struct pci_dev *dev)
 {
@@ -1885,12 +1913,16 @@ static const struct dev_pm_ops qcom_pcie
 
 static struct platform_driver qcom_pcie_driver = {
 	.probe = qcom_pcie_probe,
+	.remove = qcom_pcie_remove,
 	.driver = {
 		.name = "qcom-pcie",
-		.suppress_bind_attrs = true,
 		.of_match_table = qcom_pcie_match,
 		.pm = &qcom_pcie_pm_ops,
 		.probe_type = PROBE_PREFER_ASYNCHRONOUS,
 	},
 };
-builtin_platform_driver(qcom_pcie_driver);
+module_platform_driver(qcom_pcie_driver);
+
+MODULE_AUTHOR("Stanimir Varbanov <svarbanov@mm-sol.com>");
+MODULE_DESCRIPTION("Qualcomm PCIe root complex driver");
+MODULE_LICENSE("GPL");
diff -Nrup linux-6.16.6/drivers/phy/broadcom/phy-bcm-ns2-pcie.c linux-lenovo-x13s-linux-6.16.y/drivers/phy/broadcom/phy-bcm-ns2-pcie.c
--- linux-6.16.6/drivers/phy/broadcom/phy-bcm-ns2-pcie.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/phy/broadcom/phy-bcm-ns2-pcie.c	2025-09-11 09:47:42.000000000 -0600
@@ -61,8 +61,6 @@ static int ns2_pci_phy_probe(struct mdio
 		return PTR_ERR(provider);
 	}
 
-	dev_info(dev, "%s PHY registered\n", dev_name(dev));
-
 	return 0;
 }
 
diff -Nrup linux-6.16.6/drivers/phy/broadcom/phy-bcm-ns2-usbdrd.c linux-lenovo-x13s-linux-6.16.y/drivers/phy/broadcom/phy-bcm-ns2-usbdrd.c
--- linux-6.16.6/drivers/phy/broadcom/phy-bcm-ns2-usbdrd.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/phy/broadcom/phy-bcm-ns2-usbdrd.c	2025-09-11 09:47:42.000000000 -0600
@@ -395,7 +395,6 @@ static int ns2_drd_phy_probe(struct plat
 
 	platform_set_drvdata(pdev, driver);
 
-	dev_info(dev, "Registered NS2 DRD Phy device\n");
 	queue_delayed_work(system_power_efficient_wq, &driver->wq_extcon,
 			   driver->debounce_jiffies);
 
diff -Nrup linux-6.16.6/drivers/phy/broadcom/phy-bcm-sr-pcie.c linux-lenovo-x13s-linux-6.16.y/drivers/phy/broadcom/phy-bcm-sr-pcie.c
--- linux-6.16.6/drivers/phy/broadcom/phy-bcm-sr-pcie.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/phy/broadcom/phy-bcm-sr-pcie.c	2025-09-11 09:47:42.000000000 -0600
@@ -277,8 +277,6 @@ static int sr_pcie_phy_probe(struct plat
 		return PTR_ERR(provider);
 	}
 
-	dev_info(dev, "Stingray PCIe PHY driver initialized\n");
-
 	return 0;
 }
 
diff -Nrup linux-6.16.6/drivers/phy/broadcom/phy-brcm-sata.c linux-lenovo-x13s-linux-6.16.y/drivers/phy/broadcom/phy-brcm-sata.c
--- linux-6.16.6/drivers/phy/broadcom/phy-brcm-sata.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/phy/broadcom/phy-brcm-sata.c	2025-09-11 09:47:42.000000000 -0600
@@ -832,7 +832,7 @@ static int brcm_sata_phy_probe(struct pl
 		return PTR_ERR(provider);
 	}
 
-	dev_info(dev, "registered %d port(s)\n", count);
+	dev_dbg(dev, "registered %d port(s)\n", count);
 
 	return 0;
 }
diff -Nrup linux-6.16.6/drivers/phy/marvell/phy-pxa-usb.c linux-lenovo-x13s-linux-6.16.y/drivers/phy/marvell/phy-pxa-usb.c
--- linux-6.16.6/drivers/phy/marvell/phy-pxa-usb.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/phy/marvell/phy-pxa-usb.c	2025-09-11 09:47:42.000000000 -0600
@@ -325,7 +325,6 @@ static int pxa_usb_phy_probe(struct plat
 		phy_create_lookup(pxa_usb_phy->phy, "usb", "mv-otg");
 	}
 
-	dev_info(dev, "Marvell PXA USB PHY");
 	return 0;
 }
 
diff -Nrup linux-6.16.6/drivers/phy/phy-snps-eusb2.c linux-lenovo-x13s-linux-6.16.y/drivers/phy/phy-snps-eusb2.c
--- linux-6.16.6/drivers/phy/phy-snps-eusb2.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/phy/phy-snps-eusb2.c	2025-09-11 09:47:42.000000000 -0600
@@ -256,7 +256,7 @@ static int exynos_eusb2_ref_clk_init(str
 	}
 
 	if (!config) {
-		dev_err(&phy->phy->dev, "unsupported ref_clk_freq:%lu\n", ref_clk_freq);
+		dev_err(&phy->phy->dev, "unsupported ref_clk_freq: %lu\n", ref_clk_freq);
 		return -EINVAL;
 	}
 
@@ -293,7 +293,7 @@ static int qcom_eusb2_ref_clk_init(struc
 	}
 
 	if (!config) {
-		dev_err(&phy->phy->dev, "unsupported ref_clk_freq:%lu\n", ref_clk_freq);
+		dev_err(&phy->phy->dev, "unsupported ref_clk_freq: %lu\n", ref_clk_freq);
 		return -EINVAL;
 	}
 
@@ -464,39 +464,40 @@ static int snps_eusb2_hsphy_init(struct
 
 	ret = phy_init(phy->repeater);
 	if (ret) {
-		dev_err(&p->dev, "repeater init failed. %d\n", ret);
+		dev_err(&p->dev, "repeater init failed: %d\n", ret);
 		goto disable_vreg;
 	}
 
 	ret = clk_bulk_prepare_enable(phy->data->num_clks, phy->clks);
 	if (ret) {
-		dev_err(&p->dev, "failed to enable ref clock, %d\n", ret);
-		goto disable_vreg;
+		dev_err(&p->dev, "failed to enable ref clock: %d\n", ret);
+		goto exit_repeater;
 	}
 
 	ret = reset_control_assert(phy->phy_reset);
 	if (ret) {
-		dev_err(&p->dev, "failed to assert phy_reset, %d\n", ret);
-		goto disable_ref_clk;
+		dev_err(&p->dev, "failed to assert phy_reset: %d\n", ret);
+		goto disable_clks;
 	}
 
 	usleep_range(100, 150);
 
 	ret = reset_control_deassert(phy->phy_reset);
 	if (ret) {
-		dev_err(&p->dev, "failed to de-assert phy_reset, %d\n", ret);
-		goto disable_ref_clk;
+		dev_err(&p->dev, "failed to de-assert phy_reset: %d\n", ret);
+		goto disable_clks;
 	}
 
 	ret = phy->data->phy_init(p);
 	if (ret)
-		goto disable_ref_clk;
+		goto disable_clks;
 
 	return 0;
 
-disable_ref_clk:
+disable_clks:
 	clk_bulk_disable_unprepare(phy->data->num_clks, phy->clks);
-
+exit_repeater:
+	phy_exit(phy->repeater);
 disable_vreg:
 	regulator_bulk_disable(ARRAY_SIZE(phy->vregs), phy->vregs);
 
@@ -507,7 +508,7 @@ static int snps_eusb2_hsphy_exit(struct
 {
 	struct snps_eusb2_hsphy *phy = phy_get_drvdata(p);
 
-	clk_disable_unprepare(phy->ref_clk);
+	clk_bulk_disable_unprepare(phy->data->num_clks, phy->clks);
 
 	regulator_bulk_disable(ARRAY_SIZE(phy->vregs), phy->vregs);
 
@@ -554,7 +555,7 @@ static int snps_eusb2_hsphy_probe(struct
 	if (!phy->clks)
 		return -ENOMEM;
 
-	for (int i = 0; i < phy->data->num_clks; ++i)
+	for (i = 0; i < phy->data->num_clks; ++i)
 		phy->clks[i].id = phy->data->clk_names[i];
 
 	ret = devm_clk_bulk_get(dev, phy->data->num_clks, phy->clks);
@@ -563,7 +564,7 @@ static int snps_eusb2_hsphy_probe(struct
 				     "failed to get phy clock(s)\n");
 
 	phy->ref_clk = NULL;
-	for (int i = 0; i < phy->data->num_clks; ++i) {
+	for (i = 0; i < phy->data->num_clks; ++i) {
 		if (!strcmp(phy->clks[i].id, "ref")) {
 			phy->ref_clk = phy->clks[i].clk;
 			break;
@@ -585,14 +586,14 @@ static int snps_eusb2_hsphy_probe(struct
 		return dev_err_probe(dev, ret,
 				     "failed to get regulator supplies\n");
 
-	phy->repeater = devm_of_phy_optional_get(dev, np, 0);
+	phy->repeater = devm_of_phy_optional_get(dev, np, NULL);
 	if (IS_ERR(phy->repeater))
 		return dev_err_probe(dev, PTR_ERR(phy->repeater),
 				     "failed to get repeater\n");
 
 	generic_phy = devm_phy_create(dev, NULL, &snps_eusb2_hsphy_ops);
 	if (IS_ERR(generic_phy)) {
-		dev_err(dev, "failed to create phy %d\n", ret);
+		dev_err(dev, "failed to create phy: %d\n", ret);
 		return PTR_ERR(generic_phy);
 	}
 
@@ -603,8 +604,6 @@ static int snps_eusb2_hsphy_probe(struct
 	if (IS_ERR(phy_provider))
 		return PTR_ERR(phy_provider);
 
-	dev_info(dev, "Registered Snps-eUSB2 phy\n");
-
 	return 0;
 }
 
@@ -615,7 +614,9 @@ static const struct of_device_id snps_eu
 	}, {
 		.compatible = "samsung,exynos2200-eusb2-phy",
 		.data = &exynos2200_snps_eusb2_phy,
-	}, { },
+	}, {
+		/* sentinel */
+	}
 };
 MODULE_DEVICE_TABLE(of, snps_eusb2_hsphy_of_match_table);
 
diff -Nrup linux-6.16.6/drivers/phy/qualcomm/phy-qcom-eusb2-repeater.c linux-lenovo-x13s-linux-6.16.y/drivers/phy/qualcomm/phy-qcom-eusb2-repeater.c
--- linux-6.16.6/drivers/phy/qualcomm/phy-qcom-eusb2-repeater.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/phy/qualcomm/phy-qcom-eusb2-repeater.c	2025-09-11 09:47:42.000000000 -0600
@@ -241,8 +241,6 @@ static int eusb2_repeater_probe(struct p
 	if (IS_ERR(phy_provider))
 		return PTR_ERR(phy_provider);
 
-	dev_info(dev, "Registered Qcom-eUSB2 repeater\n");
-
 	return 0;
 }
 
diff -Nrup linux-6.16.6/drivers/phy/qualcomm/phy-qcom-m31.c linux-lenovo-x13s-linux-6.16.y/drivers/phy/qualcomm/phy-qcom-m31.c
--- linux-6.16.6/drivers/phy/qualcomm/phy-qcom-m31.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/phy/qualcomm/phy-qcom-m31.c	2025-09-11 09:47:42.000000000 -0600
@@ -311,8 +311,6 @@ static int m31usb_phy_probe(struct platf
 	phy_set_drvdata(qphy->phy, qphy);
 
 	phy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);
-	if (!IS_ERR(phy_provider))
-		dev_info(dev, "Registered M31 USB phy\n");
 
 	return PTR_ERR_OR_ZERO(phy_provider);
 }
diff -Nrup linux-6.16.6/drivers/phy/qualcomm/phy-qcom-qmp-combo.c linux-lenovo-x13s-linux-6.16.y/drivers/phy/qualcomm/phy-qcom-qmp-combo.c
--- linux-6.16.6/drivers/phy/qualcomm/phy-qcom-qmp-combo.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/phy/qualcomm/phy-qcom-qmp-combo.c	2025-09-11 09:47:42.000000000 -0600
@@ -19,6 +19,7 @@
 #include <linux/reset.h>
 #include <linux/slab.h>
 #include <linux/usb/typec.h>
+#include <linux/usb/typec_dp.h>
 #include <linux/usb/typec_mux.h>
 
 #include <drm/bridge/aux-bridge.h>
@@ -61,6 +62,12 @@
 
 #define PHY_INIT_COMPLETE_TIMEOUT		10000
 
+enum qmpphy_mode {
+	QMPPHY_MODE_USB3DP = 0,
+	QMPPHY_MODE_DP_ONLY,
+	QMPPHY_MODE_USB3_ONLY,
+};
+
 /* set of registers with offsets different per-PHY */
 enum qphy_reg_layout {
 	/* PCS registers */
@@ -1685,15 +1692,17 @@ struct qmp_combo {
 
 	struct mutex phy_mutex;
 	int init_count;
+	enum qmpphy_mode qmpphy_mode;
 
 	struct phy *usb_phy;
-	enum phy_mode mode;
+	enum phy_mode phy_mode;
 	unsigned int usb_init_count;
 
 	struct phy *dp_phy;
 	unsigned int dp_aux_cfg;
 	struct phy_configure_opts_dp dp_opts;
 	unsigned int dp_init_count;
+	bool dp_powered_on;
 
 	struct clk_fixed_rate pipe_clk_fixed;
 	struct clk_hw dp_link_hw;
@@ -1701,6 +1710,8 @@ struct qmp_combo {
 
 	struct typec_switch_dev *sw;
 	enum typec_orientation orientation;
+
+	struct typec_mux_dev *mux;
 };
 
 static void qmp_v3_dp_aux_init(struct qmp_combo *qmp);
@@ -2816,12 +2827,33 @@ static int qmp_combo_com_init(struct qmp
 	if (qmp->orientation == TYPEC_ORIENTATION_REVERSE)
 		val |= SW_PORTSELECT_VAL;
 	writel(val, com + QPHY_V3_DP_COM_TYPEC_CTRL);
-	writel(USB3_MODE | DP_MODE, com + QPHY_V3_DP_COM_PHY_MODE_CTRL);
 
-	/* bring both QMP USB and QMP DP PHYs PCS block out of reset */
-	qphy_clrbits(com, QPHY_V3_DP_COM_RESET_OVRD_CTRL,
-			SW_DPPHY_RESET_MUX | SW_DPPHY_RESET |
-			SW_USB3PHY_RESET_MUX | SW_USB3PHY_RESET);
+	switch (qmp->qmpphy_mode) {
+	case QMPPHY_MODE_USB3DP:
+		writel(USB3_MODE | DP_MODE, com + QPHY_V3_DP_COM_PHY_MODE_CTRL);
+
+		/* bring both QMP USB and QMP DP PHYs PCS block out of reset */
+		qphy_clrbits(com, QPHY_V3_DP_COM_RESET_OVRD_CTRL,
+				SW_DPPHY_RESET_MUX | SW_DPPHY_RESET |
+				SW_USB3PHY_RESET_MUX | SW_USB3PHY_RESET);
+		break;
+
+	case QMPPHY_MODE_DP_ONLY:
+		writel(DP_MODE, com + QPHY_V3_DP_COM_PHY_MODE_CTRL);
+
+		/* bring QMP DP PHY PCS block out of reset */
+		qphy_clrbits(com, QPHY_V3_DP_COM_RESET_OVRD_CTRL,
+				SW_DPPHY_RESET_MUX | SW_DPPHY_RESET);
+		break;
+
+	case QMPPHY_MODE_USB3_ONLY:
+		writel(USB3_MODE, com + QPHY_V3_DP_COM_PHY_MODE_CTRL);
+
+		/* bring QMP USB PHY PCS block out of reset */
+		qphy_clrbits(com, QPHY_V3_DP_COM_RESET_OVRD_CTRL,
+				SW_USB3PHY_RESET_MUX | SW_USB3PHY_RESET);
+		break;
+	}
 
 	qphy_clrbits(com, QPHY_V3_DP_COM_SWI_CTRL, 0x03);
 	qphy_clrbits(com, QPHY_V3_DP_COM_SW_RESET, SW_RESET);
@@ -2913,6 +2945,8 @@ static int qmp_combo_dp_power_on(struct
 	/* Configure link rate, swing, etc. */
 	cfg->configure_dp_phy(qmp);
 
+	qmp->dp_powered_on = true;
+
 	mutex_unlock(&qmp->phy_mutex);
 
 	return 0;
@@ -2927,6 +2961,8 @@ static int qmp_combo_dp_power_off(struct
 	/* Assert DP PHY power down */
 	writel(DP_PHY_PD_CTL_PSR_PWRDN, qmp->dp_dp_phy + QSERDES_DP_PHY_PD_CTL);
 
+	qmp->dp_powered_on = false;
+
 	mutex_unlock(&qmp->phy_mutex);
 
 	return 0;
@@ -3062,7 +3098,7 @@ static int qmp_combo_usb_set_mode(struct
 {
 	struct qmp_combo *qmp = phy_get_drvdata(phy);
 
-	qmp->mode = mode;
+	qmp->phy_mode = mode;
 
 	return 0;
 }
@@ -3091,8 +3127,8 @@ static void qmp_combo_enable_autonomous_
 	void __iomem *pcs_misc = qmp->pcs_misc;
 	u32 intr_mask;
 
-	if (qmp->mode == PHY_MODE_USB_HOST_SS ||
-	    qmp->mode == PHY_MODE_USB_DEVICE_SS)
+	if (qmp->phy_mode == PHY_MODE_USB_HOST_SS ||
+	    qmp->phy_mode == PHY_MODE_USB_DEVICE_SS)
 		intr_mask = ARCVR_DTCT_EN | ALFPS_DTCT_EN;
 	else
 		intr_mask = ARCVR_DTCT_EN | ARCVR_DTCT_EVENT_SEL;
@@ -3135,7 +3171,7 @@ static int __maybe_unused qmp_combo_runt
 {
 	struct qmp_combo *qmp = dev_get_drvdata(dev);
 
-	dev_vdbg(dev, "Suspending QMP phy, mode:%d\n", qmp->mode);
+	dev_vdbg(dev, "Suspending QMP phy, mode:%d\n", qmp->phy_mode);
 
 	if (!qmp->init_count) {
 		dev_vdbg(dev, "PHY not initialized, bailing out\n");
@@ -3155,7 +3191,7 @@ static int __maybe_unused qmp_combo_runt
 	struct qmp_combo *qmp = dev_get_drvdata(dev);
 	int ret = 0;
 
-	dev_vdbg(dev, "Resuming QMP phy, mode:%d\n", qmp->mode);
+	dev_vdbg(dev, "Resuming QMP phy, mode:%d\n", qmp->phy_mode);
 
 	if (!qmp->init_count) {
 		dev_vdbg(dev, "PHY not initialized, bailing out\n");
@@ -3549,17 +3585,109 @@ static int qmp_combo_typec_switch_set(st
 	return 0;
 }
 
-static void qmp_combo_typec_unregister(void *data)
+static int qmp_combo_typec_mux_set(struct typec_mux_dev *mux, struct typec_mux_state *state)
+{
+	struct qmp_combo *qmp = typec_mux_get_drvdata(mux);
+	const struct qmp_phy_cfg *cfg = qmp->cfg;
+	enum qmpphy_mode new_mode;
+	unsigned int svid;
+
+	guard(mutex)(&qmp->phy_mutex);
+
+	if (state->alt)
+		svid = state->alt->svid;
+	else
+		svid = 0;
+
+	if (svid == USB_TYPEC_DP_SID) {
+		switch (state->mode) {
+		/* DP Only */
+		case TYPEC_DP_STATE_C:
+		case TYPEC_DP_STATE_E:
+			new_mode = QMPPHY_MODE_DP_ONLY;
+			break;
+
+		/* DP + USB */
+		case TYPEC_DP_STATE_D:
+		case TYPEC_DP_STATE_F:
+
+		/* Safe fallback...*/
+		default:
+			new_mode = QMPPHY_MODE_USB3DP;
+			break;
+		}
+	} else {
+		/* No DP SVID => don't care, assume it's just USB3 */
+		new_mode = QMPPHY_MODE_USB3_ONLY;
+	}
+
+	if (new_mode == qmp->qmpphy_mode) {
+		dev_dbg(qmp->dev, "typec_mux_set: same qmpphy mode, bail out\n");
+		return 0;
+	}
+
+	if (qmp->qmpphy_mode != QMPPHY_MODE_USB3_ONLY && qmp->dp_powered_on) {
+		dev_dbg(qmp->dev, "typec_mux_set: DP PHY is still in use, delaying switch\n");
+		return 0;
+	}
+
+	dev_dbg(qmp->dev, "typec_mux_set: switching from qmpphy mode %d to %d\n",
+		qmp->qmpphy_mode, new_mode);
+
+	qmp->qmpphy_mode = new_mode;
+
+	if (qmp->init_count) {
+		if (qmp->usb_init_count)
+			qmp_combo_usb_power_off(qmp->usb_phy);
+
+		if (qmp->dp_init_count)
+			writel(DP_PHY_PD_CTL_PSR_PWRDN, qmp->dp_dp_phy + QSERDES_DP_PHY_PD_CTL);
+
+		qmp_combo_com_exit(qmp, true);
+
+		/* Now everything's powered down, power up the right PHYs */
+		qmp_combo_com_init(qmp, true);
+
+		if (new_mode == QMPPHY_MODE_DP_ONLY) {
+			if (qmp->usb_init_count)
+				qmp->usb_init_count--;
+		}
+
+		if (new_mode == QMPPHY_MODE_USB3DP || new_mode == QMPPHY_MODE_USB3_ONLY) {
+			qmp_combo_usb_power_on(qmp->usb_phy);
+			if (!qmp->usb_init_count)
+				qmp->usb_init_count++;
+		}
+
+		if (new_mode == QMPPHY_MODE_DP_ONLY || new_mode == QMPPHY_MODE_USB3DP) {
+			if (qmp->dp_init_count)
+				cfg->dp_aux_init(qmp);
+		}
+	}
+
+	return 0;
+}
+
+static void qmp_combo_typec_switch_unregister(void *data)
 {
 	struct qmp_combo *qmp = data;
 
 	typec_switch_unregister(qmp->sw);
 }
 
-static int qmp_combo_typec_switch_register(struct qmp_combo *qmp)
+static void qmp_combo_typec_mux_unregister(void *data)
+{
+	struct qmp_combo *qmp = data;
+
+	typec_mux_unregister(qmp->mux);
+}
+
+static int qmp_combo_typec_register(struct qmp_combo *qmp)
 {
 	struct typec_switch_desc sw_desc = {};
+	struct typec_mux_desc mux_desc = { };
 	struct device *dev = qmp->dev;
+	int ret;
 
 	sw_desc.drvdata = qmp;
 	sw_desc.fwnode = dev->fwnode;
@@ -3570,10 +3698,23 @@ static int qmp_combo_typec_switch_regist
 		return PTR_ERR(qmp->sw);
 	}
 
-	return devm_add_action_or_reset(dev, qmp_combo_typec_unregister, qmp);
+	ret = devm_add_action_or_reset(dev, qmp_combo_typec_switch_unregister, qmp);
+	if (ret)
+		return ret;
+
+	mux_desc.drvdata = qmp;
+	mux_desc.fwnode = dev->fwnode;
+	mux_desc.set = qmp_combo_typec_mux_set;
+	qmp->mux = typec_mux_register(dev, &mux_desc);
+	if (IS_ERR(qmp->mux)) {
+		dev_err(dev, "Unable to register typec mux: %pe\n", qmp->mux);
+		return PTR_ERR(qmp->mux);
+	}
+
+	return devm_add_action_or_reset(dev, qmp_combo_typec_mux_unregister, qmp);
 }
 #else
-static int qmp_combo_typec_switch_register(struct qmp_combo *qmp)
+static int qmp_combo_typec_register(struct qmp_combo *qmp)
 {
 	return 0;
 }
@@ -3806,7 +3947,7 @@ static int qmp_combo_probe(struct platfo
 	if (ret)
 		goto err_node_put;
 
-	ret = qmp_combo_typec_switch_register(qmp);
+	ret = qmp_combo_typec_register(qmp);
 	if (ret)
 		goto err_node_put;
 
@@ -3828,6 +3969,12 @@ static int qmp_combo_probe(struct platfo
 	if (ret)
 		goto err_node_put;
 
+	/*
+	 * The hw default is USB3_ONLY, but USB3+DP mode lets us more easily
+	 * check both sub-blocks' init tables for blunders at probe time.
+	 */
+	qmp->qmpphy_mode = QMPPHY_MODE_USB3DP;
+
 	qmp->usb_phy = devm_phy_create(dev, usb_np, &qmp_combo_usb_phy_ops);
 	if (IS_ERR(qmp->usb_phy)) {
 		ret = PTR_ERR(qmp->usb_phy);
diff -Nrup linux-6.16.6/drivers/phy/qualcomm/phy-qcom-qusb2.c linux-lenovo-x13s-linux-6.16.y/drivers/phy/qualcomm/phy-qcom-qusb2.c
--- linux-6.16.6/drivers/phy/qualcomm/phy-qcom-qusb2.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/phy/qualcomm/phy-qcom-qusb2.c	2025-09-11 09:47:42.000000000 -0600
@@ -1114,9 +1114,7 @@ static int qusb2_phy_probe(struct platfo
 	phy_set_drvdata(generic_phy, qphy);
 
 	phy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);
-	if (!IS_ERR(phy_provider))
-		dev_info(dev, "Registered Qcom-QUSB2 phy\n");
-	else
+	if (IS_ERR(phy_provider))
 		pm_runtime_disable(dev);
 
 	return PTR_ERR_OR_ZERO(phy_provider);
diff -Nrup linux-6.16.6/drivers/phy/st/phy-stih407-usb.c linux-lenovo-x13s-linux-6.16.y/drivers/phy/st/phy-stih407-usb.c
--- linux-6.16.6/drivers/phy/st/phy-stih407-usb.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/phy/st/phy-stih407-usb.c	2025-09-11 09:47:42.000000000 -0600
@@ -139,8 +139,6 @@ static int stih407_usb2_picophy_probe(st
 	if (IS_ERR(phy_provider))
 		return PTR_ERR(phy_provider);
 
-	dev_info(dev, "STiH407 USB Generic picoPHY driver probed!");
-
 	return 0;
 }
 
diff -Nrup linux-6.16.6/drivers/phy/st/phy-stm32-usbphyc.c linux-lenovo-x13s-linux-6.16.y/drivers/phy/st/phy-stm32-usbphyc.c
--- linux-6.16.6/drivers/phy/st/phy-stm32-usbphyc.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/phy/st/phy-stm32-usbphyc.c	2025-09-11 09:47:42.000000000 -0600
@@ -757,8 +757,8 @@ static int stm32_usbphyc_probe(struct pl
 	}
 
 	version = readl_relaxed(usbphyc->base + STM32_USBPHYC_VERSION);
-	dev_info(dev, "registered rev:%lu.%lu\n",
-		 FIELD_GET(MAJREV, version), FIELD_GET(MINREV, version));
+	dev_dbg(dev, "registered rev: %lu.%lu\n",
+		FIELD_GET(MAJREV, version), FIELD_GET(MINREV, version));
 
 	return 0;
 
diff -Nrup linux-6.16.6/drivers/phy/ti/phy-twl4030-usb.c linux-lenovo-x13s-linux-6.16.y/drivers/phy/ti/phy-twl4030-usb.c
--- linux-6.16.6/drivers/phy/ti/phy-twl4030-usb.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/phy/ti/phy-twl4030-usb.c	2025-09-11 09:47:42.000000000 -0600
@@ -784,7 +784,6 @@ static int twl4030_usb_probe(struct plat
 	pm_runtime_mark_last_busy(&pdev->dev);
 	pm_runtime_put_autosuspend(twl->dev);
 
-	dev_info(&pdev->dev, "Initialized TWL4030 USB module\n");
 	return 0;
 }
 
diff -Nrup linux-6.16.6/drivers/platform/x86/intel/int3472/led.c linux-lenovo-x13s-linux-6.16.y/drivers/platform/x86/intel/int3472/led.c
--- linux-6.16.6/drivers/platform/x86/intel/int3472/led.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/platform/x86/intel/int3472/led.c	2025-09-11 09:47:42.000000000 -0600
@@ -43,7 +43,7 @@ int skl_int3472_register_pled(struct int
 
 	int3472->pled.lookup.provider = int3472->pled.name;
 	int3472->pled.lookup.dev_id = int3472->sensor_name;
-	int3472->pled.lookup.con_id = "privacy-led";
+	int3472->pled.lookup.con_id = "privacy";
 	led_add_lookup(&int3472->pled.lookup);
 
 	return 0;
diff -Nrup linux-6.16.6/drivers/power/supply/qcom_battmgr.c linux-lenovo-x13s-linux-6.16.y/drivers/power/supply/qcom_battmgr.c
--- linux-6.16.6/drivers/power/supply/qcom_battmgr.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/power/supply/qcom_battmgr.c	2025-09-11 09:47:42.000000000 -0600
@@ -577,6 +577,8 @@ static int qcom_battmgr_bat_get_property
 		val->intval = battmgr->status.capacity;
 		break;
 	case POWER_SUPPLY_PROP_CAPACITY:
+		if (battmgr->status.percent == (unsigned int)-1)
+			return -ENODATA;
 		val->intval = battmgr->status.percent;
 		break;
 	case POWER_SUPPLY_PROP_TEMP:
@@ -617,6 +619,7 @@ static const enum power_supply_property
 	POWER_SUPPLY_PROP_STATUS,
 	POWER_SUPPLY_PROP_PRESENT,
 	POWER_SUPPLY_PROP_TECHNOLOGY,
+	POWER_SUPPLY_PROP_CAPACITY,
 	POWER_SUPPLY_PROP_CYCLE_COUNT,
 	POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN,
 	POWER_SUPPLY_PROP_VOLTAGE_NOW,
@@ -1065,6 +1068,21 @@ static void qcom_battmgr_sc8280xp_callba
 		battmgr->ac.online = source == BATTMGR_CHARGING_SOURCE_AC;
 		battmgr->usb.online = source == BATTMGR_CHARGING_SOURCE_USB;
 		battmgr->wireless.online = source == BATTMGR_CHARGING_SOURCE_WIRELESS;
+		if (battmgr->info.last_full_capacity != 0) {
+			/*
+			 * 100 * battmgr->status.capacity can overflow a 32bit
+			 * unsigned integer. Do a temporary cast to avoid that.
+			 */
+			battmgr->status.percent =
+				(uint64_t)100 * battmgr->status.capacity /
+				battmgr->info.last_full_capacity;
+		} else {
+			/*
+			 * Let the sysfs handler know no data is available at
+			 * this time.
+			 */
+			battmgr->status.percent = (unsigned int)-1;
+		}
 		break;
 	case BATTMGR_BAT_DISCHARGE_TIME:
 		battmgr->status.discharge_time = le32_to_cpu(resp->time);
diff -Nrup linux-6.16.6/drivers/soc/qcom/icc-bwmon.c linux-lenovo-x13s-linux-6.16.y/drivers/soc/qcom/icc-bwmon.c
--- linux-6.16.6/drivers/soc/qcom/icc-bwmon.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/soc/qcom/icc-bwmon.c	2025-09-11 09:47:42.000000000 -0600
@@ -827,7 +827,7 @@ static const struct icc_bwmon_data msm89
 static const struct icc_bwmon_data sdm845_cpu_bwmon_data = {
 	.sample_ms = 4,
 	.count_unit_kb = 64,
-	.zone1_thres_count = 16,
+	.zone1_thres_count = 3,
 	.zone3_thres_count = 1,
 	.quirks = BWMON_HAS_GLOBAL_IRQ,
 	.regmap_fields = sdm845_cpu_bwmon_reg_fields,
@@ -846,7 +846,7 @@ static const struct icc_bwmon_data sdm84
 static const struct icc_bwmon_data sc7280_llcc_bwmon_data = {
 	.sample_ms = 4,
 	.count_unit_kb = 64,
-	.zone1_thres_count = 16,
+	.zone1_thres_count = 3,
 	.zone3_thres_count = 1,
 	.quirks = BWMON_NEEDS_FORCE_CLEAR,
 	.regmap_fields = sdm845_llcc_bwmon_reg_fields,
diff -Nrup linux-6.16.6/drivers/soundwire/bus.c linux-lenovo-x13s-linux-6.16.y/drivers/soundwire/bus.c
--- linux-6.16.6/drivers/soundwire/bus.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/soundwire/bus.c	2025-09-11 09:47:42.000000000 -0600
@@ -1360,6 +1360,18 @@ int sdw_slave_get_scale_index(struct sdw
 }
 EXPORT_SYMBOL(sdw_slave_get_scale_index);
 
+int sdw_slave_get_current_bank(struct sdw_slave *slave)
+{
+	int tmp;
+
+	tmp = sdw_read(slave, SDW_SCP_CTRL);
+	if (tmp < 0)
+		return tmp;
+
+	return FIELD_GET(SDW_SCP_STAT_CURR_BANK, tmp);
+}
+EXPORT_SYMBOL_GPL(sdw_slave_get_current_bank);
+
 static int sdw_slave_set_frequency(struct sdw_slave *slave)
 {
 	int scale_index;
diff -Nrup linux-6.16.6/drivers/soundwire/qcom.c linux-lenovo-x13s-linux-6.16.y/drivers/soundwire/qcom.c
--- linux-6.16.6/drivers/soundwire/qcom.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/soundwire/qcom.c	2025-09-11 09:47:42.000000000 -0600
@@ -1622,9 +1622,9 @@ static int qcom_swrm_probe(struct platfo
 	if (ret)
 		goto err_master_add;
 
-	dev_info(dev, "Qualcomm Soundwire controller v%x.%x.%x Registered\n",
-		 (ctrl->version >> 24) & 0xff, (ctrl->version >> 16) & 0xff,
-		 ctrl->version & 0xffff);
+	dev_dbg(dev, "Qualcomm Soundwire controller v%x.%x.%x registered\n",
+		(ctrl->version >> 24) & 0xff, (ctrl->version >> 16) & 0xff,
+		ctrl->version & 0xffff);
 
 	pm_runtime_set_autosuspend_delay(dev, 3000);
 	pm_runtime_use_autosuspend(dev);
diff -Nrup linux-6.16.6/drivers/soundwire/slave.c linux-lenovo-x13s-linux-6.16.y/drivers/soundwire/slave.c
--- linux-6.16.6/drivers/soundwire/slave.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/drivers/soundwire/slave.c	2025-09-11 09:47:42.000000000 -0600
@@ -273,4 +273,10 @@ int sdw_of_find_slaves(struct sdw_bus *b
 	return 0;
 }
 
+struct device *of_sdw_find_device_by_node(struct device_node *np)
+{
+	return bus_find_device_by_of_node(&sdw_bus_type, np);
+}
+EXPORT_SYMBOL_GPL(of_sdw_find_device_by_node);
+
 MODULE_IMPORT_NS("SND_SOC_SDCA");
diff -Nrup linux-6.16.6/include/dt-bindings/clock/qcom,dispcc-sm8150.h linux-lenovo-x13s-linux-6.16.y/include/dt-bindings/clock/qcom,dispcc-sm8150.h
--- linux-6.16.6/include/dt-bindings/clock/qcom,dispcc-sm8150.h	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/include/dt-bindings/clock/qcom,dispcc-sm8150.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,76 +1 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.
- */
-
-#ifndef _DT_BINDINGS_CLK_QCOM_DISP_CC_SM8250_H
-#define _DT_BINDINGS_CLK_QCOM_DISP_CC_SM8250_H
-
-/* DISP_CC clock registers */
-#define DISP_CC_MDSS_AHB_CLK			0
-#define DISP_CC_MDSS_AHB_CLK_SRC		1
-#define DISP_CC_MDSS_BYTE0_CLK			2
-#define DISP_CC_MDSS_BYTE0_CLK_SRC		3
-#define DISP_CC_MDSS_BYTE0_DIV_CLK_SRC		4
-#define DISP_CC_MDSS_BYTE0_INTF_CLK		5
-#define DISP_CC_MDSS_BYTE1_CLK			6
-#define DISP_CC_MDSS_BYTE1_CLK_SRC		7
-#define DISP_CC_MDSS_BYTE1_DIV_CLK_SRC		8
-#define DISP_CC_MDSS_BYTE1_INTF_CLK		9
-#define DISP_CC_MDSS_DP_AUX1_CLK		10
-#define DISP_CC_MDSS_DP_AUX1_CLK_SRC		11
-#define DISP_CC_MDSS_DP_AUX_CLK			12
-#define DISP_CC_MDSS_DP_AUX_CLK_SRC		13
-#define DISP_CC_MDSS_DP_LINK1_CLK		14
-#define DISP_CC_MDSS_DP_LINK1_CLK_SRC		15
-#define DISP_CC_MDSS_DP_LINK1_DIV_CLK_SRC	16
-#define DISP_CC_MDSS_DP_LINK1_INTF_CLK		17
-#define DISP_CC_MDSS_DP_LINK_CLK		18
-#define DISP_CC_MDSS_DP_LINK_CLK_SRC		19
-#define DISP_CC_MDSS_DP_LINK_DIV_CLK_SRC	20
-#define DISP_CC_MDSS_DP_LINK_INTF_CLK		21
-#define DISP_CC_MDSS_DP_PIXEL1_CLK		22
-#define DISP_CC_MDSS_DP_PIXEL1_CLK_SRC		23
-#define DISP_CC_MDSS_DP_PIXEL2_CLK		24
-#define DISP_CC_MDSS_DP_PIXEL2_CLK_SRC		25
-#define DISP_CC_MDSS_DP_PIXEL_CLK		26
-#define DISP_CC_MDSS_DP_PIXEL_CLK_SRC		27
-#define DISP_CC_MDSS_ESC0_CLK			28
-#define DISP_CC_MDSS_ESC0_CLK_SRC		29
-#define DISP_CC_MDSS_ESC1_CLK			30
-#define DISP_CC_MDSS_ESC1_CLK_SRC		31
-#define DISP_CC_MDSS_MDP_CLK			32
-#define DISP_CC_MDSS_MDP_CLK_SRC		33
-#define DISP_CC_MDSS_MDP_LUT_CLK		34
-#define DISP_CC_MDSS_NON_GDSC_AHB_CLK		35
-#define DISP_CC_MDSS_PCLK0_CLK			36
-#define DISP_CC_MDSS_PCLK0_CLK_SRC		37
-#define DISP_CC_MDSS_PCLK1_CLK			38
-#define DISP_CC_MDSS_PCLK1_CLK_SRC		39
-#define DISP_CC_MDSS_ROT_CLK			40
-#define DISP_CC_MDSS_ROT_CLK_SRC		41
-#define DISP_CC_MDSS_RSCC_AHB_CLK		42
-#define DISP_CC_MDSS_RSCC_VSYNC_CLK		43
-#define DISP_CC_MDSS_VSYNC_CLK			44
-#define DISP_CC_MDSS_VSYNC_CLK_SRC		45
-#define DISP_CC_PLL0				46
-#define DISP_CC_PLL1				47
-#define DISP_CC_MDSS_EDP_AUX_CLK		48
-#define DISP_CC_MDSS_EDP_AUX_CLK_SRC		49
-#define DISP_CC_MDSS_EDP_GTC_CLK		50
-#define DISP_CC_MDSS_EDP_GTC_CLK_SRC		51
-#define DISP_CC_MDSS_EDP_LINK_CLK		52
-#define DISP_CC_MDSS_EDP_LINK_CLK_SRC		53
-#define DISP_CC_MDSS_EDP_LINK_INTF_CLK		54
-#define DISP_CC_MDSS_EDP_PIXEL_CLK		55
-#define DISP_CC_MDSS_EDP_PIXEL_CLK_SRC		56
-#define DISP_CC_MDSS_EDP_LINK_DIV_CLK_SRC	57
-
-/* DISP_CC Reset */
-#define DISP_CC_MDSS_CORE_BCR			0
-#define DISP_CC_MDSS_RSCC_BCR			1
-
-/* DISP_CC GDSCR */
-#define MDSS_GDSC				0
-
-#endif
+qcom,dispcc-sm8250.h
\ No newline at end of file
diff -Nrup linux-6.16.6/include/dt-bindings/clock/qcom,dispcc-sm8350.h linux-lenovo-x13s-linux-6.16.y/include/dt-bindings/clock/qcom,dispcc-sm8350.h
--- linux-6.16.6/include/dt-bindings/clock/qcom,dispcc-sm8350.h	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/include/dt-bindings/clock/qcom,dispcc-sm8350.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,76 +1 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.
- */
-
-#ifndef _DT_BINDINGS_CLK_QCOM_DISP_CC_SM8250_H
-#define _DT_BINDINGS_CLK_QCOM_DISP_CC_SM8250_H
-
-/* DISP_CC clock registers */
-#define DISP_CC_MDSS_AHB_CLK			0
-#define DISP_CC_MDSS_AHB_CLK_SRC		1
-#define DISP_CC_MDSS_BYTE0_CLK			2
-#define DISP_CC_MDSS_BYTE0_CLK_SRC		3
-#define DISP_CC_MDSS_BYTE0_DIV_CLK_SRC		4
-#define DISP_CC_MDSS_BYTE0_INTF_CLK		5
-#define DISP_CC_MDSS_BYTE1_CLK			6
-#define DISP_CC_MDSS_BYTE1_CLK_SRC		7
-#define DISP_CC_MDSS_BYTE1_DIV_CLK_SRC		8
-#define DISP_CC_MDSS_BYTE1_INTF_CLK		9
-#define DISP_CC_MDSS_DP_AUX1_CLK		10
-#define DISP_CC_MDSS_DP_AUX1_CLK_SRC		11
-#define DISP_CC_MDSS_DP_AUX_CLK			12
-#define DISP_CC_MDSS_DP_AUX_CLK_SRC		13
-#define DISP_CC_MDSS_DP_LINK1_CLK		14
-#define DISP_CC_MDSS_DP_LINK1_CLK_SRC		15
-#define DISP_CC_MDSS_DP_LINK1_DIV_CLK_SRC	16
-#define DISP_CC_MDSS_DP_LINK1_INTF_CLK		17
-#define DISP_CC_MDSS_DP_LINK_CLK		18
-#define DISP_CC_MDSS_DP_LINK_CLK_SRC		19
-#define DISP_CC_MDSS_DP_LINK_DIV_CLK_SRC	20
-#define DISP_CC_MDSS_DP_LINK_INTF_CLK		21
-#define DISP_CC_MDSS_DP_PIXEL1_CLK		22
-#define DISP_CC_MDSS_DP_PIXEL1_CLK_SRC		23
-#define DISP_CC_MDSS_DP_PIXEL2_CLK		24
-#define DISP_CC_MDSS_DP_PIXEL2_CLK_SRC		25
-#define DISP_CC_MDSS_DP_PIXEL_CLK		26
-#define DISP_CC_MDSS_DP_PIXEL_CLK_SRC		27
-#define DISP_CC_MDSS_ESC0_CLK			28
-#define DISP_CC_MDSS_ESC0_CLK_SRC		29
-#define DISP_CC_MDSS_ESC1_CLK			30
-#define DISP_CC_MDSS_ESC1_CLK_SRC		31
-#define DISP_CC_MDSS_MDP_CLK			32
-#define DISP_CC_MDSS_MDP_CLK_SRC		33
-#define DISP_CC_MDSS_MDP_LUT_CLK		34
-#define DISP_CC_MDSS_NON_GDSC_AHB_CLK		35
-#define DISP_CC_MDSS_PCLK0_CLK			36
-#define DISP_CC_MDSS_PCLK0_CLK_SRC		37
-#define DISP_CC_MDSS_PCLK1_CLK			38
-#define DISP_CC_MDSS_PCLK1_CLK_SRC		39
-#define DISP_CC_MDSS_ROT_CLK			40
-#define DISP_CC_MDSS_ROT_CLK_SRC		41
-#define DISP_CC_MDSS_RSCC_AHB_CLK		42
-#define DISP_CC_MDSS_RSCC_VSYNC_CLK		43
-#define DISP_CC_MDSS_VSYNC_CLK			44
-#define DISP_CC_MDSS_VSYNC_CLK_SRC		45
-#define DISP_CC_PLL0				46
-#define DISP_CC_PLL1				47
-#define DISP_CC_MDSS_EDP_AUX_CLK		48
-#define DISP_CC_MDSS_EDP_AUX_CLK_SRC		49
-#define DISP_CC_MDSS_EDP_GTC_CLK		50
-#define DISP_CC_MDSS_EDP_GTC_CLK_SRC		51
-#define DISP_CC_MDSS_EDP_LINK_CLK		52
-#define DISP_CC_MDSS_EDP_LINK_CLK_SRC		53
-#define DISP_CC_MDSS_EDP_LINK_INTF_CLK		54
-#define DISP_CC_MDSS_EDP_PIXEL_CLK		55
-#define DISP_CC_MDSS_EDP_PIXEL_CLK_SRC		56
-#define DISP_CC_MDSS_EDP_LINK_DIV_CLK_SRC	57
-
-/* DISP_CC Reset */
-#define DISP_CC_MDSS_CORE_BCR			0
-#define DISP_CC_MDSS_RSCC_BCR			1
-
-/* DISP_CC GDSCR */
-#define MDSS_GDSC				0
-
-#endif
+qcom,dispcc-sm8250.h
\ No newline at end of file
diff -Nrup linux-6.16.6/include/dt-bindings/clock/qcom,sm8650-dispcc.h linux-lenovo-x13s-linux-6.16.y/include/dt-bindings/clock/qcom,sm8650-dispcc.h
--- linux-6.16.6/include/dt-bindings/clock/qcom,sm8650-dispcc.h	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/include/dt-bindings/clock/qcom,sm8650-dispcc.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,101 +1 @@
-/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */
-/*
- * Copyright (c) 2022, The Linux Foundation. All rights reserved.
- */
-
-#ifndef _DT_BINDINGS_CLK_QCOM_SM8550_DISP_CC_H
-#define _DT_BINDINGS_CLK_QCOM_SM8550_DISP_CC_H
-
-/* DISP_CC clocks */
-#define DISP_CC_MDSS_ACCU_CLK					0
-#define DISP_CC_MDSS_AHB1_CLK					1
-#define DISP_CC_MDSS_AHB_CLK					2
-#define DISP_CC_MDSS_AHB_CLK_SRC				3
-#define DISP_CC_MDSS_BYTE0_CLK					4
-#define DISP_CC_MDSS_BYTE0_CLK_SRC				5
-#define DISP_CC_MDSS_BYTE0_DIV_CLK_SRC				6
-#define DISP_CC_MDSS_BYTE0_INTF_CLK				7
-#define DISP_CC_MDSS_BYTE1_CLK					8
-#define DISP_CC_MDSS_BYTE1_CLK_SRC				9
-#define DISP_CC_MDSS_BYTE1_DIV_CLK_SRC				10
-#define DISP_CC_MDSS_BYTE1_INTF_CLK				11
-#define DISP_CC_MDSS_DPTX0_AUX_CLK				12
-#define DISP_CC_MDSS_DPTX0_AUX_CLK_SRC				13
-#define DISP_CC_MDSS_DPTX0_CRYPTO_CLK				14
-#define DISP_CC_MDSS_DPTX0_LINK_CLK				15
-#define DISP_CC_MDSS_DPTX0_LINK_CLK_SRC				16
-#define DISP_CC_MDSS_DPTX0_LINK_DIV_CLK_SRC			17
-#define DISP_CC_MDSS_DPTX0_LINK_INTF_CLK			18
-#define DISP_CC_MDSS_DPTX0_PIXEL0_CLK				19
-#define DISP_CC_MDSS_DPTX0_PIXEL0_CLK_SRC			20
-#define DISP_CC_MDSS_DPTX0_PIXEL1_CLK				21
-#define DISP_CC_MDSS_DPTX0_PIXEL1_CLK_SRC			22
-#define DISP_CC_MDSS_DPTX0_USB_ROUTER_LINK_INTF_CLK		23
-#define DISP_CC_MDSS_DPTX1_AUX_CLK				24
-#define DISP_CC_MDSS_DPTX1_AUX_CLK_SRC				25
-#define DISP_CC_MDSS_DPTX1_CRYPTO_CLK				26
-#define DISP_CC_MDSS_DPTX1_LINK_CLK				27
-#define DISP_CC_MDSS_DPTX1_LINK_CLK_SRC				28
-#define DISP_CC_MDSS_DPTX1_LINK_DIV_CLK_SRC			29
-#define DISP_CC_MDSS_DPTX1_LINK_INTF_CLK			30
-#define DISP_CC_MDSS_DPTX1_PIXEL0_CLK				31
-#define DISP_CC_MDSS_DPTX1_PIXEL0_CLK_SRC			32
-#define DISP_CC_MDSS_DPTX1_PIXEL1_CLK				33
-#define DISP_CC_MDSS_DPTX1_PIXEL1_CLK_SRC			34
-#define DISP_CC_MDSS_DPTX1_USB_ROUTER_LINK_INTF_CLK		35
-#define DISP_CC_MDSS_DPTX2_AUX_CLK				36
-#define DISP_CC_MDSS_DPTX2_AUX_CLK_SRC				37
-#define DISP_CC_MDSS_DPTX2_CRYPTO_CLK				38
-#define DISP_CC_MDSS_DPTX2_LINK_CLK				39
-#define DISP_CC_MDSS_DPTX2_LINK_CLK_SRC				40
-#define DISP_CC_MDSS_DPTX2_LINK_DIV_CLK_SRC			41
-#define DISP_CC_MDSS_DPTX2_LINK_INTF_CLK			42
-#define DISP_CC_MDSS_DPTX2_PIXEL0_CLK				43
-#define DISP_CC_MDSS_DPTX2_PIXEL0_CLK_SRC			44
-#define DISP_CC_MDSS_DPTX2_PIXEL1_CLK				45
-#define DISP_CC_MDSS_DPTX2_PIXEL1_CLK_SRC			46
-#define DISP_CC_MDSS_DPTX3_AUX_CLK				47
-#define DISP_CC_MDSS_DPTX3_AUX_CLK_SRC				48
-#define DISP_CC_MDSS_DPTX3_CRYPTO_CLK				49
-#define DISP_CC_MDSS_DPTX3_LINK_CLK				50
-#define DISP_CC_MDSS_DPTX3_LINK_CLK_SRC				51
-#define DISP_CC_MDSS_DPTX3_LINK_DIV_CLK_SRC			52
-#define DISP_CC_MDSS_DPTX3_LINK_INTF_CLK			53
-#define DISP_CC_MDSS_DPTX3_PIXEL0_CLK				54
-#define DISP_CC_MDSS_DPTX3_PIXEL0_CLK_SRC			55
-#define DISP_CC_MDSS_ESC0_CLK					56
-#define DISP_CC_MDSS_ESC0_CLK_SRC				57
-#define DISP_CC_MDSS_ESC1_CLK					58
-#define DISP_CC_MDSS_ESC1_CLK_SRC				59
-#define DISP_CC_MDSS_MDP1_CLK					60
-#define DISP_CC_MDSS_MDP_CLK					61
-#define DISP_CC_MDSS_MDP_CLK_SRC				62
-#define DISP_CC_MDSS_MDP_LUT1_CLK				63
-#define DISP_CC_MDSS_MDP_LUT_CLK				64
-#define DISP_CC_MDSS_NON_GDSC_AHB_CLK				65
-#define DISP_CC_MDSS_PCLK0_CLK					66
-#define DISP_CC_MDSS_PCLK0_CLK_SRC				67
-#define DISP_CC_MDSS_PCLK1_CLK					68
-#define DISP_CC_MDSS_PCLK1_CLK_SRC				69
-#define DISP_CC_MDSS_RSCC_AHB_CLK				70
-#define DISP_CC_MDSS_RSCC_VSYNC_CLK				71
-#define DISP_CC_MDSS_VSYNC1_CLK					72
-#define DISP_CC_MDSS_VSYNC_CLK					73
-#define DISP_CC_MDSS_VSYNC_CLK_SRC				74
-#define DISP_CC_PLL0						75
-#define DISP_CC_PLL1						76
-#define DISP_CC_SLEEP_CLK					77
-#define DISP_CC_SLEEP_CLK_SRC					78
-#define DISP_CC_XO_CLK						79
-#define DISP_CC_XO_CLK_SRC					80
-
-/* DISP_CC resets */
-#define DISP_CC_MDSS_CORE_BCR					0
-#define DISP_CC_MDSS_CORE_INT2_BCR				1
-#define DISP_CC_MDSS_RSCC_BCR					2
-
-/* DISP_CC GDSCR */
-#define MDSS_GDSC						0
-#define MDSS_INT2_GDSC						1
-
-#endif
+qcom,sm8550-dispcc.h
\ No newline at end of file
diff -Nrup linux-6.16.6/include/dt-bindings/input/linux-event-codes.h linux-lenovo-x13s-linux-6.16.y/include/dt-bindings/input/linux-event-codes.h
--- linux-6.16.6/include/dt-bindings/input/linux-event-codes.h	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/include/dt-bindings/input/linux-event-codes.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,982 +1 @@
-/* SPDX-License-Identifier: GPL-2.0-only WITH Linux-syscall-note */
-/*
- * Input event codes
- *
- *    *** IMPORTANT ***
- * This file is not only included from C-code but also from devicetree source
- * files. As such this file MUST only contain comments and defines.
- *
- * Copyright (c) 1999-2002 Vojtech Pavlik
- * Copyright (c) 2015 Hans de Goede <hdegoede@redhat.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published by
- * the Free Software Foundation.
- */
-#ifndef _UAPI_INPUT_EVENT_CODES_H
-#define _UAPI_INPUT_EVENT_CODES_H
-
-/*
- * Device properties and quirks
- */
-
-#define INPUT_PROP_POINTER		0x00	/* needs a pointer */
-#define INPUT_PROP_DIRECT		0x01	/* direct input devices */
-#define INPUT_PROP_BUTTONPAD		0x02	/* has button(s) under pad */
-#define INPUT_PROP_SEMI_MT		0x03	/* touch rectangle only */
-#define INPUT_PROP_TOPBUTTONPAD		0x04	/* softbuttons at top of pad */
-#define INPUT_PROP_POINTING_STICK	0x05	/* is a pointing stick */
-#define INPUT_PROP_ACCELEROMETER	0x06	/* has accelerometer */
-
-#define INPUT_PROP_MAX			0x1f
-#define INPUT_PROP_CNT			(INPUT_PROP_MAX + 1)
-
-/*
- * Event types
- */
-
-#define EV_SYN			0x00
-#define EV_KEY			0x01
-#define EV_REL			0x02
-#define EV_ABS			0x03
-#define EV_MSC			0x04
-#define EV_SW			0x05
-#define EV_LED			0x11
-#define EV_SND			0x12
-#define EV_REP			0x14
-#define EV_FF			0x15
-#define EV_PWR			0x16
-#define EV_FF_STATUS		0x17
-#define EV_MAX			0x1f
-#define EV_CNT			(EV_MAX+1)
-
-/*
- * Synchronization events.
- */
-
-#define SYN_REPORT		0
-#define SYN_CONFIG		1
-#define SYN_MT_REPORT		2
-#define SYN_DROPPED		3
-#define SYN_MAX			0xf
-#define SYN_CNT			(SYN_MAX+1)
-
-/*
- * Keys and buttons
- *
- * Most of the keys/buttons are modeled after USB HUT 1.12
- * (see http://www.usb.org/developers/hidpage).
- * Abbreviations in the comments:
- * AC - Application Control
- * AL - Application Launch Button
- * SC - System Control
- */
-
-#define KEY_RESERVED		0
-#define KEY_ESC			1
-#define KEY_1			2
-#define KEY_2			3
-#define KEY_3			4
-#define KEY_4			5
-#define KEY_5			6
-#define KEY_6			7
-#define KEY_7			8
-#define KEY_8			9
-#define KEY_9			10
-#define KEY_0			11
-#define KEY_MINUS		12
-#define KEY_EQUAL		13
-#define KEY_BACKSPACE		14
-#define KEY_TAB			15
-#define KEY_Q			16
-#define KEY_W			17
-#define KEY_E			18
-#define KEY_R			19
-#define KEY_T			20
-#define KEY_Y			21
-#define KEY_U			22
-#define KEY_I			23
-#define KEY_O			24
-#define KEY_P			25
-#define KEY_LEFTBRACE		26
-#define KEY_RIGHTBRACE		27
-#define KEY_ENTER		28
-#define KEY_LEFTCTRL		29
-#define KEY_A			30
-#define KEY_S			31
-#define KEY_D			32
-#define KEY_F			33
-#define KEY_G			34
-#define KEY_H			35
-#define KEY_J			36
-#define KEY_K			37
-#define KEY_L			38
-#define KEY_SEMICOLON		39
-#define KEY_APOSTROPHE		40
-#define KEY_GRAVE		41
-#define KEY_LEFTSHIFT		42
-#define KEY_BACKSLASH		43
-#define KEY_Z			44
-#define KEY_X			45
-#define KEY_C			46
-#define KEY_V			47
-#define KEY_B			48
-#define KEY_N			49
-#define KEY_M			50
-#define KEY_COMMA		51
-#define KEY_DOT			52
-#define KEY_SLASH		53
-#define KEY_RIGHTSHIFT		54
-#define KEY_KPASTERISK		55
-#define KEY_LEFTALT		56
-#define KEY_SPACE		57
-#define KEY_CAPSLOCK		58
-#define KEY_F1			59
-#define KEY_F2			60
-#define KEY_F3			61
-#define KEY_F4			62
-#define KEY_F5			63
-#define KEY_F6			64
-#define KEY_F7			65
-#define KEY_F8			66
-#define KEY_F9			67
-#define KEY_F10			68
-#define KEY_NUMLOCK		69
-#define KEY_SCROLLLOCK		70
-#define KEY_KP7			71
-#define KEY_KP8			72
-#define KEY_KP9			73
-#define KEY_KPMINUS		74
-#define KEY_KP4			75
-#define KEY_KP5			76
-#define KEY_KP6			77
-#define KEY_KPPLUS		78
-#define KEY_KP1			79
-#define KEY_KP2			80
-#define KEY_KP3			81
-#define KEY_KP0			82
-#define KEY_KPDOT		83
-
-#define KEY_ZENKAKUHANKAKU	85
-#define KEY_102ND		86
-#define KEY_F11			87
-#define KEY_F12			88
-#define KEY_RO			89
-#define KEY_KATAKANA		90
-#define KEY_HIRAGANA		91
-#define KEY_HENKAN		92
-#define KEY_KATAKANAHIRAGANA	93
-#define KEY_MUHENKAN		94
-#define KEY_KPJPCOMMA		95
-#define KEY_KPENTER		96
-#define KEY_RIGHTCTRL		97
-#define KEY_KPSLASH		98
-#define KEY_SYSRQ		99
-#define KEY_RIGHTALT		100
-#define KEY_LINEFEED		101
-#define KEY_HOME		102
-#define KEY_UP			103
-#define KEY_PAGEUP		104
-#define KEY_LEFT		105
-#define KEY_RIGHT		106
-#define KEY_END			107
-#define KEY_DOWN		108
-#define KEY_PAGEDOWN		109
-#define KEY_INSERT		110
-#define KEY_DELETE		111
-#define KEY_MACRO		112
-#define KEY_MUTE		113
-#define KEY_VOLUMEDOWN		114
-#define KEY_VOLUMEUP		115
-#define KEY_POWER		116	/* SC System Power Down */
-#define KEY_KPEQUAL		117
-#define KEY_KPPLUSMINUS		118
-#define KEY_PAUSE		119
-#define KEY_SCALE		120	/* AL Compiz Scale (Expose) */
-
-#define KEY_KPCOMMA		121
-#define KEY_HANGEUL		122
-#define KEY_HANGUEL		KEY_HANGEUL
-#define KEY_HANJA		123
-#define KEY_YEN			124
-#define KEY_LEFTMETA		125
-#define KEY_RIGHTMETA		126
-#define KEY_COMPOSE		127
-
-#define KEY_STOP		128	/* AC Stop */
-#define KEY_AGAIN		129
-#define KEY_PROPS		130	/* AC Properties */
-#define KEY_UNDO		131	/* AC Undo */
-#define KEY_FRONT		132
-#define KEY_COPY		133	/* AC Copy */
-#define KEY_OPEN		134	/* AC Open */
-#define KEY_PASTE		135	/* AC Paste */
-#define KEY_FIND		136	/* AC Search */
-#define KEY_CUT			137	/* AC Cut */
-#define KEY_HELP		138	/* AL Integrated Help Center */
-#define KEY_MENU		139	/* Menu (show menu) */
-#define KEY_CALC		140	/* AL Calculator */
-#define KEY_SETUP		141
-#define KEY_SLEEP		142	/* SC System Sleep */
-#define KEY_WAKEUP		143	/* System Wake Up */
-#define KEY_FILE		144	/* AL Local Machine Browser */
-#define KEY_SENDFILE		145
-#define KEY_DELETEFILE		146
-#define KEY_XFER		147
-#define KEY_PROG1		148
-#define KEY_PROG2		149
-#define KEY_WWW			150	/* AL Internet Browser */
-#define KEY_MSDOS		151
-#define KEY_COFFEE		152	/* AL Terminal Lock/Screensaver */
-#define KEY_SCREENLOCK		KEY_COFFEE
-#define KEY_ROTATE_DISPLAY	153	/* Display orientation for e.g. tablets */
-#define KEY_DIRECTION		KEY_ROTATE_DISPLAY
-#define KEY_CYCLEWINDOWS	154
-#define KEY_MAIL		155
-#define KEY_BOOKMARKS		156	/* AC Bookmarks */
-#define KEY_COMPUTER		157
-#define KEY_BACK		158	/* AC Back */
-#define KEY_FORWARD		159	/* AC Forward */
-#define KEY_CLOSECD		160
-#define KEY_EJECTCD		161
-#define KEY_EJECTCLOSECD	162
-#define KEY_NEXTSONG		163
-#define KEY_PLAYPAUSE		164
-#define KEY_PREVIOUSSONG	165
-#define KEY_STOPCD		166
-#define KEY_RECORD		167
-#define KEY_REWIND		168
-#define KEY_PHONE		169	/* Media Select Telephone */
-#define KEY_ISO			170
-#define KEY_CONFIG		171	/* AL Consumer Control Configuration */
-#define KEY_HOMEPAGE		172	/* AC Home */
-#define KEY_REFRESH		173	/* AC Refresh */
-#define KEY_EXIT		174	/* AC Exit */
-#define KEY_MOVE		175
-#define KEY_EDIT		176
-#define KEY_SCROLLUP		177
-#define KEY_SCROLLDOWN		178
-#define KEY_KPLEFTPAREN		179
-#define KEY_KPRIGHTPAREN	180
-#define KEY_NEW			181	/* AC New */
-#define KEY_REDO		182	/* AC Redo/Repeat */
-
-#define KEY_F13			183
-#define KEY_F14			184
-#define KEY_F15			185
-#define KEY_F16			186
-#define KEY_F17			187
-#define KEY_F18			188
-#define KEY_F19			189
-#define KEY_F20			190
-#define KEY_F21			191
-#define KEY_F22			192
-#define KEY_F23			193
-#define KEY_F24			194
-
-#define KEY_PLAYCD		200
-#define KEY_PAUSECD		201
-#define KEY_PROG3		202
-#define KEY_PROG4		203
-#define KEY_ALL_APPLICATIONS	204	/* AC Desktop Show All Applications */
-#define KEY_DASHBOARD		KEY_ALL_APPLICATIONS
-#define KEY_SUSPEND		205
-#define KEY_CLOSE		206	/* AC Close */
-#define KEY_PLAY		207
-#define KEY_FASTFORWARD		208
-#define KEY_BASSBOOST		209
-#define KEY_PRINT		210	/* AC Print */
-#define KEY_HP			211
-#define KEY_CAMERA		212
-#define KEY_SOUND		213
-#define KEY_QUESTION		214
-#define KEY_EMAIL		215
-#define KEY_CHAT		216
-#define KEY_SEARCH		217
-#define KEY_CONNECT		218
-#define KEY_FINANCE		219	/* AL Checkbook/Finance */
-#define KEY_SPORT		220
-#define KEY_SHOP		221
-#define KEY_ALTERASE		222
-#define KEY_CANCEL		223	/* AC Cancel */
-#define KEY_BRIGHTNESSDOWN	224
-#define KEY_BRIGHTNESSUP	225
-#define KEY_MEDIA		226
-
-#define KEY_SWITCHVIDEOMODE	227	/* Cycle between available video
-					   outputs (Monitor/LCD/TV-out/etc) */
-#define KEY_KBDILLUMTOGGLE	228
-#define KEY_KBDILLUMDOWN	229
-#define KEY_KBDILLUMUP		230
-
-#define KEY_SEND		231	/* AC Send */
-#define KEY_REPLY		232	/* AC Reply */
-#define KEY_FORWARDMAIL		233	/* AC Forward Msg */
-#define KEY_SAVE		234	/* AC Save */
-#define KEY_DOCUMENTS		235
-
-#define KEY_BATTERY		236
-
-#define KEY_BLUETOOTH		237
-#define KEY_WLAN		238
-#define KEY_UWB			239
-
-#define KEY_UNKNOWN		240
-
-#define KEY_VIDEO_NEXT		241	/* drive next video source */
-#define KEY_VIDEO_PREV		242	/* drive previous video source */
-#define KEY_BRIGHTNESS_CYCLE	243	/* brightness up, after max is min */
-#define KEY_BRIGHTNESS_AUTO	244	/* Set Auto Brightness: manual
-					  brightness control is off,
-					  rely on ambient */
-#define KEY_BRIGHTNESS_ZERO	KEY_BRIGHTNESS_AUTO
-#define KEY_DISPLAY_OFF		245	/* display device to off state */
-
-#define KEY_WWAN		246	/* Wireless WAN (LTE, UMTS, GSM, etc.) */
-#define KEY_WIMAX		KEY_WWAN
-#define KEY_RFKILL		247	/* Key that controls all radios */
-
-#define KEY_MICMUTE		248	/* Mute / unmute the microphone */
-
-/* Code 255 is reserved for special needs of AT keyboard driver */
-
-#define BTN_MISC		0x100
-#define BTN_0			0x100
-#define BTN_1			0x101
-#define BTN_2			0x102
-#define BTN_3			0x103
-#define BTN_4			0x104
-#define BTN_5			0x105
-#define BTN_6			0x106
-#define BTN_7			0x107
-#define BTN_8			0x108
-#define BTN_9			0x109
-
-#define BTN_MOUSE		0x110
-#define BTN_LEFT		0x110
-#define BTN_RIGHT		0x111
-#define BTN_MIDDLE		0x112
-#define BTN_SIDE		0x113
-#define BTN_EXTRA		0x114
-#define BTN_FORWARD		0x115
-#define BTN_BACK		0x116
-#define BTN_TASK		0x117
-
-#define BTN_JOYSTICK		0x120
-#define BTN_TRIGGER		0x120
-#define BTN_THUMB		0x121
-#define BTN_THUMB2		0x122
-#define BTN_TOP			0x123
-#define BTN_TOP2		0x124
-#define BTN_PINKIE		0x125
-#define BTN_BASE		0x126
-#define BTN_BASE2		0x127
-#define BTN_BASE3		0x128
-#define BTN_BASE4		0x129
-#define BTN_BASE5		0x12a
-#define BTN_BASE6		0x12b
-#define BTN_DEAD		0x12f
-
-#define BTN_GAMEPAD		0x130
-#define BTN_SOUTH		0x130
-#define BTN_A			BTN_SOUTH
-#define BTN_EAST		0x131
-#define BTN_B			BTN_EAST
-#define BTN_C			0x132
-#define BTN_NORTH		0x133
-#define BTN_X			BTN_NORTH
-#define BTN_WEST		0x134
-#define BTN_Y			BTN_WEST
-#define BTN_Z			0x135
-#define BTN_TL			0x136
-#define BTN_TR			0x137
-#define BTN_TL2			0x138
-#define BTN_TR2			0x139
-#define BTN_SELECT		0x13a
-#define BTN_START		0x13b
-#define BTN_MODE		0x13c
-#define BTN_THUMBL		0x13d
-#define BTN_THUMBR		0x13e
-
-#define BTN_DIGI		0x140
-#define BTN_TOOL_PEN		0x140
-#define BTN_TOOL_RUBBER		0x141
-#define BTN_TOOL_BRUSH		0x142
-#define BTN_TOOL_PENCIL		0x143
-#define BTN_TOOL_AIRBRUSH	0x144
-#define BTN_TOOL_FINGER		0x145
-#define BTN_TOOL_MOUSE		0x146
-#define BTN_TOOL_LENS		0x147
-#define BTN_TOOL_QUINTTAP	0x148	/* Five fingers on trackpad */
-#define BTN_STYLUS3		0x149
-#define BTN_TOUCH		0x14a
-#define BTN_STYLUS		0x14b
-#define BTN_STYLUS2		0x14c
-#define BTN_TOOL_DOUBLETAP	0x14d
-#define BTN_TOOL_TRIPLETAP	0x14e
-#define BTN_TOOL_QUADTAP	0x14f	/* Four fingers on trackpad */
-
-#define BTN_WHEEL		0x150
-#define BTN_GEAR_DOWN		0x150
-#define BTN_GEAR_UP		0x151
-
-#define KEY_OK			0x160
-#define KEY_SELECT		0x161
-#define KEY_GOTO		0x162
-#define KEY_CLEAR		0x163
-#define KEY_POWER2		0x164
-#define KEY_OPTION		0x165
-#define KEY_INFO		0x166	/* AL OEM Features/Tips/Tutorial */
-#define KEY_TIME		0x167
-#define KEY_VENDOR		0x168
-#define KEY_ARCHIVE		0x169
-#define KEY_PROGRAM		0x16a	/* Media Select Program Guide */
-#define KEY_CHANNEL		0x16b
-#define KEY_FAVORITES		0x16c
-#define KEY_EPG			0x16d
-#define KEY_PVR			0x16e	/* Media Select Home */
-#define KEY_MHP			0x16f
-#define KEY_LANGUAGE		0x170
-#define KEY_TITLE		0x171
-#define KEY_SUBTITLE		0x172
-#define KEY_ANGLE		0x173
-#define KEY_FULL_SCREEN		0x174	/* AC View Toggle */
-#define KEY_ZOOM		KEY_FULL_SCREEN
-#define KEY_MODE		0x175
-#define KEY_KEYBOARD		0x176
-#define KEY_ASPECT_RATIO	0x177	/* HUTRR37: Aspect */
-#define KEY_SCREEN		KEY_ASPECT_RATIO
-#define KEY_PC			0x178	/* Media Select Computer */
-#define KEY_TV			0x179	/* Media Select TV */
-#define KEY_TV2			0x17a	/* Media Select Cable */
-#define KEY_VCR			0x17b	/* Media Select VCR */
-#define KEY_VCR2		0x17c	/* VCR Plus */
-#define KEY_SAT			0x17d	/* Media Select Satellite */
-#define KEY_SAT2		0x17e
-#define KEY_CD			0x17f	/* Media Select CD */
-#define KEY_TAPE		0x180	/* Media Select Tape */
-#define KEY_RADIO		0x181
-#define KEY_TUNER		0x182	/* Media Select Tuner */
-#define KEY_PLAYER		0x183
-#define KEY_TEXT		0x184
-#define KEY_DVD			0x185	/* Media Select DVD */
-#define KEY_AUX			0x186
-#define KEY_MP3			0x187
-#define KEY_AUDIO		0x188	/* AL Audio Browser */
-#define KEY_VIDEO		0x189	/* AL Movie Browser */
-#define KEY_DIRECTORY		0x18a
-#define KEY_LIST		0x18b
-#define KEY_MEMO		0x18c	/* Media Select Messages */
-#define KEY_CALENDAR		0x18d
-#define KEY_RED			0x18e
-#define KEY_GREEN		0x18f
-#define KEY_YELLOW		0x190
-#define KEY_BLUE		0x191
-#define KEY_CHANNELUP		0x192	/* Channel Increment */
-#define KEY_CHANNELDOWN		0x193	/* Channel Decrement */
-#define KEY_FIRST		0x194
-#define KEY_LAST		0x195	/* Recall Last */
-#define KEY_AB			0x196
-#define KEY_NEXT		0x197
-#define KEY_RESTART		0x198
-#define KEY_SLOW		0x199
-#define KEY_SHUFFLE		0x19a
-#define KEY_BREAK		0x19b
-#define KEY_PREVIOUS		0x19c
-#define KEY_DIGITS		0x19d
-#define KEY_TEEN		0x19e
-#define KEY_TWEN		0x19f
-#define KEY_VIDEOPHONE		0x1a0	/* Media Select Video Phone */
-#define KEY_GAMES		0x1a1	/* Media Select Games */
-#define KEY_ZOOMIN		0x1a2	/* AC Zoom In */
-#define KEY_ZOOMOUT		0x1a3	/* AC Zoom Out */
-#define KEY_ZOOMRESET		0x1a4	/* AC Zoom */
-#define KEY_WORDPROCESSOR	0x1a5	/* AL Word Processor */
-#define KEY_EDITOR		0x1a6	/* AL Text Editor */
-#define KEY_SPREADSHEET		0x1a7	/* AL Spreadsheet */
-#define KEY_GRAPHICSEDITOR	0x1a8	/* AL Graphics Editor */
-#define KEY_PRESENTATION	0x1a9	/* AL Presentation App */
-#define KEY_DATABASE		0x1aa	/* AL Database App */
-#define KEY_NEWS		0x1ab	/* AL Newsreader */
-#define KEY_VOICEMAIL		0x1ac	/* AL Voicemail */
-#define KEY_ADDRESSBOOK		0x1ad	/* AL Contacts/Address Book */
-#define KEY_MESSENGER		0x1ae	/* AL Instant Messaging */
-#define KEY_DISPLAYTOGGLE	0x1af	/* Turn display (LCD) on and off */
-#define KEY_BRIGHTNESS_TOGGLE	KEY_DISPLAYTOGGLE
-#define KEY_SPELLCHECK		0x1b0   /* AL Spell Check */
-#define KEY_LOGOFF		0x1b1   /* AL Logoff */
-
-#define KEY_DOLLAR		0x1b2
-#define KEY_EURO		0x1b3
-
-#define KEY_FRAMEBACK		0x1b4	/* Consumer - transport controls */
-#define KEY_FRAMEFORWARD	0x1b5
-#define KEY_CONTEXT_MENU	0x1b6	/* GenDesc - system context menu */
-#define KEY_MEDIA_REPEAT	0x1b7	/* Consumer - transport control */
-#define KEY_10CHANNELSUP	0x1b8	/* 10 channels up (10+) */
-#define KEY_10CHANNELSDOWN	0x1b9	/* 10 channels down (10-) */
-#define KEY_IMAGES		0x1ba	/* AL Image Browser */
-#define KEY_NOTIFICATION_CENTER	0x1bc	/* Show/hide the notification center */
-#define KEY_PICKUP_PHONE	0x1bd	/* Answer incoming call */
-#define KEY_HANGUP_PHONE	0x1be	/* Decline incoming call */
-#define KEY_LINK_PHONE		0x1bf   /* AL Phone Syncing */
-
-#define KEY_DEL_EOL		0x1c0
-#define KEY_DEL_EOS		0x1c1
-#define KEY_INS_LINE		0x1c2
-#define KEY_DEL_LINE		0x1c3
-
-#define KEY_FN			0x1d0
-#define KEY_FN_ESC		0x1d1
-#define KEY_FN_F1		0x1d2
-#define KEY_FN_F2		0x1d3
-#define KEY_FN_F3		0x1d4
-#define KEY_FN_F4		0x1d5
-#define KEY_FN_F5		0x1d6
-#define KEY_FN_F6		0x1d7
-#define KEY_FN_F7		0x1d8
-#define KEY_FN_F8		0x1d9
-#define KEY_FN_F9		0x1da
-#define KEY_FN_F10		0x1db
-#define KEY_FN_F11		0x1dc
-#define KEY_FN_F12		0x1dd
-#define KEY_FN_1		0x1de
-#define KEY_FN_2		0x1df
-#define KEY_FN_D		0x1e0
-#define KEY_FN_E		0x1e1
-#define KEY_FN_F		0x1e2
-#define KEY_FN_S		0x1e3
-#define KEY_FN_B		0x1e4
-#define KEY_FN_RIGHT_SHIFT	0x1e5
-
-#define KEY_BRL_DOT1		0x1f1
-#define KEY_BRL_DOT2		0x1f2
-#define KEY_BRL_DOT3		0x1f3
-#define KEY_BRL_DOT4		0x1f4
-#define KEY_BRL_DOT5		0x1f5
-#define KEY_BRL_DOT6		0x1f6
-#define KEY_BRL_DOT7		0x1f7
-#define KEY_BRL_DOT8		0x1f8
-#define KEY_BRL_DOT9		0x1f9
-#define KEY_BRL_DOT10		0x1fa
-
-#define KEY_NUMERIC_0		0x200	/* used by phones, remote controls, */
-#define KEY_NUMERIC_1		0x201	/* and other keypads */
-#define KEY_NUMERIC_2		0x202
-#define KEY_NUMERIC_3		0x203
-#define KEY_NUMERIC_4		0x204
-#define KEY_NUMERIC_5		0x205
-#define KEY_NUMERIC_6		0x206
-#define KEY_NUMERIC_7		0x207
-#define KEY_NUMERIC_8		0x208
-#define KEY_NUMERIC_9		0x209
-#define KEY_NUMERIC_STAR	0x20a
-#define KEY_NUMERIC_POUND	0x20b
-#define KEY_NUMERIC_A		0x20c	/* Phone key A - HUT Telephony 0xb9 */
-#define KEY_NUMERIC_B		0x20d
-#define KEY_NUMERIC_C		0x20e
-#define KEY_NUMERIC_D		0x20f
-
-#define KEY_CAMERA_FOCUS	0x210
-#define KEY_WPS_BUTTON		0x211	/* WiFi Protected Setup key */
-
-#define KEY_TOUCHPAD_TOGGLE	0x212	/* Request switch touchpad on or off */
-#define KEY_TOUCHPAD_ON		0x213
-#define KEY_TOUCHPAD_OFF	0x214
-
-#define KEY_CAMERA_ZOOMIN	0x215
-#define KEY_CAMERA_ZOOMOUT	0x216
-#define KEY_CAMERA_UP		0x217
-#define KEY_CAMERA_DOWN		0x218
-#define KEY_CAMERA_LEFT		0x219
-#define KEY_CAMERA_RIGHT	0x21a
-
-#define KEY_ATTENDANT_ON	0x21b
-#define KEY_ATTENDANT_OFF	0x21c
-#define KEY_ATTENDANT_TOGGLE	0x21d	/* Attendant call on or off */
-#define KEY_LIGHTS_TOGGLE	0x21e	/* Reading light on or off */
-
-#define BTN_DPAD_UP		0x220
-#define BTN_DPAD_DOWN		0x221
-#define BTN_DPAD_LEFT		0x222
-#define BTN_DPAD_RIGHT		0x223
-
-#define KEY_ALS_TOGGLE		0x230	/* Ambient light sensor */
-#define KEY_ROTATE_LOCK_TOGGLE	0x231	/* Display rotation lock */
-#define KEY_REFRESH_RATE_TOGGLE	0x232	/* Display refresh rate toggle */
-
-#define KEY_BUTTONCONFIG		0x240	/* AL Button Configuration */
-#define KEY_TASKMANAGER		0x241	/* AL Task/Project Manager */
-#define KEY_JOURNAL		0x242	/* AL Log/Journal/Timecard */
-#define KEY_CONTROLPANEL		0x243	/* AL Control Panel */
-#define KEY_APPSELECT		0x244	/* AL Select Task/Application */
-#define KEY_SCREENSAVER		0x245	/* AL Screen Saver */
-#define KEY_VOICECOMMAND		0x246	/* Listening Voice Command */
-#define KEY_ASSISTANT		0x247	/* AL Context-aware desktop assistant */
-#define KEY_KBD_LAYOUT_NEXT	0x248	/* AC Next Keyboard Layout Select */
-#define KEY_EMOJI_PICKER	0x249	/* Show/hide emoji picker (HUTRR101) */
-#define KEY_DICTATE		0x24a	/* Start or Stop Voice Dictation Session (HUTRR99) */
-#define KEY_CAMERA_ACCESS_ENABLE	0x24b	/* Enables programmatic access to camera devices. (HUTRR72) */
-#define KEY_CAMERA_ACCESS_DISABLE	0x24c	/* Disables programmatic access to camera devices. (HUTRR72) */
-#define KEY_CAMERA_ACCESS_TOGGLE	0x24d	/* Toggles the current state of the camera access control. (HUTRR72) */
-#define KEY_ACCESSIBILITY		0x24e	/* Toggles the system bound accessibility UI/command (HUTRR116) */
-#define KEY_DO_NOT_DISTURB		0x24f	/* Toggles the system-wide "Do Not Disturb" control (HUTRR94)*/
-
-#define KEY_BRIGHTNESS_MIN		0x250	/* Set Brightness to Minimum */
-#define KEY_BRIGHTNESS_MAX		0x251	/* Set Brightness to Maximum */
-
-#define KEY_KBDINPUTASSIST_PREV		0x260
-#define KEY_KBDINPUTASSIST_NEXT		0x261
-#define KEY_KBDINPUTASSIST_PREVGROUP		0x262
-#define KEY_KBDINPUTASSIST_NEXTGROUP		0x263
-#define KEY_KBDINPUTASSIST_ACCEPT		0x264
-#define KEY_KBDINPUTASSIST_CANCEL		0x265
-
-/* Diagonal movement keys */
-#define KEY_RIGHT_UP			0x266
-#define KEY_RIGHT_DOWN			0x267
-#define KEY_LEFT_UP			0x268
-#define KEY_LEFT_DOWN			0x269
-
-#define KEY_ROOT_MENU			0x26a /* Show Device's Root Menu */
-/* Show Top Menu of the Media (e.g. DVD) */
-#define KEY_MEDIA_TOP_MENU		0x26b
-#define KEY_NUMERIC_11			0x26c
-#define KEY_NUMERIC_12			0x26d
-/*
- * Toggle Audio Description: refers to an audio service that helps blind and
- * visually impaired consumers understand the action in a program. Note: in
- * some countries this is referred to as "Video Description".
- */
-#define KEY_AUDIO_DESC			0x26e
-#define KEY_3D_MODE			0x26f
-#define KEY_NEXT_FAVORITE		0x270
-#define KEY_STOP_RECORD			0x271
-#define KEY_PAUSE_RECORD		0x272
-#define KEY_VOD				0x273 /* Video on Demand */
-#define KEY_UNMUTE			0x274
-#define KEY_FASTREVERSE			0x275
-#define KEY_SLOWREVERSE			0x276
-/*
- * Control a data application associated with the currently viewed channel,
- * e.g. teletext or data broadcast application (MHEG, MHP, HbbTV, etc.)
- */
-#define KEY_DATA			0x277
-#define KEY_ONSCREEN_KEYBOARD		0x278
-/* Electronic privacy screen control */
-#define KEY_PRIVACY_SCREEN_TOGGLE	0x279
-
-/* Select an area of screen to be copied */
-#define KEY_SELECTIVE_SCREENSHOT	0x27a
-
-/* Move the focus to the next or previous user controllable element within a UI container */
-#define KEY_NEXT_ELEMENT               0x27b
-#define KEY_PREVIOUS_ELEMENT           0x27c
-
-/* Toggle Autopilot engagement */
-#define KEY_AUTOPILOT_ENGAGE_TOGGLE    0x27d
-
-/* Shortcut Keys */
-#define KEY_MARK_WAYPOINT              0x27e
-#define KEY_SOS                                0x27f
-#define KEY_NAV_CHART                  0x280
-#define KEY_FISHING_CHART              0x281
-#define KEY_SINGLE_RANGE_RADAR         0x282
-#define KEY_DUAL_RANGE_RADAR           0x283
-#define KEY_RADAR_OVERLAY              0x284
-#define KEY_TRADITIONAL_SONAR          0x285
-#define KEY_CLEARVU_SONAR              0x286
-#define KEY_SIDEVU_SONAR               0x287
-#define KEY_NAV_INFO                   0x288
-#define KEY_BRIGHTNESS_MENU            0x289
-
-/*
- * Some keyboards have keys which do not have a defined meaning, these keys
- * are intended to be programmed / bound to macros by the user. For most
- * keyboards with these macro-keys the key-sequence to inject, or action to
- * take, is all handled by software on the host side. So from the kernel's
- * point of view these are just normal keys.
- *
- * The KEY_MACRO# codes below are intended for such keys, which may be labeled
- * e.g. G1-G18, or S1 - S30. The KEY_MACRO# codes MUST NOT be used for keys
- * where the marking on the key does indicate a defined meaning / purpose.
- *
- * The KEY_MACRO# codes MUST also NOT be used as fallback for when no existing
- * KEY_FOO define matches the marking / purpose. In this case a new KEY_FOO
- * define MUST be added.
- */
-#define KEY_MACRO1			0x290
-#define KEY_MACRO2			0x291
-#define KEY_MACRO3			0x292
-#define KEY_MACRO4			0x293
-#define KEY_MACRO5			0x294
-#define KEY_MACRO6			0x295
-#define KEY_MACRO7			0x296
-#define KEY_MACRO8			0x297
-#define KEY_MACRO9			0x298
-#define KEY_MACRO10			0x299
-#define KEY_MACRO11			0x29a
-#define KEY_MACRO12			0x29b
-#define KEY_MACRO13			0x29c
-#define KEY_MACRO14			0x29d
-#define KEY_MACRO15			0x29e
-#define KEY_MACRO16			0x29f
-#define KEY_MACRO17			0x2a0
-#define KEY_MACRO18			0x2a1
-#define KEY_MACRO19			0x2a2
-#define KEY_MACRO20			0x2a3
-#define KEY_MACRO21			0x2a4
-#define KEY_MACRO22			0x2a5
-#define KEY_MACRO23			0x2a6
-#define KEY_MACRO24			0x2a7
-#define KEY_MACRO25			0x2a8
-#define KEY_MACRO26			0x2a9
-#define KEY_MACRO27			0x2aa
-#define KEY_MACRO28			0x2ab
-#define KEY_MACRO29			0x2ac
-#define KEY_MACRO30			0x2ad
-
-/*
- * Some keyboards with the macro-keys described above have some extra keys
- * for controlling the host-side software responsible for the macro handling:
- * -A macro recording start/stop key. Note that not all keyboards which emit
- *  KEY_MACRO_RECORD_START will also emit KEY_MACRO_RECORD_STOP if
- *  KEY_MACRO_RECORD_STOP is not advertised, then KEY_MACRO_RECORD_START
- *  should be interpreted as a recording start/stop toggle;
- * -Keys for switching between different macro (pre)sets, either a key for
- *  cycling through the configured presets or keys to directly select a preset.
- */
-#define KEY_MACRO_RECORD_START		0x2b0
-#define KEY_MACRO_RECORD_STOP		0x2b1
-#define KEY_MACRO_PRESET_CYCLE		0x2b2
-#define KEY_MACRO_PRESET1		0x2b3
-#define KEY_MACRO_PRESET2		0x2b4
-#define KEY_MACRO_PRESET3		0x2b5
-
-/*
- * Some keyboards have a buildin LCD panel where the contents are controlled
- * by the host. Often these have a number of keys directly below the LCD
- * intended for controlling a menu shown on the LCD. These keys often don't
- * have any labeling so we just name them KEY_KBD_LCD_MENU#
- */
-#define KEY_KBD_LCD_MENU1		0x2b8
-#define KEY_KBD_LCD_MENU2		0x2b9
-#define KEY_KBD_LCD_MENU3		0x2ba
-#define KEY_KBD_LCD_MENU4		0x2bb
-#define KEY_KBD_LCD_MENU5		0x2bc
-
-#define BTN_TRIGGER_HAPPY		0x2c0
-#define BTN_TRIGGER_HAPPY1		0x2c0
-#define BTN_TRIGGER_HAPPY2		0x2c1
-#define BTN_TRIGGER_HAPPY3		0x2c2
-#define BTN_TRIGGER_HAPPY4		0x2c3
-#define BTN_TRIGGER_HAPPY5		0x2c4
-#define BTN_TRIGGER_HAPPY6		0x2c5
-#define BTN_TRIGGER_HAPPY7		0x2c6
-#define BTN_TRIGGER_HAPPY8		0x2c7
-#define BTN_TRIGGER_HAPPY9		0x2c8
-#define BTN_TRIGGER_HAPPY10		0x2c9
-#define BTN_TRIGGER_HAPPY11		0x2ca
-#define BTN_TRIGGER_HAPPY12		0x2cb
-#define BTN_TRIGGER_HAPPY13		0x2cc
-#define BTN_TRIGGER_HAPPY14		0x2cd
-#define BTN_TRIGGER_HAPPY15		0x2ce
-#define BTN_TRIGGER_HAPPY16		0x2cf
-#define BTN_TRIGGER_HAPPY17		0x2d0
-#define BTN_TRIGGER_HAPPY18		0x2d1
-#define BTN_TRIGGER_HAPPY19		0x2d2
-#define BTN_TRIGGER_HAPPY20		0x2d3
-#define BTN_TRIGGER_HAPPY21		0x2d4
-#define BTN_TRIGGER_HAPPY22		0x2d5
-#define BTN_TRIGGER_HAPPY23		0x2d6
-#define BTN_TRIGGER_HAPPY24		0x2d7
-#define BTN_TRIGGER_HAPPY25		0x2d8
-#define BTN_TRIGGER_HAPPY26		0x2d9
-#define BTN_TRIGGER_HAPPY27		0x2da
-#define BTN_TRIGGER_HAPPY28		0x2db
-#define BTN_TRIGGER_HAPPY29		0x2dc
-#define BTN_TRIGGER_HAPPY30		0x2dd
-#define BTN_TRIGGER_HAPPY31		0x2de
-#define BTN_TRIGGER_HAPPY32		0x2df
-#define BTN_TRIGGER_HAPPY33		0x2e0
-#define BTN_TRIGGER_HAPPY34		0x2e1
-#define BTN_TRIGGER_HAPPY35		0x2e2
-#define BTN_TRIGGER_HAPPY36		0x2e3
-#define BTN_TRIGGER_HAPPY37		0x2e4
-#define BTN_TRIGGER_HAPPY38		0x2e5
-#define BTN_TRIGGER_HAPPY39		0x2e6
-#define BTN_TRIGGER_HAPPY40		0x2e7
-
-/* We avoid low common keys in module aliases so they don't get huge. */
-#define KEY_MIN_INTERESTING	KEY_MUTE
-#define KEY_MAX			0x2ff
-#define KEY_CNT			(KEY_MAX+1)
-
-/*
- * Relative axes
- */
-
-#define REL_X			0x00
-#define REL_Y			0x01
-#define REL_Z			0x02
-#define REL_RX			0x03
-#define REL_RY			0x04
-#define REL_RZ			0x05
-#define REL_HWHEEL		0x06
-#define REL_DIAL		0x07
-#define REL_WHEEL		0x08
-#define REL_MISC		0x09
-/*
- * 0x0a is reserved and should not be used in input drivers.
- * It was used by HID as REL_MISC+1 and userspace needs to detect if
- * the next REL_* event is correct or is just REL_MISC + n.
- * We define here REL_RESERVED so userspace can rely on it and detect
- * the situation described above.
- */
-#define REL_RESERVED		0x0a
-#define REL_WHEEL_HI_RES	0x0b
-#define REL_HWHEEL_HI_RES	0x0c
-#define REL_MAX			0x0f
-#define REL_CNT			(REL_MAX+1)
-
-/*
- * Absolute axes
- */
-
-#define ABS_X			0x00
-#define ABS_Y			0x01
-#define ABS_Z			0x02
-#define ABS_RX			0x03
-#define ABS_RY			0x04
-#define ABS_RZ			0x05
-#define ABS_THROTTLE		0x06
-#define ABS_RUDDER		0x07
-#define ABS_WHEEL		0x08
-#define ABS_GAS			0x09
-#define ABS_BRAKE		0x0a
-#define ABS_HAT0X		0x10
-#define ABS_HAT0Y		0x11
-#define ABS_HAT1X		0x12
-#define ABS_HAT1Y		0x13
-#define ABS_HAT2X		0x14
-#define ABS_HAT2Y		0x15
-#define ABS_HAT3X		0x16
-#define ABS_HAT3Y		0x17
-#define ABS_PRESSURE		0x18
-#define ABS_DISTANCE		0x19
-#define ABS_TILT_X		0x1a
-#define ABS_TILT_Y		0x1b
-#define ABS_TOOL_WIDTH		0x1c
-
-#define ABS_VOLUME		0x20
-#define ABS_PROFILE		0x21
-
-#define ABS_MISC		0x28
-
-/*
- * 0x2e is reserved and should not be used in input drivers.
- * It was used by HID as ABS_MISC+6 and userspace needs to detect if
- * the next ABS_* event is correct or is just ABS_MISC + n.
- * We define here ABS_RESERVED so userspace can rely on it and detect
- * the situation described above.
- */
-#define ABS_RESERVED		0x2e
-
-#define ABS_MT_SLOT		0x2f	/* MT slot being modified */
-#define ABS_MT_TOUCH_MAJOR	0x30	/* Major axis of touching ellipse */
-#define ABS_MT_TOUCH_MINOR	0x31	/* Minor axis (omit if circular) */
-#define ABS_MT_WIDTH_MAJOR	0x32	/* Major axis of approaching ellipse */
-#define ABS_MT_WIDTH_MINOR	0x33	/* Minor axis (omit if circular) */
-#define ABS_MT_ORIENTATION	0x34	/* Ellipse orientation */
-#define ABS_MT_POSITION_X	0x35	/* Center X touch position */
-#define ABS_MT_POSITION_Y	0x36	/* Center Y touch position */
-#define ABS_MT_TOOL_TYPE	0x37	/* Type of touching device */
-#define ABS_MT_BLOB_ID		0x38	/* Group a set of packets as a blob */
-#define ABS_MT_TRACKING_ID	0x39	/* Unique ID of initiated contact */
-#define ABS_MT_PRESSURE		0x3a	/* Pressure on contact area */
-#define ABS_MT_DISTANCE		0x3b	/* Contact hover distance */
-#define ABS_MT_TOOL_X		0x3c	/* Center X tool position */
-#define ABS_MT_TOOL_Y		0x3d	/* Center Y tool position */
-
-
-#define ABS_MAX			0x3f
-#define ABS_CNT			(ABS_MAX+1)
-
-/*
- * Switch events
- */
-
-#define SW_LID			0x00  /* set = lid shut */
-#define SW_TABLET_MODE		0x01  /* set = tablet mode */
-#define SW_HEADPHONE_INSERT	0x02  /* set = inserted */
-#define SW_RFKILL_ALL		0x03  /* rfkill master switch, type "any"
-					 set = radio enabled */
-#define SW_RADIO		SW_RFKILL_ALL	/* deprecated */
-#define SW_MICROPHONE_INSERT	0x04  /* set = inserted */
-#define SW_DOCK			0x05  /* set = plugged into dock */
-#define SW_LINEOUT_INSERT	0x06  /* set = inserted */
-#define SW_JACK_PHYSICAL_INSERT 0x07  /* set = mechanical switch set */
-#define SW_VIDEOOUT_INSERT	0x08  /* set = inserted */
-#define SW_CAMERA_LENS_COVER	0x09  /* set = lens covered */
-#define SW_KEYPAD_SLIDE		0x0a  /* set = keypad slide out */
-#define SW_FRONT_PROXIMITY	0x0b  /* set = front proximity sensor active */
-#define SW_ROTATE_LOCK		0x0c  /* set = rotate locked/disabled */
-#define SW_LINEIN_INSERT	0x0d  /* set = inserted */
-#define SW_MUTE_DEVICE		0x0e  /* set = device disabled */
-#define SW_PEN_INSERTED		0x0f  /* set = pen inserted */
-#define SW_MACHINE_COVER	0x10  /* set = cover closed */
-#define SW_USB_INSERT		0x11  /* set = USB audio device connected */
-#define SW_MAX			0x11
-#define SW_CNT			(SW_MAX+1)
-
-/*
- * Misc events
- */
-
-#define MSC_SERIAL		0x00
-#define MSC_PULSELED		0x01
-#define MSC_GESTURE		0x02
-#define MSC_RAW			0x03
-#define MSC_SCAN		0x04
-#define MSC_TIMESTAMP		0x05
-#define MSC_MAX			0x07
-#define MSC_CNT			(MSC_MAX+1)
-
-/*
- * LEDs
- */
-
-#define LED_NUML		0x00
-#define LED_CAPSL		0x01
-#define LED_SCROLLL		0x02
-#define LED_COMPOSE		0x03
-#define LED_KANA		0x04
-#define LED_SLEEP		0x05
-#define LED_SUSPEND		0x06
-#define LED_MUTE		0x07
-#define LED_MISC		0x08
-#define LED_MAIL		0x09
-#define LED_CHARGING		0x0a
-#define LED_MAX			0x0f
-#define LED_CNT			(LED_MAX+1)
-
-/*
- * Autorepeat values
- */
-
-#define REP_DELAY		0x00
-#define REP_PERIOD		0x01
-#define REP_MAX			0x01
-#define REP_CNT			(REP_MAX+1)
-
-/*
- * Sounds
- */
-
-#define SND_CLICK		0x00
-#define SND_BELL		0x01
-#define SND_TONE		0x02
-#define SND_MAX			0x07
-#define SND_CNT			(SND_MAX+1)
-
-#endif
+../../uapi/linux/input-event-codes.h
\ No newline at end of file
diff -Nrup linux-6.16.6/include/linux/leds.h linux-lenovo-x13s-linux-6.16.y/include/linux/leds.h
--- linux-6.16.6/include/linux/leds.h	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/include/linux/leds.h	2025-09-11 09:47:42.000000000 -0600
@@ -294,7 +294,6 @@ void led_remove_lookup(struct led_lookup
 struct led_classdev *__must_check led_get(struct device *dev, char *con_id);
 struct led_classdev *__must_check devm_led_get(struct device *dev, char *con_id);
 
-extern struct led_classdev *of_led_get(struct device_node *np, int index);
 extern void led_put(struct led_classdev *led_cdev);
 struct led_classdev *__must_check devm_of_led_get(struct device *dev,
 						  int index);
diff -Nrup linux-6.16.6/include/linux/sched/bore.h linux-lenovo-x13s-linux-6.16.y/include/linux/sched/bore.h
--- linux-6.16.6/include/linux/sched/bore.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-lenovo-x13s-linux-6.16.y/include/linux/sched/bore.h	2025-09-11 09:47:42.000000000 -0600
@@ -0,0 +1,39 @@
+#ifndef _KERNEL_SCHED_BORE_H
+#define _KERNEL_SCHED_BORE_H
+
+#include <linux/sched.h>
+#include <linux/sched/cputime.h>
+#include <linux/atomic.h>
+#include <linux/list.h>
+#include <linux/rcupdate.h>
+
+#define SCHED_BORE_AUTHOR   "Masahito Suzuki"
+#define SCHED_BORE_PROGNAME "BORE CPU Scheduler modification"
+
+#define SCHED_BORE_VERSION  "6.5.2"
+
+extern u8   __read_mostly sched_bore;
+extern u8   __read_mostly sched_burst_inherit_type;
+extern u8   __read_mostly sched_burst_smoothness;
+extern u8   __read_mostly sched_burst_penalty_offset;
+extern uint __read_mostly sched_burst_penalty_scale;
+extern uint __read_mostly sched_burst_cache_lifetime;
+
+extern u8   effective_prio_bore(struct task_struct *p);
+extern void update_curr_bore(struct task_struct *p, u64 delta_exec);
+extern void restart_burst_bore(struct task_struct *p);
+extern void restart_burst_rescale_deadline_bore(struct task_struct *p);
+extern void task_fork_bore(struct task_struct *p, struct task_struct *parent,
+													u64 clone_flags, u64 now);
+extern void sched_init_bore(void);
+extern void reset_task_bore(struct task_struct *p);
+
+extern int  sched_bore_update_handler(const struct ctl_table *table,
+	int write, void __user *buffer, size_t *lenp, loff_t *ppos);
+extern int  sched_burst_inherit_type_update_handler(const struct ctl_table *table,
+	int write, void __user *buffer, size_t *lenp, loff_t *ppos);
+
+extern void reweight_entity(
+	struct cfs_rq *cfs_rq, struct sched_entity *se, unsigned long weight);
+
+#endif /* _KERNEL_SCHED_BORE_H */
diff -Nrup linux-6.16.6/include/linux/sched.h linux-lenovo-x13s-linux-6.16.y/include/linux/sched.h
--- linux-6.16.6/include/linux/sched.h	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/include/linux/sched.h	2025-09-11 09:47:42.000000000 -0600
@@ -809,6 +809,32 @@ struct kmap_ctrl {
 #endif
 };
 
+#ifdef CONFIG_SCHED_BORE
+#define BORE_BC_TIMESTAMP_SHIFT 16
+
+struct bore_bc {
+	u64				timestamp:	48;
+	u64				penalty:	16;
+};
+
+struct bore_ctx {
+	struct bore_bc	subtree;
+	struct bore_bc	group;
+	u64				burst_time;
+	u16				prev_penalty;
+	u16				curr_penalty;
+	union {
+		u16			penalty;
+		struct {
+			u8		_;
+			u8		score;
+		};
+	};
+	bool			stop_update;
+	bool			futex_waiting;
+};
+#endif /* CONFIG_SCHED_BORE */
+
 struct task_struct {
 #ifdef CONFIG_THREAD_INFO_IN_TASK
 	/*
@@ -869,6 +895,9 @@ struct task_struct {
 #ifdef CONFIG_SCHED_CLASS_EXT
 	struct sched_ext_entity		scx;
 #endif
+#ifdef CONFIG_SCHED_BORE
+	struct bore_ctx			bore;
+#endif /* CONFIG_SCHED_BORE */
 	const struct sched_class	*sched_class;
 
 #ifdef CONFIG_SCHED_CORE
diff -Nrup linux-6.16.6/include/linux/soundwire/sdw.h linux-lenovo-x13s-linux-6.16.y/include/linux/soundwire/sdw.h
--- linux-6.16.6/include/linux/soundwire/sdw.h	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/include/linux/soundwire/sdw.h	2025-09-11 09:47:42.000000000 -0600
@@ -19,6 +19,7 @@
 
 struct dentry;
 struct fwnode_handle;
+struct device_node;
 
 struct sdw_bus;
 struct sdw_slave;
@@ -1086,6 +1087,10 @@ int sdw_stream_add_slave(struct sdw_slav
 int sdw_stream_remove_slave(struct sdw_slave *slave,
 			    struct sdw_stream_runtime *stream);
 
+struct device *of_sdw_find_device_by_node(struct device_node *np);
+
+int sdw_slave_get_current_bank(struct sdw_slave *sdev);
+
 int sdw_slave_get_scale_index(struct sdw_slave *slave, u8 *base);
 
 /* messaging and data APIs */
@@ -1117,6 +1122,18 @@ static inline int sdw_stream_remove_slav
 {
 	WARN_ONCE(1, "SoundWire API is disabled");
 	return -EINVAL;
+}
+
+static inline struct device *of_sdw_find_device_by_node(struct device_node *np)
+{
+	WARN_ONCE(1, "SoundWire API is disabled");
+	return NULL;
+}
+
+static inline int sdw_slave_get_current_bank(struct sdw_slave *sdev)
+{
+	WARN_ONCE(1, "SoundWire API is disabled");
+	return -EINVAL;
 }
 
 /* messaging and data APIs */
diff -Nrup linux-6.16.6/include/uapi/sound/snd_ar_tokens.h linux-lenovo-x13s-linux-6.16.y/include/uapi/sound/snd_ar_tokens.h
--- linux-6.16.6/include/uapi/sound/snd_ar_tokens.h	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/include/uapi/sound/snd_ar_tokens.h	2025-09-11 09:47:42.000000000 -0600
@@ -118,6 +118,12 @@ enum ar_event_types {
  *						LPAIF_WSA = 2,
  *						LPAIF_VA = 3,
  *						LPAIF_AXI = 4
+ * Possible values for MI2S
+ *						I2S_INTF_TYPE_PRIMARY = 0,
+ *						I2S_INTF_TYPE_SECONDARY = 1,
+ *						I2S_INTF_TYPE_TERTIARY = 2,
+ *						I2S_INTF_TYPE_QUATERNARY = 3,
+ *						I2S_INTF_TYPE_QUINARY = 4,
  *
  * %AR_TKN_U32_MODULE_FMT_INTERLEAVE:		PCM Interleaving
  *						PCM_INTERLEAVED = 1,
@@ -184,8 +190,8 @@ enum ar_event_types {
 #define AR_TKN_U32_MODULE_INSTANCE_ID		201
 #define AR_TKN_U32_MODULE_MAX_IP_PORTS		202
 #define AR_TKN_U32_MODULE_MAX_OP_PORTS		203
-#define AR_TKN_U32_MODULE_IN_PORTS		204
-#define AR_TKN_U32_MODULE_OUT_PORTS		205
+#define AR_TKN_U32_MODULE_IN_PORTS		204 /* deprecated */
+#define AR_TKN_U32_MODULE_OUT_PORTS		205 /* deprecated */
 #define AR_TKN_U32_MODULE_SRC_OP_PORT_ID	206
 #define AR_TKN_U32_MODULE_DST_IN_PORT_ID	207
 #define AR_TKN_U32_MODULE_SRC_INSTANCE_ID	208
@@ -232,4 +238,12 @@ enum ar_event_types {
 #define AR_TKN_U32_MODULE_LOG_TAP_POINT_ID	260
 #define AR_TKN_U32_MODULE_LOG_MODE		261
 
+#define SND_SOC_AR_TPLG_MODULE_CFG_TYPE 0x01001006
+struct audioreach_module_priv_data {
+	__le32 size;	/* size in bytes of the array, including all elements */
+	__le32 type;	/* SND_SOC_AR_TPLG_MODULE_CFG_TYPE */
+	__le32 priv[2];	/* Private data for future expansion */
+	__le32 data[0];	/* config data */
+};
+
 #endif /* __SND_AR_TOKENS_H__ */
diff -Nrup linux-6.16.6/init/Kconfig linux-lenovo-x13s-linux-6.16.y/init/Kconfig
--- linux-6.16.6/init/Kconfig	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/init/Kconfig	2025-09-11 09:47:42.000000000 -0600
@@ -1381,6 +1381,23 @@ config CHECKPOINT_RESTORE
 
 	  If unsure, say N here.
 
+config SCHED_BORE
+	bool "Burst-Oriented Response Enhancer"
+	default y
+	help
+	  In Desktop and Mobile computing, one might prefer interactive
+	  tasks to keep responsive no matter what they run in the background.
+
+	  Enabling this kernel feature modifies the scheduler to discriminate
+	  tasks by their burst time (runtime since it last went sleeping or
+	  yielding state) and prioritize those that run less bursty.
+	  Such tasks usually include window compositor, widgets backend,
+	  terminal emulator, video playback, games and so on.
+	  With a little impact to scheduling fairness, it may improve
+	  responsiveness especially under heavy background workload.
+
+	  If unsure, say Y here.
+
 config SCHED_AUTOGROUP
 	bool "Automatic process group scheduling"
 	select CGROUPS
diff -Nrup linux-6.16.6/kernel/fork.c linux-lenovo-x13s-linux-6.16.y/kernel/fork.c
--- linux-6.16.6/kernel/fork.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/kernel/fork.c	2025-09-11 09:47:42.000000000 -0600
@@ -115,6 +115,10 @@
 /* For dup_mmap(). */
 #include "../mm/internal.h"
 
+#ifdef CONFIG_SCHED_BORE
+#include <linux/sched/bore.h>
+#endif /* CONFIG_SCHED_BORE */
+
 #include <trace/events/sched.h>
 
 #define CREATE_TRACE_POINTS
@@ -2313,6 +2317,10 @@ __latent_entropy struct task_struct *cop
 	 * Need tasklist lock for parent etc handling!
 	 */
 	write_lock_irq(&tasklist_lock);
+#ifdef CONFIG_SCHED_BORE
+	if (likely(p->pid))
+		task_fork_bore(p, current, clone_flags, p->start_time);
+#endif /* CONFIG_SCHED_BORE */
 
 	/* CLONE_PARENT re-uses the old parent */
 	if (clone_flags & (CLONE_PARENT|CLONE_THREAD)) {
diff -Nrup linux-6.16.6/kernel/futex/waitwake.c linux-lenovo-x13s-linux-6.16.y/kernel/futex/waitwake.c
--- linux-6.16.6/kernel/futex/waitwake.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/kernel/futex/waitwake.c	2025-09-11 09:47:42.000000000 -0600
@@ -4,6 +4,9 @@
 #include <linux/sched/task.h>
 #include <linux/sched/signal.h>
 #include <linux/freezer.h>
+#ifdef CONFIG_SCHED_BORE
+#include <linux/sched/bore.h>
+#endif // CONFIG_SCHED_BORE
 
 #include "futex.h"
 
@@ -355,7 +358,15 @@ void futex_do_wait(struct futex_q *q, st
 		 * is no timeout, or if it has yet to expire.
 		 */
 		if (!timeout || timeout->task)
+#ifdef CONFIG_SCHED_BORE
+		{
+			current->bore.futex_waiting = true;
+#endif // CONFIG_SCHED_BORE
 			schedule();
+#ifdef CONFIG_SCHED_BORE
+			current->bore.futex_waiting = false;
+		}
+#endif // CONFIG_SCHED_BORE
 	}
 	__set_current_state(TASK_RUNNING);
 }
diff -Nrup linux-6.16.6/kernel/Kconfig.hz linux-lenovo-x13s-linux-6.16.y/kernel/Kconfig.hz
--- linux-6.16.6/kernel/Kconfig.hz	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/kernel/Kconfig.hz	2025-09-11 09:47:42.000000000 -0600
@@ -57,3 +57,20 @@ config HZ
 
 config SCHED_HRTICK
 	def_bool HIGH_RES_TIMERS
+
+config MIN_BASE_SLICE_NS
+	int "Default value for min_base_slice_ns"
+	default 2000000
+	help
+	 The BORE Scheduler automatically calculates the optimal base
+	 slice for the configured HZ using the following equation:
+	 
+	 base_slice_ns =
+	 	1000000000/HZ * DIV_ROUNDUP(min_base_slice_ns, 1000000000/HZ)
+	 
+	 This option sets the default lower bound limit of the base slice
+	 to prevent the loss of task throughput due to overscheduling.
+	 
+	 Setting this value too high can cause the system to boot with
+	 an unnecessarily large base slice, resulting in high scheduling
+	 latency and poor system responsiveness.
diff -Nrup linux-6.16.6/kernel/sched/bore.c linux-lenovo-x13s-linux-6.16.y/kernel/sched/bore.c
--- linux-6.16.6/kernel/sched/bore.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-lenovo-x13s-linux-6.16.y/kernel/sched/bore.c	2025-09-11 09:47:42.000000000 -0600
@@ -0,0 +1,393 @@
+/*
+ *  Burst-Oriented Response Enhancer (BORE) CPU Scheduler
+ *  Copyright (C) 2021-2025 Masahito Suzuki <firelzrd@gmail.com>
+ */
+#include <linux/cpuset.h>
+#include <linux/sched/task.h>
+#include <linux/sched/bore.h>
+#include "sched.h"
+
+#ifdef CONFIG_SCHED_BORE
+u8   __read_mostly sched_bore                   = 1;
+u8   __read_mostly sched_burst_inherit_type     = 2;
+u8   __read_mostly sched_burst_smoothness       = 1;
+u8   __read_mostly sched_burst_penalty_offset   = 24;
+uint __read_mostly sched_burst_penalty_scale    = 1536;
+uint __read_mostly sched_burst_cache_lifetime   = 75000000;
+static int __maybe_unused maxval_prio    =   39;
+static int __maybe_unused maxval_6_bits  =   63;
+static int __maybe_unused maxval_8_bits  =  255;
+static int __maybe_unused maxval_12_bits = 4095;
+
+#define MAX_BURST_PENALTY ((40U << 8) - 1)
+#define BURST_CACHE_STOP_COUNT 63
+
+static u32 (*inherit_penalty_fn)(struct task_struct *, u64, u64);
+
+static inline u32 log2p1_u64_u32fp(u64 v, u8 fp) {
+	if (!v) return 0;
+	u32 exponent = fls64(v),
+		mantissa = (u32)(v << (64 - exponent) << 1 >> (64 - fp));
+	return exponent << fp | mantissa;
+}
+
+static inline u32 calc_burst_penalty(u64 burst_time) {
+	u32 greed = log2p1_u64_u32fp(burst_time, 8),
+		tolerance = sched_burst_penalty_offset << 8,
+		penalty = max(0, (s32)(greed - tolerance)),
+		scaled_penalty = penalty * sched_burst_penalty_scale >> 10;
+	return min(MAX_BURST_PENALTY, scaled_penalty);
+}
+
+static inline u64 rescale_slice(u64 delta, u8 old_prio, u8 new_prio) {
+	u64 unscaled, rescaled;
+	unscaled = mul_u64_u32_shr(delta   , sched_prio_to_weight[old_prio], 10);
+	rescaled = mul_u64_u32_shr(unscaled, sched_prio_to_wmult [new_prio], 22);
+	return rescaled;
+}
+
+static inline u32 binary_smooth(u32 new, u32 old) {
+	if (new <= old) return new;
+
+	u32 increment = new - old,
+		shift = sched_burst_smoothness,
+		divisor = 1U << shift;
+
+	return old + ((increment + divisor - 1) >> shift);
+}
+
+static void reweight_task_by_prio(struct task_struct *p, int prio) {
+	if (task_has_idle_policy(p)) return;
+
+	struct sched_entity *se = &p->se;
+	unsigned long weight = scale_load(sched_prio_to_weight[prio]);
+
+	if (se->on_rq) {
+		p->bore.stop_update = true;
+		reweight_entity(cfs_rq_of(se), se, weight);
+		p->bore.stop_update = false;
+	} else
+		se->load.weight = weight;
+	se->load.inv_weight = sched_prio_to_wmult[prio];
+}
+
+u8 effective_prio_bore(struct task_struct *p) {
+	int prio = p->static_prio - MAX_RT_PRIO;
+	if (likely(sched_bore))
+		prio += p->bore.score;
+	return (u8)clamp(prio, 0, maxval_prio);
+}
+
+static void update_penalty(struct task_struct *p) {
+	struct bore_ctx *ctx = &p->bore;
+
+	u8  prev_prio = effective_prio_bore(p);
+	u32 penalty = 0;
+
+	if (!(p->flags & PF_KTHREAD)) {
+		u32 curr_penalty = ctx->curr_penalty;
+		penalty = ctx->prev_penalty;
+		if (penalty < curr_penalty)
+			penalty = curr_penalty;
+	}
+	ctx->penalty = penalty;
+
+	u8 new_prio = effective_prio_bore(p);
+	if (new_prio != prev_prio)
+		reweight_task_by_prio(p, new_prio);
+}
+
+void update_curr_bore(struct task_struct *p, u64 delta_exec) {
+	struct bore_ctx *ctx = &p->bore;
+	if (ctx->stop_update) return;
+
+	ctx->burst_time += delta_exec;
+	u32 curr_penalty = ctx->curr_penalty = calc_burst_penalty(ctx->burst_time);
+
+	if (curr_penalty <= ctx->prev_penalty) return;
+	update_penalty(p);
+}
+
+void restart_burst_bore(struct task_struct *p) {
+	struct bore_ctx *ctx = &p->bore;
+	u32 new_penalty = binary_smooth(ctx->curr_penalty, ctx->prev_penalty);
+	ctx->prev_penalty = new_penalty;
+	ctx->curr_penalty = 0;
+	ctx->burst_time = 0;
+	update_penalty(p);
+}
+
+void restart_burst_rescale_deadline_bore(struct task_struct *p) {
+	struct sched_entity *se = &p->se;
+	s64 vscaled, vremain = se->deadline - se->vruntime;
+
+	u8 old_prio = effective_prio_bore(p);
+	restart_burst_bore(p);
+	u8 new_prio = effective_prio_bore(p);
+
+	if (old_prio > new_prio) {
+		vscaled = rescale_slice(abs(vremain), old_prio, new_prio);
+		if (unlikely(vremain < 0))
+			vscaled = -vscaled;
+		se->deadline = se->vruntime + vscaled;
+	}
+}
+
+static inline bool task_is_bore_eligible(struct task_struct *p)
+{return p && p->sched_class == &fair_sched_class && !p->exit_state;}
+
+#ifndef for_each_child_task
+#define for_each_child_task(p, t) \
+	list_for_each_entry(t, &(p)->children, sibling)
+#endif
+
+static inline u32 count_children_upto2(struct task_struct *p) {
+	struct list_head *head = &p->children;
+	struct list_head *next = head->next;
+	return (next != head) + (next->next != head);
+}
+
+static inline bool burst_cache_expired(struct bore_bc *bc, u64 now) {
+	u64 timestamp = bc->timestamp << BORE_BC_TIMESTAMP_SHIFT;
+	return now - timestamp > sched_burst_cache_lifetime;
+}
+
+static void update_burst_cache(struct bore_bc *bc,
+		struct task_struct *p, u32 count, u32 total, u64 now) {
+	u32 average = count ? total / count : 0;
+	bc->penalty = max(average, p->bore.penalty);
+	bc->timestamp = now >> BORE_BC_TIMESTAMP_SHIFT;
+}
+
+static u32 inherit_none(struct task_struct *parent,
+									u64 clone_flags, u64 now)
+{ return 0; }
+
+static u32 inherit_from_parent(struct task_struct *parent,
+									u64 clone_flags, u64 now) {
+	if (clone_flags & CLONE_PARENT)
+		parent = parent->real_parent;
+
+	struct bore_bc *bc = &parent->bore.subtree;
+
+	if (burst_cache_expired(bc, now)) {
+		struct task_struct *child;
+		u32 count = 0, total = 0;
+		for_each_child_task(parent, child) {
+			if (count >= BURST_CACHE_STOP_COUNT) break;
+
+			if (!task_is_bore_eligible(child)) continue;
+			count++;
+			total += child->bore.penalty;
+		}
+
+		update_burst_cache(bc, parent, count, total, now);
+	}
+
+	return bc->penalty;
+}
+
+static u32 inherit_from_ancestor_hub(struct task_struct *parent,
+										u64 clone_flags, u64 now) {
+	struct task_struct *ancestor = parent;
+	u32 sole_child_count = 0;
+
+	if (clone_flags & CLONE_PARENT) {
+		ancestor = ancestor->real_parent;
+		sole_child_count = 1;
+	}
+
+	for (struct task_struct *next;
+			(next = ancestor->real_parent) != ancestor &&
+			count_children_upto2(ancestor) <= sole_child_count;
+			ancestor = next, sole_child_count = 1) {}
+
+	struct bore_bc *bc = &ancestor->bore.subtree;
+
+	if (burst_cache_expired(bc, now)) {
+		struct task_struct *direct_child;
+		u32 count = 0, total = 0;
+		for_each_child_task(ancestor, direct_child) {
+			if (count >= BURST_CACHE_STOP_COUNT) break;
+
+			struct task_struct *descendant = direct_child;
+			while (count_children_upto2(descendant) == 1)
+				descendant = list_first_entry(&descendant->children,
+												struct task_struct, sibling);
+
+			if (!task_is_bore_eligible(descendant)) continue;
+			count++;
+			total += descendant->bore.penalty;
+		}
+
+		update_burst_cache(bc, ancestor, count, total, now);
+	}
+
+	return bc->penalty;
+}
+
+static u32 inherit_from_thread_group(struct task_struct *p, u64 now) {
+	struct task_struct *leader = p->group_leader;
+	struct bore_bc *bc = &leader->bore.group;
+
+	if (burst_cache_expired(bc, now)) {
+		struct task_struct *sibling;
+		u32 count = 0, total = 0;
+
+		for_each_thread(leader, sibling) {
+			if (count >= BURST_CACHE_STOP_COUNT) break;
+
+			if (!task_is_bore_eligible(sibling)) continue;
+			count++;
+			total += sibling->bore.penalty;
+		}
+
+		update_burst_cache(bc, leader, count, total, now);
+	}
+
+	return bc->penalty;
+}
+
+void task_fork_bore(struct task_struct *p,
+	               struct task_struct *parent, u64 clone_flags, u64 now) {
+	if (!task_is_bore_eligible(p) || unlikely(!sched_bore)) return;
+
+	struct bore_ctx *ctx = &p->bore;
+	u32 inherited_penalty = (clone_flags & CLONE_THREAD)?
+		inherit_from_thread_group(parent, now):
+		inherit_penalty_fn(parent, clone_flags, now);
+
+	if (ctx->prev_penalty < inherited_penalty)
+		ctx->prev_penalty = inherited_penalty;
+	ctx->curr_penalty  = 0;
+	ctx->burst_time    = 0;
+	ctx->stop_update   = false;
+	ctx->futex_waiting = false;
+	update_penalty(p);
+}
+
+void reset_task_bore(struct task_struct *p)
+{ memset(&p->bore, 0, sizeof(struct bore_ctx)); }
+
+static void update_inherit_type(void) {
+	switch(sched_burst_inherit_type) {
+	case 1:
+		inherit_penalty_fn = inherit_from_parent;
+		break;
+	case 2:
+		inherit_penalty_fn = inherit_from_ancestor_hub;
+		break;
+	default:
+		inherit_penalty_fn = inherit_none;
+	}
+}
+
+void __init sched_init_bore(void) {
+	printk(KERN_INFO "%s %s by %s\n",
+		SCHED_BORE_PROGNAME, SCHED_BORE_VERSION, SCHED_BORE_AUTHOR);
+
+	reset_task_bore(&init_task);
+	update_inherit_type();
+}
+
+static void readjust_all_task_weights(void) {
+	struct task_struct *task;
+	struct rq *rq;
+	struct rq_flags rf;
+
+	scoped_guard(write_lock_irq, &tasklist_lock)
+	for_each_process(task) {
+		if (!task_is_bore_eligible(task)) continue;
+		rq = task_rq_lock(task, &rf);
+		update_rq_clock(rq);
+		reweight_task_by_prio(task, effective_prio_bore(task));
+		task_rq_unlock(rq, task, &rf);
+	}
+}
+
+int sched_bore_update_handler(const struct ctl_table *table,
+		int write, void __user *buffer, size_t *lenp, loff_t *ppos) {
+	int ret = proc_dou8vec_minmax(table, write, buffer, lenp, ppos);
+	if (ret || !write)
+		return ret;
+
+	readjust_all_task_weights();
+
+	return 0;
+}
+
+int sched_burst_inherit_type_update_handler(const struct ctl_table *table,
+		int write, void __user *buffer, size_t *lenp, loff_t *ppos) {
+	int ret = proc_dou8vec_minmax(table, write, buffer, lenp, ppos);
+	if (ret || !write)
+		return ret;
+
+	update_inherit_type();
+
+	return 0;
+}
+
+#ifdef CONFIG_SYSCTL
+static struct ctl_table sched_bore_sysctls[] = {
+	{
+		.procname	= "sched_bore",
+		.data		= &sched_bore,
+		.maxlen		= sizeof(u8),
+		.mode		= 0644,
+		.proc_handler = sched_bore_update_handler,
+		.extra1		= SYSCTL_ZERO,
+		.extra2		= SYSCTL_ONE,
+	},
+	{
+		.procname	= "sched_burst_inherit_type",
+		.data		= &sched_burst_inherit_type,
+		.maxlen		= sizeof(u8),
+		.mode		= 0644,
+		.proc_handler = sched_burst_inherit_type_update_handler,
+		.extra1		= SYSCTL_ZERO,
+		.extra2		= SYSCTL_TWO,
+	},
+	{
+		.procname	= "sched_burst_smoothness",
+		.data		= &sched_burst_smoothness,
+		.maxlen		= sizeof(u8),
+		.mode		= 0644,
+		.proc_handler = proc_dou8vec_minmax,
+		.extra1		= SYSCTL_ZERO,
+		.extra2		= SYSCTL_THREE,
+	},
+	{
+		.procname	= "sched_burst_penalty_offset",
+		.data		= &sched_burst_penalty_offset,
+		.maxlen		= sizeof(u8),
+		.mode		= 0644,
+		.proc_handler = proc_dou8vec_minmax,
+		.extra1		= SYSCTL_ZERO,
+		.extra2		= &maxval_6_bits,
+	},
+	{
+		.procname	= "sched_burst_penalty_scale",
+		.data		= &sched_burst_penalty_scale,
+		.maxlen		= sizeof(uint),
+		.mode		= 0644,
+		.proc_handler = proc_douintvec_minmax,
+		.extra1		= SYSCTL_ZERO,
+		.extra2		= &maxval_12_bits,
+	},
+	{
+		.procname	= "sched_burst_cache_lifetime",
+		.data		= &sched_burst_cache_lifetime,
+		.maxlen		= sizeof(uint),
+		.mode		= 0644,
+		.proc_handler = proc_douintvec,
+	},
+};
+
+static int __init sched_bore_sysctl_init(void) {
+	register_sysctl_init("kernel", sched_bore_sysctls);
+	return 0;
+}
+late_initcall(sched_bore_sysctl_init);
+
+#endif // CONFIG_SYSCTL
+#endif /* CONFIG_SCHED_BORE */
diff -Nrup linux-6.16.6/kernel/sched/core.c linux-lenovo-x13s-linux-6.16.y/kernel/sched/core.c
--- linux-6.16.6/kernel/sched/core.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/kernel/sched/core.c	2025-09-11 09:47:42.000000000 -0600
@@ -97,6 +97,10 @@
 #include "../../io_uring/io-wq.h"
 #include "../smpboot.h"
 
+#ifdef CONFIG_SCHED_BORE
+#include <linux/sched/bore.h>
+#endif /* CONFIG_SCHED_BORE */
+
 EXPORT_TRACEPOINT_SYMBOL_GPL(ipi_send_cpu);
 EXPORT_TRACEPOINT_SYMBOL_GPL(ipi_send_cpumask);
 
@@ -1423,7 +1427,11 @@ int tg_nop(struct task_group *tg, void *
 
 void set_load_weight(struct task_struct *p, bool update_load)
 {
+#ifdef CONFIG_SCHED_BORE
+	int prio = effective_prio_bore(p);
+#else /* !CONFIG_SCHED_BORE */
 	int prio = p->static_prio - MAX_RT_PRIO;
+#endif /* CONFIG_SCHED_BORE */
 	struct load_weight lw;
 
 	if (task_has_idle_policy(p)) {
@@ -8523,6 +8531,10 @@ void __init sched_init(void)
 	BUG_ON(!sched_class_above(&ext_sched_class, &idle_sched_class));
 #endif
 
+#ifdef CONFIG_SCHED_BORE
+	sched_init_bore();
+#endif /* CONFIG_SCHED_BORE */
+
 	wait_bit_init();
 
 #ifdef CONFIG_FAIR_GROUP_SCHED
diff -Nrup linux-6.16.6/kernel/sched/debug.c linux-lenovo-x13s-linux-6.16.y/kernel/sched/debug.c
--- linux-6.16.6/kernel/sched/debug.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/kernel/sched/debug.c	2025-09-11 09:47:42.000000000 -0600
@@ -167,7 +167,53 @@ static const struct file_operations sche
 };
 
 #ifdef CONFIG_SMP
+#ifdef CONFIG_SCHED_BORE
+#define DEFINE_SYSCTL_SCHED_FUNC(name, update_func) \
+static ssize_t sched_##name##_write(struct file *filp, const char __user *ubuf, size_t cnt, loff_t *ppos) \
+{ \
+	char buf[16]; \
+	unsigned int value; \
+\
+	if (cnt > 15) \
+		cnt = 15; \
+\
+	if (copy_from_user(&buf, ubuf, cnt)) \
+		return -EFAULT; \
+	buf[cnt] = '\0'; \
+\
+	if (kstrtouint(buf, 10, &value)) \
+		return -EINVAL; \
+\
+	sysctl_sched_##name = value; \
+	sched_update_##update_func(); \
+\
+	*ppos += cnt; \
+	return cnt; \
+} \
+\
+static int sched_##name##_show(struct seq_file *m, void *v) \
+{ \
+	seq_printf(m, "%d\n", sysctl_sched_##name); \
+	return 0; \
+} \
+\
+static int sched_##name##_open(struct inode *inode, struct file *filp) \
+{ \
+	return single_open(filp, sched_##name##_show, NULL); \
+} \
+\
+static const struct file_operations sched_##name##_fops = { \
+	.open		= sched_##name##_open, \
+	.write		= sched_##name##_write, \
+	.read		= seq_read, \
+	.llseek		= seq_lseek, \
+	.release	= single_release, \
+};
+
+DEFINE_SYSCTL_SCHED_FUNC(min_base_slice, min_base_slice)
 
+#undef DEFINE_SYSCTL_SCHED_FUNC
+#else /* !CONFIG_SCHED_BORE */
 static ssize_t sched_scaling_write(struct file *filp, const char __user *ubuf,
 				   size_t cnt, loff_t *ppos)
 {
@@ -213,7 +259,7 @@ static const struct file_operations sche
 	.llseek		= seq_lseek,
 	.release	= single_release,
 };
-
+#endif /* CONFIG_SCHED_BORE */
 #endif /* SMP */
 
 #ifdef CONFIG_PREEMPT_DYNAMIC
@@ -507,13 +553,20 @@ static __init int sched_init_debug(void)
 	debugfs_create_file("preempt", 0644, debugfs_sched, NULL, &sched_dynamic_fops);
 #endif
 
+#ifdef CONFIG_SCHED_BORE
+	debugfs_create_file("min_base_slice_ns", 0644, debugfs_sched, NULL, &sched_min_base_slice_fops);
+	debugfs_create_u32("base_slice_ns", 0444, debugfs_sched, &sysctl_sched_base_slice);
+#else /* !CONFIG_SCHED_BORE */
 	debugfs_create_u32("base_slice_ns", 0644, debugfs_sched, &sysctl_sched_base_slice);
+#endif /* CONFIG_SCHED_BORE */
 
 	debugfs_create_u32("latency_warn_ms", 0644, debugfs_sched, &sysctl_resched_latency_warn_ms);
 	debugfs_create_u32("latency_warn_once", 0644, debugfs_sched, &sysctl_resched_latency_warn_once);
 
 #ifdef CONFIG_SMP
+#if !defined(CONFIG_SCHED_BORE)
 	debugfs_create_file("tunable_scaling", 0644, debugfs_sched, NULL, &sched_scaling_fops);
+#endif /* CONFIG_SCHED_BORE */
 	debugfs_create_u32("migration_cost_ns", 0644, debugfs_sched, &sysctl_sched_migration_cost);
 	debugfs_create_u32("nr_migrate", 0644, debugfs_sched, &sysctl_sched_nr_migrate);
 
@@ -762,6 +815,9 @@ print_task(struct seq_file *m, struct rq
 		SPLIT_NS(schedstat_val_or_zero(p->stats.sum_sleep_runtime)),
 		SPLIT_NS(schedstat_val_or_zero(p->stats.sum_block_runtime)));
 
+#ifdef CONFIG_SCHED_BORE
+	SEQ_printf(m, " %2d", p->bore.score);
+#endif /* CONFIG_SCHED_BORE */
 #ifdef CONFIG_NUMA_BALANCING
 	SEQ_printf(m, "   %d      %d", task_node(p), task_numa_group_id(p));
 #endif
@@ -1248,6 +1304,9 @@ void proc_sched_show_task(struct task_st
 
 	P(se.load.weight);
 #ifdef CONFIG_SMP
+#ifdef CONFIG_SCHED_BORE
+	P(bore.score);
+#endif /* CONFIG_SCHED_BORE */
 	P(se.avg.load_sum);
 	P(se.avg.runnable_sum);
 	P(se.avg.util_sum);
diff -Nrup linux-6.16.6/kernel/sched/fair.c linux-lenovo-x13s-linux-6.16.y/kernel/sched/fair.c
--- linux-6.16.6/kernel/sched/fair.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/kernel/sched/fair.c	2025-09-11 09:47:42.000000000 -0600
@@ -58,6 +58,10 @@
 #include "stats.h"
 #include "autogroup.h"
 
+#ifdef CONFIG_SCHED_BORE
+#include <linux/sched/bore.h>
+#endif /* CONFIG_SCHED_BORE */
+
 /*
  * The initial- and re-scaling of tunables is configurable
  *
@@ -67,17 +71,30 @@
  *   SCHED_TUNABLESCALING_LOG - scaled logarithmically, *1+ilog(ncpus)
  *   SCHED_TUNABLESCALING_LINEAR - scaled linear, *ncpus
  *
- * (default SCHED_TUNABLESCALING_LOG = *(1+ilog(ncpus))
+ * BORE : default SCHED_TUNABLESCALING_NONE = *1 constant
+ * EEVDF: default SCHED_TUNABLESCALING_LOG  = *(1+ilog(ncpus))
  */
+#ifdef CONFIG_SCHED_BORE
+unsigned int sysctl_sched_tunable_scaling = SCHED_TUNABLESCALING_NONE;
+#else /* !CONFIG_SCHED_BORE */
 unsigned int sysctl_sched_tunable_scaling = SCHED_TUNABLESCALING_LOG;
+#endif /* CONFIG_SCHED_BORE */
 
 /*
  * Minimal preemption granularity for CPU-bound tasks:
  *
- * (default: 0.70 msec * (1 + ilog(ncpus)), units: nanoseconds)
- */
+ * BORE : base_slice = minimum multiple of nsecs_per_tick >= min_base_slice
+ * (default min_base_slice = 2000000 constant, units: nanoseconds)
+ * EEVDF: default 0.70 msec * (1 + ilog(ncpus)), units: nanoseconds
+ */
+#ifdef CONFIG_SCHED_BORE
+static const unsigned int nsecs_per_tick       = 1000000000ULL / HZ;
+unsigned int sysctl_sched_min_base_slice       = CONFIG_MIN_BASE_SLICE_NS;
+__read_mostly uint sysctl_sched_base_slice     = nsecs_per_tick;
+#else /* !CONFIG_SCHED_BORE */
 unsigned int sysctl_sched_base_slice			= 700000ULL;
 static unsigned int normalized_sysctl_sched_base_slice	= 700000ULL;
+#endif /* CONFIG_SCHED_BORE */
 
 __read_mostly unsigned int sysctl_sched_migration_cost	= 500000UL;
 
@@ -191,6 +208,13 @@ static inline void update_load_set(struc
  *
  * This idea comes from the SD scheduler of Con Kolivas:
  */
+#ifdef CONFIG_SCHED_BORE
+static void update_sysctl(void) {
+	sysctl_sched_base_slice = nsecs_per_tick *
+		max(1UL, DIV_ROUND_UP(sysctl_sched_min_base_slice, nsecs_per_tick));
+}
+void sched_update_min_base_slice(void) { update_sysctl(); }
+#else /* !CONFIG_SCHED_BORE */
 static unsigned int get_update_sysctl_factor(void)
 {
 	unsigned int cpus = min_t(unsigned int, num_online_cpus(), 8);
@@ -221,6 +245,7 @@ static void update_sysctl(void)
 	SET_SYSCTL(sched_base_slice);
 #undef SET_SYSCTL
 }
+#endif /* CONFIG_SCHED_BORE */
 
 void __init sched_init_granularity(void)
 {
@@ -700,6 +725,9 @@ static void update_entity_lag(struct cfs
 
 	vlag = avg_vruntime(cfs_rq) - se->vruntime;
 	limit = calc_delta_fair(max_t(u64, 2*se->slice, TICK_NSEC), se);
+#ifdef CONFIG_SCHED_BORE
+	limit >>= !!sched_bore;
+#endif /* CONFIG_SCHED_BORE */
 
 	se->vlag = clamp(vlag, -limit, limit);
 }
@@ -939,7 +967,16 @@ static struct sched_entity *pick_eevdf(s
 	if (curr && (!curr->on_rq || !entity_eligible(cfs_rq, curr)))
 		curr = NULL;
 
+#if !defined(CONFIG_SCHED_BORE)
 	if (sched_feat(RUN_TO_PARITY) && curr && protect_slice(curr))
+#else /* CONFIG_SCHED_BORE */
+	bool run_to_parity = likely(sched_bore) ?
+		sched_feat(RUN_TO_PARITY_BORE) : sched_feat(RUN_TO_PARITY);
+	if (run_to_parity && curr && protect_slice(curr) &&
+		(!entity_is_task(curr) ||
+		 !task_of(curr)->bore.futex_waiting ||
+		 unlikely(!sched_bore)))
+#endif /* CONFIG_SCHED_BORE */
 		return curr;
 
 	/* Pick the leftmost entity if it's eligible */
@@ -997,6 +1034,7 @@ struct sched_entity *__pick_last_entity(
  * Scheduling class statistics methods:
  */
 #ifdef CONFIG_SMP
+#if !defined(CONFIG_SCHED_BORE)
 int sched_update_scaling(void)
 {
 	unsigned int factor = get_update_sysctl_factor();
@@ -1008,6 +1046,7 @@ int sched_update_scaling(void)
 
 	return 0;
 }
+#endif /* CONFIG_SCHED_BORE */
 #endif
 
 static void clear_buddies(struct cfs_rq *cfs_rq, struct sched_entity *se);
@@ -1244,6 +1283,9 @@ static void update_curr(struct cfs_rq *c
 	if (entity_is_task(curr)) {
 		struct task_struct *p = task_of(curr);
 
+#ifdef CONFIG_SCHED_BORE
+		update_curr_bore(p, delta_exec);
+#endif /* CONFIG_SCHED_BORE */
 		update_curr_task(p, delta_exec);
 
 		/*
@@ -3794,7 +3836,7 @@ dequeue_load_avg(struct cfs_rq *cfs_rq,
 
 static void place_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int flags);
 
-static void reweight_entity(struct cfs_rq *cfs_rq, struct sched_entity *se,
+void reweight_entity(struct cfs_rq *cfs_rq, struct sched_entity *se,
 			    unsigned long weight)
 {
 	bool curr = cfs_rq->curr == se;
@@ -5205,12 +5247,11 @@ void __setparam_fair(struct task_struct
 static void
 place_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int flags)
 {
-	u64 vslice, vruntime = avg_vruntime(cfs_rq);
+	u64 vslice = 0, vruntime = avg_vruntime(cfs_rq);
 	s64 lag = 0;
 
 	if (!se->custom_slice)
 		se->slice = sysctl_sched_base_slice;
-	vslice = calc_delta_fair(se->slice, se);
 
 	/*
 	 * Due to how V is constructed as the weighted average of entities,
@@ -5295,7 +5336,18 @@ place_entity(struct cfs_rq *cfs_rq, stru
 		se->rel_deadline = 0;
 		return;
 	}
-
+#ifdef CONFIG_SCHED_BORE
+	if (entity_is_task(se) &&
+			likely(sched_bore) &&
+			task_of(se)->bore.futex_waiting)
+		goto vslice_found;
+#endif /* !CONFIG_SCHED_BORE */
+	vslice = calc_delta_fair(se->slice, se);
+#ifdef CONFIG_SCHED_BORE
+	if (likely(sched_bore))
+		vslice >>= !!(flags & (ENQUEUE_INITIAL | ENQUEUE_WAKEUP));
+	else
+#endif /* CONFIG_SCHED_BORE */
 	/*
 	 * When joining the competition; the existing tasks will be,
 	 * on average, halfway through their slice, as such start tasks
@@ -5304,6 +5356,9 @@ place_entity(struct cfs_rq *cfs_rq, stru
 	if (sched_feat(PLACE_DEADLINE_INITIAL) && (flags & ENQUEUE_INITIAL))
 		vslice /= 2;
 
+#ifdef CONFIG_SCHED_BORE
+vslice_found:
+#endif /* CONFIG_SCHED_BORE */
 	/*
 	 * EEVDF: vd_i = ve_i + r_i/w_i
 	 */
@@ -5314,7 +5369,7 @@ static void check_enqueue_throttle(struc
 static inline int cfs_rq_throttled(struct cfs_rq *cfs_rq);
 
 static void
-requeue_delayed_entity(struct sched_entity *se);
+requeue_delayed_entity(struct sched_entity *se, int flags);
 
 static void
 enqueue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int flags)
@@ -5478,6 +5533,10 @@ dequeue_entity(struct cfs_rq *cfs_rq, st
 		if (sched_feat(DELAY_DEQUEUE) && delay &&
 		    !entity_eligible(cfs_rq, se)) {
 			update_load_avg(cfs_rq, se, 0);
+#ifdef CONFIG_SCHED_BORE
+			if (sched_feat(DELAY_ZERO) && likely(sched_bore))
+				update_entity_lag(cfs_rq, se);
+#endif /* CONFIG_SCHED_BORE */
 			set_delayed(se);
 			return false;
 		}
@@ -6894,7 +6953,7 @@ static int sched_idle_cpu(int cpu)
 #endif
 
 static void
-requeue_delayed_entity(struct sched_entity *se)
+requeue_delayed_entity(struct sched_entity *se, int flags)
 {
 	struct cfs_rq *cfs_rq = cfs_rq_of(se);
 
@@ -6907,13 +6966,22 @@ requeue_delayed_entity(struct sched_enti
 	WARN_ON_ONCE(!se->on_rq);
 
 	if (sched_feat(DELAY_ZERO)) {
+#ifdef CONFIG_SCHED_BORE
+		if (likely(sched_bore))
+			flags |= ENQUEUE_WAKEUP;
+		else {
+#endif /* CONFIG_SCHED_BORE */
+		flags = 0;
 		update_entity_lag(cfs_rq, se);
+#ifdef CONFIG_SCHED_BORE
+		}
+#endif /* CONFIG_SCHED_BORE */
 		if (se->vlag > 0) {
 			cfs_rq->nr_queued--;
 			if (se != cfs_rq->curr)
 				__dequeue_entity(cfs_rq, se);
 			se->vlag = 0;
-			place_entity(cfs_rq, se, 0);
+			place_entity(cfs_rq, se, flags);
 			if (se != cfs_rq->curr)
 				__enqueue_entity(cfs_rq, se);
 			cfs_rq->nr_queued++;
@@ -6950,7 +7018,7 @@ enqueue_task_fair(struct rq *rq, struct
 		util_est_enqueue(&rq->cfs, p);
 
 	if (flags & ENQUEUE_DELAYED) {
-		requeue_delayed_entity(se);
+		requeue_delayed_entity(se, flags);
 		return;
 	}
 
@@ -6968,7 +7036,7 @@ enqueue_task_fair(struct rq *rq, struct
 	for_each_sched_entity(se) {
 		if (se->on_rq) {
 			if (se->sched_delayed)
-				requeue_delayed_entity(se);
+				requeue_delayed_entity(se, flags);
 			break;
 		}
 		cfs_rq = cfs_rq_of(se);
@@ -7190,6 +7258,15 @@ static bool dequeue_task_fair(struct rq
 		util_est_dequeue(&rq->cfs, p);
 
 	util_est_update(&rq->cfs, p, flags & DEQUEUE_SLEEP);
+#ifdef CONFIG_SCHED_BORE
+	struct cfs_rq *cfs_rq = &rq->cfs;
+	struct sched_entity *se = &p->se;
+	if ((flags & DEQUEUE_SLEEP) && entity_is_task(se)) {
+		if (cfs_rq->curr == se)
+			update_curr(cfs_rq_of(&p->se));
+		restart_burst_bore(p);
+	}
+#endif /* CONFIG_SCHED_BORE */
 	if (dequeue_entities(rq, &p->se, flags) < 0)
 		return false;
 
@@ -7559,9 +7636,14 @@ static inline int sched_balance_find_dst
 	return new_cpu;
 }
 
+static inline bool is_idle_cpu(int cpu)
+{
+	return available_idle_cpu(cpu) || sched_idle_cpu(cpu);
+}
+
 static inline int __select_idle_cpu(int cpu, struct task_struct *p)
 {
-	if ((available_idle_cpu(cpu) || sched_idle_cpu(cpu)) &&
+	if (is_idle_cpu(cpu) &&
 	    sched_cpu_cookie_match(cpu_rq(cpu), p))
 		return cpu;
 
@@ -7572,6 +7654,24 @@ static inline int __select_idle_cpu(int
 DEFINE_STATIC_KEY_FALSE(sched_smt_present);
 EXPORT_SYMBOL_GPL(sched_smt_present);
 
+/*
+ * Return true if all the CPUs in the SMT core where @cpu belongs are idle,
+ * false otherwise.
+ */
+static bool is_idle_core(int cpu)
+{
+	int sibling;
+
+	if (!sched_smt_active())
+		return is_idle_cpu(cpu);
+
+	for_each_cpu(sibling, cpu_smt_mask(cpu))
+		if (!is_idle_cpu(sibling))
+			return false;
+
+	return true;
+}
+
 static inline void set_idle_cores(int cpu, int val)
 {
 	struct sched_domain_shared *sds;
@@ -7654,29 +7754,6 @@ static int select_idle_core(struct task_
 	return -1;
 }
 
-/*
- * Scan the local SMT mask for idle CPUs.
- */
-static int select_idle_smt(struct task_struct *p, struct sched_domain *sd, int target)
-{
-	int cpu;
-
-	for_each_cpu_and(cpu, cpu_smt_mask(target), p->cpus_ptr) {
-		if (cpu == target)
-			continue;
-		/*
-		 * Check if the CPU is in the LLC scheduling domain of @target.
-		 * Due to isolcpus, there is no guarantee that all the siblings are in the domain.
-		 */
-		if (!cpumask_test_cpu(cpu, sched_domain_span(sd)))
-			continue;
-		if (available_idle_cpu(cpu) || sched_idle_cpu(cpu))
-			return cpu;
-	}
-
-	return -1;
-}
-
 #else /* CONFIG_SCHED_SMT */
 
 static inline void set_idle_cores(int cpu, int val)
@@ -7693,9 +7770,9 @@ static inline int select_idle_core(struc
 	return __select_idle_cpu(core, p);
 }
 
-static inline int select_idle_smt(struct task_struct *p, struct sched_domain *sd, int target)
+static inline bool is_idle_core(int cpu)
 {
-	return -1;
+	return is_idle_cpu(cpu);
 }
 
 #endif /* CONFIG_SCHED_SMT */
@@ -7792,7 +7869,7 @@ select_idle_capacity(struct task_struct
 	for_each_cpu_wrap(cpu, cpus, target) {
 		unsigned long cpu_cap = capacity_of(cpu);
 
-		if (!available_idle_cpu(cpu) && !sched_idle_cpu(cpu))
+		if (!is_idle_cpu(cpu))
 			continue;
 
 		fits = util_fits_cpu(task_util, util_min, util_max, cpu);
@@ -7863,7 +7940,7 @@ static int select_idle_sibling(struct ta
 	 */
 	lockdep_assert_irqs_disabled();
 
-	if ((available_idle_cpu(target) || sched_idle_cpu(target)) &&
+	if (is_idle_core(target) &&
 	    asym_fits_cpu(task_util, util_min, util_max, target))
 		return target;
 
@@ -7871,7 +7948,7 @@ static int select_idle_sibling(struct ta
 	 * If the previous CPU is cache affine and idle, don't be stupid:
 	 */
 	if (prev != target && cpus_share_cache(prev, target) &&
-	    (available_idle_cpu(prev) || sched_idle_cpu(prev)) &&
+	    is_idle_core(prev) &&
 	    asym_fits_cpu(task_util, util_min, util_max, prev)) {
 
 		if (!static_branch_unlikely(&sched_cluster_active) ||
@@ -7903,7 +7980,7 @@ static int select_idle_sibling(struct ta
 	if (recent_used_cpu != prev &&
 	    recent_used_cpu != target &&
 	    cpus_share_cache(recent_used_cpu, target) &&
-	    (available_idle_cpu(recent_used_cpu) || sched_idle_cpu(recent_used_cpu)) &&
+	    is_idle_core(recent_used_cpu) &&
 	    cpumask_test_cpu(recent_used_cpu, p->cpus_ptr) &&
 	    asym_fits_cpu(task_util, util_min, util_max, recent_used_cpu)) {
 
@@ -7939,16 +8016,9 @@ static int select_idle_sibling(struct ta
 	if (!sd)
 		return target;
 
-	if (sched_smt_active()) {
+	if (sched_smt_active())
 		has_idle_core = test_idle_cores(target);
 
-		if (!has_idle_core && cpus_share_cache(prev, target)) {
-			i = select_idle_smt(p, sd, prev);
-			if ((unsigned int)i < nr_cpumask_bits)
-				return i;
-		}
-	}
-
 	i = select_idle_cpu(p, sd, has_idle_core, target);
 	if ((unsigned)i < nr_cpumask_bits)
 		return i;
@@ -9019,16 +9089,25 @@ static void yield_task_fair(struct rq *r
 	/*
 	 * Are we the only task in the tree?
 	 */
+#if !defined(CONFIG_SCHED_BORE)
 	if (unlikely(rq->nr_running == 1))
 		return;
 
 	clear_buddies(cfs_rq, se);
+#endif /* CONFIG_SCHED_BORE */
 
 	update_rq_clock(rq);
 	/*
 	 * Update run-time statistics of the 'current'.
 	 */
 	update_curr(cfs_rq);
+#ifdef CONFIG_SCHED_BORE
+	restart_burst_rescale_deadline_bore(curr);
+	if (unlikely(rq->nr_running == 1))
+		return;
+
+	clear_buddies(cfs_rq, se);
+#endif /* CONFIG_SCHED_BORE */
 	/*
 	 * Tell update_rq_clock() that we've just updated,
 	 * so we don't do microscopic update in schedule()
@@ -13273,6 +13352,9 @@ static void switched_to_fair(struct rq *
 	WARN_ON_ONCE(p->se.sched_delayed);
 
 	attach_task_cfs_rq(p);
+#ifdef CONFIG_SCHED_BORE
+	reset_task_bore(p);
+#endif /* CONFIG_SCHED_BORE */
 
 	set_task_max_allowed_capacity(p);
 
diff -Nrup linux-6.16.6/kernel/sched/features.h linux-lenovo-x13s-linux-6.16.y/kernel/sched/features.h
--- linux-6.16.6/kernel/sched/features.h	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/kernel/sched/features.h	2025-09-11 09:47:42.000000000 -0600
@@ -18,6 +18,9 @@ SCHED_FEAT(PLACE_REL_DEADLINE, true)
  * 0-lag point or until is has exhausted it's slice.
  */
 SCHED_FEAT(RUN_TO_PARITY, true)
+#ifdef CONFIG_SCHED_BORE
+SCHED_FEAT(RUN_TO_PARITY_BORE, false)
+#endif /* CONFIG_SCHED_BORE */
 /*
  * Allow wakeup of tasks with a shorter slice to cancel RUN_TO_PARITY for
  * current.
diff -Nrup linux-6.16.6/kernel/sched/Makefile linux-lenovo-x13s-linux-6.16.y/kernel/sched/Makefile
--- linux-6.16.6/kernel/sched/Makefile	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/kernel/sched/Makefile	2025-09-11 09:47:42.000000000 -0600
@@ -37,3 +37,4 @@ obj-y += core.o
 obj-y += fair.o
 obj-y += build_policy.o
 obj-y += build_utility.o
+obj-$(CONFIG_SCHED_BORE) += bore.o
diff -Nrup linux-6.16.6/kernel/sched/sched.h linux-lenovo-x13s-linux-6.16.y/kernel/sched/sched.h
--- linux-6.16.6/kernel/sched/sched.h	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/kernel/sched/sched.h	2025-09-11 09:47:42.000000000 -0600
@@ -2119,7 +2119,11 @@ extern int group_balance_cpu(struct sche
 extern void update_sched_domain_debugfs(void);
 extern void dirty_sched_domain_sysctl(int cpu);
 
+#ifdef CONFIG_SCHED_BORE
+extern void sched_update_min_base_slice(void);
+#else /* !CONFIG_SCHED_BORE */
 extern int sched_update_scaling(void);
+#endif /* CONFIG_SCHED_BORE */
 
 static inline const struct cpumask *task_user_cpus(struct task_struct *p)
 {
@@ -2825,7 +2829,12 @@ extern void wakeup_preempt(struct rq *rq
 extern __read_mostly unsigned int sysctl_sched_nr_migrate;
 extern __read_mostly unsigned int sysctl_sched_migration_cost;
 
+#ifdef CONFIG_SCHED_BORE
+extern unsigned int sysctl_sched_min_base_slice;
+extern __read_mostly uint sysctl_sched_base_slice;
+#else /* !CONFIG_SCHED_BORE */
 extern unsigned int sysctl_sched_base_slice;
+#endif /* CONFIG_SCHED_BORE */
 
 extern int sysctl_resched_latency_warn_ms;
 extern int sysctl_resched_latency_warn_once;
diff -Nrup linux-6.16.6/net/qrtr/mhi.c linux-lenovo-x13s-linux-6.16.y/net/qrtr/mhi.c
--- linux-6.16.6/net/qrtr/mhi.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/net/qrtr/mhi.c	2025-09-11 09:47:42.000000000 -0600
@@ -15,6 +15,7 @@ struct qrtr_mhi_dev {
 	struct qrtr_endpoint ep;
 	struct mhi_device *mhi_dev;
 	struct device *dev;
+	struct completion prepared;
 };
 
 /* From MHI to QRTR */
@@ -53,6 +54,10 @@ static int qcom_mhi_qrtr_send(struct qrt
 	if (skb->sk)
 		sock_hold(skb->sk);
 
+	rc = wait_for_completion_interruptible(&qdev->prepared);
+	if (rc)
+		goto free_skb;
+
 	rc = skb_linearize(skb);
 	if (rc)
 		goto free_skb;
@@ -85,6 +90,7 @@ static int qcom_mhi_qrtr_probe(struct mh
 	qdev->mhi_dev = mhi_dev;
 	qdev->dev = &mhi_dev->dev;
 	qdev->ep.xmit = qcom_mhi_qrtr_send;
+	init_completion(&qdev->prepared);
 
 	dev_set_drvdata(&mhi_dev->dev, qdev);
 	rc = qrtr_endpoint_register(&qdev->ep, QRTR_EP_NID_AUTO);
@@ -97,6 +103,7 @@ static int qcom_mhi_qrtr_probe(struct mh
 		qrtr_endpoint_unregister(&qdev->ep);
 		return rc;
 	}
+	complete_all(&qdev->prepared);
 
 	dev_dbg(qdev->dev, "Qualcomm MHI QRTR driver probed\n");
 
File linux-6.16.6/scripts/dtc/include-prefixes/arc is a directory while file linux-lenovo-x13s-linux-6.16.y/scripts/dtc/include-prefixes/arc is a regular file
File linux-6.16.6/scripts/dtc/include-prefixes/arm is a directory while file linux-lenovo-x13s-linux-6.16.y/scripts/dtc/include-prefixes/arm is a regular file
File linux-6.16.6/scripts/dtc/include-prefixes/arm64 is a directory while file linux-lenovo-x13s-linux-6.16.y/scripts/dtc/include-prefixes/arm64 is a regular file
File linux-6.16.6/scripts/dtc/include-prefixes/dt-bindings is a directory while file linux-lenovo-x13s-linux-6.16.y/scripts/dtc/include-prefixes/dt-bindings is a regular file
File linux-6.16.6/scripts/dtc/include-prefixes/microblaze is a directory while file linux-lenovo-x13s-linux-6.16.y/scripts/dtc/include-prefixes/microblaze is a regular file
File linux-6.16.6/scripts/dtc/include-prefixes/mips is a directory while file linux-lenovo-x13s-linux-6.16.y/scripts/dtc/include-prefixes/mips is a regular file
File linux-6.16.6/scripts/dtc/include-prefixes/nios2 is a directory while file linux-lenovo-x13s-linux-6.16.y/scripts/dtc/include-prefixes/nios2 is a regular file
File linux-6.16.6/scripts/dtc/include-prefixes/openrisc is a directory while file linux-lenovo-x13s-linux-6.16.y/scripts/dtc/include-prefixes/openrisc is a regular file
File linux-6.16.6/scripts/dtc/include-prefixes/powerpc is a directory while file linux-lenovo-x13s-linux-6.16.y/scripts/dtc/include-prefixes/powerpc is a regular file
File linux-6.16.6/scripts/dtc/include-prefixes/riscv is a directory while file linux-lenovo-x13s-linux-6.16.y/scripts/dtc/include-prefixes/riscv is a regular file
File linux-6.16.6/scripts/dtc/include-prefixes/sh is a directory while file linux-lenovo-x13s-linux-6.16.y/scripts/dtc/include-prefixes/sh is a regular file
File linux-6.16.6/scripts/dtc/include-prefixes/xtensa is a directory while file linux-lenovo-x13s-linux-6.16.y/scripts/dtc/include-prefixes/xtensa is a regular file
diff -Nrup linux-6.16.6/scripts/dummy-tools/nm linux-lenovo-x13s-linux-6.16.y/scripts/dummy-tools/nm
--- linux-6.16.6/scripts/dummy-tools/nm	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/scripts/dummy-tools/nm	2025-09-11 09:47:42.000000000 -0600
@@ -1,30 +1 @@
-#!/bin/sh
-# SPDX-License-Identifier: GPL-2.0-only
-
-# Dummy script that always succeeds.
-
-# Check if the first parameter appears in the rest. Succeeds if found.
-# This helper is useful if a particular option was passed to this script.
-# Typically used like this:
-#   arg_contain <word-you-are-searching-for> "$@"
-arg_contain ()
-{
-	search="$1"
-	shift
-
-	while [ $# -gt 0 ]
-	do
-		if [ "$search" = "$1" ]; then
-			return 0
-		fi
-		shift
-	done
-
-	return 1
-}
-
-if arg_contain --version "$@" || arg_contain -v "$@"; then
-	progname=$(basename $0)
-	echo "GNU $progname (scripts/dummy-tools/$progname) 2.50"
-	exit 0
-fi
+ld
\ No newline at end of file
diff -Nrup linux-6.16.6/scripts/dummy-tools/objcopy linux-lenovo-x13s-linux-6.16.y/scripts/dummy-tools/objcopy
--- linux-6.16.6/scripts/dummy-tools/objcopy	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/scripts/dummy-tools/objcopy	2025-09-11 09:47:42.000000000 -0600
@@ -1,30 +1 @@
-#!/bin/sh
-# SPDX-License-Identifier: GPL-2.0-only
-
-# Dummy script that always succeeds.
-
-# Check if the first parameter appears in the rest. Succeeds if found.
-# This helper is useful if a particular option was passed to this script.
-# Typically used like this:
-#   arg_contain <word-you-are-searching-for> "$@"
-arg_contain ()
-{
-	search="$1"
-	shift
-
-	while [ $# -gt 0 ]
-	do
-		if [ "$search" = "$1" ]; then
-			return 0
-		fi
-		shift
-	done
-
-	return 1
-}
-
-if arg_contain --version "$@" || arg_contain -v "$@"; then
-	progname=$(basename $0)
-	echo "GNU $progname (scripts/dummy-tools/$progname) 2.50"
-	exit 0
-fi
+ld
\ No newline at end of file
diff -Nrup linux-6.16.6/scripts/kernel-doc linux-lenovo-x13s-linux-6.16.y/scripts/kernel-doc
--- linux-6.16.6/scripts/kernel-doc	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/scripts/kernel-doc	2025-09-11 09:47:42.000000000 -0600
@@ -1,315 +1 @@
-#!/usr/bin/env python3
-# SPDX-License-Identifier: GPL-2.0
-# Copyright(c) 2025: Mauro Carvalho Chehab <mchehab@kernel.org>.
-#
-# pylint: disable=C0103,R0915
-#
-# Converted from the kernel-doc script originally written in Perl
-# under GPLv2, copyrighted since 1998 by the following authors:
-#
-#    Aditya Srivastava <yashsri421@gmail.com>
-#    Akira Yokosawa <akiyks@gmail.com>
-#    Alexander A. Klimov <grandmaster@al2klimov.de>
-#    Alexander Lobakin <aleksander.lobakin@intel.com>
-#    André Almeida <andrealmeid@igalia.com>
-#    Andy Shevchenko <andriy.shevchenko@linux.intel.com>
-#    Anna-Maria Behnsen <anna-maria@linutronix.de>
-#    Armin Kuster <akuster@mvista.com>
-#    Bart Van Assche <bart.vanassche@sandisk.com>
-#    Ben Hutchings <ben@decadent.org.uk>
-#    Borislav Petkov <bbpetkov@yahoo.de>
-#    Chen-Yu Tsai <wenst@chromium.org>
-#    Coco Li <lixiaoyan@google.com>
-#    Conchúr Navid <conchur@web.de>
-#    Daniel Santos <daniel.santos@pobox.com>
-#    Danilo Cesar Lemes de Paula <danilo.cesar@collabora.co.uk>
-#    Dan Luedtke <mail@danrl.de>
-#    Donald Hunter <donald.hunter@gmail.com>
-#    Gabriel Krisman Bertazi <krisman@collabora.co.uk>
-#    Greg Kroah-Hartman <gregkh@linuxfoundation.org>
-#    Harvey Harrison <harvey.harrison@gmail.com>
-#    Horia Geanta <horia.geanta@freescale.com>
-#    Ilya Dryomov <idryomov@gmail.com>
-#    Jakub Kicinski <kuba@kernel.org>
-#    Jani Nikula <jani.nikula@intel.com>
-#    Jason Baron <jbaron@redhat.com>
-#    Jason Gunthorpe <jgg@nvidia.com>
-#    Jérémy Bobbio <lunar@debian.org>
-#    Johannes Berg <johannes.berg@intel.com>
-#    Johannes Weiner <hannes@cmpxchg.org>
-#    Jonathan Cameron <Jonathan.Cameron@huawei.com>
-#    Jonathan Corbet <corbet@lwn.net>
-#    Jonathan Neuschäfer <j.neuschaefer@gmx.net>
-#    Kamil Rytarowski <n54@gmx.com>
-#    Kees Cook <kees@kernel.org>
-#    Laurent Pinchart <laurent.pinchart@ideasonboard.com>
-#    Levin, Alexander (Sasha Levin) <alexander.levin@verizon.com>
-#    Linus Torvalds <torvalds@linux-foundation.org>
-#    Lucas De Marchi <lucas.demarchi@profusion.mobi>
-#    Mark Rutland <mark.rutland@arm.com>
-#    Markus Heiser <markus.heiser@darmarit.de>
-#    Martin Waitz <tali@admingilde.org>
-#    Masahiro Yamada <masahiroy@kernel.org>
-#    Matthew Wilcox <willy@infradead.org>
-#    Mauro Carvalho Chehab <mchehab+huawei@kernel.org>
-#    Michal Wajdeczko <michal.wajdeczko@intel.com>
-#    Michael Zucchi
-#    Mike Rapoport <rppt@linux.ibm.com>
-#    Niklas Söderlund <niklas.soderlund@corigine.com>
-#    Nishanth Menon <nm@ti.com>
-#    Paolo Bonzini <pbonzini@redhat.com>
-#    Pavan Kumar Linga <pavan.kumar.linga@intel.com>
-#    Pavel Pisa <pisa@cmp.felk.cvut.cz>
-#    Peter Maydell <peter.maydell@linaro.org>
-#    Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
-#    Randy Dunlap <rdunlap@infradead.org>
-#    Richard Kennedy <richard@rsk.demon.co.uk>
-#    Rich Walker <rw@shadow.org.uk>
-#    Rolf Eike Beer <eike-kernel@sf-tec.de>
-#    Sakari Ailus <sakari.ailus@linux.intel.com>
-#    Silvio Fricke <silvio.fricke@gmail.com>
-#    Simon Huggins
-#    Tim Waugh <twaugh@redhat.com>
-#    Tomasz Warniełło <tomasz.warniello@gmail.com>
-#    Utkarsh Tripathi <utripathi2002@gmail.com>
-#    valdis.kletnieks@vt.edu <valdis.kletnieks@vt.edu>
-#    Vegard Nossum <vegard.nossum@oracle.com>
-#    Will Deacon <will.deacon@arm.com>
-#    Yacine Belkadi <yacine.belkadi.1@gmail.com>
-#    Yujie Liu <yujie.liu@intel.com>
-
-"""
-kernel_doc
-==========
-
-Print formatted kernel documentation to stdout
-
-Read C language source or header FILEs, extract embedded
-documentation comments, and print formatted documentation
-to standard output.
-
-The documentation comments are identified by the "/**"
-opening comment mark.
-
-See Documentation/doc-guide/kernel-doc.rst for the
-documentation comment syntax.
-"""
-
-import argparse
-import logging
-import os
-import sys
-
-# Import Python modules
-
-LIB_DIR = "lib/kdoc"
-SRC_DIR = os.path.dirname(os.path.realpath(__file__))
-
-sys.path.insert(0, os.path.join(SRC_DIR, LIB_DIR))
-
-from kdoc_files import KernelFiles                      # pylint: disable=C0413
-from kdoc_output import RestFormat, ManFormat           # pylint: disable=C0413
-
-DESC = """
-Read C language source or header FILEs, extract embedded documentation comments,
-and print formatted documentation to standard output.
-
-The documentation comments are identified by the "/**" opening comment mark.
-
-See Documentation/doc-guide/kernel-doc.rst for the documentation comment syntax.
-"""
-
-EXPORT_FILE_DESC = """
-Specify an additional FILE in which to look for EXPORT_SYMBOL information.
-
-May be used multiple times.
-"""
-
-EXPORT_DESC = """
-Only output documentation for the symbols that have been
-exported using EXPORT_SYMBOL() and related macros in any input
-FILE or -export-file FILE.
-"""
-
-INTERNAL_DESC = """
-Only output documentation for the symbols that have NOT been
-exported using EXPORT_SYMBOL() and related macros in any input
-FILE or -export-file FILE.
-"""
-
-FUNCTION_DESC = """
-Only output documentation for the given function or DOC: section
-title. All other functions and DOC: sections are ignored.
-
-May be used multiple times.
-"""
-
-NOSYMBOL_DESC = """
-Exclude the specified symbol from the output documentation.
-
-May be used multiple times.
-"""
-
-FILES_DESC = """
-Header and C source files to be parsed.
-"""
-
-WARN_CONTENTS_BEFORE_SECTIONS_DESC = """
-Warns if there are contents before sections (deprecated).
-
-This option is kept just for backward-compatibility, but it does nothing,
-neither here nor at the original Perl script.
-"""
-
-
-class MsgFormatter(logging.Formatter):
-    """Helper class to format warnings on a similar way to kernel-doc.pl"""
-
-    def format(self, record):
-        record.levelname = record.levelname.capitalize()
-        return logging.Formatter.format(self, record)
-
-def main():
-    """Main program"""
-
-    parser = argparse.ArgumentParser(formatter_class=argparse.RawTextHelpFormatter,
-                                     description=DESC)
-
-    # Normal arguments
-
-    parser.add_argument("-v", "-verbose", "--verbose", action="store_true",
-                        help="Verbose output, more warnings and other information.")
-
-    parser.add_argument("-d", "-debug", "--debug", action="store_true",
-                        help="Enable debug messages")
-
-    parser.add_argument("-M", "-modulename", "--modulename",
-                        default="Kernel API",
-                        help="Allow setting a module name at the output.")
-
-    parser.add_argument("-l", "-enable-lineno", "--enable_lineno",
-                        action="store_true",
-                        help="Enable line number output (only in ReST mode)")
-
-    # Arguments to control the warning behavior
-
-    parser.add_argument("-Wreturn", "--wreturn", action="store_true",
-                        help="Warns about the lack of a return markup on functions.")
-
-    parser.add_argument("-Wshort-desc", "-Wshort-description", "--wshort-desc",
-                        action="store_true",
-                        help="Warns if initial short description is missing")
-
-    parser.add_argument("-Wcontents-before-sections",
-                        "--wcontents-before-sections", action="store_true",
-                        help=WARN_CONTENTS_BEFORE_SECTIONS_DESC)
-
-    parser.add_argument("-Wall", "--wall", action="store_true",
-                        help="Enable all types of warnings")
-
-    parser.add_argument("-Werror", "--werror", action="store_true",
-                        help="Treat warnings as errors.")
-
-    parser.add_argument("-export-file", "--export-file", action='append',
-                        help=EXPORT_FILE_DESC)
-
-    # Output format mutually-exclusive group
-
-    out_group = parser.add_argument_group("Output format selection (mutually exclusive)")
-
-    out_fmt = out_group.add_mutually_exclusive_group()
-
-    out_fmt.add_argument("-m", "-man", "--man", action="store_true",
-                         help="Output troff manual page format.")
-    out_fmt.add_argument("-r", "-rst", "--rst", action="store_true",
-                         help="Output reStructuredText format (default).")
-    out_fmt.add_argument("-N", "-none", "--none", action="store_true",
-                         help="Do not output documentation, only warnings.")
-
-    # Output selection mutually-exclusive group
-
-    sel_group = parser.add_argument_group("Output selection (mutually exclusive)")
-    sel_mut = sel_group.add_mutually_exclusive_group()
-
-    sel_mut.add_argument("-e", "-export", "--export", action='store_true',
-                         help=EXPORT_DESC)
-
-    sel_mut.add_argument("-i", "-internal", "--internal", action='store_true',
-                         help=INTERNAL_DESC)
-
-    sel_mut.add_argument("-s", "-function", "--symbol", action='append',
-                         help=FUNCTION_DESC)
-
-    # Those are valid for all 3 types of filter
-    parser.add_argument("-n", "-nosymbol", "--nosymbol", action='append',
-                        help=NOSYMBOL_DESC)
-
-    parser.add_argument("-D", "-no-doc-sections", "--no-doc-sections",
-                        action='store_true', help="Don't outputt DOC sections")
-
-    parser.add_argument("files", metavar="FILE",
-                        nargs="+", help=FILES_DESC)
-
-    args = parser.parse_args()
-
-    if args.wall:
-        args.wreturn = True
-        args.wshort_desc = True
-        args.wcontents_before_sections = True
-
-    logger = logging.getLogger()
-
-    if not args.debug:
-        logger.setLevel(logging.INFO)
-    else:
-        logger.setLevel(logging.DEBUG)
-
-    formatter = MsgFormatter('%(levelname)s: %(message)s')
-
-    handler = logging.StreamHandler()
-    handler.setFormatter(formatter)
-
-    logger.addHandler(handler)
-
-    if args.man:
-        out_style = ManFormat(modulename=args.modulename)
-    elif args.none:
-        out_style = None
-    else:
-        out_style = RestFormat()
-
-    kfiles = KernelFiles(verbose=args.verbose,
-                         out_style=out_style, werror=args.werror,
-                         wreturn=args.wreturn, wshort_desc=args.wshort_desc,
-                         wcontents_before_sections=args.wcontents_before_sections)
-
-    kfiles.parse(args.files, export_file=args.export_file)
-
-    for t in kfiles.msg(enable_lineno=args.enable_lineno, export=args.export,
-                        internal=args.internal, symbol=args.symbol,
-                        nosymbol=args.nosymbol, export_file=args.export_file,
-                        no_doc_sections=args.no_doc_sections):
-        msg = t[1]
-        if msg:
-            print(msg)
-
-    error_count = kfiles.errors
-    if not error_count:
-        sys.exit(0)
-
-    if args.werror:
-        print(f"{error_count} warnings as errors")
-        sys.exit(error_count)
-
-    if args.verbose:
-        print(f"{error_count} errors")
-
-    if args.none:
-        sys.exit(0)
-
-    sys.exit(error_count)
-
-
-# Call main method
-if __name__ == "__main__":
-    main()
+kernel-doc.py
\ No newline at end of file
diff -Nrup linux-6.16.6/sound/soc/codecs/Kconfig linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/Kconfig
--- linux-6.16.6/sound/soc/codecs/Kconfig	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/Kconfig	2025-09-11 09:47:42.000000000 -0600
@@ -2227,6 +2227,9 @@ config SND_SOC_UDA1380
 config SND_SOC_WCD_CLASSH
 	tristate
 
+config SND_SOC_WCD_COMMON
+	tristate
+
 config SND_SOC_WCD9335
 	tristate "WCD9335 Codec"
 	depends on SLIMBUS
@@ -2248,6 +2251,7 @@ config SND_SOC_WCD934X
 	select REGMAP_IRQ
 	select REGMAP_SLIMBUS
 	select SND_SOC_WCD_CLASSH
+	select SND_SOC_WCD_COMMON
 	select SND_SOC_WCD_MBHC
 	depends on MFD_WCD934X || COMPILE_TEST
 	help
@@ -2259,6 +2263,7 @@ config SND_SOC_WCD937X
 	tristate
 	depends on SOUNDWIRE || !SOUNDWIRE
 	select SND_SOC_WCD_CLASSH
+	select SND_SOC_WCD_COMMON
 
 config SND_SOC_WCD937X_SDW
 	tristate "WCD9370/WCD9375 Codec - SDW"
@@ -2278,6 +2283,7 @@ config SND_SOC_WCD938X
 	tristate
 	depends on SOUNDWIRE || !SOUNDWIRE
 	select SND_SOC_WCD_CLASSH
+	select SND_SOC_WCD_COMMON
 	select MULTIPLEXER
 
 config SND_SOC_WCD938X_SDW
@@ -2297,6 +2303,7 @@ config SND_SOC_WCD939X
 	depends on SOUNDWIRE || !SOUNDWIRE
 	depends on TYPEC || !TYPEC
 	select SND_SOC_WCD_CLASSH
+	select SND_SOC_WCD_COMMON
 
 config SND_SOC_WCD939X_SDW
 	tristate "WCD9390/WCD9395 Codec - SDW"
diff -Nrup linux-6.16.6/sound/soc/codecs/Makefile linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/Makefile
--- linux-6.16.6/sound/soc/codecs/Makefile	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/Makefile	2025-09-11 09:47:42.000000000 -0600
@@ -338,6 +338,7 @@ snd-soc-uda1334-y := uda1334.o
 snd-soc-uda1342-y := uda1342.o
 snd-soc-uda1380-y := uda1380.o
 snd-soc-wcd-classh-y := wcd-clsh-v2.o
+snd-soc-wcd-common-y := wcd-common.o
 snd-soc-wcd-mbhc-y := wcd-mbhc-v2.o
 snd-soc-wcd9335-y := wcd9335.o
 snd-soc-wcd934x-y := wcd934x.o
@@ -759,6 +760,7 @@ obj-$(CONFIG_SND_SOC_UDA1334)	+= snd-soc
 obj-$(CONFIG_SND_SOC_UDA1342)	+= snd-soc-uda1342.o
 obj-$(CONFIG_SND_SOC_UDA1380)	+= snd-soc-uda1380.o
 obj-$(CONFIG_SND_SOC_WCD_CLASSH)	+= snd-soc-wcd-classh.o
+obj-$(CONFIG_SND_SOC_WCD_COMMON)	+= snd-soc-wcd-common.o
 obj-$(CONFIG_SND_SOC_WCD_MBHC)	+= snd-soc-wcd-mbhc.o
 obj-$(CONFIG_SND_SOC_WCD9335)	+= snd-soc-wcd9335.o
 obj-$(CONFIG_SND_SOC_WCD934X)	+= snd-soc-wcd934x.o
diff -Nrup linux-6.16.6/sound/soc/codecs/wcd934x.c linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd934x.c
--- linux-6.16.6/sound/soc/codecs/wcd934x.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd934x.c	2025-09-11 09:47:42.000000000 -0600
@@ -21,6 +21,7 @@
 #include <sound/soc-dapm.h>
 #include <sound/tlv.h>
 #include "wcd-clsh-v2.h"
+#include "wcd-common.h"
 #include "wcd-mbhc-v2.h"
 
 #include <dt-bindings/sound/qcom,wcd934x.h>
@@ -116,9 +117,6 @@
 #define WCD934X_DEC_PWR_LVL_DF		0x00
 #define WCD934X_DEC_PWR_LVL_HYBRID WCD934X_DEC_PWR_LVL_DF
 
-#define WCD934X_DEF_MICBIAS_MV	1800
-#define WCD934X_MAX_MICBIAS_MV	2850
-
 #define WCD_IIR_FILTER_SIZE	(sizeof(u32) * BAND_MAX)
 
 #define WCD_IIR_FILTER_CTL(xname, iidx, bidx) \
@@ -530,6 +528,7 @@ struct wcd934x_codec {
 	struct slim_device *sdev;
 	struct slim_device *sidev;
 	struct wcd_clsh_ctrl *clsh_ctrl;
+	struct wcd_common common;
 	struct snd_soc_component *component;
 	struct wcd934x_slim_ch rx_chs[WCD934X_RX_MAX];
 	struct wcd934x_slim_ch tx_chs[WCD934X_TX_MAX];
@@ -557,7 +556,6 @@ struct wcd934x_codec {
 	struct mutex micb_lock;
 	u32 micb_ref[WCD934X_MAX_MICBIAS];
 	u32 pullup_ref[WCD934X_MAX_MICBIAS];
-	u32 micb2_mv;
 };
 
 #define to_wcd934x_codec(_hw) container_of(_hw, struct wcd934x_codec, hw)
@@ -2172,55 +2170,24 @@ static struct clk *wcd934x_register_mclk
 	return NULL;
 }
 
-static int wcd934x_get_micbias_val(struct device *dev, const char *micbias,
-				   u32 *micb_mv)
-{
-	int mv;
-
-	if (of_property_read_u32(dev->parent->of_node, micbias, &mv)) {
-		dev_err(dev, "%s value not found, using default\n", micbias);
-		mv = WCD934X_DEF_MICBIAS_MV;
-	} else {
-		/* convert it to milli volts */
-		mv = mv/1000;
-	}
-
-	if (mv < 1000 || mv > 2850) {
-		dev_err(dev, "%s value not in valid range, using default\n",
-			micbias);
-		mv = WCD934X_DEF_MICBIAS_MV;
-	}
-
-	if (micb_mv)
-		*micb_mv = mv;
-
-	return (mv - 1000) / 50;
-}
-
 static int wcd934x_init_dmic(struct snd_soc_component *comp)
 {
-	int vout_ctl_1, vout_ctl_2, vout_ctl_3, vout_ctl_4;
 	struct wcd934x_codec *wcd = dev_get_drvdata(comp->dev);
 	u32 def_dmic_rate, dmic_clk_drv;
+	int ret;
 
-	vout_ctl_1 = wcd934x_get_micbias_val(comp->dev,
-					     "qcom,micbias1-microvolt", NULL);
-	vout_ctl_2 = wcd934x_get_micbias_val(comp->dev,
-					     "qcom,micbias2-microvolt",
-					     &wcd->micb2_mv);
-	vout_ctl_3 = wcd934x_get_micbias_val(comp->dev,
-					     "qcom,micbias3-microvolt", NULL);
-	vout_ctl_4 = wcd934x_get_micbias_val(comp->dev,
-					     "qcom,micbias4-microvolt", NULL);
+	ret = wcd_dt_parse_mbhc_data(comp->dev, &wcd->mbhc_cfg);
+	if (ret)
+		return ret;
 
 	snd_soc_component_update_bits(comp, WCD934X_ANA_MICB1,
-				      WCD934X_MICB_VAL_MASK, vout_ctl_1);
+				      WCD934X_MICB_VAL_MASK, wcd->common.micb_vout[0]);
 	snd_soc_component_update_bits(comp, WCD934X_ANA_MICB2,
-				      WCD934X_MICB_VAL_MASK, vout_ctl_2);
+				      WCD934X_MICB_VAL_MASK, wcd->common.micb_vout[1]);
 	snd_soc_component_update_bits(comp, WCD934X_ANA_MICB3,
-				      WCD934X_MICB_VAL_MASK, vout_ctl_3);
+				      WCD934X_MICB_VAL_MASK, wcd->common.micb_vout[2]);
 	snd_soc_component_update_bits(comp, WCD934X_ANA_MICB4,
-				      WCD934X_MICB_VAL_MASK, vout_ctl_4);
+				      WCD934X_MICB_VAL_MASK, wcd->common.micb_vout[3]);
 
 	if (wcd->rate == WCD934X_MCLK_CLK_9P6MHZ)
 		def_dmic_rate = WCD9XXX_DMIC_SAMPLE_RATE_4P8MHZ;
@@ -2521,15 +2488,6 @@ static void wcd934x_mbhc_micb_ramp_contr
 	}
 }
 
-static int wcd934x_get_micb_vout_ctl_val(u32 micb_mv)
-{
-	/* min micbias voltage is 1V and maximum is 2.85V */
-	if (micb_mv < 1000 || micb_mv > 2850)
-		return -EINVAL;
-
-	return (micb_mv - 1000) / 50;
-}
-
 static int wcd934x_mbhc_micb_adjust_voltage(struct snd_soc_component *component,
 					    int req_volt, int micb_num)
 {
@@ -2566,7 +2524,7 @@ static int wcd934x_mbhc_micb_adjust_volt
 	cur_vout_ctl = snd_soc_component_read_field(component, micb_reg,
 						    WCD934X_MICB_VAL_MASK);
 
-	req_vout_ctl = wcd934x_get_micb_vout_ctl_val(req_volt);
+	req_vout_ctl = wcd_get_micb_vout_ctl_val(component->dev, req_volt);
 	if (req_vout_ctl < 0) {
 		ret = -EINVAL;
 		goto exit;
@@ -2614,10 +2572,10 @@ static int wcd934x_mbhc_micb_ctrl_thresh
 	 * voltage needed to detect threshold microphone, then do
 	 * not change the micbias, just return.
 	 */
-	if (wcd934x->micb2_mv >= WCD_MBHC_THR_HS_MICB_MV)
+	if (wcd934x->common.micb_mv[1] >= WCD_MBHC_THR_HS_MICB_MV)
 		return 0;
 
-	micb_mv = req_en ? WCD_MBHC_THR_HS_MICB_MV : wcd934x->micb2_mv;
+	micb_mv = req_en ? WCD_MBHC_THR_HS_MICB_MV : wcd934x->common.micb_mv[1];
 
 	rc = wcd934x_mbhc_micb_adjust_voltage(component, micb_mv, MIC_BIAS_2);
 
@@ -3040,7 +2998,7 @@ static void wcd934x_mbhc_deinit(struct s
 static int wcd934x_comp_probe(struct snd_soc_component *component)
 {
 	struct wcd934x_codec *wcd = dev_get_drvdata(component->dev);
-	int i;
+	int i, ret;
 
 	snd_soc_component_init_regmap(component, wcd->regmap);
 	wcd->component = component;
@@ -3058,7 +3016,12 @@ static int wcd934x_comp_probe(struct snd
 	for (i = 0; i < NUM_CODEC_DAIS; i++)
 		INIT_LIST_HEAD(&wcd->dai[i].slim_ch_list);
 
-	wcd934x_init_dmic(component);
+
+	ret = wcd934x_init_dmic(component);
+	if (ret) {
+		dev_err(component->dev, "Failed to Initialize micbias\n");
+		return ret;
+	}
 
 	if (wcd934x_mbhc_init(component))
 		dev_err(component->dev, "Failed to Initialize MBHC\n");
@@ -5864,14 +5827,13 @@ static int wcd934x_codec_parse_data(stru
 	cfg->anc_micbias = MIC_BIAS_2;
 	cfg->v_hs_max = WCD_MBHC_HS_V_MAX;
 	cfg->num_btn = WCD934X_MBHC_MAX_BUTTONS;
-	cfg->micb_mv = wcd->micb2_mv;
+	cfg->micb_mv = wcd->common.micb_mv[1];
 	cfg->linein_th = 5000;
 	cfg->hs_thr = 1700;
 	cfg->hph_thr = 50;
 
 	wcd_dt_parse_mbhc_data(dev, cfg);
 
-
 	return 0;
 }
 
@@ -5892,6 +5854,8 @@ static int wcd934x_codec_probe(struct pl
 	wcd->sdev = to_slim_device(data->dev);
 	mutex_init(&wcd->sysclk_mutex);
 	mutex_init(&wcd->micb_lock);
+	wcd->common.dev = dev->parent;
+	wcd->common.max_bias = 4;
 
 	ret = wcd934x_codec_parse_data(wcd);
 	if (ret)
diff -Nrup linux-6.16.6/sound/soc/codecs/wcd937x.c linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd937x.c
--- linux-6.16.6/sound/soc/codecs/wcd937x.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd937x.c	2025-09-11 09:47:42.000000000 -0600
@@ -21,6 +21,7 @@
 #include <sound/tlv.h>
 
 #include "wcd-clsh-v2.h"
+#include "wcd-common.h"
 #include "wcd-mbhc-v2.h"
 #include "wcd937x.h"
 
@@ -87,6 +88,7 @@ struct wcd937x_priv {
 	struct wcd_mbhc_config mbhc_cfg;
 	struct wcd_mbhc_intr intr_ids;
 	struct wcd_clsh_ctrl *clsh_info;
+	struct wcd_common common;
 	struct irq_domain *virq;
 	struct regmap_irq_chip *wcd_regmap_irq_chip;
 	struct regmap_irq_chip_data *irq_chip;
@@ -97,9 +99,6 @@ struct wcd937x_priv {
 	s32 pullup_ref[WCD937X_MAX_MICBIAS];
 	u32 hph_mode;
 	int ear_rx_path;
-	u32 micb1_mv;
-	u32 micb2_mv;
-	u32 micb3_mv;
 	int hphr_pdm_wd_int;
 	int hphl_pdm_wd_int;
 	int aux_pdm_wd_int;
@@ -872,15 +871,6 @@ static int wcd937x_enable_rx3(struct snd
 	return 0;
 }
 
-static int wcd937x_get_micb_vout_ctl_val(u32 micb_mv)
-{
-	if (micb_mv < 1000 || micb_mv > 2850) {
-		pr_err("Unsupported micbias voltage (%u mV)\n", micb_mv);
-		return -EINVAL;
-	}
-
-	return (micb_mv - 1000) / 50;
-}
 
 static int wcd937x_tx_swr_ctrl(struct snd_soc_dapm_widget *w,
 			       struct snd_kcontrol *kcontrol, int event)
@@ -1193,7 +1183,7 @@ static int wcd937x_codec_enable_micbias_
 static int wcd937x_connect_port(struct wcd937x_sdw_priv *wcd, u8 port_idx, u8 ch_id, bool enable)
 {
 	struct sdw_port_config *port_config = &wcd->port_config[port_idx - 1];
-	const struct wcd937x_sdw_ch_info *ch_info = &wcd->ch_info[ch_id];
+	const struct wcd_sdw_ch_info *ch_info = &wcd->ch_info[ch_id];
 	u8 port_num = ch_info->port_num;
 	u8 ch_mask = ch_info->ch_mask;
 	u8 mstr_port_num, mstr_ch_mask;
@@ -1481,7 +1471,7 @@ static int wcd937x_mbhc_micb_adjust_volt
 	cur_vout_ctl = snd_soc_component_read_field(component, micb_reg,
 						    WCD937X_MICB_VOUT_MASK);
 
-	req_vout_ctl = wcd937x_get_micb_vout_ctl_val(req_volt);
+	req_vout_ctl = wcd_get_micb_vout_ctl_val(component->dev, req_volt);
 	if (req_vout_ctl < 0) {
 		ret = -EINVAL;
 		goto exit;
@@ -1529,10 +1519,10 @@ static int wcd937x_mbhc_micb_ctrl_thresh
 	 * voltage needed to detect threshold microphone, then do
 	 * not change the micbias, just return.
 	 */
-	if (wcd937x->micb2_mv >= WCD_MBHC_THR_HS_MICB_MV)
+	if (wcd937x->common.micb_mv[2] >= WCD_MBHC_THR_HS_MICB_MV)
 		return 0;
 
-	micb_mv = req_en ? WCD_MBHC_THR_HS_MICB_MV : wcd937x->micb2_mv;
+	micb_mv = req_en ? WCD_MBHC_THR_HS_MICB_MV : wcd937x->common.micb_mv[2];
 
 	return wcd937x_mbhc_micb_adjust_voltage(component, micb_mv, MIC_BIAS_2);
 }
@@ -2046,9 +2036,9 @@ static const struct snd_kcontrol_new wcd
 	SOC_ENUM_EXT("RX HPH Mode", rx_hph_mode_mux_enum,
 		     wcd937x_rx_hph_mode_get, wcd937x_rx_hph_mode_put),
 
-	SOC_SINGLE_EXT("HPHL_COMP Switch", SND_SOC_NOPM, 0, 1, 0,
+	SOC_SINGLE_EXT("HPHL_COMP Switch", WCD937X_COMP_L, 0, 1, 0,
 		       wcd937x_get_compander, wcd937x_set_compander),
-	SOC_SINGLE_EXT("HPHR_COMP Switch", SND_SOC_NOPM, 1, 1, 0,
+	SOC_SINGLE_EXT("HPHR_COMP Switch", WCD937X_COMP_R, 1, 1, 0,
 		       wcd937x_get_compander, wcd937x_set_compander),
 
 	SOC_SINGLE_TLV("HPHL Volume", WCD937X_HPH_L_EN, 0, 20, 1, line_gain),
@@ -2436,22 +2426,14 @@ static const struct snd_soc_dapm_route w
 	{ "DMIC6_MIXER", "Switch", "DMIC6" },
 };
 
-static int wcd937x_set_micbias_data(struct wcd937x_priv *wcd937x)
+static void wcd937x_set_micbias_data(struct device *dev, struct wcd937x_priv *wcd937x)
 {
-	int vout_ctl[3];
-
-	/* Set micbias voltage */
-	vout_ctl[0] = wcd937x_get_micb_vout_ctl_val(wcd937x->micb1_mv);
-	vout_ctl[1] = wcd937x_get_micb_vout_ctl_val(wcd937x->micb2_mv);
-	vout_ctl[2] = wcd937x_get_micb_vout_ctl_val(wcd937x->micb3_mv);
-	if ((vout_ctl[0] | vout_ctl[1] | vout_ctl[2]) < 0)
-		return -EINVAL;
-
-	regmap_update_bits(wcd937x->regmap, WCD937X_ANA_MICB1, WCD937X_ANA_MICB_VOUT, vout_ctl[0]);
-	regmap_update_bits(wcd937x->regmap, WCD937X_ANA_MICB2, WCD937X_ANA_MICB_VOUT, vout_ctl[1]);
-	regmap_update_bits(wcd937x->regmap, WCD937X_ANA_MICB3, WCD937X_ANA_MICB_VOUT, vout_ctl[2]);
-
-	return 0;
+	regmap_update_bits(wcd937x->regmap, WCD937X_ANA_MICB1, WCD937X_ANA_MICB_VOUT,
+			wcd937x->common.micb_vout[0]);
+	regmap_update_bits(wcd937x->regmap, WCD937X_ANA_MICB2, WCD937X_ANA_MICB_VOUT,
+			wcd937x->common.micb_vout[1]);
+	regmap_update_bits(wcd937x->regmap, WCD937X_ANA_MICB3, WCD937X_ANA_MICB_VOUT,
+			wcd937x->common.micb_vout[2]);
 }
 
 static irqreturn_t wcd937x_wd_handle_irq(int irq, void *data)
@@ -2630,31 +2612,6 @@ static const struct snd_soc_component_dr
 	.endianness = 1,
 };
 
-static void wcd937x_dt_parse_micbias_info(struct device *dev, struct wcd937x_priv *wcd)
-{
-	struct device_node *np = dev->of_node;
-	u32 prop_val = 0;
-	int ret = 0;
-
-	ret = of_property_read_u32(np, "qcom,micbias1-microvolt", &prop_val);
-	if (!ret)
-		wcd->micb1_mv = prop_val / 1000;
-	else
-		dev_warn(dev, "Micbias1 DT property not found\n");
-
-	ret = of_property_read_u32(np, "qcom,micbias2-microvolt", &prop_val);
-	if (!ret)
-		wcd->micb2_mv = prop_val / 1000;
-	else
-		dev_warn(dev, "Micbias2 DT property not found\n");
-
-	ret = of_property_read_u32(np, "qcom,micbias3-microvolt", &prop_val);
-	if (!ret)
-		wcd->micb3_mv = prop_val / 1000;
-	else
-		dev_warn(dev, "Micbias3 DT property not found\n");
-}
-
 static bool wcd937x_swap_gnd_mic(struct snd_soc_component *component)
 {
 	int value;
@@ -2788,7 +2745,7 @@ static int wcd937x_bind(struct device *d
 		return ret;
 	}
 
-	wcd937x->rxdev = wcd937x_sdw_device_get(wcd937x->rxnode);
+	wcd937x->rxdev = of_sdw_find_device_by_node(wcd937x->rxnode);
 	if (!wcd937x->rxdev) {
 		dev_err(dev, "could not find slave with matching of node\n");
 		return -EINVAL;
@@ -2797,7 +2754,7 @@ static int wcd937x_bind(struct device *d
 	wcd937x->sdw_priv[AIF1_PB] = dev_get_drvdata(wcd937x->rxdev);
 	wcd937x->sdw_priv[AIF1_PB]->wcd937x = wcd937x;
 
-	wcd937x->txdev = wcd937x_sdw_device_get(wcd937x->txnode);
+	wcd937x->txdev = of_sdw_find_device_by_node(wcd937x->txnode);
 	if (!wcd937x->txdev) {
 		dev_err(dev, "could not find txslave with matching of node\n");
 		return -EINVAL;
@@ -2833,7 +2790,7 @@ static int wcd937x_bind(struct device *d
 		return -EINVAL;
 	}
 
-	wcd937x->regmap = dev_get_regmap(&wcd937x->tx_sdw_dev->dev, NULL);
+	wcd937x->regmap = wcd937x->sdw_priv[AIF1_CAP]->regmap;
 	if (!wcd937x->regmap) {
 		dev_err(dev, "could not get TX device regmap\n");
 		return -EINVAL;
@@ -2848,11 +2805,7 @@ static int wcd937x_bind(struct device *d
 	wcd937x->sdw_priv[AIF1_PB]->slave_irq = wcd937x->virq;
 	wcd937x->sdw_priv[AIF1_CAP]->slave_irq = wcd937x->virq;
 
-	ret = wcd937x_set_micbias_data(wcd937x);
-	if (ret < 0) {
-		dev_err(dev, "Bad micbias pdata\n");
-		return ret;
-	}
+	wcd937x_set_micbias_data(dev, wcd937x);
 
 	ret = snd_soc_register_component(dev, &soc_codec_dev_wcd937x,
 					 wcd937x_dais, ARRAY_SIZE(wcd937x_dais));
@@ -2920,6 +2873,8 @@ static int wcd937x_probe(struct platform
 
 	dev_set_drvdata(dev, wcd937x);
 	mutex_init(&wcd937x->micb_lock);
+	wcd937x->common.dev = dev;
+	wcd937x->common.max_bias = 3;
 
 	wcd937x->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_LOW);
 	if (IS_ERR(wcd937x->reset_gpio))
@@ -2947,13 +2902,15 @@ static int wcd937x_probe(struct platform
 	if (ret)
 		return dev_err_probe(dev, ret, "Failed to enable supplies\n");
 
-	wcd937x_dt_parse_micbias_info(dev, wcd937x);
+	ret = wcd_dt_parse_micbias_info(&wcd937x->common);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get micbias\n");
 
 	cfg->mbhc_micbias = MIC_BIAS_2;
 	cfg->anc_micbias = MIC_BIAS_2;
 	cfg->v_hs_max = WCD_MBHC_HS_V_MAX;
 	cfg->num_btn = WCD937X_MBHC_MAX_BUTTONS;
-	cfg->micb_mv = wcd937x->micb2_mv;
+	cfg->micb_mv = wcd937x->common.micb_mv[2];
 	cfg->linein_th = 5000;
 	cfg->hs_thr = 1700;
 	cfg->hph_thr = 50;
diff -Nrup linux-6.16.6/sound/soc/codecs/wcd937x.h linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd937x.h
--- linux-6.16.6/sound/soc/codecs/wcd937x.h	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd937x.h	2025-09-11 09:47:42.000000000 -0600
@@ -7,6 +7,7 @@
 
 #include <linux/soundwire/sdw.h>
 #include <linux/soundwire/sdw_type.h>
+#include "wcd-common.h"
 
 #define WCD937X_BASE_ADDRESS			0x3000
 #define WCD937X_ANA_BIAS			0x3001
@@ -508,26 +509,13 @@ enum wcd937x_rx_sdw_ports {
 	WCD937X_MAX_SWR_PORTS = WCD937X_DSD_PORT,
 };
 
-struct wcd937x_sdw_ch_info {
-	int port_num;
-	unsigned int ch_mask;
-	unsigned int master_ch_mask;
-};
-
-#define WCD_SDW_CH(id, pn, cmask)	\
-	[id] = {			\
-		.port_num = pn,		\
-		.ch_mask = cmask,	\
-		.master_ch_mask = cmask,	\
-	}
-
 struct wcd937x_priv;
 struct wcd937x_sdw_priv {
 	struct sdw_slave *sdev;
 	struct sdw_stream_config sconfig;
 	struct sdw_stream_runtime *sruntime;
 	struct sdw_port_config port_config[WCD937X_MAX_SWR_PORTS];
-	struct wcd937x_sdw_ch_info *ch_info;
+	struct wcd_sdw_ch_info *ch_info;
 	bool port_enable[WCD937X_MAX_SWR_CH_IDS];
 	unsigned int master_channel_map[SDW_MAX_PORTS];
 	int active_ports;
@@ -550,24 +538,22 @@ int wcd937x_sdw_hw_params(struct wcd937x
 			  struct snd_pcm_hw_params *params,
 			  struct snd_soc_dai *dai);
 
-struct device *wcd937x_sdw_device_get(struct device_node *np);
-
 #else
-int wcd937x_sdw_free(struct wcd937x_sdw_priv *wcd,
+static inline int wcd937x_sdw_free(struct wcd937x_sdw_priv *wcd,
 		     struct snd_pcm_substream *substream,
 		     struct snd_soc_dai *dai)
 {
 	return -EOPNOTSUPP;
 }
 
-int wcd937x_sdw_set_sdw_stream(struct wcd937x_sdw_priv *wcd,
+static inline int wcd937x_sdw_set_sdw_stream(struct wcd937x_sdw_priv *wcd,
 			       struct snd_soc_dai *dai,
 			       void *stream, int direction)
 {
 	return -EOPNOTSUPP;
 }
 
-int wcd937x_sdw_hw_params(struct wcd937x_sdw_priv *wcd,
+static inline int wcd937x_sdw_hw_params(struct wcd937x_sdw_priv *wcd,
 			  struct snd_pcm_substream *substream,
 			  struct snd_pcm_hw_params *params,
 			  struct snd_soc_dai *dai)
diff -Nrup linux-6.16.6/sound/soc/codecs/wcd937x-sdw.c linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd937x-sdw.c
--- linux-6.16.6/sound/soc/codecs/wcd937x-sdw.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd937x-sdw.c	2025-09-11 09:47:42.000000000 -0600
@@ -19,7 +19,7 @@
 #include <sound/soc.h>
 #include "wcd937x.h"
 
-static struct wcd937x_sdw_ch_info wcd937x_sdw_rx_ch_info[] = {
+static struct wcd_sdw_ch_info wcd937x_sdw_rx_ch_info[] = {
 	WCD_SDW_CH(WCD937X_HPH_L, WCD937X_HPH_PORT, BIT(0)),
 	WCD_SDW_CH(WCD937X_HPH_R, WCD937X_HPH_PORT, BIT(1)),
 	WCD_SDW_CH(WCD937X_CLSH, WCD937X_CLSH_PORT, BIT(0)),
@@ -30,7 +30,7 @@ static struct wcd937x_sdw_ch_info wcd937
 	WCD_SDW_CH(WCD937X_DSD_R, WCD937X_DSD_PORT, BIT(1)),
 };
 
-static struct wcd937x_sdw_ch_info wcd937x_sdw_tx_ch_info[] = {
+static struct wcd_sdw_ch_info wcd937x_sdw_tx_ch_info[] = {
 	WCD_SDW_CH(WCD937X_ADC1, WCD937X_ADC_1_PORT, BIT(0)),
 	WCD_SDW_CH(WCD937X_ADC2, WCD937X_ADC_2_3_PORT, BIT(0)),
 	WCD_SDW_CH(WCD937X_ADC3, WCD937X_ADC_2_3_PORT, BIT(0)),
@@ -78,12 +78,6 @@ static struct sdw_dpn_prop wcd937x_dpn_p
 	}
 };
 
-struct device *wcd937x_sdw_device_get(struct device_node *np)
-{
-	return bus_find_device_by_of_node(&sdw_bus_type, np);
-}
-EXPORT_SYMBOL_GPL(wcd937x_sdw_device_get);
-
 int wcd937x_sdw_hw_params(struct wcd937x_sdw_priv *wcd,
 			  struct snd_pcm_substream *substream,
 			  struct snd_pcm_hw_params *params,
@@ -118,19 +112,6 @@ int wcd937x_sdw_hw_params(struct wcd937x
 }
 EXPORT_SYMBOL_GPL(wcd937x_sdw_hw_params);
 
-static int wcd9370_update_status(struct sdw_slave *slave, enum sdw_slave_status status)
-{
-	struct wcd937x_sdw_priv *wcd = dev_get_drvdata(&slave->dev);
-
-	if (wcd->regmap && status == SDW_SLAVE_ATTACHED) {
-		/* Write out any cached changes that happened between probe and attach */
-		regcache_cache_only(wcd->regmap, false);
-		return regcache_sync(wcd->regmap);
-	}
-
-	return 0;
-}
-
 /*
  * Handle Soundwire out-of-band interrupt event by triggering
  * the first irq of the slave_irq irq domain, which then will
@@ -141,18 +122,9 @@ static int wcd9370_interrupt_callback(st
 				      struct sdw_slave_intr_status *status)
 {
 	struct wcd937x_sdw_priv *wcd = dev_get_drvdata(&slave->dev);
-	struct irq_domain *slave_irq = wcd->slave_irq;
-	u32 sts1, sts2, sts3;
-
-	do {
-		handle_nested_irq(irq_find_mapping(slave_irq, 0));
-		regmap_read(wcd->regmap, WCD937X_DIGITAL_INTR_STATUS_0, &sts1);
-		regmap_read(wcd->regmap, WCD937X_DIGITAL_INTR_STATUS_1, &sts2);
-		regmap_read(wcd->regmap, WCD937X_DIGITAL_INTR_STATUS_2, &sts3);
 
-	} while (sts1 || sts2 || sts3);
-
-	return IRQ_HANDLED;
+	return wcd_interrupt_callback(slave, wcd->slave_irq, WCD937X_DIGITAL_INTR_STATUS_0,
+				WCD937X_DIGITAL_INTR_STATUS_1, WCD937X_DIGITAL_INTR_STATUS_2);
 }
 
 static const struct reg_default wcd937x_defaults[] = {
@@ -985,35 +957,10 @@ static const struct regmap_config wcd937
 };
 
 static const struct sdw_slave_ops wcd9370_slave_ops = {
-	.update_status = wcd9370_update_status,
+	.update_status = wcd_update_status,
 	.interrupt_callback = wcd9370_interrupt_callback,
 };
 
-static int wcd937x_sdw_component_bind(struct device *dev,
-				      struct device *master, void *data)
-{
-	pm_runtime_set_autosuspend_delay(dev, 3000);
-	pm_runtime_use_autosuspend(dev);
-	pm_runtime_mark_last_busy(dev);
-	pm_runtime_set_active(dev);
-	pm_runtime_enable(dev);
-
-	return 0;
-}
-
-static void wcd937x_sdw_component_unbind(struct device *dev,
-					 struct device *master, void *data)
-{
-	pm_runtime_disable(dev);
-	pm_runtime_set_suspended(dev);
-	pm_runtime_dont_use_autosuspend(dev);
-}
-
-static const struct component_ops wcd937x_sdw_component_ops = {
-	.bind = wcd937x_sdw_component_bind,
-	.unbind = wcd937x_sdw_component_unbind,
-};
-
 static int wcd9370_probe(struct sdw_slave *pdev,
 			 const struct sdw_device_id *id)
 {
@@ -1099,7 +1046,7 @@ static int wcd9370_probe(struct sdw_slav
 	}
 
 
-	ret = component_add(dev, &wcd937x_sdw_component_ops);
+	ret = component_add(dev, &wcd_sdw_component_ops);
 	if (ret)
 		return ret;
 
@@ -1113,7 +1060,7 @@ static int wcd9370_remove(struct sdw_sla
 {
 	struct device *dev = &pdev->dev;
 
-	component_del(dev, &wcd937x_sdw_component_ops);
+	component_del(dev, &wcd_sdw_component_ops);
 
 	return 0;
 }
diff -Nrup linux-6.16.6/sound/soc/codecs/wcd938x.c linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd938x.c
--- linux-6.16.6/sound/soc/codecs/wcd938x.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd938x.c	2025-09-11 09:47:42.000000000 -0600
@@ -22,6 +22,7 @@
 #include <linux/regulator/consumer.h>
 
 #include "wcd-clsh-v2.h"
+#include "wcd-common.h"
 #include "wcd-mbhc-v2.h"
 #include "wcd938x.h"
 
@@ -158,6 +159,7 @@ struct wcd938x_priv {
 	struct wcd_mbhc_config mbhc_cfg;
 	struct wcd_mbhc_intr intr_ids;
 	struct wcd_clsh_ctrl *clsh_info;
+	struct wcd_common common;
 	struct irq_domain *virq;
 	struct regmap_irq_chip *wcd_regmap_irq_chip;
 	struct regmap_irq_chip_data *irq_chip;
@@ -175,10 +177,6 @@ struct wcd938x_priv {
 	struct gpio_desc *us_euro_gpio;
 	struct mux_control *us_euro_mux;
 	unsigned int mux_state;
-	u32 micb1_mv;
-	u32 micb2_mv;
-	u32 micb3_mv;
-	u32 micb4_mv;
 	int hphr_pdm_wd_int;
 	int hphl_pdm_wd_int;
 	int aux_pdm_wd_int;
@@ -398,7 +396,7 @@ static int wcd938x_io_init(struct wcd938
 
 }
 
-static int wcd938x_sdw_connect_port(const struct wcd938x_sdw_ch_info *ch_info,
+static int wcd938x_sdw_connect_port(const struct wcd_sdw_ch_info *ch_info,
 				    struct sdw_port_config *port_config,
 				    u8 enable)
 {
@@ -1096,8 +1094,7 @@ static int wcd938x_tx_swr_ctrl(struct sn
 	int bank;
 	int rate;
 
-	bank = (wcd938x_swr_get_current_bank(wcd938x->sdw_priv[AIF1_CAP]->sdev)) ? 0 : 1;
-	bank = bank ? 0 : 1;
+	bank = sdw_slave_get_current_bank(wcd938x->sdw_priv[AIF1_CAP]->sdev);
 
 	switch (event) {
 	case SND_SOC_DAPM_PRE_PMU:
@@ -1977,15 +1974,6 @@ static void wcd938x_mbhc_micb_ramp_contr
 	}
 }
 
-static int wcd938x_get_micb_vout_ctl_val(u32 micb_mv)
-{
-	/* min micbias voltage is 1V and maximum is 2.85V */
-	if (micb_mv < 1000 || micb_mv > 2850)
-		return -EINVAL;
-
-	return (micb_mv - 1000) / 50;
-}
-
 static int wcd938x_mbhc_micb_adjust_voltage(struct snd_soc_component *component,
 					    int req_volt, int micb_num)
 {
@@ -2022,7 +2010,7 @@ static int wcd938x_mbhc_micb_adjust_volt
 	cur_vout_ctl = snd_soc_component_read_field(component, micb_reg,
 						    WCD938X_MICB_VOUT_MASK);
 
-	req_vout_ctl = wcd938x_get_micb_vout_ctl_val(req_volt);
+	req_vout_ctl = wcd_get_micb_vout_ctl_val(component->dev, req_volt);
 	if (req_vout_ctl < 0) {
 		ret = -EINVAL;
 		goto exit;
@@ -2070,10 +2058,10 @@ static int wcd938x_mbhc_micb_ctrl_thresh
 	 * voltage needed to detect threshold microphone, then do
 	 * not change the micbias, just return.
 	 */
-	if (wcd938x->micb2_mv >= WCD_MBHC_THR_HS_MICB_MV)
+	if (wcd938x->common.micb_mv[2] >= WCD_MBHC_THR_HS_MICB_MV)
 		return 0;
 
-	micb_mv = req_en ? WCD_MBHC_THR_HS_MICB_MV : wcd938x->micb2_mv;
+	micb_mv = req_en ? WCD_MBHC_THR_HS_MICB_MV : wcd938x->common.micb_mv[2];
 
 	return wcd938x_mbhc_micb_adjust_voltage(component, micb_mv, MIC_BIAS_2);
 }
@@ -2978,28 +2966,16 @@ static const struct snd_soc_dapm_route w
 	{"EAR", NULL, "EAR PGA"},
 };
 
-static int wcd938x_set_micbias_data(struct wcd938x_priv *wcd938x)
+static void wcd938x_set_micbias_data(struct device *dev, struct wcd938x_priv *wcd938x)
 {
-	int vout_ctl_1, vout_ctl_2, vout_ctl_3, vout_ctl_4;
-
-	/* set micbias voltage */
-	vout_ctl_1 = wcd938x_get_micb_vout_ctl_val(wcd938x->micb1_mv);
-	vout_ctl_2 = wcd938x_get_micb_vout_ctl_val(wcd938x->micb2_mv);
-	vout_ctl_3 = wcd938x_get_micb_vout_ctl_val(wcd938x->micb3_mv);
-	vout_ctl_4 = wcd938x_get_micb_vout_ctl_val(wcd938x->micb4_mv);
-	if (vout_ctl_1 < 0 || vout_ctl_2 < 0 || vout_ctl_3 < 0 || vout_ctl_4 < 0)
-		return -EINVAL;
-
 	regmap_update_bits(wcd938x->regmap, WCD938X_ANA_MICB1,
-			   WCD938X_MICB_VOUT_MASK, vout_ctl_1);
+			   WCD938X_MICB_VOUT_MASK, wcd938x->common.micb_vout[0]);
 	regmap_update_bits(wcd938x->regmap, WCD938X_ANA_MICB2,
-			   WCD938X_MICB_VOUT_MASK, vout_ctl_2);
+			   WCD938X_MICB_VOUT_MASK, wcd938x->common.micb_vout[1]);
 	regmap_update_bits(wcd938x->regmap, WCD938X_ANA_MICB3,
-			   WCD938X_MICB_VOUT_MASK, vout_ctl_3);
+			   WCD938X_MICB_VOUT_MASK, wcd938x->common.micb_vout[2]);
 	regmap_update_bits(wcd938x->regmap, WCD938X_ANA_MICB4,
-			   WCD938X_MICB_VOUT_MASK, vout_ctl_4);
-
-	return 0;
+			   WCD938X_MICB_VOUT_MASK, wcd938x->common.micb_vout[3]);
 }
 
 static irqreturn_t wcd938x_wd_handle_irq(int irq, void *data)
@@ -3202,37 +3178,6 @@ static const struct snd_soc_component_dr
 	.endianness = 1,
 };
 
-static void wcd938x_dt_parse_micbias_info(struct device *dev, struct wcd938x_priv *wcd)
-{
-	struct device_node *np = dev->of_node;
-	u32 prop_val = 0;
-	int rc = 0;
-
-	rc = of_property_read_u32(np, "qcom,micbias1-microvolt",  &prop_val);
-	if (!rc)
-		wcd->micb1_mv = prop_val/1000;
-	else
-		dev_info(dev, "%s: Micbias1 DT property not found\n", __func__);
-
-	rc = of_property_read_u32(np, "qcom,micbias2-microvolt",  &prop_val);
-	if (!rc)
-		wcd->micb2_mv = prop_val/1000;
-	else
-		dev_info(dev, "%s: Micbias2 DT property not found\n", __func__);
-
-	rc = of_property_read_u32(np, "qcom,micbias3-microvolt", &prop_val);
-	if (!rc)
-		wcd->micb3_mv = prop_val/1000;
-	else
-		dev_info(dev, "%s: Micbias3 DT property not found\n", __func__);
-
-	rc = of_property_read_u32(np, "qcom,micbias4-microvolt",  &prop_val);
-	if (!rc)
-		wcd->micb4_mv = prop_val/1000;
-	else
-		dev_info(dev, "%s: Micbias4 DT property not found\n", __func__);
-}
-
 static bool wcd938x_swap_gnd_mic(struct snd_soc_component *component)
 {
 	struct wcd938x_priv *wcd938x = snd_soc_component_get_drvdata(component);
@@ -3307,13 +3252,15 @@ static int wcd938x_populate_dt_data(stru
 		return dev_err_probe(dev, ret, "Failed to enable supplies\n");
 	}
 
-	wcd938x_dt_parse_micbias_info(dev, wcd938x);
+	ret = wcd_dt_parse_micbias_info(&wcd938x->common);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get and enable supplies\n");
 
 	cfg->mbhc_micbias = MIC_BIAS_2;
 	cfg->anc_micbias = MIC_BIAS_2;
 	cfg->v_hs_max = WCD_MBHC_HS_V_MAX;
 	cfg->num_btn = WCD938X_MBHC_MAX_BUTTONS;
-	cfg->micb_mv = wcd938x->micb2_mv;
+	cfg->micb_mv = wcd938x->common.micb_mv[2];
 	cfg->linein_th = 5000;
 	cfg->hs_thr = 1700;
 	cfg->hph_thr = 50;
@@ -3411,7 +3358,7 @@ static int wcd938x_bind(struct device *d
 		return ret;
 	}
 
-	wcd938x->rxdev = wcd938x_sdw_device_get(wcd938x->rxnode);
+	wcd938x->rxdev = of_sdw_find_device_by_node(wcd938x->rxnode);
 	if (!wcd938x->rxdev) {
 		dev_err(dev, "could not find slave with matching of node\n");
 		ret = -EINVAL;
@@ -3420,7 +3367,7 @@ static int wcd938x_bind(struct device *d
 	wcd938x->sdw_priv[AIF1_PB] = dev_get_drvdata(wcd938x->rxdev);
 	wcd938x->sdw_priv[AIF1_PB]->wcd938x = wcd938x;
 
-	wcd938x->txdev = wcd938x_sdw_device_get(wcd938x->txnode);
+	wcd938x->txdev = of_sdw_find_device_by_node(wcd938x->txnode);
 	if (!wcd938x->txdev) {
 		dev_err(dev, "could not find txslave with matching of node\n");
 		ret = -EINVAL;
@@ -3453,7 +3400,7 @@ static int wcd938x_bind(struct device *d
 		goto err_remove_tx_link;
 	}
 
-	wcd938x->regmap = dev_get_regmap(&wcd938x->tx_sdw_dev->dev, NULL);
+	wcd938x->regmap = wcd938x->sdw_priv[AIF1_CAP]->regmap;
 	if (!wcd938x->regmap) {
 		dev_err(dev, "could not get TX device regmap\n");
 		ret = -EINVAL;
@@ -3469,11 +3416,7 @@ static int wcd938x_bind(struct device *d
 	wcd938x->sdw_priv[AIF1_PB]->slave_irq = wcd938x->virq;
 	wcd938x->sdw_priv[AIF1_CAP]->slave_irq = wcd938x->virq;
 
-	ret = wcd938x_set_micbias_data(wcd938x);
-	if (ret < 0) {
-		dev_err(dev, "%s: bad micbias pdata\n", __func__);
-		goto err_remove_rx_link;
-	}
+	wcd938x_set_micbias_data(dev, wcd938x);
 
 	ret = snd_soc_register_component(dev, &soc_codec_dev_wcd938x,
 					 wcd938x_dais, ARRAY_SIZE(wcd938x_dais));
@@ -3562,6 +3505,8 @@ static int wcd938x_probe(struct platform
 
 	dev_set_drvdata(dev, wcd938x);
 	mutex_init(&wcd938x->micb_lock);
+	wcd938x->common.dev = dev;
+	wcd938x->common.max_bias = 4;
 
 	ret = wcd938x_populate_dt_data(wcd938x, dev);
 	if (ret)
diff -Nrup linux-6.16.6/sound/soc/codecs/wcd938x.h linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd938x.h
--- linux-6.16.6/sound/soc/codecs/wcd938x.h	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd938x.h	2025-09-11 09:47:42.000000000 -0600
@@ -587,17 +587,6 @@
 
 #define WCD938X_MAX_SWR_CH_IDS	15
 
-struct wcd938x_sdw_ch_info {
-	int port_num;
-	unsigned int ch_mask;
-};
-
-#define WCD_SDW_CH(id, pn, cmask)	\
-	[id] = {			\
-		.port_num = pn,		\
-		.ch_mask = cmask,	\
-	}
-
 enum wcd938x_tx_sdw_ports {
 	WCD938X_ADC_1_2_PORT = 1,
 	WCD938X_ADC_3_4_PORT,
@@ -649,7 +638,7 @@ struct wcd938x_sdw_priv {
 	struct sdw_stream_config sconfig;
 	struct sdw_stream_runtime *sruntime;
 	struct sdw_port_config port_config[WCD938X_MAX_SWR_PORTS];
-	const struct wcd938x_sdw_ch_info *ch_info;
+	const struct wcd_sdw_ch_info *ch_info;
 	bool port_enable[WCD938X_MAX_SWR_CH_IDS];
 	int active_ports;
 	bool is_tx;
@@ -669,10 +658,6 @@ int wcd938x_sdw_hw_params(struct wcd938x
 			  struct snd_pcm_substream *substream,
 			  struct snd_pcm_hw_params *params,
 			  struct snd_soc_dai *dai);
-
-struct device *wcd938x_sdw_device_get(struct device_node *np);
-int wcd938x_swr_get_current_bank(struct sdw_slave *sdev);
-
 #else
 
 static inline int wcd938x_sdw_free(struct wcd938x_sdw_priv *wcd,
@@ -697,14 +682,5 @@ static inline int wcd938x_sdw_hw_params(
 	return -EOPNOTSUPP;
 }
 
-static inline struct device *wcd938x_sdw_device_get(struct device_node *np)
-{
-	return NULL;
-}
-
-static inline int wcd938x_swr_get_current_bank(struct sdw_slave *sdev)
-{
-	return 0;
-}
 #endif /* CONFIG_SND_SOC_WCD938X_SDW */
 #endif /* __WCD938X_H__ */
diff -Nrup linux-6.16.6/sound/soc/codecs/wcd938x-sdw.c linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd938x-sdw.c
--- linux-6.16.6/sound/soc/codecs/wcd938x-sdw.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd938x-sdw.c	2025-09-11 09:47:42.000000000 -0600
@@ -18,10 +18,9 @@
 #include <sound/soc.h>
 #include <sound/soc-dapm.h>
 #include "wcd938x.h"
+#include "wcd-common.h"
 
-#define SWRS_SCP_HOST_CLK_DIV2_CTL_BANK(m) (0xE0 + 0x10 * (m))
-
-static const struct wcd938x_sdw_ch_info wcd938x_sdw_rx_ch_info[] = {
+static const struct wcd_sdw_ch_info wcd938x_sdw_rx_ch_info[] = {
 	WCD_SDW_CH(WCD938X_HPH_L, WCD938X_HPH_PORT, BIT(0)),
 	WCD_SDW_CH(WCD938X_HPH_R, WCD938X_HPH_PORT, BIT(1)),
 	WCD_SDW_CH(WCD938X_CLSH, WCD938X_CLSH_PORT, BIT(0)),
@@ -32,7 +31,7 @@ static const struct wcd938x_sdw_ch_info
 	WCD_SDW_CH(WCD938X_DSD_R, WCD938X_DSD_PORT, BIT(1)),
 };
 
-static const struct wcd938x_sdw_ch_info wcd938x_sdw_tx_ch_info[] = {
+static const struct wcd_sdw_ch_info wcd938x_sdw_tx_ch_info[] = {
 	WCD_SDW_CH(WCD938X_ADC1, WCD938X_ADC_1_2_PORT, BIT(0)),
 	WCD_SDW_CH(WCD938X_ADC2, WCD938X_ADC_1_2_PORT, BIT(1)),
 	WCD_SDW_CH(WCD938X_ADC3, WCD938X_ADC_3_4_PORT, BIT(0)),
@@ -82,23 +81,6 @@ static struct sdw_dpn_prop wcd938x_dpn_p
 	}
 };
 
-struct device *wcd938x_sdw_device_get(struct device_node *np)
-{
-	return bus_find_device_by_of_node(&sdw_bus_type, np);
-
-}
-EXPORT_SYMBOL_GPL(wcd938x_sdw_device_get);
-
-int wcd938x_swr_get_current_bank(struct sdw_slave *sdev)
-{
-	int bank;
-
-	bank  = sdw_read(sdev, SDW_SCP_CTRL);
-
-	return ((bank & 0x40) ? 1 : 0);
-}
-EXPORT_SYMBOL_GPL(wcd938x_swr_get_current_bank);
-
 int wcd938x_sdw_hw_params(struct wcd938x_sdw_priv *wcd,
 			  struct snd_pcm_substream *substream,
 			  struct snd_pcm_hw_params *params,
@@ -158,44 +140,13 @@ int wcd938x_sdw_set_sdw_stream(struct wc
 }
 EXPORT_SYMBOL_GPL(wcd938x_sdw_set_sdw_stream);
 
-static int wcd9380_update_status(struct sdw_slave *slave,
-				 enum sdw_slave_status status)
-{
-	struct wcd938x_sdw_priv *wcd = dev_get_drvdata(&slave->dev);
-
-	if (wcd->regmap && (status == SDW_SLAVE_ATTACHED)) {
-		/* Write out any cached changes that happened between probe and attach */
-		regcache_cache_only(wcd->regmap, false);
-		return regcache_sync(wcd->regmap);
-	}
-
-	return 0;
-}
-
-static int wcd9380_bus_config(struct sdw_slave *slave,
-			      struct sdw_bus_params *params)
-{
-	sdw_write(slave, SWRS_SCP_HOST_CLK_DIV2_CTL_BANK(params->next_bank),  0x01);
-
-	return 0;
-}
-
 static int wcd9380_interrupt_callback(struct sdw_slave *slave,
 				      struct sdw_slave_intr_status *status)
 {
 	struct wcd938x_sdw_priv *wcd = dev_get_drvdata(&slave->dev);
-	struct irq_domain *slave_irq = wcd->slave_irq;
-	u32 sts1, sts2, sts3;
-
-	do {
-		handle_nested_irq(irq_find_mapping(slave_irq, 0));
-		regmap_read(wcd->regmap, WCD938X_DIGITAL_INTR_STATUS_0, &sts1);
-		regmap_read(wcd->regmap, WCD938X_DIGITAL_INTR_STATUS_1, &sts2);
-		regmap_read(wcd->regmap, WCD938X_DIGITAL_INTR_STATUS_2, &sts3);
 
-	} while (sts1 || sts2 || sts3);
-
-	return IRQ_HANDLED;
+	return wcd_interrupt_callback(slave, wcd->slave_irq, WCD938X_DIGITAL_INTR_STATUS_0,
+				WCD938X_DIGITAL_INTR_STATUS_1, WCD938X_DIGITAL_INTR_STATUS_2);
 }
 
 static const struct reg_default wcd938x_defaults[] = {
@@ -1193,25 +1144,9 @@ static const struct regmap_config wcd938
 };
 
 static const struct sdw_slave_ops wcd9380_slave_ops = {
-	.update_status = wcd9380_update_status,
+	.update_status = wcd_update_status,
 	.interrupt_callback = wcd9380_interrupt_callback,
-	.bus_config = wcd9380_bus_config,
-};
-
-static int wcd938x_sdw_component_bind(struct device *dev,
-				      struct device *master, void *data)
-{
-	return 0;
-}
-
-static void wcd938x_sdw_component_unbind(struct device *dev,
-					 struct device *master, void *data)
-{
-}
-
-static const struct component_ops wcd938x_sdw_component_ops = {
-	.bind   = wcd938x_sdw_component_bind,
-	.unbind = wcd938x_sdw_component_unbind,
+	.bus_config = wcd_bus_config,
 };
 
 static int wcd9380_probe(struct sdw_slave *pdev,
@@ -1278,7 +1213,7 @@ static int wcd9380_probe(struct sdw_slav
 	pm_runtime_set_active(dev);
 	pm_runtime_enable(dev);
 
-	ret = component_add(dev, &wcd938x_sdw_component_ops);
+	ret = component_add(dev, &wcd_sdw_component_ops);
 	if (ret)
 		goto err_disable_rpm;
 
@@ -1296,7 +1231,7 @@ static int wcd9380_remove(struct sdw_sla
 {
 	struct device *dev = &pdev->dev;
 
-	component_del(dev, &wcd938x_sdw_component_ops);
+	component_del(dev, &wcd_sdw_component_ops);
 
 	pm_runtime_disable(dev);
 	pm_runtime_set_suspended(dev);
diff -Nrup linux-6.16.6/sound/soc/codecs/wcd939x.c linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd939x.c
--- linux-6.16.6/sound/soc/codecs/wcd939x.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd939x.c	2025-09-11 09:47:42.000000000 -0600
@@ -28,6 +28,7 @@
 #include <linux/usb/typec_altmode.h>
 
 #include "wcd-clsh-v2.h"
+#include "wcd-common.h"
 #include "wcd-mbhc-v2.h"
 #include "wcd939x.h"
 
@@ -189,6 +190,7 @@ struct wcd939x_priv {
 	struct wcd_mbhc_config mbhc_cfg;
 	struct wcd_mbhc_intr intr_ids;
 	struct wcd_clsh_ctrl *clsh_info;
+	struct wcd_common common;
 	struct irq_domain *virq;
 	struct regmap_irq_chip *wcd_regmap_irq_chip;
 	struct regmap_irq_chip_data *irq_chip;
@@ -201,10 +203,6 @@ struct wcd939x_priv {
 	u32 tx_mode[TX_ADC_MAX];
 	int variant;
 	struct gpio_desc *reset_gpio;
-	u32 micb1_mv;
-	u32 micb2_mv;
-	u32 micb3_mv;
-	u32 micb4_mv;
 	int hphr_pdm_wd_int;
 	int hphl_pdm_wd_int;
 	int ear_pdm_wd_int;
@@ -411,7 +409,7 @@ static int wcd939x_io_init(struct snd_so
 	return 0;
 }
 
-static int wcd939x_sdw_connect_port(const struct wcd939x_sdw_ch_info *ch_info,
+static int wcd939x_sdw_connect_port(const struct wcd_sdw_ch_info *ch_info,
 				    struct sdw_port_config *port_config,
 				    u8 enable)
 {
@@ -1013,7 +1011,7 @@ static int wcd939x_tx_swr_ctrl(struct sn
 	int bank;
 	int rate;
 
-	bank = wcd939x_swr_get_current_bank(wcd939x->sdw_priv[AIF1_CAP]->sdev);
+	bank = sdw_slave_get_current_bank(wcd939x->sdw_priv[AIF1_CAP]->sdev);
 
 	switch (event) {
 	case SND_SOC_DAPM_PRE_PMU:
@@ -1915,17 +1913,6 @@ static void wcd939x_mbhc_micb_ramp_contr
 	}
 }
 
-static int wcd939x_get_micb_vout_ctl_val(u32 micb_mv)
-{
-	/* min micbias voltage is 1V and maximum is 2.85V */
-	if (micb_mv < 1000 || micb_mv > 2850) {
-		pr_err("%s: unsupported micbias voltage\n", __func__);
-		return -EINVAL;
-	}
-
-	return (micb_mv - 1000) / 50;
-}
-
 static int wcd939x_mbhc_micb_adjust_voltage(struct snd_soc_component *component,
 					    int req_volt, int micb_num)
 {
@@ -1965,7 +1952,7 @@ static int wcd939x_mbhc_micb_adjust_volt
 	cur_vout_ctl = snd_soc_component_read_field(component, micb_reg,
 						    WCD939X_MICB_VOUT_CTL);
 
-	req_vout_ctl = wcd939x_get_micb_vout_ctl_val(req_volt);
+	req_vout_ctl = wcd_get_micb_vout_ctl_val(component->dev, req_volt);
 	if (req_vout_ctl < 0) {
 		ret = req_vout_ctl;
 		goto exit;
@@ -2017,10 +2004,10 @@ static int wcd939x_mbhc_micb_ctrl_thresh
 	 * voltage needed to detect threshold microphone, then do
 	 * not change the micbias, just return.
 	 */
-	if (wcd939x->micb2_mv >= WCD_MBHC_THR_HS_MICB_MV)
+	if (wcd939x->common.micb_mv[1] >= WCD_MBHC_THR_HS_MICB_MV)
 		return 0;
 
-	micb_mv = req_en ? WCD_MBHC_THR_HS_MICB_MV : wcd939x->micb2_mv;
+	micb_mv = req_en ? WCD_MBHC_THR_HS_MICB_MV : wcd939x->common.micb_mv[1];
 
 	return wcd939x_mbhc_micb_adjust_voltage(component, micb_mv, MIC_BIAS_2);
 }
@@ -2891,28 +2878,16 @@ static const struct snd_soc_dapm_route w
 	{"EAR", NULL, "EAR PGA"},
 };
 
-static int wcd939x_set_micbias_data(struct wcd939x_priv *wcd939x)
+static void wcd939x_set_micbias_data(struct device *dev, struct wcd939x_priv *wcd939x)
 {
-	int vout_ctl_1, vout_ctl_2, vout_ctl_3, vout_ctl_4;
-
-	/* set micbias voltage */
-	vout_ctl_1 = wcd939x_get_micb_vout_ctl_val(wcd939x->micb1_mv);
-	vout_ctl_2 = wcd939x_get_micb_vout_ctl_val(wcd939x->micb2_mv);
-	vout_ctl_3 = wcd939x_get_micb_vout_ctl_val(wcd939x->micb3_mv);
-	vout_ctl_4 = wcd939x_get_micb_vout_ctl_val(wcd939x->micb4_mv);
-	if (vout_ctl_1 < 0 || vout_ctl_2 < 0 || vout_ctl_3 < 0 || vout_ctl_4 < 0)
-		return -EINVAL;
-
 	regmap_update_bits(wcd939x->regmap, WCD939X_ANA_MICB1,
-			   WCD939X_MICB_VOUT_CTL, vout_ctl_1);
+			   WCD939X_MICB_VOUT_CTL, wcd939x->common.micb_vout[0]);
 	regmap_update_bits(wcd939x->regmap, WCD939X_ANA_MICB2,
-			   WCD939X_MICB_VOUT_CTL, vout_ctl_2);
+			   WCD939X_MICB_VOUT_CTL, wcd939x->common.micb_vout[1]);
 	regmap_update_bits(wcd939x->regmap, WCD939X_ANA_MICB3,
-			   WCD939X_MICB_VOUT_CTL, vout_ctl_3);
+			   WCD939X_MICB_VOUT_CTL, wcd939x->common.micb_vout[2]);
 	regmap_update_bits(wcd939x->regmap, WCD939X_ANA_MICB4,
-			   WCD939X_MICB_VOUT_CTL, vout_ctl_4);
-
-	return 0;
+			   WCD939X_MICB_VOUT_CTL, wcd939x->common.micb_vout[3]);
 }
 
 static irqreturn_t wcd939x_wd_handle_irq(int irq, void *data)
@@ -3182,37 +3157,6 @@ static int wcd939x_typec_mux_set(struct
 }
 #endif /* CONFIG_TYPEC */
 
-static void wcd939x_dt_parse_micbias_info(struct device *dev, struct wcd939x_priv *wcd)
-{
-	struct device_node *np = dev->of_node;
-	u32 prop_val = 0;
-	int rc = 0;
-
-	rc = of_property_read_u32(np, "qcom,micbias1-microvolt",  &prop_val);
-	if (!rc)
-		wcd->micb1_mv = prop_val / 1000;
-	else
-		dev_info(dev, "%s: Micbias1 DT property not found\n", __func__);
-
-	rc = of_property_read_u32(np, "qcom,micbias2-microvolt",  &prop_val);
-	if (!rc)
-		wcd->micb2_mv = prop_val / 1000;
-	else
-		dev_info(dev, "%s: Micbias2 DT property not found\n", __func__);
-
-	rc = of_property_read_u32(np, "qcom,micbias3-microvolt", &prop_val);
-	if (!rc)
-		wcd->micb3_mv = prop_val / 1000;
-	else
-		dev_info(dev, "%s: Micbias3 DT property not found\n", __func__);
-
-	rc = of_property_read_u32(np, "qcom,micbias4-microvolt",  &prop_val);
-	if (!rc)
-		wcd->micb4_mv = prop_val / 1000;
-	else
-		dev_info(dev, "%s: Micbias4 DT property not found\n", __func__);
-}
-
 #if IS_ENABLED(CONFIG_TYPEC)
 static bool wcd939x_swap_gnd_mic(struct snd_soc_component *component)
 {
@@ -3259,13 +3203,15 @@ static int wcd939x_populate_dt_data(stru
 		return dev_err_probe(dev, ret, "Failed to enable supplies\n");
 	}
 
-	wcd939x_dt_parse_micbias_info(dev, wcd939x);
+	ret = wcd_dt_parse_micbias_info(&wcd939x->common);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get micbias\n");
 
 	cfg->mbhc_micbias = MIC_BIAS_2;
 	cfg->anc_micbias = MIC_BIAS_2;
 	cfg->v_hs_max = WCD_MBHC_HS_V_MAX;
 	cfg->num_btn = WCD939X_MBHC_MAX_BUTTONS;
-	cfg->micb_mv = wcd939x->micb2_mv;
+	cfg->micb_mv = wcd939x->common.micb_mv[1];
 	cfg->linein_th = 5000;
 	cfg->hs_thr = 1700;
 	cfg->hph_thr = 50;
@@ -3390,7 +3336,7 @@ static int wcd939x_bind(struct device *d
 		goto err_put_typec_switch;
 	}
 
-	wcd939x->rxdev = wcd939x_sdw_device_get(wcd939x->rxnode);
+	wcd939x->rxdev = of_sdw_find_device_by_node(wcd939x->rxnode);
 	if (!wcd939x->rxdev) {
 		dev_err(dev, "could not find slave with matching of node\n");
 		ret = -EINVAL;
@@ -3399,7 +3345,7 @@ static int wcd939x_bind(struct device *d
 	wcd939x->sdw_priv[AIF1_PB] = dev_get_drvdata(wcd939x->rxdev);
 	wcd939x->sdw_priv[AIF1_PB]->wcd939x = wcd939x;
 
-	wcd939x->txdev = wcd939x_sdw_device_get(wcd939x->txnode);
+	wcd939x->txdev = of_sdw_find_device_by_node(wcd939x->txnode);
 	if (!wcd939x->txdev) {
 		dev_err(dev, "could not find txslave with matching of node\n");
 		ret = -EINVAL;
@@ -3435,10 +3381,10 @@ static int wcd939x_bind(struct device *d
 	}
 
 	/* Get regmap from TX SoundWire device */
-	wcd939x->regmap = wcd939x_swr_get_regmap(wcd939x->sdw_priv[AIF1_CAP]);
-	if (IS_ERR(wcd939x->regmap)) {
+	wcd939x->regmap = wcd939x->sdw_priv[AIF1_CAP]->regmap;
+	if (!wcd939x->regmap) {
 		dev_err(dev, "could not get TX device regmap\n");
-		ret = PTR_ERR(wcd939x->regmap);
+		ret = -ENODEV;
 		goto err_remove_rx_link;
 	}
 
@@ -3451,11 +3397,7 @@ static int wcd939x_bind(struct device *d
 	wcd939x->sdw_priv[AIF1_PB]->slave_irq = wcd939x->virq;
 	wcd939x->sdw_priv[AIF1_CAP]->slave_irq = wcd939x->virq;
 
-	ret = wcd939x_set_micbias_data(wcd939x);
-	if (ret < 0) {
-		dev_err(dev, "%s: bad micbias pdata\n", __func__);
-		goto err_remove_rx_link;
-	}
+	wcd939x_set_micbias_data(dev, wcd939x);
 
 	/* Check WCD9395 version */
 	regmap_read(wcd939x->regmap, WCD939X_DIGITAL_CHIP_ID1, &id1);
@@ -3620,6 +3562,8 @@ static int wcd939x_probe(struct platform
 
 	dev_set_drvdata(dev, wcd939x);
 	mutex_init(&wcd939x->micb_lock);
+	wcd939x->common.dev = dev;
+	wcd939x->common.max_bias = 4;
 
 	ret = wcd939x_populate_dt_data(wcd939x, dev);
 	if (ret) {
diff -Nrup linux-6.16.6/sound/soc/codecs/wcd939x.h linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd939x.h
--- linux-6.16.6/sound/soc/codecs/wcd939x.h	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd939x.h	2025-09-11 09:47:42.000000000 -0600
@@ -844,17 +844,6 @@
 
 #define WCD939X_MAX_SWR_CH_IDS		(15)
 
-struct wcd939x_sdw_ch_info {
-	int port_num;
-	unsigned int ch_mask;
-};
-
-#define WCD_SDW_CH(id, pn, cmask)	\
-	[id] = {			\
-		.port_num = pn,		\
-		.ch_mask = cmask,	\
-	}
-
 enum wcd939x_tx_sdw_ports {
 	WCD939X_ADC_1_4_PORT = 1,
 	WCD939X_ADC_DMIC_1_2_PORT,
@@ -909,7 +898,7 @@ struct wcd939x_sdw_priv {
 	struct sdw_stream_config sconfig;
 	struct sdw_stream_runtime *sruntime;
 	struct sdw_port_config port_config[WCD939X_MAX_SWR_PORTS];
-	const struct wcd939x_sdw_ch_info *ch_info;
+	const struct wcd_sdw_ch_info *ch_info;
 	bool port_enable[WCD939X_MAX_SWR_CH_IDS];
 	int active_ports;
 	bool is_tx;
@@ -929,11 +918,6 @@ int wcd939x_sdw_hw_params(struct wcd939x
 			  struct snd_pcm_substream *substream,
 			  struct snd_pcm_hw_params *params,
 			  struct snd_soc_dai *dai);
-
-struct device *wcd939x_sdw_device_get(struct device_node *np);
-unsigned int wcd939x_swr_get_current_bank(struct sdw_slave *sdev);
-
-struct regmap *wcd939x_swr_get_regmap(struct wcd939x_sdw_priv *wcd);
 #else
 
 static inline int wcd939x_sdw_free(struct wcd939x_sdw_priv *wcd,
@@ -958,20 +942,6 @@ static inline int wcd939x_sdw_hw_params(
 	return -EOPNOTSUPP;
 }
 
-static inline struct device *wcd939x_sdw_device_get(struct device_node *np)
-{
-	return NULL;
-}
-
-static inline unsigned int wcd939x_swr_get_current_bank(struct sdw_slave *sdev)
-{
-	return 0;
-}
-
-struct regmap *wcd939x_swr_get_regmap(struct wcd939x_sdw_priv *wcd)
-{
-	return PTR_ERR(-EINVAL);
-}
 #endif /* CONFIG_SND_SOC_WCD939X_SDW */
 
 #endif /* __WCD939X_H__ */
diff -Nrup linux-6.16.6/sound/soc/codecs/wcd939x-sdw.c linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd939x-sdw.c
--- linux-6.16.6/sound/soc/codecs/wcd939x-sdw.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd939x-sdw.c	2025-09-11 09:47:42.000000000 -0600
@@ -20,10 +20,9 @@
 #include <sound/soc.h>
 #include <sound/soc-dapm.h>
 #include "wcd939x.h"
+#include "wcd-common.h"
 
-#define SWRS_SCP_HOST_CLK_DIV2_CTL_BANK(m) (0xE0 + 0x10 * (m))
-
-static const struct wcd939x_sdw_ch_info wcd939x_sdw_rx_ch_info[] = {
+static const struct wcd_sdw_ch_info wcd939x_sdw_rx_ch_info[] = {
 	WCD_SDW_CH(WCD939X_HPH_L, WCD939X_HPH_PORT, BIT(0)),
 	WCD_SDW_CH(WCD939X_HPH_R, WCD939X_HPH_PORT, BIT(1)),
 	WCD_SDW_CH(WCD939X_CLSH, WCD939X_CLSH_PORT, BIT(0)),
@@ -36,7 +35,7 @@ static const struct wcd939x_sdw_ch_info
 	WCD_SDW_CH(WCD939X_HIFI_PCM_R, WCD939X_HIFI_PCM_PORT, BIT(1)),
 };
 
-static const struct wcd939x_sdw_ch_info wcd939x_sdw_tx_ch_info[] = {
+static const struct wcd_sdw_ch_info wcd939x_sdw_tx_ch_info[] = {
 	WCD_SDW_CH(WCD939X_ADC1, WCD939X_ADC_1_4_PORT, BIT(0)),
 	WCD_SDW_CH(WCD939X_ADC2, WCD939X_ADC_1_4_PORT, BIT(1)),
 	WCD_SDW_CH(WCD939X_ADC3, WCD939X_ADC_1_4_PORT, BIT(2)),
@@ -128,19 +127,6 @@ static struct sdw_dpn_prop wcd939x_tx_dp
 	}
 };
 
-struct device *wcd939x_sdw_device_get(struct device_node *np)
-{
-	return bus_find_device_by_of_node(&sdw_bus_type, np);
-}
-EXPORT_SYMBOL_GPL(wcd939x_sdw_device_get);
-
-unsigned int wcd939x_swr_get_current_bank(struct sdw_slave *sdev)
-{
-	return FIELD_GET(SDW_SCP_STAT_CURR_BANK,
-			 sdw_read(sdev, SDW_SCP_CTRL));
-}
-EXPORT_SYMBOL_GPL(wcd939x_swr_get_current_bank);
-
 int wcd939x_sdw_hw_params(struct wcd939x_sdw_priv *wcd,
 			  struct snd_pcm_substream *substream,
 			  struct snd_pcm_hw_params *params,
@@ -199,38 +185,6 @@ int wcd939x_sdw_set_sdw_stream(struct wc
 }
 EXPORT_SYMBOL_GPL(wcd939x_sdw_set_sdw_stream);
 
-struct regmap *wcd939x_swr_get_regmap(struct wcd939x_sdw_priv *wcd)
-{
-	if (wcd->regmap)
-		return wcd->regmap;
-
-	return ERR_PTR(-EINVAL);
-}
-EXPORT_SYMBOL_GPL(wcd939x_swr_get_regmap);
-
-static int wcd9390_update_status(struct sdw_slave *slave,
-				 enum sdw_slave_status status)
-{
-	struct wcd939x_sdw_priv *wcd = dev_get_drvdata(&slave->dev);
-
-	if (wcd->regmap && status == SDW_SLAVE_ATTACHED) {
-		/* Write out any cached changes that happened between probe and attach */
-		regcache_cache_only(wcd->regmap, false);
-		return regcache_sync(wcd->regmap);
-	}
-
-	return 0;
-}
-
-static int wcd9390_bus_config(struct sdw_slave *slave,
-			      struct sdw_bus_params *params)
-{
-	sdw_write(slave, SWRS_SCP_HOST_CLK_DIV2_CTL_BANK(params->next_bank),
-		  0x01);
-
-	return 0;
-}
-
 /*
  * Handle Soundwire out-of-band interrupt event by triggering
  * the first irq of the slave_irq irq domain, which then will
@@ -241,18 +195,9 @@ static int wcd9390_interrupt_callback(st
 				      struct sdw_slave_intr_status *status)
 {
 	struct wcd939x_sdw_priv *wcd = dev_get_drvdata(&slave->dev);
-	struct irq_domain *slave_irq = wcd->slave_irq;
-	u32 sts1, sts2, sts3;
-
-	do {
-		handle_nested_irq(irq_find_mapping(slave_irq, 0));
-		regmap_read(wcd->regmap, WCD939X_DIGITAL_INTR_STATUS_0, &sts1);
-		regmap_read(wcd->regmap, WCD939X_DIGITAL_INTR_STATUS_1, &sts2);
-		regmap_read(wcd->regmap, WCD939X_DIGITAL_INTR_STATUS_2, &sts3);
-
-	} while (sts1 || sts2 || sts3);
 
-	return IRQ_HANDLED;
+	return wcd_interrupt_callback(slave, wcd->slave_irq, WCD939X_DIGITAL_INTR_STATUS_0,
+			WCD939X_DIGITAL_INTR_STATUS_1, WCD939X_DIGITAL_INTR_STATUS_2);
 }
 
 static const struct reg_default wcd939x_defaults[] = {
@@ -1385,34 +1330,9 @@ static const struct regmap_config wcd939
 };
 
 static const struct sdw_slave_ops wcd9390_slave_ops = {
-	.update_status = wcd9390_update_status,
+	.update_status = wcd_update_status,
 	.interrupt_callback = wcd9390_interrupt_callback,
-	.bus_config = wcd9390_bus_config,
-};
-
-static int wcd939x_sdw_component_bind(struct device *dev, struct device *master,
-				      void *data)
-{
-	pm_runtime_set_autosuspend_delay(dev, 3000);
-	pm_runtime_use_autosuspend(dev);
-	pm_runtime_mark_last_busy(dev);
-	pm_runtime_set_active(dev);
-	pm_runtime_enable(dev);
-
-	return 0;
-}
-
-static void wcd939x_sdw_component_unbind(struct device *dev,
-					 struct device *master, void *data)
-{
-	pm_runtime_disable(dev);
-	pm_runtime_set_suspended(dev);
-	pm_runtime_dont_use_autosuspend(dev);
-}
-
-static const struct component_ops wcd939x_sdw_component_ops = {
-	.bind = wcd939x_sdw_component_bind,
-	.unbind = wcd939x_sdw_component_unbind,
+	.bus_config = wcd_bus_config,
 };
 
 static int wcd9390_probe(struct sdw_slave *pdev, const struct sdw_device_id *id)
@@ -1478,7 +1398,7 @@ static int wcd9390_probe(struct sdw_slav
 		regcache_cache_only(wcd->regmap, true);
 	}
 
-	ret = component_add(dev, &wcd939x_sdw_component_ops);
+	ret = component_add(dev, &wcd_sdw_component_ops);
 	if (ret)
 		return ret;
 
@@ -1493,7 +1413,7 @@ static int wcd9390_remove(struct sdw_sla
 	struct device *dev = &pdev->dev;
 	struct wcd939x_sdw_priv *wcd = dev_get_drvdata(dev);
 
-	component_del(dev, &wcd939x_sdw_component_ops);
+	component_del(dev, &wcd_sdw_component_ops);
 
 	if (wcd->regmap)
 		regmap_exit(wcd->regmap);
diff -Nrup linux-6.16.6/sound/soc/codecs/wcd-common.c linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd-common.c
--- linux-6.16.6/sound/soc/codecs/wcd-common.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd-common.c	2025-09-11 09:47:42.000000000 -0600
@@ -0,0 +1,143 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2025, Qualcomm Technologies, Inc. and/or its subsidiaries.
+
+#include <linux/export.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/of.h>
+#include <linux/printk.h>
+#include <linux/component.h>
+#include <linux/pm_runtime.h>
+#include <linux/soundwire/sdw.h>
+#include <linux/soundwire/sdw_type.h>
+#include <linux/regmap.h>
+
+#include "wcd-common.h"
+
+#define WCD_MIN_MICBIAS_MV	1000
+#define WCD_DEF_MICBIAS_MV	1800
+#define WCD_MAX_MICBIAS_MV	2850
+
+#define SWRS_SCP_HOST_CLK_DIV2_CTL_BANK(m) (0xE0 + 0x10 * (m))
+
+int wcd_get_micb_vout_ctl_val(struct device *dev, u32 micb_mv)
+{
+	/* min micbias voltage is 1V and maximum is 2.85V */
+	if (micb_mv < WCD_MIN_MICBIAS_MV || micb_mv > WCD_MAX_MICBIAS_MV) {
+		dev_err(dev, "Unsupported micbias voltage (%u mV)\n", micb_mv);
+		return -EINVAL;
+	}
+
+	return (micb_mv - WCD_MIN_MICBIAS_MV) / 50;
+}
+EXPORT_SYMBOL_GPL(wcd_get_micb_vout_ctl_val);
+
+static int wcd_get_micbias_val(struct device *dev, int micb_num, u32 *micb_mv)
+{
+	char micbias[64];
+	int mv;
+
+	sprintf(micbias, "qcom,micbias%d-microvolt", micb_num);
+
+	if (of_property_read_u32(dev->of_node, micbias, &mv)) {
+		dev_err(dev, "%s value not found, using default\n", micbias);
+		mv = WCD_DEF_MICBIAS_MV;
+	} else {
+		/* convert it to milli volts */
+		mv = mv/1000;
+	}
+	if (micb_mv)
+		*micb_mv = mv;
+
+	mv = wcd_get_micb_vout_ctl_val(dev, mv);
+	if (mv < 0) {
+		dev_err(dev, "Unsupported %s voltage (%d mV), falling back to default (%d mV)\n",
+				micbias, mv, WCD_DEF_MICBIAS_MV);
+		return wcd_get_micb_vout_ctl_val(dev, WCD_DEF_MICBIAS_MV);
+	}
+
+	return mv;
+}
+
+int wcd_dt_parse_micbias_info(struct wcd_common *common)
+{
+	int i;
+
+	for (i = 0; i < common->max_bias; i++) {
+		common->micb_vout[i] = wcd_get_micbias_val(common->dev, i + 1, &common->micb_mv[i]);
+		if (common->micb_vout[i] < 0)
+			return -EINVAL;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(wcd_dt_parse_micbias_info);
+
+static int wcd_sdw_component_bind(struct device *dev, struct device *master, void *data)
+{
+	pm_runtime_set_autosuspend_delay(dev, 3000);
+	pm_runtime_use_autosuspend(dev);
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+
+	return 0;
+}
+
+static void wcd_sdw_component_unbind(struct device *dev, struct device *master, void *data)
+{
+	pm_runtime_disable(dev);
+	pm_runtime_set_suspended(dev);
+	pm_runtime_dont_use_autosuspend(dev);
+}
+
+const struct component_ops wcd_sdw_component_ops = {
+	.bind = wcd_sdw_component_bind,
+	.unbind = wcd_sdw_component_unbind,
+};
+EXPORT_SYMBOL_GPL(wcd_sdw_component_ops);
+
+int wcd_update_status(struct sdw_slave *slave, enum sdw_slave_status status)
+{
+	struct regmap *regmap = dev_get_regmap(&slave->dev, NULL);
+
+	if (regmap && status == SDW_SLAVE_ATTACHED) {
+		/* Write out any cached changes that happened between probe and attach */
+		regcache_cache_only(regmap, false);
+		return regcache_sync(regmap);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(wcd_update_status);
+
+int wcd_bus_config(struct sdw_slave *slave, struct sdw_bus_params *params)
+{
+	sdw_write(slave, SWRS_SCP_HOST_CLK_DIV2_CTL_BANK(params->next_bank), 0x01);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(wcd_bus_config);
+
+int wcd_interrupt_callback(struct sdw_slave *slave, struct irq_domain *slave_irq,
+		unsigned int wcd_intr_status0, unsigned int wcd_intr_status1,
+		unsigned int wcd_intr_status2)
+{
+	struct regmap *regmap = dev_get_regmap(&slave->dev, NULL);
+	u32 sts1, sts2, sts3;
+
+	do {
+		handle_nested_irq(irq_find_mapping(slave_irq, 0));
+		regmap_read(regmap, wcd_intr_status0, &sts1);
+		regmap_read(regmap, wcd_intr_status1, &sts2);
+		regmap_read(regmap, wcd_intr_status2, &sts3);
+
+	} while (sts1 || sts2 || sts3);
+
+	return IRQ_HANDLED;
+}
+EXPORT_SYMBOL_GPL(wcd_interrupt_callback);
+
+MODULE_DESCRIPTION("Common Qualcomm WCD Codec helpers driver");
+MODULE_LICENSE("GPL");
diff -Nrup linux-6.16.6/sound/soc/codecs/wcd-common.h linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd-common.h
--- linux-6.16.6/sound/soc/codecs/wcd-common.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/codecs/wcd-common.h	2025-09-11 09:47:42.000000000 -0600
@@ -0,0 +1,46 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2025, Qualcomm Technologies, Inc. and/or its subsidiaries.
+ */
+
+#ifndef __WCD_COMMON_H__
+#define __WCD_COMMON_H__
+
+struct device;
+struct sdw_slave;
+struct sdw_bus_params;
+struct irq_domain;
+enum sdw_slave_status;
+
+#define WCD_MAX_MICBIAS		4
+
+struct wcd_sdw_ch_info {
+	int port_num;
+	unsigned int ch_mask;
+	unsigned int master_ch_mask;
+};
+
+#define WCD_SDW_CH(id, pn, cmask)	\
+	[id] = {			\
+		.port_num = pn,		\
+		.ch_mask = cmask,	\
+		.master_ch_mask = cmask,	\
+	}
+
+struct wcd_common {
+	struct device *dev;
+	int max_bias;
+	u32 micb_mv[WCD_MAX_MICBIAS];
+	u32 micb_vout[WCD_MAX_MICBIAS];
+};
+
+extern const struct component_ops wcd_sdw_component_ops;
+int wcd_get_micb_vout_ctl_val(struct device *dev, u32 micb_mv);
+int wcd_dt_parse_micbias_info(struct wcd_common *common);
+int wcd_update_status(struct sdw_slave *slave, enum sdw_slave_status status);
+int wcd_bus_config(struct sdw_slave *slave, struct sdw_bus_params *params);
+int wcd_interrupt_callback(struct sdw_slave *slave, struct irq_domain *slave_irq,
+		unsigned int wcd_intr_status0, unsigned int wcd_intr_status1,
+		unsigned int wcd_intr_status2);
+
+#endif /* __WCD_COMMON_H__  */
diff -Nrup linux-6.16.6/sound/soc/qcom/qdsp6/audioreach.c linux-lenovo-x13s-linux-6.16.y/sound/soc/qcom/qdsp6/audioreach.c
--- linux-6.16.6/sound/soc/qcom/qdsp6/audioreach.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/qcom/qdsp6/audioreach.c	2025-09-11 09:47:42.000000000 -0600
@@ -202,6 +202,31 @@ struct apm_display_port_module_intf_cfg
 } __packed;
 #define APM_DP_INTF_CFG_PSIZE ALIGN(sizeof(struct apm_display_port_module_intf_cfg), 8)
 
+struct apm_module_sp_vi_op_mode_cfg {
+	struct apm_module_param_data param_data;
+	struct param_id_sp_vi_op_mode_cfg cfg;
+} __packed;
+
+#define APM_SP_VI_OP_MODE_CFG_PSIZE(ch) ALIGN( \
+				sizeof(struct apm_module_sp_vi_op_mode_cfg) + \
+				(ch) * sizeof(uint32_t), 8)
+
+struct apm_module_sp_vi_ex_mode_cfg {
+	struct apm_module_param_data param_data;
+	struct param_id_sp_vi_ex_mode_cfg cfg;
+} __packed;
+
+#define APM_SP_VI_EX_MODE_CFG_PSIZE ALIGN(sizeof(struct apm_module_sp_vi_ex_mode_cfg), 8)
+
+struct apm_module_sp_vi_channel_map_cfg {
+	struct apm_module_param_data param_data;
+	struct param_id_sp_vi_channel_map_cfg cfg;
+} __packed;
+
+#define APM_SP_VI_CH_MAP_CFG_PSIZE(ch) ALIGN( \
+				sizeof(struct apm_module_sp_vi_channel_map_cfg) + \
+				(ch) * sizeof(uint32_t), 8)
+
 static void *__audioreach_alloc_pkt(int payload_size, uint32_t opcode, uint32_t token,
 				    uint32_t src_port, uint32_t dest_port, bool has_cmd_hdr)
 {
@@ -811,6 +836,30 @@ static int audioreach_gapless_set_media_
 					 EARLY_EOS_DELAY_MS);
 }
 
+static int audioreach_set_module_config(struct q6apm_graph *graph,
+					struct audioreach_module *module,
+					struct audioreach_module_config *cfg)
+{
+	int payload_size = le32_to_cpu(module->data->size);
+	struct gpr_pkt *pkt;
+	int rc;
+	void *p;
+
+	pkt = audioreach_alloc_apm_cmd_pkt(payload_size, APM_CMD_SET_CFG, 0);
+	if (IS_ERR(pkt))
+		return PTR_ERR(pkt);
+
+	p = (void *)pkt + GPR_HDR_SIZE + APM_CMD_HDR_SIZE;
+
+	memcpy(p, module->data->data, payload_size);
+
+	rc = q6apm_send_cmd_sync(graph->apm, pkt, 0);
+
+	kfree(pkt);
+
+	return rc;
+}
+
 static int audioreach_mfc_set_media_format(struct q6apm_graph *graph,
 					   struct audioreach_module *module,
 					   struct audioreach_module_config *cfg)
@@ -1226,6 +1275,98 @@ static int audioreach_gain_set(struct q6
 	return rc;
 }
 
+static int audioreach_speaker_protection(struct q6apm_graph *graph,
+					 struct audioreach_module *module,
+					 uint32_t operation_mode)
+{
+	return audioreach_send_u32_param(graph, module, PARAM_ID_SP_OP_MODE,
+					 operation_mode);
+}
+
+static int audioreach_speaker_protection_vi(struct q6apm_graph *graph,
+					    struct audioreach_module *module,
+					    struct audioreach_module_config *mcfg)
+{
+	u32 num_channels = mcfg->num_channels;
+	struct apm_module_sp_vi_op_mode_cfg *op_cfg;
+	struct apm_module_sp_vi_channel_map_cfg *cm_cfg;
+	struct apm_module_sp_vi_ex_mode_cfg *ex_cfg;
+	int op_sz, cm_sz, ex_sz;
+	struct apm_module_param_data *param_data;
+	int rc, i, payload_size;
+	struct gpr_pkt *pkt;
+	void *p;
+
+	if (num_channels > 2) {
+		dev_err(graph->dev, "Error: Invalid channels (%d)!\n", num_channels);
+		return -EINVAL;
+	}
+
+	op_sz = APM_SP_VI_OP_MODE_CFG_PSIZE(num_channels);
+	/* Channel mapping for Isense and Vsense, thus twice number of speakers. */
+	cm_sz = APM_SP_VI_CH_MAP_CFG_PSIZE(num_channels * 2);
+	ex_sz = APM_SP_VI_EX_MODE_CFG_PSIZE;
+
+	payload_size = op_sz + cm_sz + ex_sz;
+
+	pkt = audioreach_alloc_apm_cmd_pkt(payload_size, APM_CMD_SET_CFG, 0);
+	if (IS_ERR(pkt))
+		return PTR_ERR(pkt);
+
+	p = (void *)pkt + GPR_HDR_SIZE + APM_CMD_HDR_SIZE;
+
+	op_cfg = p;
+	param_data = &op_cfg->param_data;
+	param_data->module_instance_id = module->instance_id;
+	param_data->error_code = 0;
+	param_data->param_id = PARAM_ID_SP_VI_OP_MODE_CFG;
+	param_data->param_size = op_sz - APM_MODULE_PARAM_DATA_SIZE;
+
+	op_cfg->cfg.num_channels = num_channels;
+	op_cfg->cfg.operation_mode = PARAM_ID_SP_VI_OP_MODE_NORMAL;
+	op_cfg->cfg.quick_calibration = 1;
+	/*
+	 * op_cfg->cfg.r0_t0_selection should be set only for normal mode, keep
+	 * as 0 for calibration
+	 */
+	p += op_sz;
+
+	cm_cfg = p;
+	param_data = &cm_cfg->param_data;
+	param_data->module_instance_id = module->instance_id;
+	param_data->error_code = 0;
+	param_data->param_id = PARAM_ID_SP_VI_CHANNEL_MAP_CFG;
+	param_data->param_size = cm_sz - APM_MODULE_PARAM_DATA_SIZE;
+
+	cm_cfg->cfg.num_channels = num_channels * 2;
+	for (i = 0; i < num_channels; i++) {
+		/*
+		 * Map speakers into Vsense and then Isense of each channel.
+		 * E.g. for PCM_CHANNEL_FL and PCM_CHANNEL_FR to:
+		 * [ 1, 2, 3, 4]
+		 */
+		cm_cfg->cfg.channel_mapping[2 * i] = (mcfg->channel_map[i] - 1) * 2 + 1;
+		cm_cfg->cfg.channel_mapping[2 * i + 1] = (mcfg->channel_map[i] - 1) * 2 + 2;
+	}
+
+	p += cm_sz;
+
+	ex_cfg = p;
+	param_data = &ex_cfg->param_data;
+	param_data->module_instance_id = module->instance_id;
+	param_data->error_code = 0;
+	param_data->param_id = PARAM_ID_SP_VI_EX_MODE_CFG;
+	param_data->param_size = ex_sz - APM_MODULE_PARAM_DATA_SIZE;
+
+	ex_cfg->cfg.factory_mode = 0;
+
+	rc = q6apm_send_cmd_sync(graph->apm, pkt, 0);
+
+	kfree(pkt);
+
+	return rc;
+}
+
 int audioreach_set_media_format(struct q6apm_graph *graph, struct audioreach_module *module,
 				struct audioreach_module_config *cfg)
 {
@@ -1247,6 +1388,9 @@ int audioreach_set_media_format(struct q
 	case MODULE_ID_DISPLAY_PORT_SINK:
 		rc = audioreach_display_port_set_media_format(graph, module, cfg);
 		break;
+	case  MODULE_ID_SMECNS_V2:
+		rc = audioreach_set_module_config(graph, module, cfg);
+		break;
 	case MODULE_ID_I2S_SOURCE:
 	case MODULE_ID_I2S_SINK:
 		rc = audioreach_i2s_set_media_format(graph, module, cfg);
@@ -1272,6 +1416,14 @@ int audioreach_set_media_format(struct q
 	case MODULE_ID_GAPLESS:
 		rc = audioreach_gapless_set_media_format(graph, module, cfg);
 		break;
+	case MODULE_ID_SPEAKER_PROTECTION:
+		rc = audioreach_speaker_protection(graph, module,
+						   PARAM_ID_SP_OP_MODE_NORMAL);
+		break;
+	case MODULE_ID_SPEAKER_PROTECTION_VI:
+		rc = audioreach_speaker_protection_vi(graph, module, cfg);
+		break;
+
 	default:
 		rc = 0;
 	}
diff -Nrup linux-6.16.6/sound/soc/qcom/qdsp6/audioreach.h linux-lenovo-x13s-linux-6.16.y/sound/soc/qcom/qdsp6/audioreach.h
--- linux-6.16.6/sound/soc/qcom/qdsp6/audioreach.h	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/qcom/qdsp6/audioreach.h	2025-09-11 09:47:42.000000000 -0600
@@ -4,6 +4,7 @@
 #define __AUDIOREACH_H__
 #include <linux/types.h>
 #include <linux/soc/qcom/apr.h>
+#include <uapi/sound/snd_ar_tokens.h>
 #include <sound/soc.h>
 struct q6apm;
 struct q6apm_graph;
@@ -17,18 +18,21 @@ struct q6apm_graph;
 #define MODULE_ID_PCM_DEC		0x07001005
 #define MODULE_ID_PLACEHOLDER_ENCODER	0x07001008
 #define MODULE_ID_PLACEHOLDER_DECODER	0x07001009
-#define MODULE_ID_SAL			0x07001010
-#define MODULE_ID_MFC			0x07001015
-#define MODULE_ID_CODEC_DMA_SINK	0x07001023
-#define MODULE_ID_CODEC_DMA_SOURCE	0x07001024
 #define MODULE_ID_I2S_SINK		0x0700100A
 #define MODULE_ID_I2S_SOURCE		0x0700100B
+#define MODULE_ID_SAL			0x07001010
+#define MODULE_ID_MFC			0x07001015
 #define MODULE_ID_DATA_LOGGING		0x0700101A
 #define MODULE_ID_AAC_DEC		0x0700101F
+#define MODULE_ID_CODEC_DMA_SINK	0x07001023
+#define MODULE_ID_CODEC_DMA_SOURCE	0x07001024
 #define MODULE_ID_FLAC_DEC		0x0700102F
+#define MODULE_ID_SMECNS_V2		0x07001031
 #define MODULE_ID_MP3_DECODE		0x0700103B
 #define MODULE_ID_GAPLESS		0x0700104D
 #define MODULE_ID_DISPLAY_PORT_SINK	0x07001069
+#define MODULE_ID_SPEAKER_PROTECTION	0x070010E2
+#define MODULE_ID_SPEAKER_PROTECTION_VI	0x070010E3
 
 #define APM_CMD_GET_SPF_STATE		0x01001021
 #define APM_CMD_RSP_GET_SPF_STATE	0x02001007
@@ -461,8 +465,8 @@ struct param_id_i2s_intf_cfg {
 } __packed;
 
 #define I2S_INTF_TYPE_PRIMARY		0
-#define I2S_INTF_TYPE_SECOINDARY	1
-#define I2S_INTF_TYPE_TERTINARY		2
+#define I2S_INTF_TYPE_SECONDARY		1
+#define I2S_INTF_TYPE_TERTIARY		2
 #define I2S_INTF_TYPE_QUATERNARY	3
 #define I2S_INTF_TYPE_QUINARY		4
 #define I2S_SD0				1
@@ -540,6 +544,43 @@ struct data_logging_config {
 	uint32_t mode;
 } __packed;
 
+/* Speaker Protection */
+#define PARAM_ID_SP_OP_MODE			0x080011e9
+#define PARAM_ID_SP_OP_MODE_NORMAL		0
+#define PARAM_ID_SP_OP_MODE_CALIBRATION		1
+#define PARAM_ID_SP_OP_MODE_FACTORY_TEST	2
+#define PARAM_ID_SP_OP_MODE_VALIDATION		3
+
+struct param_id_sp_op_mode {
+	uint32_t operation_mode;
+} __packed;
+
+/* Speaker Protection VI */
+
+#define PARAM_ID_SP_VI_OP_MODE_CFG		0x080011f4
+#define PARAM_ID_SP_VI_OP_MODE_NORMAL		0
+#define PARAM_ID_SP_VI_OP_MODE_CALIBRATION	1
+#define PARAM_ID_SP_VI_OP_MODE_FACTORY_TEST	2
+#define PARAM_ID_SP_VI_OP_MODE_VALIDATION	3
+struct param_id_sp_vi_op_mode_cfg {
+	uint32_t num_channels;
+	uint32_t operation_mode;
+	uint32_t quick_calibration;
+	uint32_t r0_t0_selection[];
+} __packed;
+
+#define PARAM_ID_SP_VI_EX_MODE_CFG		0x080011ff
+struct param_id_sp_vi_ex_mode_cfg {
+	uint32_t factory_mode;
+} __packed;
+
+#define PARAM_ID_SP_VI_CHANNEL_MAP_CFG		0x08001203
+struct param_id_sp_vi_channel_map_cfg {
+	uint32_t num_channels;
+	/* [ Vsense of ch 1, Isense of ch 1, Vsense of ch 2, Isense of ch 2, ... ] */
+	uint32_t channel_mapping[];
+} __packed;
+
 #define PARAM_ID_SAL_OUTPUT_CFG			0x08001016
 struct param_id_sal_output_config {
 	uint32_t bits_per_sample;
@@ -707,9 +748,6 @@ struct audioreach_module {
 	uint32_t max_ip_port;
 	uint32_t max_op_port;
 
-	uint32_t in_port;
-	uint32_t out_port;
-
 	uint32_t num_connections;
 	/* Connections */
 	uint32_t src_mod_inst_id;
@@ -745,6 +783,7 @@ struct audioreach_module {
 	struct list_head node;
 	struct audioreach_container *container;
 	struct snd_soc_dapm_widget *widget;
+	struct audioreach_module_priv_data *data;
 };
 
 struct audioreach_module_config {
diff -Nrup linux-6.16.6/sound/soc/qcom/qdsp6/q6apm-lpass-dais.c linux-lenovo-x13s-linux-6.16.y/sound/soc/qcom/qdsp6/q6apm-lpass-dais.c
--- linux-6.16.6/sound/soc/qcom/qdsp6/q6apm-lpass-dais.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/qcom/qdsp6/q6apm-lpass-dais.c	2025-09-11 09:47:42.000000000 -0600
@@ -213,8 +213,10 @@ static int q6apm_lpass_dai_prepare(struc
 
 	return 0;
 err:
-	q6apm_graph_close(dai_data->graph[dai->id]);
-	dai_data->graph[dai->id] = NULL;
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		q6apm_graph_close(dai_data->graph[dai->id]);
+		dai_data->graph[dai->id] = NULL;
+	}
 	return rc;
 }
 
diff -Nrup linux-6.16.6/sound/soc/qcom/qdsp6/topology.c linux-lenovo-x13s-linux-6.16.y/sound/soc/qcom/qdsp6/topology.c
--- linux-6.16.6/sound/soc/qcom/qdsp6/topology.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/qcom/qdsp6/topology.c	2025-09-11 09:47:42.000000000 -0600
@@ -305,6 +305,34 @@ static struct snd_soc_tplg_vendor_array
 	return NULL;
 }
 
+static struct audioreach_module_priv_data *audioreach_get_module_priv_data(
+		struct snd_soc_tplg_private *private)
+{
+	int sz;
+
+	for (sz = 0; sz < le32_to_cpu(private->size); ) {
+		struct snd_soc_tplg_vendor_array *mod_array;
+
+		mod_array = (struct snd_soc_tplg_vendor_array *)((u8 *)private->array + sz);
+		if (le32_to_cpu(mod_array->type) == SND_SOC_AR_TPLG_MODULE_CFG_TYPE) {
+			struct audioreach_module_priv_data *pdata;
+
+			pdata = kzalloc(struct_size(pdata, data, le32_to_cpu(mod_array->size)),
+				       GFP_KERNEL);
+			if (!pdata)
+				return ERR_PTR(-ENOMEM);
+
+			memcpy(pdata, ((u8 *)private->data + sz), struct_size(pdata, data,
+						le32_to_cpu(mod_array->size)));
+			return pdata;
+		}
+
+		sz = sz + le32_to_cpu(mod_array->size);
+	}
+
+	return NULL;
+}
+
 static struct audioreach_sub_graph *audioreach_parse_sg_tokens(struct q6apm *apm,
 						       struct snd_soc_tplg_private *private)
 {
@@ -412,7 +440,7 @@ static struct audioreach_module *audiore
 							struct snd_soc_tplg_private *private,
 							struct snd_soc_dapm_widget *w)
 {
-	uint32_t max_ip_port = 0, max_op_port = 0, in_port = 0, out_port = 0;
+	uint32_t max_ip_port = 0, max_op_port = 0;
 	uint32_t src_mod_op_port_id[AR_MAX_MOD_LINKS] = { 0, };
 	uint32_t dst_mod_inst_id[AR_MAX_MOD_LINKS] = { 0, };
 	uint32_t dst_mod_ip_port_id[AR_MAX_MOD_LINKS] = { 0, };
@@ -455,12 +483,6 @@ static struct audioreach_module *audiore
 		case AR_TKN_U32_MODULE_MAX_OP_PORTS:
 			max_op_port = le32_to_cpu(mod_elem->value);
 			break;
-		case AR_TKN_U32_MODULE_IN_PORTS:
-			in_port = le32_to_cpu(mod_elem->value);
-			break;
-		case AR_TKN_U32_MODULE_OUT_PORTS:
-			out_port = le32_to_cpu(mod_elem->value);
-			break;
 		case AR_TKN_U32_MODULE_SRC_INSTANCE_ID:
 			src_mod_inst_id = le32_to_cpu(mod_elem->value);
 			break;
@@ -550,8 +572,6 @@ static struct audioreach_module *audiore
 		mod->module_id = module_id;
 		mod->max_ip_port = max_ip_port;
 		mod->max_op_port = max_op_port;
-		mod->in_port = in_port;
-		mod->out_port = out_port;
 		mod->src_mod_inst_id = src_mod_inst_id;
 		for (pn = 0; pn < mod->max_op_port; pn++) {
 			if (src_mod_op_port_id[pn] && dst_mod_inst_id[pn] &&
@@ -587,8 +607,10 @@ static int audioreach_widget_load_module
 		return PTR_ERR(cont);
 
 	mod = audioreach_parse_common_tokens(apm, cont, &tplg_w->priv, w);
-	if (IS_ERR(mod))
-		return PTR_ERR(mod);
+	if (IS_ERR_OR_NULL(mod))
+		return mod ? PTR_ERR(mod) : -ENODEV;
+
+	mod->data = audioreach_get_module_priv_data(&tplg_w->priv);
 
 	dobj = &w->dobj;
 	dobj->private = mod;
@@ -947,6 +969,7 @@ static int audioreach_widget_unload(stru
 	cont->num_modules--;
 
 	list_del(&mod->node);
+	kfree(mod->data);
 	kfree(mod);
 	/* Graph Info has N sub-graphs, sub-graph has N containers, Container has N Modules */
 	if (list_empty(&cont->modules_list)) { /* if no modules in the container then remove it */
diff -Nrup linux-6.16.6/sound/soc/qcom/sc8280xp.c linux-lenovo-x13s-linux-6.16.y/sound/soc/qcom/sc8280xp.c
--- linux-6.16.6/sound/soc/qcom/sc8280xp.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/sound/soc/qcom/sc8280xp.c	2025-09-11 09:47:42.000000000 -0600
@@ -7,6 +7,7 @@
 #include <sound/soc.h>
 #include <sound/soc-dapm.h>
 #include <sound/pcm.h>
+#include <sound/pcm_params.h>
 #include <linux/soundwire/sdw.h>
 #include <sound/jack.h>
 #include <linux/input-event-codes.h>
@@ -82,8 +83,10 @@ static int sc8280xp_be_hw_params_fixup(s
 					SNDRV_PCM_HW_PARAM_RATE);
 	struct snd_interval *channels = hw_param_interval(params,
 					SNDRV_PCM_HW_PARAM_CHANNELS);
+	struct snd_mask *fmt = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);
 
 	rate->min = rate->max = 48000;
+	snd_mask_set_format(fmt, SNDRV_PCM_FORMAT_S16_LE);
 	channels->min = 2;
 	channels->max = 2;
 	switch (cpu_dai->id) {
diff -Nrup linux-6.16.6/tools/perf/arch/arm64/entry/syscalls/syscall_64.tbl linux-lenovo-x13s-linux-6.16.y/tools/perf/arch/arm64/entry/syscalls/syscall_64.tbl
--- linux-6.16.6/tools/perf/arch/arm64/entry/syscalls/syscall_64.tbl	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/arch/arm64/entry/syscalls/syscall_64.tbl	2025-09-11 09:47:42.000000000 -0600
@@ -1,410 +1 @@
-# SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note
-#
-# This file contains the system call numbers for all of the
-# more recently added architectures.
-#
-# As a basic principle, no duplication of functionality
-# should be added, e.g. we don't use lseek when llseek
-# is present. New architectures should use this file
-# and implement the less feature-full calls in user space.
-#
-0	common	io_setup			sys_io_setup			compat_sys_io_setup
-1	common	io_destroy			sys_io_destroy
-2	common	io_submit			sys_io_submit			compat_sys_io_submit
-3	common	io_cancel			sys_io_cancel
-4	time32	io_getevents			sys_io_getevents_time32
-4	64	io_getevents			sys_io_getevents
-5	common	setxattr			sys_setxattr
-6	common	lsetxattr			sys_lsetxattr
-7	common	fsetxattr			sys_fsetxattr
-8	common	getxattr			sys_getxattr
-9	common	lgetxattr			sys_lgetxattr
-10	common	fgetxattr			sys_fgetxattr
-11	common	listxattr			sys_listxattr
-12	common	llistxattr			sys_llistxattr
-13	common	flistxattr			sys_flistxattr
-14	common	removexattr			sys_removexattr
-15	common	lremovexattr			sys_lremovexattr
-16	common	fremovexattr			sys_fremovexattr
-17	common	getcwd				sys_getcwd
-18	common	lookup_dcookie			sys_ni_syscall
-19	common	eventfd2			sys_eventfd2
-20	common	epoll_create1			sys_epoll_create1
-21	common	epoll_ctl			sys_epoll_ctl
-22	common	epoll_pwait			sys_epoll_pwait			compat_sys_epoll_pwait
-23	common	dup				sys_dup
-24	common	dup3				sys_dup3
-25	32	fcntl64				sys_fcntl64			compat_sys_fcntl64
-25	64	fcntl				sys_fcntl
-26	common	inotify_init1			sys_inotify_init1
-27	common	inotify_add_watch		sys_inotify_add_watch
-28	common	inotify_rm_watch		sys_inotify_rm_watch
-29	common	ioctl				sys_ioctl			compat_sys_ioctl
-30	common	ioprio_set			sys_ioprio_set
-31	common	ioprio_get			sys_ioprio_get
-32	common	flock				sys_flock
-33	common	mknodat				sys_mknodat
-34	common	mkdirat				sys_mkdirat
-35	common	unlinkat			sys_unlinkat
-36	common	symlinkat			sys_symlinkat
-37	common	linkat				sys_linkat
-# renameat is superseded with flags by renameat2
-38	renameat renameat			sys_renameat
-39	common	umount2				sys_umount
-40	common	mount				sys_mount
-41	common	pivot_root			sys_pivot_root
-42	common	nfsservctl			sys_ni_syscall
-43	32	statfs64			sys_statfs64			compat_sys_statfs64
-43	64	statfs				sys_statfs
-44	32	fstatfs64			sys_fstatfs64			compat_sys_fstatfs64
-44	64	fstatfs				sys_fstatfs
-45	32	truncate64			sys_truncate64			compat_sys_truncate64
-45	64	truncate			sys_truncate
-46	32	ftruncate64			sys_ftruncate64			compat_sys_ftruncate64
-46	64	ftruncate			sys_ftruncate
-47	common	fallocate			sys_fallocate			compat_sys_fallocate
-48	common	faccessat			sys_faccessat
-49	common	chdir				sys_chdir
-50	common	fchdir				sys_fchdir
-51	common	chroot				sys_chroot
-52	common	fchmod				sys_fchmod
-53	common	fchmodat			sys_fchmodat
-54	common	fchownat			sys_fchownat
-55	common	fchown				sys_fchown
-56	common	openat				sys_openat
-57	common	close				sys_close
-58	common	vhangup				sys_vhangup
-59	common	pipe2				sys_pipe2
-60	common	quotactl			sys_quotactl
-61	common	getdents64			sys_getdents64
-62	32	llseek				sys_llseek
-62	64	lseek				sys_lseek
-63	common	read				sys_read
-64	common	write				sys_write
-65	common	readv				sys_readv			sys_readv
-66	common	writev				sys_writev			sys_writev
-67	common	pread64				sys_pread64			compat_sys_pread64
-68	common	pwrite64			sys_pwrite64			compat_sys_pwrite64
-69	common	preadv				sys_preadv			compat_sys_preadv
-70	common	pwritev				sys_pwritev			compat_sys_pwritev
-71	32	sendfile64			sys_sendfile64
-71	64	sendfile			sys_sendfile64
-72	time32	pselect6			sys_pselect6_time32		compat_sys_pselect6_time32
-72	64	pselect6			sys_pselect6
-73	time32	ppoll				sys_ppoll_time32		compat_sys_ppoll_time32
-73	64	ppoll				sys_ppoll
-74	common	signalfd4			sys_signalfd4			compat_sys_signalfd4
-75	common	vmsplice			sys_vmsplice
-76	common	splice				sys_splice
-77	common	tee				sys_tee
-78	common	readlinkat			sys_readlinkat
-79	stat64	fstatat64			sys_fstatat64
-79	64	newfstatat			sys_newfstatat
-80	stat64	fstat64				sys_fstat64
-80	64	fstat				sys_newfstat
-81	common	sync				sys_sync
-82	common	fsync				sys_fsync
-83	common	fdatasync			sys_fdatasync
-84	common	sync_file_range			sys_sync_file_range		compat_sys_sync_file_range
-85	common	timerfd_create			sys_timerfd_create
-86	time32	timerfd_settime			sys_timerfd_settime32
-86	64	timerfd_settime			sys_timerfd_settime
-87	time32	timerfd_gettime			sys_timerfd_gettime32
-87	64	timerfd_gettime			sys_timerfd_gettime
-88	time32	utimensat			sys_utimensat_time32
-88	64	utimensat			sys_utimensat
-89	common	acct				sys_acct
-90	common	capget				sys_capget
-91	common	capset				sys_capset
-92	common	personality			sys_personality
-93	common	exit				sys_exit
-94	common	exit_group			sys_exit_group
-95	common	waitid				sys_waitid			compat_sys_waitid
-96	common	set_tid_address			sys_set_tid_address
-97	common	unshare				sys_unshare
-98	time32	futex				sys_futex_time32
-98	64	futex				sys_futex
-99	common	set_robust_list			sys_set_robust_list		compat_sys_set_robust_list
-100	common	get_robust_list			sys_get_robust_list		compat_sys_get_robust_list
-101	time32	nanosleep			sys_nanosleep_time32
-101	64	nanosleep			sys_nanosleep
-102	common	getitimer			sys_getitimer			compat_sys_getitimer
-103	common	setitimer			sys_setitimer			compat_sys_setitimer
-104	common	kexec_load			sys_kexec_load			compat_sys_kexec_load
-105	common	init_module			sys_init_module
-106	common	delete_module			sys_delete_module
-107	common	timer_create			sys_timer_create		compat_sys_timer_create
-108	time32	timer_gettime			sys_timer_gettime32
-108	64	timer_gettime			sys_timer_gettime
-109	common	timer_getoverrun		sys_timer_getoverrun
-110	time32	timer_settime			sys_timer_settime32
-110	64	timer_settime			sys_timer_settime
-111	common	timer_delete			sys_timer_delete
-112	time32	clock_settime			sys_clock_settime32
-112	64	clock_settime			sys_clock_settime
-113	time32	clock_gettime			sys_clock_gettime32
-113	64	clock_gettime			sys_clock_gettime
-114	time32	clock_getres			sys_clock_getres_time32
-114	64	clock_getres			sys_clock_getres
-115	time32	clock_nanosleep			sys_clock_nanosleep_time32
-115	64	clock_nanosleep			sys_clock_nanosleep
-116	common	syslog				sys_syslog
-117	common	ptrace				sys_ptrace			compat_sys_ptrace
-118	common	sched_setparam			sys_sched_setparam
-119	common	sched_setscheduler		sys_sched_setscheduler
-120	common	sched_getscheduler		sys_sched_getscheduler
-121	common	sched_getparam			sys_sched_getparam
-122	common	sched_setaffinity		sys_sched_setaffinity		compat_sys_sched_setaffinity
-123	common	sched_getaffinity		sys_sched_getaffinity		compat_sys_sched_getaffinity
-124	common	sched_yield			sys_sched_yield
-125	common	sched_get_priority_max		sys_sched_get_priority_max
-126	common	sched_get_priority_min		sys_sched_get_priority_min
-127	time32	sched_rr_get_interval		sys_sched_rr_get_interval_time32
-127	64	sched_rr_get_interval		sys_sched_rr_get_interval
-128	common	restart_syscall			sys_restart_syscall
-129	common	kill				sys_kill
-130	common	tkill				sys_tkill
-131	common	tgkill				sys_tgkill
-132	common	sigaltstack			sys_sigaltstack			compat_sys_sigaltstack
-133	common	rt_sigsuspend			sys_rt_sigsuspend		compat_sys_rt_sigsuspend
-134	common	rt_sigaction			sys_rt_sigaction		compat_sys_rt_sigaction
-135	common	rt_sigprocmask			sys_rt_sigprocmask		compat_sys_rt_sigprocmask
-136	common	rt_sigpending			sys_rt_sigpending		compat_sys_rt_sigpending
-137	time32	rt_sigtimedwait			sys_rt_sigtimedwait_time32	compat_sys_rt_sigtimedwait_time32
-137	64	rt_sigtimedwait			sys_rt_sigtimedwait
-138	common	rt_sigqueueinfo			sys_rt_sigqueueinfo		compat_sys_rt_sigqueueinfo
-139	common	rt_sigreturn			sys_rt_sigreturn		compat_sys_rt_sigreturn
-140	common	setpriority			sys_setpriority
-141	common	getpriority			sys_getpriority
-142	common	reboot				sys_reboot
-143	common	setregid			sys_setregid
-144	common	setgid				sys_setgid
-145	common	setreuid			sys_setreuid
-146	common	setuid				sys_setuid
-147	common	setresuid			sys_setresuid
-148	common	getresuid			sys_getresuid
-149	common	setresgid			sys_setresgid
-150	common	getresgid			sys_getresgid
-151	common	setfsuid			sys_setfsuid
-152	common	setfsgid			sys_setfsgid
-153	common	times				sys_times			compat_sys_times
-154	common	setpgid				sys_setpgid
-155	common	getpgid				sys_getpgid
-156	common	getsid				sys_getsid
-157	common	setsid				sys_setsid
-158	common	getgroups			sys_getgroups
-159	common	setgroups			sys_setgroups
-160	common	uname				sys_newuname
-161	common	sethostname			sys_sethostname
-162	common	setdomainname			sys_setdomainname
-# getrlimit and setrlimit are superseded with prlimit64
-163	rlimit	getrlimit			sys_getrlimit			compat_sys_getrlimit
-164	rlimit	setrlimit			sys_setrlimit			compat_sys_setrlimit
-165	common	getrusage			sys_getrusage			compat_sys_getrusage
-166	common	umask				sys_umask
-167	common	prctl				sys_prctl
-168	common	getcpu				sys_getcpu
-169	time32	gettimeofday			sys_gettimeofday		compat_sys_gettimeofday
-169	64	gettimeofday			sys_gettimeofday
-170	time32	settimeofday			sys_settimeofday		compat_sys_settimeofday
-170	64	settimeofday			sys_settimeofday
-171	time32	adjtimex			sys_adjtimex_time32
-171	64	adjtimex			sys_adjtimex
-172	common	getpid				sys_getpid
-173	common	getppid				sys_getppid
-174	common	getuid				sys_getuid
-175	common	geteuid				sys_geteuid
-176	common	getgid				sys_getgid
-177	common	getegid				sys_getegid
-178	common	gettid				sys_gettid
-179	common	sysinfo				sys_sysinfo			compat_sys_sysinfo
-180	common	mq_open				sys_mq_open			compat_sys_mq_open
-181	common	mq_unlink			sys_mq_unlink
-182	time32	mq_timedsend			sys_mq_timedsend_time32
-182	64	mq_timedsend			sys_mq_timedsend
-183	time32	mq_timedreceive			sys_mq_timedreceive_time32
-183	64	mq_timedreceive			sys_mq_timedreceive
-184	common	mq_notify			sys_mq_notify			compat_sys_mq_notify
-185	common	mq_getsetattr			sys_mq_getsetattr		compat_sys_mq_getsetattr
-186	common	msgget				sys_msgget
-187	common	msgctl				sys_msgctl			compat_sys_msgctl
-188	common	msgrcv				sys_msgrcv			compat_sys_msgrcv
-189	common	msgsnd				sys_msgsnd			compat_sys_msgsnd
-190	common	semget				sys_semget
-191	common	semctl				sys_semctl			compat_sys_semctl
-192	time32	semtimedop			sys_semtimedop_time32
-192	64	semtimedop			sys_semtimedop
-193	common	semop				sys_semop
-194	common	shmget				sys_shmget
-195	common	shmctl				sys_shmctl			compat_sys_shmctl
-196	common	shmat				sys_shmat			compat_sys_shmat
-197	common	shmdt				sys_shmdt
-198	common	socket				sys_socket
-199	common	socketpair			sys_socketpair
-200	common	bind				sys_bind
-201	common	listen				sys_listen
-202	common	accept				sys_accept
-203	common	connect				sys_connect
-204	common	getsockname			sys_getsockname
-205	common	getpeername			sys_getpeername
-206	common	sendto				sys_sendto
-207	common	recvfrom			sys_recvfrom			compat_sys_recvfrom
-208	common	setsockopt			sys_setsockopt			sys_setsockopt
-209	common	getsockopt			sys_getsockopt			sys_getsockopt
-210	common	shutdown			sys_shutdown
-211	common	sendmsg				sys_sendmsg			compat_sys_sendmsg
-212	common	recvmsg				sys_recvmsg			compat_sys_recvmsg
-213	common	readahead			sys_readahead			compat_sys_readahead
-214	common	brk				sys_brk
-215	common	munmap				sys_munmap
-216	common	mremap				sys_mremap
-217	common	add_key				sys_add_key
-218	common	request_key			sys_request_key
-219	common	keyctl				sys_keyctl			compat_sys_keyctl
-220	common	clone				sys_clone
-221	common	execve				sys_execve			compat_sys_execve
-222	32	mmap2				sys_mmap2
-222	64	mmap				sys_mmap
-223	32	fadvise64_64			sys_fadvise64_64		compat_sys_fadvise64_64
-223	64	fadvise64			sys_fadvise64_64
-224	common	swapon				sys_swapon
-225	common	swapoff				sys_swapoff
-226	common	mprotect			sys_mprotect
-227	common	msync				sys_msync
-228	common	mlock				sys_mlock
-229	common	munlock				sys_munlock
-230	common	mlockall			sys_mlockall
-231	common	munlockall			sys_munlockall
-232	common	mincore				sys_mincore
-233	common	madvise				sys_madvise
-234	common	remap_file_pages		sys_remap_file_pages
-235	common	mbind				sys_mbind
-236	common	get_mempolicy			sys_get_mempolicy
-237	common	set_mempolicy			sys_set_mempolicy
-238	common	migrate_pages			sys_migrate_pages
-239	common	move_pages			sys_move_pages
-240	common	rt_tgsigqueueinfo		sys_rt_tgsigqueueinfo		compat_sys_rt_tgsigqueueinfo
-241	common	perf_event_open			sys_perf_event_open
-242	common	accept4				sys_accept4
-243	time32	recvmmsg			sys_recvmmsg_time32		compat_sys_recvmmsg_time32
-243	64	recvmmsg			sys_recvmmsg
-# Architectures may provide up to 16 syscalls of their own between 244 and 259
-244	arc	cacheflush			sys_cacheflush
-245	arc	arc_settls			sys_arc_settls
-246	arc	arc_gettls			sys_arc_gettls
-247	arc	sysfs				sys_sysfs
-248	arc	arc_usr_cmpxchg			sys_arc_usr_cmpxchg
-
-244	csky	set_thread_area			sys_set_thread_area
-245	csky	cacheflush			sys_cacheflush
-
-244	nios2	cacheflush			sys_cacheflush
-
-244	or1k	or1k_atomic			sys_or1k_atomic
-
-258	riscv	riscv_hwprobe			sys_riscv_hwprobe
-259	riscv	riscv_flush_icache		sys_riscv_flush_icache
-
-260	time32	wait4				sys_wait4			compat_sys_wait4
-260	64	wait4				sys_wait4
-261	common	prlimit64			sys_prlimit64
-262	common	fanotify_init			sys_fanotify_init
-263	common	fanotify_mark			sys_fanotify_mark
-264	common	name_to_handle_at		sys_name_to_handle_at
-265	common	open_by_handle_at		sys_open_by_handle_at
-266	time32	clock_adjtime			sys_clock_adjtime32
-266	64	clock_adjtime			sys_clock_adjtime
-267	common	syncfs				sys_syncfs
-268	common	setns				sys_setns
-269	common	sendmmsg			sys_sendmmsg			compat_sys_sendmmsg
-270	common	process_vm_readv		sys_process_vm_readv
-271	common	process_vm_writev		sys_process_vm_writev
-272	common	kcmp				sys_kcmp
-273	common	finit_module			sys_finit_module
-274	common	sched_setattr			sys_sched_setattr
-275	common	sched_getattr			sys_sched_getattr
-276	common	renameat2			sys_renameat2
-277	common	seccomp				sys_seccomp
-278	common	getrandom			sys_getrandom
-279	common	memfd_create			sys_memfd_create
-280	common	bpf				sys_bpf
-281	common	execveat			sys_execveat			compat_sys_execveat
-282	common	userfaultfd			sys_userfaultfd
-283	common	membarrier			sys_membarrier
-284	common	mlock2				sys_mlock2
-285	common	copy_file_range			sys_copy_file_range
-286	common	preadv2				sys_preadv2			compat_sys_preadv2
-287	common	pwritev2			sys_pwritev2			compat_sys_pwritev2
-288	common	pkey_mprotect			sys_pkey_mprotect
-289	common	pkey_alloc			sys_pkey_alloc
-290	common	pkey_free			sys_pkey_free
-291	common	statx				sys_statx
-292	time32	io_pgetevents			sys_io_pgetevents_time32	compat_sys_io_pgetevents
-292	64	io_pgetevents			sys_io_pgetevents
-293	common	rseq				sys_rseq
-294	common	kexec_file_load			sys_kexec_file_load
-# 295 through 402 are unassigned to sync up with generic numbers don't use
-403	32	clock_gettime64			sys_clock_gettime
-404	32	clock_settime64			sys_clock_settime
-405	32	clock_adjtime64			sys_clock_adjtime
-406	32	clock_getres_time64		sys_clock_getres
-407	32	clock_nanosleep_time64		sys_clock_nanosleep
-408	32	timer_gettime64			sys_timer_gettime
-409	32	timer_settime64			sys_timer_settime
-410	32	timerfd_gettime64		sys_timerfd_gettime
-411	32	timerfd_settime64		sys_timerfd_settime
-412	32	utimensat_time64		sys_utimensat
-413	32	pselect6_time64			sys_pselect6			compat_sys_pselect6_time64
-414	32	ppoll_time64			sys_ppoll			compat_sys_ppoll_time64
-416	32	io_pgetevents_time64		sys_io_pgetevents		compat_sys_io_pgetevents_time64
-417	32	recvmmsg_time64			sys_recvmmsg			compat_sys_recvmmsg_time64
-418	32	mq_timedsend_time64		sys_mq_timedsend
-419	32	mq_timedreceive_time64		sys_mq_timedreceive
-420	32	semtimedop_time64		sys_semtimedop
-421	32	rt_sigtimedwait_time64		sys_rt_sigtimedwait		compat_sys_rt_sigtimedwait_time64
-422	32	futex_time64			sys_futex
-423	32	sched_rr_get_interval_time64	sys_sched_rr_get_interval
-424	common	pidfd_send_signal		sys_pidfd_send_signal
-425	common	io_uring_setup			sys_io_uring_setup
-426	common	io_uring_enter			sys_io_uring_enter
-427	common	io_uring_register		sys_io_uring_register
-428	common	open_tree			sys_open_tree
-429	common	move_mount			sys_move_mount
-430	common	fsopen				sys_fsopen
-431	common	fsconfig			sys_fsconfig
-432	common	fsmount				sys_fsmount
-433	common	fspick				sys_fspick
-434	common	pidfd_open			sys_pidfd_open
-435	common	clone3				sys_clone3
-436	common	close_range			sys_close_range
-437	common	openat2				sys_openat2
-438	common	pidfd_getfd			sys_pidfd_getfd
-439	common	faccessat2			sys_faccessat2
-440	common	process_madvise			sys_process_madvise
-441	common	epoll_pwait2			sys_epoll_pwait2		compat_sys_epoll_pwait2
-442	common	mount_setattr			sys_mount_setattr
-443	common	quotactl_fd			sys_quotactl_fd
-444	common	landlock_create_ruleset		sys_landlock_create_ruleset
-445	common	landlock_add_rule		sys_landlock_add_rule
-446	common	landlock_restrict_self		sys_landlock_restrict_self
-447	memfd_secret	memfd_secret		sys_memfd_secret
-448	common	process_mrelease		sys_process_mrelease
-449	common	futex_waitv			sys_futex_waitv
-450	common	set_mempolicy_home_node		sys_set_mempolicy_home_node
-451	common	cachestat			sys_cachestat
-452	common	fchmodat2			sys_fchmodat2
-453	common	map_shadow_stack		sys_map_shadow_stack
-454	common	futex_wake			sys_futex_wake
-455	common	futex_wait			sys_futex_wait
-456	common	futex_requeue			sys_futex_requeue
-457	common	statmount			sys_statmount
-458	common	listmount			sys_listmount
-459	common	lsm_get_self_attr		sys_lsm_get_self_attr
-460	common	lsm_set_self_attr		sys_lsm_set_self_attr
-461	common	lsm_list_modules		sys_lsm_list_modules
-462	common	mseal				sys_mseal
-463	common	setxattrat			sys_setxattrat
-464	common	getxattrat			sys_getxattrat
-465	common	listxattrat			sys_listxattrat
-466	common	removexattrat			sys_removexattrat
-467	common	open_tree_attr			sys_open_tree_attr
+../../../../../scripts/syscall.tbl
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/perf/pmu-events/arch/riscv/sifive/bullet-07/firmware.json linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-07/firmware.json
--- linux-6.16.6/tools/perf/pmu-events/arch/riscv/sifive/bullet-07/firmware.json	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-07/firmware.json	2025-09-11 09:47:42.000000000 -0600
@@ -1,68 +1 @@
-[
-  {
-    "ArchStdEvent": "FW_MISALIGNED_LOAD"
-  },
-  {
-    "ArchStdEvent": "FW_MISALIGNED_STORE"
-  },
-  {
-    "ArchStdEvent": "FW_ACCESS_LOAD"
-  },
-  {
-    "ArchStdEvent": "FW_ACCESS_STORE"
-  },
-  {
-    "ArchStdEvent": "FW_ILLEGAL_INSN"
-  },
-  {
-    "ArchStdEvent": "FW_SET_TIMER"
-  },
-  {
-    "ArchStdEvent": "FW_IPI_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_IPI_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_FENCE_I_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_FENCE_I_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_ASID_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_ASID_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_VMID_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_VMID_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_ASID_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_ASID_RECEIVED"
-  }
-]
+../bullet/firmware.json
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/perf/pmu-events/arch/riscv/sifive/bullet-07/instruction.json linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-07/instruction.json
--- linux-6.16.6/tools/perf/pmu-events/arch/riscv/sifive/bullet-07/instruction.json	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-07/instruction.json	2025-09-11 09:47:42.000000000 -0600
@@ -1,92 +1 @@
-[
-  {
-    "EventName": "EXCEPTION_TAKEN",
-    "EventCode": "0x100",
-    "BriefDescription": "Counts exceptions taken"
-  },
-  {
-    "EventName": "INTEGER_LOAD_RETIRED",
-    "EventCode": "0x200",
-    "BriefDescription": "Counts integer load instructions retired"
-  },
-  {
-    "EventName": "INTEGER_STORE_RETIRED",
-    "EventCode": "0x400",
-    "BriefDescription": "Counts integer store instructions retired"
-  },
-  {
-    "EventName": "ATOMIC_MEMORY_RETIRED",
-    "EventCode": "0x800",
-    "BriefDescription": "Counts atomic memory instructions retired"
-  },
-  {
-    "EventName": "SYSTEM_INSTRUCTION_RETIRED",
-    "EventCode": "0x1000",
-    "BriefDescription": "Counts system instructions retired (CSR, WFI, MRET, etc.)"
-  },
-  {
-    "EventName": "INTEGER_ARITHMETIC_RETIRED",
-    "EventCode": "0x2000",
-    "BriefDescription": "Counts integer arithmetic instructions retired"
-  },
-  {
-    "EventName": "CONDITIONAL_BRANCH_RETIRED",
-    "EventCode": "0x4000",
-    "BriefDescription": "Counts conditional branch instructions retired"
-  },
-  {
-    "EventName": "JAL_INSTRUCTION_RETIRED",
-    "EventCode": "0x8000",
-    "BriefDescription": "Counts jump-and-link instructions retired"
-  },
-  {
-    "EventName": "JALR_INSTRUCTION_RETIRED",
-    "EventCode": "0x10000",
-    "BriefDescription": "Counts indirect jump instructions (JALR) retired"
-  },
-  {
-    "EventName": "INTEGER_MULTIPLICATION_RETIRED",
-    "EventCode": "0x20000",
-    "BriefDescription": "Counts integer multiplication instructions retired"
-  },
-  {
-    "EventName": "INTEGER_DIVISION_RETIRED",
-    "EventCode": "0x40000",
-    "BriefDescription": "Counts integer division instructions retired"
-  },
-  {
-    "EventName": "FP_LOAD_RETIRED",
-    "EventCode": "0x80000",
-    "BriefDescription": "Counts floating-point load instructions retired"
-  },
-  {
-    "EventName": "FP_STORE_RETIRED",
-    "EventCode": "0x100000",
-    "BriefDescription": "Counts floating-point store instructions retired"
-  },
-  {
-    "EventName": "FP_ADD_RETIRED",
-    "EventCode": "0x200000",
-    "BriefDescription": "Counts floating-point add instructions retired"
-  },
-  {
-    "EventName": "FP_MUL_RETIRED",
-    "EventCode": "0x400000",
-    "BriefDescription": "Counts floating-point multiply instructions retired"
-  },
-  {
-    "EventName": "FP_MULADD_RETIRED",
-    "EventCode": "0x800000",
-    "BriefDescription": "Counts floating-point fused multiply-add instructions retired"
-  },
-  {
-    "EventName": "FP_DIV_SQRT_RETIRED",
-    "EventCode": "0x1000000",
-    "BriefDescription": "Counts floating point divide or square root instructions retired"
-  },
-  {
-    "EventName": "OTHER_FP_RETIRED",
-    "EventCode": "0x2000000",
-    "BriefDescription": "Counts other floating-point instructions retired"
-  }
-]
+../bullet/instruction.json
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/perf/pmu-events/arch/riscv/sifive/bullet-07/memory.json linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-07/memory.json
--- linux-6.16.6/tools/perf/pmu-events/arch/riscv/sifive/bullet-07/memory.json	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-07/memory.json	2025-09-11 09:47:42.000000000 -0600
@@ -1,32 +1 @@
-[
-  {
-    "EventName": "ICACHE_MISS",
-    "EventCode": "0x102",
-    "BriefDescription": "Counts instruction cache misses"
-  },
-  {
-    "EventName": "DCACHE_MISS",
-    "EventCode": "0x202",
-    "BriefDescription": "Counts data cache misses"
-  },
-  {
-    "EventName": "DCACHE_RELEASE",
-    "EventCode": "0x402",
-    "BriefDescription": "Counts writeback requests from the data cache"
-  },
-  {
-    "EventName": "ITLB_MISS",
-    "EventCode": "0x802",
-    "BriefDescription": "Counts Instruction TLB misses caused by instruction address translation requests"
-  },
-  {
-    "EventName": "DTLB_MISS",
-    "EventCode": "0x1002",
-    "BriefDescription": "Counts Data TLB misses caused by data address translation requests"
-  },
-  {
-    "EventName": "UTLB_MISS",
-    "EventCode": "0x2002",
-    "BriefDescription": "Counts Unified TLB misses caused by address translation requests"
-  }
-]
+../bullet/memory.json
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/cycle-and-instruction-count.json linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/cycle-and-instruction-count.json
--- linux-6.16.6/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/cycle-and-instruction-count.json	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/cycle-and-instruction-count.json	2025-09-11 09:47:42.000000000 -0600
@@ -1,12 +1 @@
-[
-  {
-    "EventName": "CORE_CLOCK_CYCLES",
-    "EventCode": "0x165",
-    "BriefDescription": "Counts core clock cycles"
-  },
-  {
-    "EventName": "INSTRUCTIONS_RETIRED",
-    "EventCode": "0x265",
-    "BriefDescription": "Counts instructions retired"
-  }
-]
+../bullet-07/cycle-and-instruction-count.json
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/firmware.json linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/firmware.json
--- linux-6.16.6/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/firmware.json	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/firmware.json	2025-09-11 09:47:42.000000000 -0600
@@ -1,68 +1 @@
-[
-  {
-    "ArchStdEvent": "FW_MISALIGNED_LOAD"
-  },
-  {
-    "ArchStdEvent": "FW_MISALIGNED_STORE"
-  },
-  {
-    "ArchStdEvent": "FW_ACCESS_LOAD"
-  },
-  {
-    "ArchStdEvent": "FW_ACCESS_STORE"
-  },
-  {
-    "ArchStdEvent": "FW_ILLEGAL_INSN"
-  },
-  {
-    "ArchStdEvent": "FW_SET_TIMER"
-  },
-  {
-    "ArchStdEvent": "FW_IPI_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_IPI_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_FENCE_I_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_FENCE_I_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_ASID_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_ASID_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_VMID_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_VMID_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_ASID_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_ASID_RECEIVED"
-  }
-]
+../bullet/firmware.json
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/instruction.json linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/instruction.json
--- linux-6.16.6/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/instruction.json	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/instruction.json	2025-09-11 09:47:42.000000000 -0600
@@ -1,92 +1 @@
-[
-  {
-    "EventName": "EXCEPTION_TAKEN",
-    "EventCode": "0x100",
-    "BriefDescription": "Counts exceptions taken"
-  },
-  {
-    "EventName": "INTEGER_LOAD_RETIRED",
-    "EventCode": "0x200",
-    "BriefDescription": "Counts integer load instructions retired"
-  },
-  {
-    "EventName": "INTEGER_STORE_RETIRED",
-    "EventCode": "0x400",
-    "BriefDescription": "Counts integer store instructions retired"
-  },
-  {
-    "EventName": "ATOMIC_MEMORY_RETIRED",
-    "EventCode": "0x800",
-    "BriefDescription": "Counts atomic memory instructions retired"
-  },
-  {
-    "EventName": "SYSTEM_INSTRUCTION_RETIRED",
-    "EventCode": "0x1000",
-    "BriefDescription": "Counts system instructions retired (CSR, WFI, MRET, etc.)"
-  },
-  {
-    "EventName": "INTEGER_ARITHMETIC_RETIRED",
-    "EventCode": "0x2000",
-    "BriefDescription": "Counts integer arithmetic instructions retired"
-  },
-  {
-    "EventName": "CONDITIONAL_BRANCH_RETIRED",
-    "EventCode": "0x4000",
-    "BriefDescription": "Counts conditional branch instructions retired"
-  },
-  {
-    "EventName": "JAL_INSTRUCTION_RETIRED",
-    "EventCode": "0x8000",
-    "BriefDescription": "Counts jump-and-link instructions retired"
-  },
-  {
-    "EventName": "JALR_INSTRUCTION_RETIRED",
-    "EventCode": "0x10000",
-    "BriefDescription": "Counts indirect jump instructions (JALR) retired"
-  },
-  {
-    "EventName": "INTEGER_MULTIPLICATION_RETIRED",
-    "EventCode": "0x20000",
-    "BriefDescription": "Counts integer multiplication instructions retired"
-  },
-  {
-    "EventName": "INTEGER_DIVISION_RETIRED",
-    "EventCode": "0x40000",
-    "BriefDescription": "Counts integer division instructions retired"
-  },
-  {
-    "EventName": "FP_LOAD_RETIRED",
-    "EventCode": "0x80000",
-    "BriefDescription": "Counts floating-point load instructions retired"
-  },
-  {
-    "EventName": "FP_STORE_RETIRED",
-    "EventCode": "0x100000",
-    "BriefDescription": "Counts floating-point store instructions retired"
-  },
-  {
-    "EventName": "FP_ADD_RETIRED",
-    "EventCode": "0x200000",
-    "BriefDescription": "Counts floating-point add instructions retired"
-  },
-  {
-    "EventName": "FP_MUL_RETIRED",
-    "EventCode": "0x400000",
-    "BriefDescription": "Counts floating-point multiply instructions retired"
-  },
-  {
-    "EventName": "FP_MULADD_RETIRED",
-    "EventCode": "0x800000",
-    "BriefDescription": "Counts floating-point fused multiply-add instructions retired"
-  },
-  {
-    "EventName": "FP_DIV_SQRT_RETIRED",
-    "EventCode": "0x1000000",
-    "BriefDescription": "Counts floating point divide or square root instructions retired"
-  },
-  {
-    "EventName": "OTHER_FP_RETIRED",
-    "EventCode": "0x2000000",
-    "BriefDescription": "Counts other floating-point instructions retired"
-  }
-]
+../bullet/instruction.json
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/memory.json linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/memory.json
--- linux-6.16.6/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/memory.json	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/memory.json	2025-09-11 09:47:42.000000000 -0600
@@ -1,32 +1 @@
-[
-  {
-    "EventName": "ICACHE_MISS",
-    "EventCode": "0x102",
-    "BriefDescription": "Counts instruction cache misses"
-  },
-  {
-    "EventName": "DCACHE_MISS",
-    "EventCode": "0x202",
-    "BriefDescription": "Counts data cache misses"
-  },
-  {
-    "EventName": "DCACHE_RELEASE",
-    "EventCode": "0x402",
-    "BriefDescription": "Counts writeback requests from the data cache"
-  },
-  {
-    "EventName": "ITLB_MISS",
-    "EventCode": "0x802",
-    "BriefDescription": "Counts Instruction TLB misses caused by instruction address translation requests"
-  },
-  {
-    "EventName": "DTLB_MISS",
-    "EventCode": "0x1002",
-    "BriefDescription": "Counts Data TLB misses caused by data address translation requests"
-  },
-  {
-    "EventName": "UTLB_MISS",
-    "EventCode": "0x2002",
-    "BriefDescription": "Counts Unified TLB misses caused by address translation requests"
-  }
-]
+../bullet/memory.json
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/watchpoint.json linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/watchpoint.json
--- linux-6.16.6/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/watchpoint.json	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/bullet-0d/watchpoint.json	2025-09-11 09:47:42.000000000 -0600
@@ -1,42 +1 @@
-[
-  {
-    "EventName": "WATCHPOINT_0",
-    "EventCode": "0x164",
-    "BriefDescription": "Counts occurrences of watchpoint 0 with action=8"
-  },
-  {
-    "EventName": "WATCHPOINT_1",
-    "EventCode": "0x264",
-    "BriefDescription": "Counts occurrences of watchpoint 1 with action=8"
-  },
-  {
-    "EventName": "WATCHPOINT_2",
-    "EventCode": "0x464",
-    "BriefDescription": "Counts occurrences of watchpoint 2 with action=8"
-  },
-  {
-    "EventName": "WATCHPOINT_3",
-    "EventCode": "0x864",
-    "BriefDescription": "Counts occurrences of watchpoint 3 with action=8"
-  },
-  {
-    "EventName": "WATCHPOINT_4",
-    "EventCode": "0x1064",
-    "BriefDescription": "Counts occurrences of watchpoint 4 with action=8"
-  },
-  {
-    "EventName": "WATCHPOINT_5",
-    "EventCode": "0x2064",
-    "BriefDescription": "Counts occurrences of watchpoint 5 with action=8"
-  },
-  {
-    "EventName": "WATCHPOINT_6",
-    "EventCode": "0x4064",
-    "BriefDescription": "Counts occurrences of watchpoint 6 with action=8"
-  },
-  {
-    "EventName": "WATCHPOINT_7",
-    "EventCode": "0x8064",
-    "BriefDescription": "Counts occurrences of watchpoint 7 with action=8"
-  }
-]
+../bullet-07/watchpoint.json
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/perf/pmu-events/arch/riscv/sifive/p550/firmware.json linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/p550/firmware.json
--- linux-6.16.6/tools/perf/pmu-events/arch/riscv/sifive/p550/firmware.json	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/p550/firmware.json	2025-09-11 09:47:42.000000000 -0600
@@ -1,68 +1 @@
-[
-  {
-    "ArchStdEvent": "FW_MISALIGNED_LOAD"
-  },
-  {
-    "ArchStdEvent": "FW_MISALIGNED_STORE"
-  },
-  {
-    "ArchStdEvent": "FW_ACCESS_LOAD"
-  },
-  {
-    "ArchStdEvent": "FW_ACCESS_STORE"
-  },
-  {
-    "ArchStdEvent": "FW_ILLEGAL_INSN"
-  },
-  {
-    "ArchStdEvent": "FW_SET_TIMER"
-  },
-  {
-    "ArchStdEvent": "FW_IPI_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_IPI_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_FENCE_I_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_FENCE_I_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_ASID_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_ASID_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_VMID_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_VMID_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_ASID_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_ASID_RECEIVED"
-  }
-]
+../bullet/firmware.json
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/perf/pmu-events/arch/riscv/sifive/p550/instruction.json linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/p550/instruction.json
--- linux-6.16.6/tools/perf/pmu-events/arch/riscv/sifive/p550/instruction.json	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/p550/instruction.json	2025-09-11 09:47:42.000000000 -0600
@@ -1,92 +1 @@
-[
-  {
-    "EventName": "EXCEPTION_TAKEN",
-    "EventCode": "0x100",
-    "BriefDescription": "Counts exceptions taken"
-  },
-  {
-    "EventName": "INTEGER_LOAD_RETIRED",
-    "EventCode": "0x200",
-    "BriefDescription": "Counts integer load instructions retired"
-  },
-  {
-    "EventName": "INTEGER_STORE_RETIRED",
-    "EventCode": "0x400",
-    "BriefDescription": "Counts integer store instructions retired"
-  },
-  {
-    "EventName": "ATOMIC_MEMORY_RETIRED",
-    "EventCode": "0x800",
-    "BriefDescription": "Counts atomic memory instructions retired"
-  },
-  {
-    "EventName": "SYSTEM_INSTRUCTION_RETIRED",
-    "EventCode": "0x1000",
-    "BriefDescription": "Counts system instructions retired (CSR, WFI, MRET, etc.)"
-  },
-  {
-    "EventName": "INTEGER_ARITHMETIC_RETIRED",
-    "EventCode": "0x2000",
-    "BriefDescription": "Counts integer arithmetic instructions retired"
-  },
-  {
-    "EventName": "CONDITIONAL_BRANCH_RETIRED",
-    "EventCode": "0x4000",
-    "BriefDescription": "Counts conditional branch instructions retired"
-  },
-  {
-    "EventName": "JAL_INSTRUCTION_RETIRED",
-    "EventCode": "0x8000",
-    "BriefDescription": "Counts jump-and-link instructions retired"
-  },
-  {
-    "EventName": "JALR_INSTRUCTION_RETIRED",
-    "EventCode": "0x10000",
-    "BriefDescription": "Counts indirect jump instructions (JALR) retired"
-  },
-  {
-    "EventName": "INTEGER_MULTIPLICATION_RETIRED",
-    "EventCode": "0x20000",
-    "BriefDescription": "Counts integer multiplication instructions retired"
-  },
-  {
-    "EventName": "INTEGER_DIVISION_RETIRED",
-    "EventCode": "0x40000",
-    "BriefDescription": "Counts integer division instructions retired"
-  },
-  {
-    "EventName": "FP_LOAD_RETIRED",
-    "EventCode": "0x80000",
-    "BriefDescription": "Counts floating-point load instructions retired"
-  },
-  {
-    "EventName": "FP_STORE_RETIRED",
-    "EventCode": "0x100000",
-    "BriefDescription": "Counts floating-point store instructions retired"
-  },
-  {
-    "EventName": "FP_ADD_RETIRED",
-    "EventCode": "0x200000",
-    "BriefDescription": "Counts floating-point add instructions retired"
-  },
-  {
-    "EventName": "FP_MUL_RETIRED",
-    "EventCode": "0x400000",
-    "BriefDescription": "Counts floating-point multiply instructions retired"
-  },
-  {
-    "EventName": "FP_MULADD_RETIRED",
-    "EventCode": "0x800000",
-    "BriefDescription": "Counts floating-point fused multiply-add instructions retired"
-  },
-  {
-    "EventName": "FP_DIV_SQRT_RETIRED",
-    "EventCode": "0x1000000",
-    "BriefDescription": "Counts floating point divide or square root instructions retired"
-  },
-  {
-    "EventName": "OTHER_FP_RETIRED",
-    "EventCode": "0x2000000",
-    "BriefDescription": "Counts other floating-point instructions retired"
-  }
-]
+../bullet/instruction.json
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/perf/pmu-events/arch/riscv/sifive/p550/microarch.json linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/p550/microarch.json
--- linux-6.16.6/tools/perf/pmu-events/arch/riscv/sifive/p550/microarch.json	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/p550/microarch.json	2025-09-11 09:47:42.000000000 -0600
@@ -1,57 +1 @@
-[
-  {
-    "EventName": "ADDRESSGEN_INTERLOCK",
-    "EventCode": "0x101",
-    "BriefDescription": "Counts cycles with an address-generation interlock"
-  },
-  {
-    "EventName": "LONGLATENCY_INTERLOCK",
-    "EventCode": "0x201",
-    "BriefDescription": "Counts cycles with a long-latency interlock"
-  },
-  {
-    "EventName": "CSR_INTERLOCK",
-    "EventCode": "0x401",
-    "BriefDescription": "Counts cycles with a CSR interlock"
-  },
-  {
-    "EventName": "ICACHE_BLOCKED",
-    "EventCode": "0x801",
-    "BriefDescription": "Counts cycles in which the instruction cache was not able to provide an instruction"
-  },
-  {
-    "EventName": "DCACHE_BLOCKED",
-    "EventCode": "0x1001",
-    "BriefDescription": "Counts cycles in which the data cache blocked an instruction"
-  },
-  {
-    "EventName": "BRANCH_DIRECTION_MISPREDICTION",
-    "EventCode": "0x2001",
-    "BriefDescription": "Counts mispredictions of conditional branch direction (taken/not taken)"
-  },
-  {
-    "EventName": "BRANCH_TARGET_MISPREDICTION",
-    "EventCode": "0x4001",
-    "BriefDescription": "Counts mispredictions of the target PC of control-flow instructions"
-  },
-  {
-    "EventName": "PIPELINE_FLUSH",
-    "EventCode": "0x8001",
-    "BriefDescription": "Counts flushes of the core pipeline. Common causes include fence.i and CSR accesses"
-  },
-  {
-    "EventName": "REPLAY",
-    "EventCode": "0x10001",
-    "BriefDescription": "Counts instruction replays"
-  },
-  {
-    "EventName": "INTEGER_MUL_DIV_INTERLOCK",
-    "EventCode": "0x20001",
-    "BriefDescription": "Counts cycles with a multiply or divide interlock"
-  },
-  {
-    "EventName": "FP_INTERLOCK",
-    "EventCode": "0x40001",
-    "BriefDescription": "Counts cycles with a floating-point interlock"
-  }
-]
+../bullet/microarch.json
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/perf/pmu-events/arch/riscv/sifive/p650/cycle-and-instruction-count.json linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/p650/cycle-and-instruction-count.json
--- linux-6.16.6/tools/perf/pmu-events/arch/riscv/sifive/p650/cycle-and-instruction-count.json	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/p650/cycle-and-instruction-count.json	2025-09-11 09:47:42.000000000 -0600
@@ -1,12 +1 @@
-[
-  {
-    "EventName": "CORE_CLOCK_CYCLES",
-    "EventCode": "0x165",
-    "BriefDescription": "Counts core clock cycles"
-  },
-  {
-    "EventName": "INSTRUCTIONS_RETIRED",
-    "EventCode": "0x265",
-    "BriefDescription": "Counts instructions retired"
-  }
-]
+../bullet-07/cycle-and-instruction-count.json
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/perf/pmu-events/arch/riscv/sifive/p650/firmware.json linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/p650/firmware.json
--- linux-6.16.6/tools/perf/pmu-events/arch/riscv/sifive/p650/firmware.json	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/p650/firmware.json	2025-09-11 09:47:42.000000000 -0600
@@ -1,68 +1 @@
-[
-  {
-    "ArchStdEvent": "FW_MISALIGNED_LOAD"
-  },
-  {
-    "ArchStdEvent": "FW_MISALIGNED_STORE"
-  },
-  {
-    "ArchStdEvent": "FW_ACCESS_LOAD"
-  },
-  {
-    "ArchStdEvent": "FW_ACCESS_STORE"
-  },
-  {
-    "ArchStdEvent": "FW_ILLEGAL_INSN"
-  },
-  {
-    "ArchStdEvent": "FW_SET_TIMER"
-  },
-  {
-    "ArchStdEvent": "FW_IPI_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_IPI_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_FENCE_I_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_FENCE_I_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_ASID_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_SFENCE_VMA_ASID_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_VMID_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_GVMA_VMID_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_RECEIVED"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_ASID_SENT"
-  },
-  {
-    "ArchStdEvent": "FW_HFENCE_VVMA_ASID_RECEIVED"
-  }
-]
+../bullet/firmware.json
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/perf/pmu-events/arch/riscv/sifive/p650/instruction.json linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/p650/instruction.json
--- linux-6.16.6/tools/perf/pmu-events/arch/riscv/sifive/p650/instruction.json	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/p650/instruction.json	2025-09-11 09:47:42.000000000 -0600
@@ -1,92 +1 @@
-[
-  {
-    "EventName": "EXCEPTION_TAKEN",
-    "EventCode": "0x100",
-    "BriefDescription": "Counts exceptions taken"
-  },
-  {
-    "EventName": "INTEGER_LOAD_RETIRED",
-    "EventCode": "0x200",
-    "BriefDescription": "Counts integer load instructions retired"
-  },
-  {
-    "EventName": "INTEGER_STORE_RETIRED",
-    "EventCode": "0x400",
-    "BriefDescription": "Counts integer store instructions retired"
-  },
-  {
-    "EventName": "ATOMIC_MEMORY_RETIRED",
-    "EventCode": "0x800",
-    "BriefDescription": "Counts atomic memory instructions retired"
-  },
-  {
-    "EventName": "SYSTEM_INSTRUCTION_RETIRED",
-    "EventCode": "0x1000",
-    "BriefDescription": "Counts system instructions retired (CSR, WFI, MRET, etc.)"
-  },
-  {
-    "EventName": "INTEGER_ARITHMETIC_RETIRED",
-    "EventCode": "0x2000",
-    "BriefDescription": "Counts integer arithmetic instructions retired"
-  },
-  {
-    "EventName": "CONDITIONAL_BRANCH_RETIRED",
-    "EventCode": "0x4000",
-    "BriefDescription": "Counts conditional branch instructions retired"
-  },
-  {
-    "EventName": "JAL_INSTRUCTION_RETIRED",
-    "EventCode": "0x8000",
-    "BriefDescription": "Counts jump-and-link instructions retired"
-  },
-  {
-    "EventName": "JALR_INSTRUCTION_RETIRED",
-    "EventCode": "0x10000",
-    "BriefDescription": "Counts indirect jump instructions (JALR) retired"
-  },
-  {
-    "EventName": "INTEGER_MULTIPLICATION_RETIRED",
-    "EventCode": "0x20000",
-    "BriefDescription": "Counts integer multiplication instructions retired"
-  },
-  {
-    "EventName": "INTEGER_DIVISION_RETIRED",
-    "EventCode": "0x40000",
-    "BriefDescription": "Counts integer division instructions retired"
-  },
-  {
-    "EventName": "FP_LOAD_RETIRED",
-    "EventCode": "0x80000",
-    "BriefDescription": "Counts floating-point load instructions retired"
-  },
-  {
-    "EventName": "FP_STORE_RETIRED",
-    "EventCode": "0x100000",
-    "BriefDescription": "Counts floating-point store instructions retired"
-  },
-  {
-    "EventName": "FP_ADD_RETIRED",
-    "EventCode": "0x200000",
-    "BriefDescription": "Counts floating-point add instructions retired"
-  },
-  {
-    "EventName": "FP_MUL_RETIRED",
-    "EventCode": "0x400000",
-    "BriefDescription": "Counts floating-point multiply instructions retired"
-  },
-  {
-    "EventName": "FP_MULADD_RETIRED",
-    "EventCode": "0x800000",
-    "BriefDescription": "Counts floating-point fused multiply-add instructions retired"
-  },
-  {
-    "EventName": "FP_DIV_SQRT_RETIRED",
-    "EventCode": "0x1000000",
-    "BriefDescription": "Counts floating point divide or square root instructions retired"
-  },
-  {
-    "EventName": "OTHER_FP_RETIRED",
-    "EventCode": "0x2000000",
-    "BriefDescription": "Counts other floating-point instructions retired"
-  }
-]
+../bullet/instruction.json
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/perf/pmu-events/arch/riscv/sifive/p650/watchpoint.json linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/p650/watchpoint.json
--- linux-6.16.6/tools/perf/pmu-events/arch/riscv/sifive/p650/watchpoint.json	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/perf/pmu-events/arch/riscv/sifive/p650/watchpoint.json	2025-09-11 09:47:42.000000000 -0600
@@ -1,42 +1 @@
-[
-  {
-    "EventName": "WATCHPOINT_0",
-    "EventCode": "0x164",
-    "BriefDescription": "Counts occurrences of watchpoint 0 with action=8"
-  },
-  {
-    "EventName": "WATCHPOINT_1",
-    "EventCode": "0x264",
-    "BriefDescription": "Counts occurrences of watchpoint 1 with action=8"
-  },
-  {
-    "EventName": "WATCHPOINT_2",
-    "EventCode": "0x464",
-    "BriefDescription": "Counts occurrences of watchpoint 2 with action=8"
-  },
-  {
-    "EventName": "WATCHPOINT_3",
-    "EventCode": "0x864",
-    "BriefDescription": "Counts occurrences of watchpoint 3 with action=8"
-  },
-  {
-    "EventName": "WATCHPOINT_4",
-    "EventCode": "0x1064",
-    "BriefDescription": "Counts occurrences of watchpoint 4 with action=8"
-  },
-  {
-    "EventName": "WATCHPOINT_5",
-    "EventCode": "0x2064",
-    "BriefDescription": "Counts occurrences of watchpoint 5 with action=8"
-  },
-  {
-    "EventName": "WATCHPOINT_6",
-    "EventCode": "0x4064",
-    "BriefDescription": "Counts occurrences of watchpoint 6 with action=8"
-  },
-  {
-    "EventName": "WATCHPOINT_7",
-    "EventCode": "0x8064",
-    "BriefDescription": "Counts occurrences of watchpoint 7 with action=8"
-  }
-]
+../bullet-07/watchpoint.json
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/testing/selftests/bpf/disasm.c linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/bpf/disasm.c
--- linux-6.16.6/tools/testing/selftests/bpf/disasm.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/bpf/disasm.c	2025-09-11 09:47:42.000000000 -0600
@@ -1,390 +1 @@
-// SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
-/* Copyright (c) 2011-2014 PLUMgrid, http://plumgrid.com
- * Copyright (c) 2016 Facebook
- */
-
-#include <linux/bpf.h>
-
-#include "disasm.h"
-
-#define __BPF_FUNC_STR_FN(x) [BPF_FUNC_ ## x] = __stringify(bpf_ ## x)
-static const char * const func_id_str[] = {
-	__BPF_FUNC_MAPPER(__BPF_FUNC_STR_FN)
-};
-#undef __BPF_FUNC_STR_FN
-
-static const char *__func_get_name(const struct bpf_insn_cbs *cbs,
-				   const struct bpf_insn *insn,
-				   char *buff, size_t len)
-{
-	BUILD_BUG_ON(ARRAY_SIZE(func_id_str) != __BPF_FUNC_MAX_ID);
-
-	if (!insn->src_reg &&
-	    insn->imm >= 0 && insn->imm < __BPF_FUNC_MAX_ID &&
-	    func_id_str[insn->imm])
-		return func_id_str[insn->imm];
-
-	if (cbs && cbs->cb_call) {
-		const char *res;
-
-		res = cbs->cb_call(cbs->private_data, insn);
-		if (res)
-			return res;
-	}
-
-	if (insn->src_reg == BPF_PSEUDO_CALL)
-		snprintf(buff, len, "%+d", insn->imm);
-	else if (insn->src_reg == BPF_PSEUDO_KFUNC_CALL)
-		snprintf(buff, len, "kernel-function");
-
-	return buff;
-}
-
-static const char *__func_imm_name(const struct bpf_insn_cbs *cbs,
-				   const struct bpf_insn *insn,
-				   u64 full_imm, char *buff, size_t len)
-{
-	if (cbs && cbs->cb_imm)
-		return cbs->cb_imm(cbs->private_data, insn, full_imm);
-
-	snprintf(buff, len, "0x%llx", (unsigned long long)full_imm);
-	return buff;
-}
-
-const char *func_id_name(int id)
-{
-	if (id >= 0 && id < __BPF_FUNC_MAX_ID && func_id_str[id])
-		return func_id_str[id];
-	else
-		return "unknown";
-}
-
-const char *const bpf_class_string[8] = {
-	[BPF_LD]    = "ld",
-	[BPF_LDX]   = "ldx",
-	[BPF_ST]    = "st",
-	[BPF_STX]   = "stx",
-	[BPF_ALU]   = "alu",
-	[BPF_JMP]   = "jmp",
-	[BPF_JMP32] = "jmp32",
-	[BPF_ALU64] = "alu64",
-};
-
-const char *const bpf_alu_string[16] = {
-	[BPF_ADD >> 4]  = "+=",
-	[BPF_SUB >> 4]  = "-=",
-	[BPF_MUL >> 4]  = "*=",
-	[BPF_DIV >> 4]  = "/=",
-	[BPF_OR  >> 4]  = "|=",
-	[BPF_AND >> 4]  = "&=",
-	[BPF_LSH >> 4]  = "<<=",
-	[BPF_RSH >> 4]  = ">>=",
-	[BPF_NEG >> 4]  = "neg",
-	[BPF_MOD >> 4]  = "%=",
-	[BPF_XOR >> 4]  = "^=",
-	[BPF_MOV >> 4]  = "=",
-	[BPF_ARSH >> 4] = "s>>=",
-	[BPF_END >> 4]  = "endian",
-};
-
-static const char *const bpf_alu_sign_string[16] = {
-	[BPF_DIV >> 4]  = "s/=",
-	[BPF_MOD >> 4]  = "s%=",
-};
-
-static const char *const bpf_movsx_string[4] = {
-	[0] = "(s8)",
-	[1] = "(s16)",
-	[3] = "(s32)",
-};
-
-static const char *const bpf_atomic_alu_string[16] = {
-	[BPF_ADD >> 4]  = "add",
-	[BPF_AND >> 4]  = "and",
-	[BPF_OR >> 4]  = "or",
-	[BPF_XOR >> 4]  = "xor",
-};
-
-static const char *const bpf_ldst_string[] = {
-	[BPF_W >> 3]  = "u32",
-	[BPF_H >> 3]  = "u16",
-	[BPF_B >> 3]  = "u8",
-	[BPF_DW >> 3] = "u64",
-};
-
-static const char *const bpf_ldsx_string[] = {
-	[BPF_W >> 3]  = "s32",
-	[BPF_H >> 3]  = "s16",
-	[BPF_B >> 3]  = "s8",
-};
-
-static const char *const bpf_jmp_string[16] = {
-	[BPF_JA >> 4]   = "jmp",
-	[BPF_JEQ >> 4]  = "==",
-	[BPF_JGT >> 4]  = ">",
-	[BPF_JLT >> 4]  = "<",
-	[BPF_JGE >> 4]  = ">=",
-	[BPF_JLE >> 4]  = "<=",
-	[BPF_JSET >> 4] = "&",
-	[BPF_JNE >> 4]  = "!=",
-	[BPF_JSGT >> 4] = "s>",
-	[BPF_JSLT >> 4] = "s<",
-	[BPF_JSGE >> 4] = "s>=",
-	[BPF_JSLE >> 4] = "s<=",
-	[BPF_CALL >> 4] = "call",
-	[BPF_EXIT >> 4] = "exit",
-};
-
-static void print_bpf_end_insn(bpf_insn_print_t verbose,
-			       void *private_data,
-			       const struct bpf_insn *insn)
-{
-	verbose(private_data, "(%02x) r%d = %s%d r%d\n",
-		insn->code, insn->dst_reg,
-		BPF_SRC(insn->code) == BPF_TO_BE ? "be" : "le",
-		insn->imm, insn->dst_reg);
-}
-
-static void print_bpf_bswap_insn(bpf_insn_print_t verbose,
-			       void *private_data,
-			       const struct bpf_insn *insn)
-{
-	verbose(private_data, "(%02x) r%d = bswap%d r%d\n",
-		insn->code, insn->dst_reg,
-		insn->imm, insn->dst_reg);
-}
-
-static bool is_sdiv_smod(const struct bpf_insn *insn)
-{
-	return (BPF_OP(insn->code)  == BPF_DIV || BPF_OP(insn->code) == BPF_MOD) &&
-	       insn->off == 1;
-}
-
-static bool is_movsx(const struct bpf_insn *insn)
-{
-	return BPF_OP(insn->code) == BPF_MOV &&
-	       (insn->off == 8 || insn->off == 16 || insn->off == 32);
-}
-
-static bool is_addr_space_cast(const struct bpf_insn *insn)
-{
-	return insn->code == (BPF_ALU64 | BPF_MOV | BPF_X) &&
-		insn->off == BPF_ADDR_SPACE_CAST;
-}
-
-/* Special (internal-only) form of mov, used to resolve per-CPU addrs:
- * dst_reg = src_reg + <percpu_base_off>
- * BPF_ADDR_PERCPU is used as a special insn->off value.
- */
-#define BPF_ADDR_PERCPU	(-1)
-
-static inline bool is_mov_percpu_addr(const struct bpf_insn *insn)
-{
-	return insn->code == (BPF_ALU64 | BPF_MOV | BPF_X) && insn->off == BPF_ADDR_PERCPU;
-}
-
-void print_bpf_insn(const struct bpf_insn_cbs *cbs,
-		    const struct bpf_insn *insn,
-		    bool allow_ptr_leaks)
-{
-	const bpf_insn_print_t verbose = cbs->cb_print;
-	u8 class = BPF_CLASS(insn->code);
-
-	if (class == BPF_ALU || class == BPF_ALU64) {
-		if (BPF_OP(insn->code) == BPF_END) {
-			if (class == BPF_ALU64)
-				print_bpf_bswap_insn(verbose, cbs->private_data, insn);
-			else
-				print_bpf_end_insn(verbose, cbs->private_data, insn);
-		} else if (BPF_OP(insn->code) == BPF_NEG) {
-			verbose(cbs->private_data, "(%02x) %c%d = -%c%d\n",
-				insn->code, class == BPF_ALU ? 'w' : 'r',
-				insn->dst_reg, class == BPF_ALU ? 'w' : 'r',
-				insn->dst_reg);
-		} else if (is_addr_space_cast(insn)) {
-			verbose(cbs->private_data, "(%02x) r%d = addr_space_cast(r%d, %u, %u)\n",
-				insn->code, insn->dst_reg,
-				insn->src_reg, ((u32)insn->imm) >> 16, (u16)insn->imm);
-		} else if (is_mov_percpu_addr(insn)) {
-			verbose(cbs->private_data, "(%02x) r%d = &(void __percpu *)(r%d)\n",
-				insn->code, insn->dst_reg, insn->src_reg);
-		} else if (BPF_SRC(insn->code) == BPF_X) {
-			verbose(cbs->private_data, "(%02x) %c%d %s %s%c%d\n",
-				insn->code, class == BPF_ALU ? 'w' : 'r',
-				insn->dst_reg,
-				is_sdiv_smod(insn) ? bpf_alu_sign_string[BPF_OP(insn->code) >> 4]
-						   : bpf_alu_string[BPF_OP(insn->code) >> 4],
-				is_movsx(insn) ? bpf_movsx_string[(insn->off >> 3) - 1] : "",
-				class == BPF_ALU ? 'w' : 'r',
-				insn->src_reg);
-		} else {
-			verbose(cbs->private_data, "(%02x) %c%d %s %d\n",
-				insn->code, class == BPF_ALU ? 'w' : 'r',
-				insn->dst_reg,
-				is_sdiv_smod(insn) ? bpf_alu_sign_string[BPF_OP(insn->code) >> 4]
-						   : bpf_alu_string[BPF_OP(insn->code) >> 4],
-				insn->imm);
-		}
-	} else if (class == BPF_STX) {
-		if (BPF_MODE(insn->code) == BPF_MEM)
-			verbose(cbs->private_data, "(%02x) *(%s *)(r%d %+d) = r%d\n",
-				insn->code,
-				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
-				insn->dst_reg,
-				insn->off, insn->src_reg);
-		else if (BPF_MODE(insn->code) == BPF_ATOMIC &&
-			 (insn->imm == BPF_ADD || insn->imm == BPF_AND ||
-			  insn->imm == BPF_OR || insn->imm == BPF_XOR)) {
-			verbose(cbs->private_data, "(%02x) lock *(%s *)(r%d %+d) %s r%d\n",
-				insn->code,
-				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
-				insn->dst_reg, insn->off,
-				bpf_alu_string[BPF_OP(insn->imm) >> 4],
-				insn->src_reg);
-		} else if (BPF_MODE(insn->code) == BPF_ATOMIC &&
-			   (insn->imm == (BPF_ADD | BPF_FETCH) ||
-			    insn->imm == (BPF_AND | BPF_FETCH) ||
-			    insn->imm == (BPF_OR | BPF_FETCH) ||
-			    insn->imm == (BPF_XOR | BPF_FETCH))) {
-			verbose(cbs->private_data, "(%02x) r%d = atomic%s_fetch_%s((%s *)(r%d %+d), r%d)\n",
-				insn->code, insn->src_reg,
-				BPF_SIZE(insn->code) == BPF_DW ? "64" : "",
-				bpf_atomic_alu_string[BPF_OP(insn->imm) >> 4],
-				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
-				insn->dst_reg, insn->off, insn->src_reg);
-		} else if (BPF_MODE(insn->code) == BPF_ATOMIC &&
-			   insn->imm == BPF_CMPXCHG) {
-			verbose(cbs->private_data, "(%02x) r0 = atomic%s_cmpxchg((%s *)(r%d %+d), r0, r%d)\n",
-				insn->code,
-				BPF_SIZE(insn->code) == BPF_DW ? "64" : "",
-				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
-				insn->dst_reg, insn->off,
-				insn->src_reg);
-		} else if (BPF_MODE(insn->code) == BPF_ATOMIC &&
-			   insn->imm == BPF_XCHG) {
-			verbose(cbs->private_data, "(%02x) r%d = atomic%s_xchg((%s *)(r%d %+d), r%d)\n",
-				insn->code, insn->src_reg,
-				BPF_SIZE(insn->code) == BPF_DW ? "64" : "",
-				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
-				insn->dst_reg, insn->off, insn->src_reg);
-		} else if (BPF_MODE(insn->code) == BPF_ATOMIC &&
-			   insn->imm == BPF_LOAD_ACQ) {
-			verbose(cbs->private_data, "(%02x) r%d = load_acquire((%s *)(r%d %+d))\n",
-				insn->code, insn->dst_reg,
-				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
-				insn->src_reg, insn->off);
-		} else if (BPF_MODE(insn->code) == BPF_ATOMIC &&
-			   insn->imm == BPF_STORE_REL) {
-			verbose(cbs->private_data, "(%02x) store_release((%s *)(r%d %+d), r%d)\n",
-				insn->code,
-				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
-				insn->dst_reg, insn->off, insn->src_reg);
-		} else {
-			verbose(cbs->private_data, "BUG_%02x\n", insn->code);
-		}
-	} else if (class == BPF_ST) {
-		if (BPF_MODE(insn->code) == BPF_MEM) {
-			verbose(cbs->private_data, "(%02x) *(%s *)(r%d %+d) = %d\n",
-				insn->code,
-				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
-				insn->dst_reg,
-				insn->off, insn->imm);
-		} else if (BPF_MODE(insn->code) == 0xc0 /* BPF_NOSPEC, no UAPI */) {
-			verbose(cbs->private_data, "(%02x) nospec\n", insn->code);
-		} else {
-			verbose(cbs->private_data, "BUG_st_%02x\n", insn->code);
-		}
-	} else if (class == BPF_LDX) {
-		if (BPF_MODE(insn->code) != BPF_MEM && BPF_MODE(insn->code) != BPF_MEMSX) {
-			verbose(cbs->private_data, "BUG_ldx_%02x\n", insn->code);
-			return;
-		}
-		verbose(cbs->private_data, "(%02x) r%d = *(%s *)(r%d %+d)\n",
-			insn->code, insn->dst_reg,
-			BPF_MODE(insn->code) == BPF_MEM ?
-				 bpf_ldst_string[BPF_SIZE(insn->code) >> 3] :
-				 bpf_ldsx_string[BPF_SIZE(insn->code) >> 3],
-			insn->src_reg, insn->off);
-	} else if (class == BPF_LD) {
-		if (BPF_MODE(insn->code) == BPF_ABS) {
-			verbose(cbs->private_data, "(%02x) r0 = *(%s *)skb[%d]\n",
-				insn->code,
-				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
-				insn->imm);
-		} else if (BPF_MODE(insn->code) == BPF_IND) {
-			verbose(cbs->private_data, "(%02x) r0 = *(%s *)skb[r%d + %d]\n",
-				insn->code,
-				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
-				insn->src_reg, insn->imm);
-		} else if (BPF_MODE(insn->code) == BPF_IMM &&
-			   BPF_SIZE(insn->code) == BPF_DW) {
-			/* At this point, we already made sure that the second
-			 * part of the ldimm64 insn is accessible.
-			 */
-			u64 imm = ((u64)(insn + 1)->imm << 32) | (u32)insn->imm;
-			bool is_ptr = insn->src_reg == BPF_PSEUDO_MAP_FD ||
-				      insn->src_reg == BPF_PSEUDO_MAP_VALUE;
-			char tmp[64];
-
-			if (is_ptr && !allow_ptr_leaks)
-				imm = 0;
-
-			verbose(cbs->private_data, "(%02x) r%d = %s\n",
-				insn->code, insn->dst_reg,
-				__func_imm_name(cbs, insn, imm,
-						tmp, sizeof(tmp)));
-		} else {
-			verbose(cbs->private_data, "BUG_ld_%02x\n", insn->code);
-			return;
-		}
-	} else if (class == BPF_JMP32 || class == BPF_JMP) {
-		u8 opcode = BPF_OP(insn->code);
-
-		if (opcode == BPF_CALL) {
-			char tmp[64];
-
-			if (insn->src_reg == BPF_PSEUDO_CALL) {
-				verbose(cbs->private_data, "(%02x) call pc%s\n",
-					insn->code,
-					__func_get_name(cbs, insn,
-							tmp, sizeof(tmp)));
-			} else {
-				strcpy(tmp, "unknown");
-				verbose(cbs->private_data, "(%02x) call %s#%d\n", insn->code,
-					__func_get_name(cbs, insn,
-							tmp, sizeof(tmp)),
-					insn->imm);
-			}
-		} else if (insn->code == (BPF_JMP | BPF_JA)) {
-			verbose(cbs->private_data, "(%02x) goto pc%+d\n",
-				insn->code, insn->off);
-		} else if (insn->code == (BPF_JMP | BPF_JCOND) &&
-			   insn->src_reg == BPF_MAY_GOTO) {
-			verbose(cbs->private_data, "(%02x) may_goto pc%+d\n",
-				insn->code, insn->off);
-		} else if (insn->code == (BPF_JMP32 | BPF_JA)) {
-			verbose(cbs->private_data, "(%02x) gotol pc%+d\n",
-				insn->code, insn->imm);
-		} else if (insn->code == (BPF_JMP | BPF_EXIT)) {
-			verbose(cbs->private_data, "(%02x) exit\n", insn->code);
-		} else if (BPF_SRC(insn->code) == BPF_X) {
-			verbose(cbs->private_data,
-				"(%02x) if %c%d %s %c%d goto pc%+d\n",
-				insn->code, class == BPF_JMP32 ? 'w' : 'r',
-				insn->dst_reg,
-				bpf_jmp_string[BPF_OP(insn->code) >> 4],
-				class == BPF_JMP32 ? 'w' : 'r',
-				insn->src_reg, insn->off);
-		} else {
-			verbose(cbs->private_data,
-				"(%02x) if %c%d %s 0x%x goto pc%+d\n",
-				insn->code, class == BPF_JMP32 ? 'w' : 'r',
-				insn->dst_reg,
-				bpf_jmp_string[BPF_OP(insn->code) >> 4],
-				(u32)insn->imm, insn->off);
-		}
-	} else {
-		verbose(cbs->private_data, "(%02x) %s\n",
-			insn->code, bpf_class_string[class]);
-	}
-}
+../../../../kernel/bpf/disasm.c
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/testing/selftests/bpf/disasm.h linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/bpf/disasm.h
--- linux-6.16.6/tools/testing/selftests/bpf/disasm.h	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/bpf/disasm.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,40 +1 @@
-/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */
-/* Copyright (c) 2011-2014 PLUMgrid, http://plumgrid.com
- * Copyright (c) 2016 Facebook
- */
-
-#ifndef __BPF_DISASM_H__
-#define __BPF_DISASM_H__
-
-#include <linux/bpf.h>
-#include <linux/kernel.h>
-#include <linux/stringify.h>
-#ifndef __KERNEL__
-#include <stdio.h>
-#include <string.h>
-#endif
-
-extern const char *const bpf_alu_string[16];
-extern const char *const bpf_class_string[8];
-
-const char *func_id_name(int id);
-
-typedef __printf(2, 3) void (*bpf_insn_print_t)(void *private_data,
-						const char *, ...);
-typedef const char *(*bpf_insn_revmap_call_t)(void *private_data,
-					      const struct bpf_insn *insn);
-typedef const char *(*bpf_insn_print_imm_t)(void *private_data,
-					    const struct bpf_insn *insn,
-					    __u64 full_imm);
-
-struct bpf_insn_cbs {
-	bpf_insn_print_t	cb_print;
-	bpf_insn_revmap_call_t	cb_call;
-	bpf_insn_print_imm_t	cb_imm;
-	void			*private_data;
-};
-
-void print_bpf_insn(const struct bpf_insn_cbs *cbs,
-		    const struct bpf_insn *insn,
-		    bool allow_ptr_leaks);
-#endif
+../../../../kernel/bpf/disasm.h
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/testing/selftests/bpf/json_writer.c linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/bpf/json_writer.c
--- linux-6.16.6/tools/testing/selftests/bpf/json_writer.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/bpf/json_writer.c	2025-09-11 09:47:42.000000000 -0600
@@ -1,355 +1 @@
-// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-2-Clause)
-/*
- * Simple streaming JSON writer
- *
- * This takes care of the annoying bits of JSON syntax like the commas
- * after elements
- *
- * Authors:	Stephen Hemminger <stephen@networkplumber.org>
- */
-
-#include <stdio.h>
-#include <stdbool.h>
-#include <stdarg.h>
-#include <assert.h>
-#include <malloc.h>
-#include <inttypes.h>
-#include <stdint.h>
-
-#include "json_writer.h"
-
-struct json_writer {
-	FILE		*out;	/* output file */
-	unsigned	depth;  /* nesting */
-	bool		pretty; /* optional whitepace */
-	char		sep;	/* either nul or comma */
-};
-
-/* indentation for pretty print */
-static void jsonw_indent(json_writer_t *self)
-{
-	unsigned i;
-	for (i = 0; i < self->depth; ++i)
-		fputs("    ", self->out);
-}
-
-/* end current line and indent if pretty printing */
-static void jsonw_eol(json_writer_t *self)
-{
-	if (!self->pretty)
-		return;
-
-	putc('\n', self->out);
-	jsonw_indent(self);
-}
-
-/* If current object is not empty print a comma */
-static void jsonw_eor(json_writer_t *self)
-{
-	if (self->sep != '\0')
-		putc(self->sep, self->out);
-	self->sep = ',';
-}
-
-
-/* Output JSON encoded string */
-/* Handles C escapes, does not do Unicode */
-static void jsonw_puts(json_writer_t *self, const char *str)
-{
-	putc('"', self->out);
-	for (; *str; ++str)
-		switch (*str) {
-		case '\t':
-			fputs("\\t", self->out);
-			break;
-		case '\n':
-			fputs("\\n", self->out);
-			break;
-		case '\r':
-			fputs("\\r", self->out);
-			break;
-		case '\f':
-			fputs("\\f", self->out);
-			break;
-		case '\b':
-			fputs("\\b", self->out);
-			break;
-		case '\\':
-			fputs("\\\\", self->out);
-			break;
-		case '"':
-			fputs("\\\"", self->out);
-			break;
-		default:
-			putc(*str, self->out);
-		}
-	putc('"', self->out);
-}
-
-/* Create a new JSON stream */
-json_writer_t *jsonw_new(FILE *f)
-{
-	json_writer_t *self = malloc(sizeof(*self));
-	if (self) {
-		self->out = f;
-		self->depth = 0;
-		self->pretty = false;
-		self->sep = '\0';
-	}
-	return self;
-}
-
-/* End output to JSON stream */
-void jsonw_destroy(json_writer_t **self_p)
-{
-	json_writer_t *self = *self_p;
-
-	assert(self->depth == 0);
-	fputs("\n", self->out);
-	fflush(self->out);
-	free(self);
-	*self_p = NULL;
-}
-
-void jsonw_pretty(json_writer_t *self, bool on)
-{
-	self->pretty = on;
-}
-
-void jsonw_reset(json_writer_t *self)
-{
-	assert(self->depth == 0);
-	self->sep = '\0';
-}
-
-/* Basic blocks */
-static void jsonw_begin(json_writer_t *self, int c)
-{
-	jsonw_eor(self);
-	putc(c, self->out);
-	++self->depth;
-	self->sep = '\0';
-}
-
-static void jsonw_end(json_writer_t *self, int c)
-{
-	assert(self->depth > 0);
-
-	--self->depth;
-	if (self->sep != '\0')
-		jsonw_eol(self);
-	putc(c, self->out);
-	self->sep = ',';
-}
-
-
-/* Add a JSON property name */
-void jsonw_name(json_writer_t *self, const char *name)
-{
-	jsonw_eor(self);
-	jsonw_eol(self);
-	self->sep = '\0';
-	jsonw_puts(self, name);
-	putc(':', self->out);
-	if (self->pretty)
-		putc(' ', self->out);
-}
-
-void jsonw_vprintf_enquote(json_writer_t *self, const char *fmt, va_list ap)
-{
-	jsonw_eor(self);
-	putc('"', self->out);
-	vfprintf(self->out, fmt, ap);
-	putc('"', self->out);
-}
-
-void jsonw_printf(json_writer_t *self, const char *fmt, ...)
-{
-	va_list ap;
-
-	va_start(ap, fmt);
-	jsonw_eor(self);
-	vfprintf(self->out, fmt, ap);
-	va_end(ap);
-}
-
-/* Collections */
-void jsonw_start_object(json_writer_t *self)
-{
-	jsonw_begin(self, '{');
-}
-
-void jsonw_end_object(json_writer_t *self)
-{
-	jsonw_end(self, '}');
-}
-
-void jsonw_start_array(json_writer_t *self)
-{
-	jsonw_begin(self, '[');
-}
-
-void jsonw_end_array(json_writer_t *self)
-{
-	jsonw_end(self, ']');
-}
-
-/* JSON value types */
-void jsonw_string(json_writer_t *self, const char *value)
-{
-	jsonw_eor(self);
-	jsonw_puts(self, value);
-}
-
-void jsonw_bool(json_writer_t *self, bool val)
-{
-	jsonw_printf(self, "%s", val ? "true" : "false");
-}
-
-void jsonw_null(json_writer_t *self)
-{
-	jsonw_printf(self, "null");
-}
-
-void jsonw_float_fmt(json_writer_t *self, const char *fmt, double num)
-{
-	jsonw_printf(self, fmt, num);
-}
-
-#ifdef notused
-void jsonw_float(json_writer_t *self, double num)
-{
-	jsonw_printf(self, "%g", num);
-}
-#endif
-
-void jsonw_hu(json_writer_t *self, unsigned short num)
-{
-	jsonw_printf(self, "%hu", num);
-}
-
-void jsonw_uint(json_writer_t *self, uint64_t num)
-{
-	jsonw_printf(self, "%"PRIu64, num);
-}
-
-void jsonw_lluint(json_writer_t *self, unsigned long long int num)
-{
-	jsonw_printf(self, "%llu", num);
-}
-
-void jsonw_int(json_writer_t *self, int64_t num)
-{
-	jsonw_printf(self, "%"PRId64, num);
-}
-
-/* Basic name/value objects */
-void jsonw_string_field(json_writer_t *self, const char *prop, const char *val)
-{
-	jsonw_name(self, prop);
-	jsonw_string(self, val);
-}
-
-void jsonw_bool_field(json_writer_t *self, const char *prop, bool val)
-{
-	jsonw_name(self, prop);
-	jsonw_bool(self, val);
-}
-
-#ifdef notused
-void jsonw_float_field(json_writer_t *self, const char *prop, double val)
-{
-	jsonw_name(self, prop);
-	jsonw_float(self, val);
-}
-#endif
-
-void jsonw_float_field_fmt(json_writer_t *self,
-			   const char *prop,
-			   const char *fmt,
-			   double val)
-{
-	jsonw_name(self, prop);
-	jsonw_float_fmt(self, fmt, val);
-}
-
-void jsonw_uint_field(json_writer_t *self, const char *prop, uint64_t num)
-{
-	jsonw_name(self, prop);
-	jsonw_uint(self, num);
-}
-
-void jsonw_hu_field(json_writer_t *self, const char *prop, unsigned short num)
-{
-	jsonw_name(self, prop);
-	jsonw_hu(self, num);
-}
-
-void jsonw_lluint_field(json_writer_t *self,
-			const char *prop,
-			unsigned long long int num)
-{
-	jsonw_name(self, prop);
-	jsonw_lluint(self, num);
-}
-
-void jsonw_int_field(json_writer_t *self, const char *prop, int64_t num)
-{
-	jsonw_name(self, prop);
-	jsonw_int(self, num);
-}
-
-void jsonw_null_field(json_writer_t *self, const char *prop)
-{
-	jsonw_name(self, prop);
-	jsonw_null(self);
-}
-
-#ifdef TEST
-int main(int argc, char **argv)
-{
-	json_writer_t *wr = jsonw_new(stdout);
-
-	jsonw_start_object(wr);
-	jsonw_pretty(wr, true);
-	jsonw_name(wr, "Vyatta");
-	jsonw_start_object(wr);
-	jsonw_string_field(wr, "url", "http://vyatta.com");
-	jsonw_uint_field(wr, "downloads", 2000000ul);
-	jsonw_float_field(wr, "stock", 8.16);
-
-	jsonw_name(wr, "ARGV");
-	jsonw_start_array(wr);
-	while (--argc)
-		jsonw_string(wr, *++argv);
-	jsonw_end_array(wr);
-
-	jsonw_name(wr, "empty");
-	jsonw_start_array(wr);
-	jsonw_end_array(wr);
-
-	jsonw_name(wr, "NIL");
-	jsonw_start_object(wr);
-	jsonw_end_object(wr);
-
-	jsonw_null_field(wr, "my_null");
-
-	jsonw_name(wr, "special chars");
-	jsonw_start_array(wr);
-	jsonw_string_field(wr, "slash", "/");
-	jsonw_string_field(wr, "newline", "\n");
-	jsonw_string_field(wr, "tab", "\t");
-	jsonw_string_field(wr, "ff", "\f");
-	jsonw_string_field(wr, "quote", "\"");
-	jsonw_string_field(wr, "tick", "\'");
-	jsonw_string_field(wr, "backslash", "\\");
-	jsonw_end_array(wr);
-
-	jsonw_end_object(wr);
-
-	jsonw_end_object(wr);
-	jsonw_destroy(&wr);
-	return 0;
-}
-
-#endif
+../../../bpf/bpftool/json_writer.c
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/testing/selftests/bpf/json_writer.h linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/bpf/json_writer.h
--- linux-6.16.6/tools/testing/selftests/bpf/json_writer.h	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/bpf/json_writer.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,74 +1 @@
-/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */
-/*
- * Simple streaming JSON writer
- *
- * This takes care of the annoying bits of JSON syntax like the commas
- * after elements
- *
- * Authors:	Stephen Hemminger <stephen@networkplumber.org>
- */
-
-#ifndef _JSON_WRITER_H_
-#define _JSON_WRITER_H_
-
-#include <stdbool.h>
-#include <stdint.h>
-#include <stdarg.h>
-#include <stdio.h>
-#include <linux/compiler.h>
-
-/* Opaque class structure */
-typedef struct json_writer json_writer_t;
-
-/* Create a new JSON stream */
-json_writer_t *jsonw_new(FILE *f);
-/* End output to JSON stream */
-void jsonw_destroy(json_writer_t **self_p);
-
-/* Cause output to have pretty whitespace */
-void jsonw_pretty(json_writer_t *self, bool on);
-
-/* Reset separator to create new JSON */
-void jsonw_reset(json_writer_t *self);
-
-/* Add property name */
-void jsonw_name(json_writer_t *self, const char *name);
-
-/* Add value  */
-void __printf(2, 0) jsonw_vprintf_enquote(json_writer_t *self, const char *fmt,
-					  va_list ap);
-void __printf(2, 3) jsonw_printf(json_writer_t *self, const char *fmt, ...);
-void jsonw_string(json_writer_t *self, const char *value);
-void jsonw_bool(json_writer_t *self, bool value);
-void jsonw_float(json_writer_t *self, double number);
-void jsonw_float_fmt(json_writer_t *self, const char *fmt, double num);
-void jsonw_uint(json_writer_t *self, uint64_t number);
-void jsonw_hu(json_writer_t *self, unsigned short number);
-void jsonw_int(json_writer_t *self, int64_t number);
-void jsonw_null(json_writer_t *self);
-void jsonw_lluint(json_writer_t *self, unsigned long long int num);
-
-/* Useful Combinations of name and value */
-void jsonw_string_field(json_writer_t *self, const char *prop, const char *val);
-void jsonw_bool_field(json_writer_t *self, const char *prop, bool value);
-void jsonw_float_field(json_writer_t *self, const char *prop, double num);
-void jsonw_uint_field(json_writer_t *self, const char *prop, uint64_t num);
-void jsonw_hu_field(json_writer_t *self, const char *prop, unsigned short num);
-void jsonw_int_field(json_writer_t *self, const char *prop, int64_t num);
-void jsonw_null_field(json_writer_t *self, const char *prop);
-void jsonw_lluint_field(json_writer_t *self, const char *prop,
-			unsigned long long int num);
-void jsonw_float_field_fmt(json_writer_t *self, const char *prop,
-			   const char *fmt, double val);
-
-/* Collections */
-void jsonw_start_object(json_writer_t *self);
-void jsonw_end_object(json_writer_t *self);
-
-void jsonw_start_array(json_writer_t *self);
-void jsonw_end_array(json_writer_t *self);
-
-/* Override default exception handling */
-typedef void (jsonw_err_handler_fn)(const char *);
-
-#endif /* _JSON_WRITER_H_ */
+../../../bpf/bpftool/json_writer.h
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/testing/selftests/drivers/net/dsa/bridge_locked_port.sh linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/bridge_locked_port.sh
--- linux-6.16.6/tools/testing/selftests/drivers/net/dsa/bridge_locked_port.sh	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/bridge_locked_port.sh	2025-09-11 09:47:42.000000000 -0600
@@ -1,9 +1 @@
-#!/bin/bash
-# SPDX-License-Identifier: GPL-2.0
-
-libdir=$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")
-testname=$(basename "${BASH_SOURCE[0]}")
-
-source "$libdir"/forwarding.config
-cd "$libdir"/../../../net/forwarding/ || exit 1
-source "./$testname" "$@"
+run_net_forwarding_test.sh
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/testing/selftests/drivers/net/dsa/bridge_mdb.sh linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/bridge_mdb.sh
--- linux-6.16.6/tools/testing/selftests/drivers/net/dsa/bridge_mdb.sh	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/bridge_mdb.sh	2025-09-11 09:47:42.000000000 -0600
@@ -1,9 +1 @@
-#!/bin/bash
-# SPDX-License-Identifier: GPL-2.0
-
-libdir=$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")
-testname=$(basename "${BASH_SOURCE[0]}")
-
-source "$libdir"/forwarding.config
-cd "$libdir"/../../../net/forwarding/ || exit 1
-source "./$testname" "$@"
+run_net_forwarding_test.sh
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/testing/selftests/drivers/net/dsa/bridge_mld.sh linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/bridge_mld.sh
--- linux-6.16.6/tools/testing/selftests/drivers/net/dsa/bridge_mld.sh	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/bridge_mld.sh	2025-09-11 09:47:42.000000000 -0600
@@ -1,9 +1 @@
-#!/bin/bash
-# SPDX-License-Identifier: GPL-2.0
-
-libdir=$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")
-testname=$(basename "${BASH_SOURCE[0]}")
-
-source "$libdir"/forwarding.config
-cd "$libdir"/../../../net/forwarding/ || exit 1
-source "./$testname" "$@"
+run_net_forwarding_test.sh
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/testing/selftests/drivers/net/dsa/bridge_vlan_aware.sh linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/bridge_vlan_aware.sh
--- linux-6.16.6/tools/testing/selftests/drivers/net/dsa/bridge_vlan_aware.sh	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/bridge_vlan_aware.sh	2025-09-11 09:47:42.000000000 -0600
@@ -1,9 +1 @@
-#!/bin/bash
-# SPDX-License-Identifier: GPL-2.0
-
-libdir=$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")
-testname=$(basename "${BASH_SOURCE[0]}")
-
-source "$libdir"/forwarding.config
-cd "$libdir"/../../../net/forwarding/ || exit 1
-source "./$testname" "$@"
+run_net_forwarding_test.sh
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/testing/selftests/drivers/net/dsa/bridge_vlan_mcast.sh linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/bridge_vlan_mcast.sh
--- linux-6.16.6/tools/testing/selftests/drivers/net/dsa/bridge_vlan_mcast.sh	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/bridge_vlan_mcast.sh	2025-09-11 09:47:42.000000000 -0600
@@ -1,9 +1 @@
-#!/bin/bash
-# SPDX-License-Identifier: GPL-2.0
-
-libdir=$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")
-testname=$(basename "${BASH_SOURCE[0]}")
-
-source "$libdir"/forwarding.config
-cd "$libdir"/../../../net/forwarding/ || exit 1
-source "./$testname" "$@"
+run_net_forwarding_test.sh
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/testing/selftests/drivers/net/dsa/bridge_vlan_unaware.sh linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/bridge_vlan_unaware.sh
--- linux-6.16.6/tools/testing/selftests/drivers/net/dsa/bridge_vlan_unaware.sh	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/bridge_vlan_unaware.sh	2025-09-11 09:47:42.000000000 -0600
@@ -1,9 +1 @@
-#!/bin/bash
-# SPDX-License-Identifier: GPL-2.0
-
-libdir=$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")
-testname=$(basename "${BASH_SOURCE[0]}")
-
-source "$libdir"/forwarding.config
-cd "$libdir"/../../../net/forwarding/ || exit 1
-source "./$testname" "$@"
+run_net_forwarding_test.sh
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/testing/selftests/drivers/net/dsa/local_termination.sh linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/local_termination.sh
--- linux-6.16.6/tools/testing/selftests/drivers/net/dsa/local_termination.sh	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/local_termination.sh	2025-09-11 09:47:42.000000000 -0600
@@ -1,9 +1 @@
-#!/bin/bash
-# SPDX-License-Identifier: GPL-2.0
-
-libdir=$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")
-testname=$(basename "${BASH_SOURCE[0]}")
-
-source "$libdir"/forwarding.config
-cd "$libdir"/../../../net/forwarding/ || exit 1
-source "./$testname" "$@"
+run_net_forwarding_test.sh
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/testing/selftests/drivers/net/dsa/no_forwarding.sh linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/no_forwarding.sh
--- linux-6.16.6/tools/testing/selftests/drivers/net/dsa/no_forwarding.sh	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/no_forwarding.sh	2025-09-11 09:47:42.000000000 -0600
@@ -1,9 +1 @@
-#!/bin/bash
-# SPDX-License-Identifier: GPL-2.0
-
-libdir=$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")
-testname=$(basename "${BASH_SOURCE[0]}")
-
-source "$libdir"/forwarding.config
-cd "$libdir"/../../../net/forwarding/ || exit 1
-source "./$testname" "$@"
+run_net_forwarding_test.sh
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/testing/selftests/drivers/net/dsa/tc_actions.sh linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/tc_actions.sh
--- linux-6.16.6/tools/testing/selftests/drivers/net/dsa/tc_actions.sh	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/tc_actions.sh	2025-09-11 09:47:42.000000000 -0600
@@ -1,9 +1 @@
-#!/bin/bash
-# SPDX-License-Identifier: GPL-2.0
-
-libdir=$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")
-testname=$(basename "${BASH_SOURCE[0]}")
-
-source "$libdir"/forwarding.config
-cd "$libdir"/../../../net/forwarding/ || exit 1
-source "./$testname" "$@"
+run_net_forwarding_test.sh
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/testing/selftests/drivers/net/dsa/tc_taprio.sh linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/tc_taprio.sh
--- linux-6.16.6/tools/testing/selftests/drivers/net/dsa/tc_taprio.sh	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/dsa/tc_taprio.sh	2025-09-11 09:47:42.000000000 -0600
@@ -1,9 +1 @@
-#!/bin/bash
-# SPDX-License-Identifier: GPL-2.0
-
-libdir=$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")
-testname=$(basename "${BASH_SOURCE[0]}")
-
-source "$libdir"/forwarding.config
-cd "$libdir"/../../../net/forwarding/ || exit 1
-source "./$testname" "$@"
+run_net_forwarding_test.sh
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/testing/selftests/drivers/net/mlxsw/spectrum-2/port_range_scale.sh linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/mlxsw/spectrum-2/port_range_scale.sh
--- linux-6.16.6/tools/testing/selftests/drivers/net/mlxsw/spectrum-2/port_range_scale.sh	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/mlxsw/spectrum-2/port_range_scale.sh	2025-09-11 09:47:42.000000000 -0600
@@ -1,16 +1 @@
-# SPDX-License-Identifier: GPL-2.0
-source ../port_range_scale.sh
-
-port_range_get_target()
-{
-	local should_fail=$1; shift
-	local target
-
-	target=$(devlink_resource_size_get port_range_registers)
-
-	if ((! should_fail)); then
-		echo $target
-	else
-		echo $((target + 1))
-	fi
-}
+../spectrum/port_range_scale.sh
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/testing/selftests/drivers/net/mlxsw/spectrum-2/rif_counter_scale.sh linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/mlxsw/spectrum-2/rif_counter_scale.sh
--- linux-6.16.6/tools/testing/selftests/drivers/net/mlxsw/spectrum-2/rif_counter_scale.sh	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/drivers/net/mlxsw/spectrum-2/rif_counter_scale.sh	2025-09-11 09:47:42.000000000 -0600
@@ -1,34 +1 @@
-# SPDX-License-Identifier: GPL-2.0
-source ../rif_counter_scale.sh
-
-rif_counter_get_target()
-{
-	local should_fail=$1; shift
-	local max_cnts
-	local max_rifs
-	local target
-
-	max_rifs=$(devlink_resource_size_get rifs)
-	max_cnts=$(devlink_resource_size_get counters rif)
-
-	# Remove already allocated RIFs.
-	((max_rifs -= $(devlink_resource_occ_get rifs)))
-
-	# 10 KVD slots per counter, ingress+egress counters per RIF
-	((max_cnts /= 20))
-
-	# Pointless to run the overflow test if we don't have enough RIFs to
-	# host all the counters.
-	if ((max_cnts > max_rifs && should_fail)); then
-		echo 0
-		return
-	fi
-
-	target=$((max_rifs < max_cnts ? max_rifs : max_cnts))
-
-	if ((! should_fail)); then
-		echo $target
-	else
-		echo $((target + 1))
-	fi
-}
+../spectrum/rif_counter_scale.sh
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/testing/selftests/net/tcp_ao/icmps-accept.c linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/net/tcp_ao/icmps-accept.c
--- linux-6.16.6/tools/testing/selftests/net/tcp_ao/icmps-accept.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/net/tcp_ao/icmps-accept.c	2025-09-11 09:47:42.000000000 -0600
@@ -1,448 +1 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Selftest that verifies that incomping ICMPs are ignored,
- * the TCP connection stays alive, no hard or soft errors get reported
- * to the usespace and the counter for ignored ICMPs is updated.
- *
- * RFC5925, 7.8:
- * >> A TCP-AO implementation MUST default to ignore incoming ICMPv4
- * messages of Type 3 (destination unreachable), Codes 2-4 (protocol
- * unreachable, port unreachable, and fragmentation needed -- ’hard
- * errors’), and ICMPv6 Type 1 (destination unreachable), Code 1
- * (administratively prohibited) and Code 4 (port unreachable) intended
- * for connections in synchronized states (ESTABLISHED, FIN-WAIT-1, FIN-
- * WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT) that match MKTs.
- *
- * Author: Dmitry Safonov <dima@arista.com>
- */
-#include <inttypes.h>
-#include <linux/icmp.h>
-#include <linux/icmpv6.h>
-#include <linux/ipv6.h>
-#include <netinet/in.h>
-#include <netinet/ip.h>
-#include <sys/socket.h>
-#include "aolib.h"
-#include "../../../../include/linux/compiler.h"
-
-const size_t packets_nr = 20;
-const size_t packet_size = 100;
-const char *tcpao_icmps	= "TCPAODroppedIcmps";
-
-#ifdef IPV6_TEST
-const char *dst_unreach	= "Icmp6InDestUnreachs";
-const int sk_ip_level	= SOL_IPV6;
-const int sk_recverr	= IPV6_RECVERR;
-#else
-const char *dst_unreach	= "InDestUnreachs";
-const int sk_ip_level	= SOL_IP;
-const int sk_recverr	= IP_RECVERR;
-#endif
-
-/* Server is expected to fail with hard error if ::accept_icmp is set */
-#ifdef TEST_ICMPS_ACCEPT
-# define test_icmps_fail test_ok
-# define test_icmps_ok test_fail
-#else
-# define test_icmps_fail test_fail
-# define test_icmps_ok test_ok
-#endif
-
-static void serve_interfered(int sk)
-{
-	ssize_t test_quota = packet_size * packets_nr * 10;
-	uint64_t dest_unreach_a, dest_unreach_b;
-	uint64_t icmp_ignored_a, icmp_ignored_b;
-	struct tcp_counters cnt1, cnt2;
-	bool counter_not_found;
-	struct netstat *ns_after, *ns_before;
-	ssize_t bytes;
-
-	ns_before = netstat_read();
-	dest_unreach_a = netstat_get(ns_before, dst_unreach, NULL);
-	icmp_ignored_a = netstat_get(ns_before, tcpao_icmps, NULL);
-	if (test_get_tcp_counters(sk, &cnt1))
-		test_error("test_get_tcp_counters()");
-	bytes = test_server_run(sk, test_quota, 0);
-	ns_after = netstat_read();
-	netstat_print_diff(ns_before, ns_after);
-	dest_unreach_b = netstat_get(ns_after, dst_unreach, NULL);
-	icmp_ignored_b = netstat_get(ns_after, tcpao_icmps,
-					&counter_not_found);
-	if (test_get_tcp_counters(sk, &cnt2))
-		test_error("test_get_tcp_counters()");
-
-	netstat_free(ns_before);
-	netstat_free(ns_after);
-
-	if (dest_unreach_a >= dest_unreach_b) {
-		test_fail("%s counter didn't change: %" PRIu64 " >= %" PRIu64,
-				dst_unreach, dest_unreach_a, dest_unreach_b);
-		return;
-	}
-	test_ok("%s delivered %" PRIu64,
-		dst_unreach, dest_unreach_b - dest_unreach_a);
-	if (bytes < 0)
-		test_icmps_fail("Server failed with %zd: %s", bytes, strerrordesc_np(-bytes));
-	else
-		test_icmps_ok("Server survived %zd bytes of traffic", test_quota);
-	if (counter_not_found) {
-		test_fail("Not found %s counter", tcpao_icmps);
-		return;
-	}
-#ifdef TEST_ICMPS_ACCEPT
-	test_assert_counters(NULL, &cnt1, &cnt2, TEST_CNT_GOOD);
-#else
-	test_assert_counters(NULL, &cnt1, &cnt2, TEST_CNT_GOOD | TEST_CNT_AO_DROPPED_ICMP);
-#endif
-	if (icmp_ignored_a >= icmp_ignored_b) {
-		test_icmps_fail("%s counter didn't change: %" PRIu64 " >= %" PRIu64,
-				tcpao_icmps, icmp_ignored_a, icmp_ignored_b);
-		return;
-	}
-	test_icmps_ok("ICMPs ignored %" PRIu64, icmp_ignored_b - icmp_ignored_a);
-}
-
-static void *server_fn(void *arg)
-{
-	int val, sk, lsk;
-	bool accept_icmps = false;
-
-	lsk = test_listen_socket(this_ip_addr, test_server_port, 1);
-
-#ifdef TEST_ICMPS_ACCEPT
-	accept_icmps = true;
-#endif
-
-	if (test_set_ao_flags(lsk, false, accept_icmps))
-		test_error("setsockopt(TCP_AO_INFO)");
-
-	if (test_add_key(lsk, DEFAULT_TEST_PASSWORD, this_ip_dest, -1, 100, 100))
-		test_error("setsockopt(TCP_AO_ADD_KEY)");
-	synchronize_threads();
-
-	if (test_wait_fd(lsk, TEST_TIMEOUT_SEC, 0))
-		test_error("test_wait_fd()");
-
-	sk = accept(lsk, NULL, NULL);
-	if (sk < 0)
-		test_error("accept()");
-
-	/* Fail on hard ip errors, such as dest unreachable (RFC1122) */
-	val = 1;
-	if (setsockopt(sk, sk_ip_level, sk_recverr, &val, sizeof(val)))
-		test_error("setsockopt()");
-
-	synchronize_threads();
-
-	serve_interfered(sk);
-	return NULL;
-}
-
-static size_t packets_sent;
-static size_t icmps_sent;
-
-static uint32_t checksum4_nofold(void *data, size_t len, uint32_t sum)
-{
-	uint16_t *words = data;
-	size_t i;
-
-	for (i = 0; i < len / sizeof(uint16_t); i++)
-		sum += words[i];
-	if (len & 1)
-		sum += ((char *)data)[len - 1];
-	return sum;
-}
-
-static uint16_t checksum4_fold(void *data, size_t len, uint32_t sum)
-{
-	sum = checksum4_nofold(data, len, sum);
-	while (sum > 0xFFFF)
-		sum = (sum & 0xFFFF) + (sum >> 16);
-	return ~sum;
-}
-
-static void set_ip4hdr(struct iphdr *iph, size_t packet_len, int proto,
-		struct sockaddr_in *src, struct sockaddr_in *dst)
-{
-	iph->version	= 4;
-	iph->ihl	= 5;
-	iph->tos	= 0;
-	iph->tot_len	= htons(packet_len);
-	iph->ttl	= 2;
-	iph->protocol	= proto;
-	iph->saddr	= src->sin_addr.s_addr;
-	iph->daddr	= dst->sin_addr.s_addr;
-	iph->check	= checksum4_fold((void *)iph, iph->ihl << 1, 0);
-}
-
-static void icmp_interfere4(uint8_t type, uint8_t code, uint32_t rcv_nxt,
-		struct sockaddr_in *src, struct sockaddr_in *dst)
-{
-	int sk = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
-	struct {
-		struct iphdr iph;
-		struct icmphdr icmph;
-		struct iphdr iphe;
-		struct {
-			uint16_t sport;
-			uint16_t dport;
-			uint32_t seq;
-		} tcph;
-	} packet = {};
-	size_t packet_len;
-	ssize_t bytes;
-
-	if (sk < 0)
-		test_error("socket(AF_INET, SOCK_RAW, IPPROTO_RAW)");
-
-	packet_len = sizeof(packet);
-	set_ip4hdr(&packet.iph, packet_len, IPPROTO_ICMP, src, dst);
-
-	packet.icmph.type = type;
-	packet.icmph.code = code;
-	if (code == ICMP_FRAG_NEEDED) {
-		randomize_buffer(&packet.icmph.un.frag.mtu,
-				sizeof(packet.icmph.un.frag.mtu));
-	}
-
-	packet_len = sizeof(packet.iphe) + sizeof(packet.tcph);
-	set_ip4hdr(&packet.iphe, packet_len, IPPROTO_TCP, dst, src);
-
-	packet.tcph.sport = dst->sin_port;
-	packet.tcph.dport = src->sin_port;
-	packet.tcph.seq = htonl(rcv_nxt);
-
-	packet_len = sizeof(packet) - sizeof(packet.iph);
-	packet.icmph.checksum = checksum4_fold((void *)&packet.icmph,
-						packet_len, 0);
-
-	bytes = sendto(sk, &packet, sizeof(packet), 0,
-		       (struct sockaddr *)dst, sizeof(*dst));
-	if (bytes != sizeof(packet))
-		test_error("send(): %zd", bytes);
-	icmps_sent++;
-
-	close(sk);
-}
-
-static void set_ip6hdr(struct ipv6hdr *iph, size_t packet_len, int proto,
-		struct sockaddr_in6 *src, struct sockaddr_in6 *dst)
-{
-	iph->version		= 6;
-	iph->payload_len	= htons(packet_len);
-	iph->nexthdr		= proto;
-	iph->hop_limit		= 2;
-	iph->saddr		= src->sin6_addr;
-	iph->daddr		= dst->sin6_addr;
-}
-
-static inline uint16_t csum_fold(uint32_t csum)
-{
-	uint32_t sum = csum;
-
-	sum = (sum & 0xffff) + (sum >> 16);
-	sum = (sum & 0xffff) + (sum >> 16);
-	return (uint16_t)~sum;
-}
-
-static inline uint32_t csum_add(uint32_t csum, uint32_t addend)
-{
-	uint32_t res = csum;
-
-	res += addend;
-	return res + (res < addend);
-}
-
-noinline uint32_t checksum6_nofold(void *data, size_t len, uint32_t sum)
-{
-	uint16_t *words = data;
-	size_t i;
-
-	for (i = 0; i < len / sizeof(uint16_t); i++)
-		sum = csum_add(sum, words[i]);
-	if (len & 1)
-		sum = csum_add(sum, ((char *)data)[len - 1]);
-	return sum;
-}
-
-noinline uint16_t icmp6_checksum(struct sockaddr_in6 *src,
-				 struct sockaddr_in6 *dst,
-				 void *ptr, size_t len, uint8_t proto)
-{
-	struct {
-		struct in6_addr saddr;
-		struct in6_addr daddr;
-		uint32_t payload_len;
-		uint8_t zero[3];
-		uint8_t nexthdr;
-	} pseudo_header = {};
-	uint32_t sum;
-
-	pseudo_header.saddr		= src->sin6_addr;
-	pseudo_header.daddr		= dst->sin6_addr;
-	pseudo_header.payload_len	= htonl(len);
-	pseudo_header.nexthdr		= proto;
-
-	sum = checksum6_nofold(&pseudo_header, sizeof(pseudo_header), 0);
-	sum = checksum6_nofold(ptr, len, sum);
-
-	return csum_fold(sum);
-}
-
-static void icmp6_interfere(int type, int code, uint32_t rcv_nxt,
-		struct sockaddr_in6 *src, struct sockaddr_in6 *dst)
-{
-	int sk = socket(AF_INET6, SOCK_RAW, IPPROTO_RAW);
-	struct sockaddr_in6 dst_raw = *dst;
-	struct {
-		struct ipv6hdr iph;
-		struct icmp6hdr icmph;
-		struct ipv6hdr iphe;
-		struct {
-			uint16_t sport;
-			uint16_t dport;
-			uint32_t seq;
-		} tcph;
-	} packet = {};
-	size_t packet_len;
-	ssize_t bytes;
-
-
-	if (sk < 0)
-		test_error("socket(AF_INET6, SOCK_RAW, IPPROTO_RAW)");
-
-	packet_len = sizeof(packet) - sizeof(packet.iph);
-	set_ip6hdr(&packet.iph, packet_len, IPPROTO_ICMPV6, src, dst);
-
-	packet.icmph.icmp6_type = type;
-	packet.icmph.icmp6_code = code;
-
-	packet_len = sizeof(packet.iphe) + sizeof(packet.tcph);
-	set_ip6hdr(&packet.iphe, packet_len, IPPROTO_TCP, dst, src);
-
-	packet.tcph.sport = dst->sin6_port;
-	packet.tcph.dport = src->sin6_port;
-	packet.tcph.seq = htonl(rcv_nxt);
-
-	packet_len = sizeof(packet) - sizeof(packet.iph);
-
-	packet.icmph.icmp6_cksum = icmp6_checksum(src, dst,
-			(void *)&packet.icmph, packet_len, IPPROTO_ICMPV6);
-
-	dst_raw.sin6_port = htons(IPPROTO_RAW);
-	bytes = sendto(sk, &packet, sizeof(packet), 0,
-		       (struct sockaddr *)&dst_raw, sizeof(dst_raw));
-	if (bytes != sizeof(packet))
-		test_error("send(): %zd", bytes);
-	icmps_sent++;
-
-	close(sk);
-}
-
-static uint32_t get_rcv_nxt(int sk)
-{
-	int val = TCP_REPAIR_ON;
-	uint32_t ret;
-	socklen_t sz = sizeof(ret);
-
-	if (setsockopt(sk, SOL_TCP, TCP_REPAIR, &val, sizeof(val)))
-		test_error("setsockopt(TCP_REPAIR)");
-	val = TCP_RECV_QUEUE;
-	if (setsockopt(sk, SOL_TCP, TCP_REPAIR_QUEUE, &val, sizeof(val)))
-		test_error("setsockopt(TCP_REPAIR_QUEUE)");
-	if (getsockopt(sk, SOL_TCP, TCP_QUEUE_SEQ, &ret, &sz))
-		test_error("getsockopt(TCP_QUEUE_SEQ)");
-	val = TCP_REPAIR_OFF_NO_WP;
-	if (setsockopt(sk, SOL_TCP, TCP_REPAIR, &val, sizeof(val)))
-		test_error("setsockopt(TCP_REPAIR)");
-	return ret;
-}
-
-static void icmp_interfere(const size_t nr, uint32_t rcv_nxt, void *src, void *dst)
-{
-	struct sockaddr_in *saddr4 = src;
-	struct sockaddr_in *daddr4 = dst;
-	struct sockaddr_in6 *saddr6 = src;
-	struct sockaddr_in6 *daddr6 = dst;
-	size_t i;
-
-	if (saddr4->sin_family != daddr4->sin_family)
-		test_error("Different address families");
-
-	for (i = 0; i < nr; i++) {
-		if (saddr4->sin_family == AF_INET) {
-			icmp_interfere4(ICMP_DEST_UNREACH, ICMP_PROT_UNREACH,
-					rcv_nxt, saddr4, daddr4);
-			icmp_interfere4(ICMP_DEST_UNREACH, ICMP_PORT_UNREACH,
-					rcv_nxt, saddr4, daddr4);
-			icmp_interfere4(ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED,
-					rcv_nxt, saddr4, daddr4);
-			icmps_sent += 3;
-		} else if (saddr4->sin_family == AF_INET6) {
-			icmp6_interfere(ICMPV6_DEST_UNREACH,
-					ICMPV6_ADM_PROHIBITED,
-					rcv_nxt, saddr6, daddr6);
-			icmp6_interfere(ICMPV6_DEST_UNREACH,
-					ICMPV6_PORT_UNREACH,
-					rcv_nxt, saddr6, daddr6);
-			icmps_sent += 2;
-		} else {
-			test_error("Not ip address family");
-		}
-	}
-}
-
-static void send_interfered(int sk)
-{
-	struct sockaddr_in6 src, dst;
-	socklen_t addr_sz;
-
-	addr_sz = sizeof(src);
-	if (getsockname(sk, &src, &addr_sz))
-		test_error("getsockname()");
-	addr_sz = sizeof(dst);
-	if (getpeername(sk, &dst, &addr_sz))
-		test_error("getpeername()");
-
-	while (1) {
-		uint32_t rcv_nxt;
-
-		if (test_client_verify(sk, packet_size, packets_nr)) {
-			test_fail("client: connection is broken");
-			return;
-		}
-		packets_sent += packets_nr;
-		rcv_nxt = get_rcv_nxt(sk);
-		icmp_interfere(packets_nr, rcv_nxt, (void *)&src, (void *)&dst);
-	}
-}
-
-static void *client_fn(void *arg)
-{
-	int sk = socket(test_family, SOCK_STREAM, IPPROTO_TCP);
-
-	if (sk < 0)
-		test_error("socket()");
-
-	if (test_add_key(sk, DEFAULT_TEST_PASSWORD, this_ip_dest, -1, 100, 100))
-		test_error("setsockopt(TCP_AO_ADD_KEY)");
-
-	synchronize_threads();
-	if (test_connect_socket(sk, this_ip_dest, test_server_port) <= 0)
-		test_error("failed to connect()");
-	synchronize_threads();
-
-	send_interfered(sk);
-
-	/* Not expecting client to quit */
-	test_fail("client disconnected");
-
-	return NULL;
-}
-
-int main(int argc, char *argv[])
-{
-	test_init(4, server_fn, client_fn);
-	return 0;
-}
+icmps-discard.c
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/testing/selftests/powerpc/copyloops/copy_mc_64.S linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/copyloops/copy_mc_64.S
--- linux-6.16.6/tools/testing/selftests/powerpc/copyloops/copy_mc_64.S	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/copyloops/copy_mc_64.S	2025-09-11 09:47:42.000000000 -0600
@@ -1,242 +1 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Copyright (C) IBM Corporation, 2011
- * Derived from copyuser_power7.s by Anton Blanchard <anton@au.ibm.com>
- * Author - Balbir Singh <bsingharora@gmail.com>
- */
-#include <linux/export.h>
-#include <asm/ppc_asm.h>
-#include <asm/errno.h>
-
-	.macro err1
-100:
-	EX_TABLE(100b,.Ldo_err1)
-	.endm
-
-	.macro err2
-200:
-	EX_TABLE(200b,.Ldo_err2)
-	.endm
-
-	.macro err3
-300:	EX_TABLE(300b,.Ldone)
-	.endm
-
-.Ldo_err2:
-	ld	r22,STK_REG(R22)(r1)
-	ld	r21,STK_REG(R21)(r1)
-	ld	r20,STK_REG(R20)(r1)
-	ld	r19,STK_REG(R19)(r1)
-	ld	r18,STK_REG(R18)(r1)
-	ld	r17,STK_REG(R17)(r1)
-	ld	r16,STK_REG(R16)(r1)
-	ld	r15,STK_REG(R15)(r1)
-	ld	r14,STK_REG(R14)(r1)
-	addi	r1,r1,STACKFRAMESIZE
-.Ldo_err1:
-	/* Do a byte by byte copy to get the exact remaining size */
-	mtctr	r7
-46:
-err3;	lbz	r0,0(r4)
-	addi	r4,r4,1
-err3;	stb	r0,0(r3)
-	addi	r3,r3,1
-	bdnz	46b
-	li	r3,0
-	blr
-
-.Ldone:
-	mfctr	r3
-	blr
-
-
-_GLOBAL(copy_mc_generic)
-	mr	r7,r5
-	cmpldi	r5,16
-	blt	.Lshort_copy
-
-.Lcopy:
-	/* Get the source 8B aligned */
-	neg	r6,r4
-	mtocrf	0x01,r6
-	clrldi	r6,r6,(64-3)
-
-	bf	cr7*4+3,1f
-err1;	lbz	r0,0(r4)
-	addi	r4,r4,1
-err1;	stb	r0,0(r3)
-	addi	r3,r3,1
-	subi	r7,r7,1
-
-1:	bf	cr7*4+2,2f
-err1;	lhz	r0,0(r4)
-	addi	r4,r4,2
-err1;	sth	r0,0(r3)
-	addi	r3,r3,2
-	subi	r7,r7,2
-
-2:	bf	cr7*4+1,3f
-err1;	lwz	r0,0(r4)
-	addi	r4,r4,4
-err1;	stw	r0,0(r3)
-	addi	r3,r3,4
-	subi	r7,r7,4
-
-3:	sub	r5,r5,r6
-	cmpldi	r5,128
-
-	mflr	r0
-	stdu	r1,-STACKFRAMESIZE(r1)
-	std	r14,STK_REG(R14)(r1)
-	std	r15,STK_REG(R15)(r1)
-	std	r16,STK_REG(R16)(r1)
-	std	r17,STK_REG(R17)(r1)
-	std	r18,STK_REG(R18)(r1)
-	std	r19,STK_REG(R19)(r1)
-	std	r20,STK_REG(R20)(r1)
-	std	r21,STK_REG(R21)(r1)
-	std	r22,STK_REG(R22)(r1)
-	std	r0,STACKFRAMESIZE+16(r1)
-
-	blt	5f
-	srdi	r6,r5,7
-	mtctr	r6
-
-	/* Now do cacheline (128B) sized loads and stores. */
-	.align	5
-4:
-err2;	ld	r0,0(r4)
-err2;	ld	r6,8(r4)
-err2;	ld	r8,16(r4)
-err2;	ld	r9,24(r4)
-err2;	ld	r10,32(r4)
-err2;	ld	r11,40(r4)
-err2;	ld	r12,48(r4)
-err2;	ld	r14,56(r4)
-err2;	ld	r15,64(r4)
-err2;	ld	r16,72(r4)
-err2;	ld	r17,80(r4)
-err2;	ld	r18,88(r4)
-err2;	ld	r19,96(r4)
-err2;	ld	r20,104(r4)
-err2;	ld	r21,112(r4)
-err2;	ld	r22,120(r4)
-	addi	r4,r4,128
-err2;	std	r0,0(r3)
-err2;	std	r6,8(r3)
-err2;	std	r8,16(r3)
-err2;	std	r9,24(r3)
-err2;	std	r10,32(r3)
-err2;	std	r11,40(r3)
-err2;	std	r12,48(r3)
-err2;	std	r14,56(r3)
-err2;	std	r15,64(r3)
-err2;	std	r16,72(r3)
-err2;	std	r17,80(r3)
-err2;	std	r18,88(r3)
-err2;	std	r19,96(r3)
-err2;	std	r20,104(r3)
-err2;	std	r21,112(r3)
-err2;	std	r22,120(r3)
-	addi	r3,r3,128
-	subi	r7,r7,128
-	bdnz	4b
-
-	clrldi	r5,r5,(64-7)
-
-	/* Up to 127B to go */
-5:	srdi	r6,r5,4
-	mtocrf	0x01,r6
-
-6:	bf	cr7*4+1,7f
-err2;	ld	r0,0(r4)
-err2;	ld	r6,8(r4)
-err2;	ld	r8,16(r4)
-err2;	ld	r9,24(r4)
-err2;	ld	r10,32(r4)
-err2;	ld	r11,40(r4)
-err2;	ld	r12,48(r4)
-err2;	ld	r14,56(r4)
-	addi	r4,r4,64
-err2;	std	r0,0(r3)
-err2;	std	r6,8(r3)
-err2;	std	r8,16(r3)
-err2;	std	r9,24(r3)
-err2;	std	r10,32(r3)
-err2;	std	r11,40(r3)
-err2;	std	r12,48(r3)
-err2;	std	r14,56(r3)
-	addi	r3,r3,64
-	subi	r7,r7,64
-
-7:	ld	r14,STK_REG(R14)(r1)
-	ld	r15,STK_REG(R15)(r1)
-	ld	r16,STK_REG(R16)(r1)
-	ld	r17,STK_REG(R17)(r1)
-	ld	r18,STK_REG(R18)(r1)
-	ld	r19,STK_REG(R19)(r1)
-	ld	r20,STK_REG(R20)(r1)
-	ld	r21,STK_REG(R21)(r1)
-	ld	r22,STK_REG(R22)(r1)
-	addi	r1,r1,STACKFRAMESIZE
-
-	/* Up to 63B to go */
-	bf	cr7*4+2,8f
-err1;	ld	r0,0(r4)
-err1;	ld	r6,8(r4)
-err1;	ld	r8,16(r4)
-err1;	ld	r9,24(r4)
-	addi	r4,r4,32
-err1;	std	r0,0(r3)
-err1;	std	r6,8(r3)
-err1;	std	r8,16(r3)
-err1;	std	r9,24(r3)
-	addi	r3,r3,32
-	subi	r7,r7,32
-
-	/* Up to 31B to go */
-8:	bf	cr7*4+3,9f
-err1;	ld	r0,0(r4)
-err1;	ld	r6,8(r4)
-	addi	r4,r4,16
-err1;	std	r0,0(r3)
-err1;	std	r6,8(r3)
-	addi	r3,r3,16
-	subi	r7,r7,16
-
-9:	clrldi	r5,r5,(64-4)
-
-	/* Up to 15B to go */
-.Lshort_copy:
-	mtocrf	0x01,r5
-	bf	cr7*4+0,12f
-err1;	lwz	r0,0(r4)	/* Less chance of a reject with word ops */
-err1;	lwz	r6,4(r4)
-	addi	r4,r4,8
-err1;	stw	r0,0(r3)
-err1;	stw	r6,4(r3)
-	addi	r3,r3,8
-	subi	r7,r7,8
-
-12:	bf	cr7*4+1,13f
-err1;	lwz	r0,0(r4)
-	addi	r4,r4,4
-err1;	stw	r0,0(r3)
-	addi	r3,r3,4
-	subi	r7,r7,4
-
-13:	bf	cr7*4+2,14f
-err1;	lhz	r0,0(r4)
-	addi	r4,r4,2
-err1;	sth	r0,0(r3)
-	addi	r3,r3,2
-	subi	r7,r7,2
-
-14:	bf	cr7*4+3,15f
-err1;	lbz	r0,0(r4)
-err1;	stb	r0,0(r3)
-
-15:	li	r3,0
-	blr
-
-EXPORT_SYMBOL_GPL(copy_mc_generic);
+../../../../../arch/powerpc/lib/copy_mc_64.S
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/testing/selftests/powerpc/copyloops/copyuser_64.S linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/copyloops/copyuser_64.S
--- linux-6.16.6/tools/testing/selftests/powerpc/copyloops/copyuser_64.S	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/copyloops/copyuser_64.S	2025-09-11 09:47:42.000000000 -0600
@@ -1,564 +1 @@
-/* SPDX-License-Identifier: GPL-2.0-or-later */
-/*
- * Copyright (C) 2002 Paul Mackerras, IBM Corp.
- */
-#include <linux/export.h>
-#include <asm/processor.h>
-#include <asm/ppc_asm.h>
-#include <asm/asm-compat.h>
-#include <asm/feature-fixups.h>
-
-#ifndef SELFTEST_CASE
-/* 0 == most CPUs, 1 == POWER6, 2 == Cell */
-#define SELFTEST_CASE	0
-#endif
-
-#ifdef __BIG_ENDIAN__
-#define sLd sld		/* Shift towards low-numbered address. */
-#define sHd srd		/* Shift towards high-numbered address. */
-#else
-#define sLd srd		/* Shift towards low-numbered address. */
-#define sHd sld		/* Shift towards high-numbered address. */
-#endif
-
-/*
- * These macros are used to generate exception table entries.
- * The exception handlers below use the original arguments
- * (stored on the stack) and the point where we're up to in
- * the destination buffer, i.e. the address of the first
- * unmodified byte.  Generally r3 points into the destination
- * buffer, but the first unmodified byte is at a variable
- * offset from r3.  In the code below, the symbol r3_offset
- * is set to indicate the current offset at each point in
- * the code.  This offset is then used as a negative offset
- * from the exception handler code, and those instructions
- * before the exception handlers are addi instructions that
- * adjust r3 to point to the correct place.
- */
-	.macro	lex		/* exception handler for load */
-100:	EX_TABLE(100b, .Lld_exc - r3_offset)
-	.endm
-
-	.macro	stex		/* exception handler for store */
-100:	EX_TABLE(100b, .Lst_exc - r3_offset)
-	.endm
-
-	.align	7
-_GLOBAL_TOC(__copy_tofrom_user)
-#ifdef CONFIG_PPC_BOOK3S_64
-BEGIN_FTR_SECTION
-	nop
-FTR_SECTION_ELSE
-	b	__copy_tofrom_user_power7
-ALT_FTR_SECTION_END_IFCLR(CPU_FTR_VMX_COPY)
-#endif
-_GLOBAL(__copy_tofrom_user_base)
-	/* first check for a 4kB copy on a 4kB boundary */
-	cmpldi	cr1,r5,16
-	cmpdi	cr6,r5,4096
-	or	r0,r3,r4
-	neg	r6,r3		/* LS 3 bits = # bytes to 8-byte dest bdry */
-	andi.	r0,r0,4095
-	std	r3,-24(r1)
-	crand	cr0*4+2,cr0*4+2,cr6*4+2
-	std	r4,-16(r1)
-	std	r5,-8(r1)
-	dcbt	0,r4
-	beq	.Lcopy_page_4K
-	andi.	r6,r6,7
-	PPC_MTOCRF(0x01,r5)
-	blt	cr1,.Lshort_copy
-/* Below we want to nop out the bne if we're on a CPU that has the
- * CPU_FTR_UNALIGNED_LD_STD bit set and the CPU_FTR_CP_USE_DCBTZ bit
- * cleared.
- * At the time of writing the only CPU that has this combination of bits
- * set is Power6.
- */
-test_feature = (SELFTEST_CASE == 1)
-BEGIN_FTR_SECTION
-	nop
-FTR_SECTION_ELSE
-	bne	.Ldst_unaligned
-ALT_FTR_SECTION_END(CPU_FTR_UNALIGNED_LD_STD | CPU_FTR_CP_USE_DCBTZ, \
-		    CPU_FTR_UNALIGNED_LD_STD)
-.Ldst_aligned:
-	addi	r3,r3,-16
-r3_offset = 16
-test_feature = (SELFTEST_CASE == 0)
-BEGIN_FTR_SECTION
-	andi.	r0,r4,7
-	bne	.Lsrc_unaligned
-END_FTR_SECTION_IFCLR(CPU_FTR_UNALIGNED_LD_STD)
-	blt	cr1,.Ldo_tail		/* if < 16 bytes to copy */
-	srdi	r0,r5,5
-	cmpdi	cr1,r0,0
-lex;	ld	r7,0(r4)
-lex;	ld	r6,8(r4)
-	addi	r4,r4,16
-	mtctr	r0
-	andi.	r0,r5,0x10
-	beq	22f
-	addi	r3,r3,16
-r3_offset = 0
-	addi	r4,r4,-16
-	mr	r9,r7
-	mr	r8,r6
-	beq	cr1,72f
-21:
-lex;	ld	r7,16(r4)
-lex;	ld	r6,24(r4)
-	addi	r4,r4,32
-stex;	std	r9,0(r3)
-r3_offset = 8
-stex;	std	r8,8(r3)
-r3_offset = 16
-22:
-lex;	ld	r9,0(r4)
-lex;	ld	r8,8(r4)
-stex;	std	r7,16(r3)
-r3_offset = 24
-stex;	std	r6,24(r3)
-	addi	r3,r3,32
-r3_offset = 0
-	bdnz	21b
-72:
-stex;	std	r9,0(r3)
-r3_offset = 8
-stex;	std	r8,8(r3)
-r3_offset = 16
-	andi.	r5,r5,0xf
-	beq+	3f
-	addi	r4,r4,16
-.Ldo_tail:
-	addi	r3,r3,16
-r3_offset = 0
-	bf	cr7*4+0,246f
-lex;	ld	r9,0(r4)
-	addi	r4,r4,8
-stex;	std	r9,0(r3)
-	addi	r3,r3,8
-246:	bf	cr7*4+1,1f
-lex;	lwz	r9,0(r4)
-	addi	r4,r4,4
-stex;	stw	r9,0(r3)
-	addi	r3,r3,4
-1:	bf	cr7*4+2,2f
-lex;	lhz	r9,0(r4)
-	addi	r4,r4,2
-stex;	sth	r9,0(r3)
-	addi	r3,r3,2
-2:	bf	cr7*4+3,3f
-lex;	lbz	r9,0(r4)
-stex;	stb	r9,0(r3)
-3:	li	r3,0
-	blr
-
-.Lsrc_unaligned:
-r3_offset = 16
-	srdi	r6,r5,3
-	addi	r5,r5,-16
-	subf	r4,r0,r4
-	srdi	r7,r5,4
-	sldi	r10,r0,3
-	cmpldi	cr6,r6,3
-	andi.	r5,r5,7
-	mtctr	r7
-	subfic	r11,r10,64
-	add	r5,r5,r0
-	bt	cr7*4+0,28f
-
-lex;	ld	r9,0(r4)	/* 3+2n loads, 2+2n stores */
-lex;	ld	r0,8(r4)
-	sLd	r6,r9,r10
-lex;	ldu	r9,16(r4)
-	sHd	r7,r0,r11
-	sLd	r8,r0,r10
-	or	r7,r7,r6
-	blt	cr6,79f
-lex;	ld	r0,8(r4)
-	b	2f
-
-28:
-lex;	ld	r0,0(r4)	/* 4+2n loads, 3+2n stores */
-lex;	ldu	r9,8(r4)
-	sLd	r8,r0,r10
-	addi	r3,r3,-8
-r3_offset = 24
-	blt	cr6,5f
-lex;	ld	r0,8(r4)
-	sHd	r12,r9,r11
-	sLd	r6,r9,r10
-lex;	ldu	r9,16(r4)
-	or	r12,r8,r12
-	sHd	r7,r0,r11
-	sLd	r8,r0,r10
-	addi	r3,r3,16
-r3_offset = 8
-	beq	cr6,78f
-
-1:	or	r7,r7,r6
-lex;	ld	r0,8(r4)
-stex;	std	r12,8(r3)
-r3_offset = 16
-2:	sHd	r12,r9,r11
-	sLd	r6,r9,r10
-lex;	ldu	r9,16(r4)
-	or	r12,r8,r12
-stex;	stdu	r7,16(r3)
-r3_offset = 8
-	sHd	r7,r0,r11
-	sLd	r8,r0,r10
-	bdnz	1b
-
-78:
-stex;	std	r12,8(r3)
-r3_offset = 16
-	or	r7,r7,r6
-79:
-stex;	std	r7,16(r3)
-r3_offset = 24
-5:	sHd	r12,r9,r11
-	or	r12,r8,r12
-stex;	std	r12,24(r3)
-r3_offset = 32
-	bne	6f
-	li	r3,0
-	blr
-6:	cmpwi	cr1,r5,8
-	addi	r3,r3,32
-r3_offset = 0
-	sLd	r9,r9,r10
-	ble	cr1,7f
-lex;	ld	r0,8(r4)
-	sHd	r7,r0,r11
-	or	r9,r7,r9
-7:
-	bf	cr7*4+1,1f
-#ifdef __BIG_ENDIAN__
-	rotldi	r9,r9,32
-#endif
-stex;	stw	r9,0(r3)
-#ifdef __LITTLE_ENDIAN__
-	rotrdi	r9,r9,32
-#endif
-	addi	r3,r3,4
-1:	bf	cr7*4+2,2f
-#ifdef __BIG_ENDIAN__
-	rotldi	r9,r9,16
-#endif
-stex;	sth	r9,0(r3)
-#ifdef __LITTLE_ENDIAN__
-	rotrdi	r9,r9,16
-#endif
-	addi	r3,r3,2
-2:	bf	cr7*4+3,3f
-#ifdef __BIG_ENDIAN__
-	rotldi	r9,r9,8
-#endif
-stex;	stb	r9,0(r3)
-#ifdef __LITTLE_ENDIAN__
-	rotrdi	r9,r9,8
-#endif
-3:	li	r3,0
-	blr
-
-.Ldst_unaligned:
-r3_offset = 0
-	PPC_MTOCRF(0x01,r6)		/* put #bytes to 8B bdry into cr7 */
-	subf	r5,r6,r5
-	li	r7,0
-	cmpldi	cr1,r5,16
-	bf	cr7*4+3,1f
-100:	EX_TABLE(100b, .Lld_exc_r7)
-	lbz	r0,0(r4)
-100:	EX_TABLE(100b, .Lst_exc_r7)
-	stb	r0,0(r3)
-	addi	r7,r7,1
-1:	bf	cr7*4+2,2f
-100:	EX_TABLE(100b, .Lld_exc_r7)
-	lhzx	r0,r7,r4
-100:	EX_TABLE(100b, .Lst_exc_r7)
-	sthx	r0,r7,r3
-	addi	r7,r7,2
-2:	bf	cr7*4+1,3f
-100:	EX_TABLE(100b, .Lld_exc_r7)
-	lwzx	r0,r7,r4
-100:	EX_TABLE(100b, .Lst_exc_r7)
-	stwx	r0,r7,r3
-3:	PPC_MTOCRF(0x01,r5)
-	add	r4,r6,r4
-	add	r3,r6,r3
-	b	.Ldst_aligned
-
-.Lshort_copy:
-r3_offset = 0
-	bf	cr7*4+0,1f
-lex;	lwz	r0,0(r4)
-lex;	lwz	r9,4(r4)
-	addi	r4,r4,8
-stex;	stw	r0,0(r3)
-stex;	stw	r9,4(r3)
-	addi	r3,r3,8
-1:	bf	cr7*4+1,2f
-lex;	lwz	r0,0(r4)
-	addi	r4,r4,4
-stex;	stw	r0,0(r3)
-	addi	r3,r3,4
-2:	bf	cr7*4+2,3f
-lex;	lhz	r0,0(r4)
-	addi	r4,r4,2
-stex;	sth	r0,0(r3)
-	addi	r3,r3,2
-3:	bf	cr7*4+3,4f
-lex;	lbz	r0,0(r4)
-stex;	stb	r0,0(r3)
-4:	li	r3,0
-	blr
-
-/*
- * exception handlers follow
- * we have to return the number of bytes not copied
- * for an exception on a load, we set the rest of the destination to 0
- * Note that the number of bytes of instructions for adjusting r3 needs
- * to equal the amount of the adjustment, due to the trick of using
- * .Lld_exc - r3_offset as the handler address.
- */
-
-.Lld_exc_r7:
-	add	r3,r3,r7
-	b	.Lld_exc
-
-	/* adjust by 24 */
-	addi	r3,r3,8
-	nop
-	/* adjust by 16 */
-	addi	r3,r3,8
-	nop
-	/* adjust by 8 */
-	addi	r3,r3,8
-	nop
-
-/*
- * Here we have had a fault on a load and r3 points to the first
- * unmodified byte of the destination.  We use the original arguments
- * and r3 to work out how much wasn't copied.  Since we load some
- * distance ahead of the stores, we continue copying byte-by-byte until
- * we hit the load fault again in order to copy as much as possible.
- */
-.Lld_exc:
-	ld	r6,-24(r1)
-	ld	r4,-16(r1)
-	ld	r5,-8(r1)
-	subf	r6,r6,r3
-	add	r4,r4,r6
-	subf	r5,r6,r5	/* #bytes left to go */
-
-/*
- * first see if we can copy any more bytes before hitting another exception
- */
-	mtctr	r5
-r3_offset = 0
-100:	EX_TABLE(100b, .Ldone)
-43:	lbz	r0,0(r4)
-	addi	r4,r4,1
-stex;	stb	r0,0(r3)
-	addi	r3,r3,1
-	bdnz	43b
-	li	r3,0		/* huh? all copied successfully this time? */
-	blr
-
-/*
- * here we have trapped again, amount remaining is in ctr.
- */
-.Ldone:
-	mfctr	r3
-	blr
-
-/*
- * exception handlers for stores: we need to work out how many bytes
- * weren't copied, and we may need to copy some more.
- * Note that the number of bytes of instructions for adjusting r3 needs
- * to equal the amount of the adjustment, due to the trick of using
- * .Lst_exc - r3_offset as the handler address.
- */
-.Lst_exc_r7:
-	add	r3,r3,r7
-	b	.Lst_exc
-
-	/* adjust by 24 */
-	addi	r3,r3,8
-	nop
-	/* adjust by 16 */
-	addi	r3,r3,8
-	nop
-	/* adjust by 8 */
-	addi	r3,r3,4
-	/* adjust by 4 */
-	addi	r3,r3,4
-.Lst_exc:
-	ld	r6,-24(r1)	/* original destination pointer */
-	ld	r4,-16(r1)	/* original source pointer */
-	ld	r5,-8(r1)	/* original number of bytes */
-	add	r7,r6,r5
-	/*
-	 * If the destination pointer isn't 8-byte aligned,
-	 * we may have got the exception as a result of a
-	 * store that overlapped a page boundary, so we may be
-	 * able to copy a few more bytes.
-	 */
-17:	andi.	r0,r3,7
-	beq	19f
-	subf	r8,r6,r3	/* #bytes copied */
-100:	EX_TABLE(100b,19f)
-	lbzx	r0,r8,r4
-100:	EX_TABLE(100b,19f)
-	stb	r0,0(r3)
-	addi	r3,r3,1
-	cmpld	r3,r7
-	blt	17b
-19:	subf	r3,r3,r7	/* #bytes not copied in r3 */
-	blr
-
-/*
- * Routine to copy a whole page of data, optimized for POWER4.
- * On POWER4 it is more than 50% faster than the simple loop
- * above (following the .Ldst_aligned label).
- */
-	.macro	exc
-100:	EX_TABLE(100b, .Labort)
-	.endm
-.Lcopy_page_4K:
-	std	r31,-32(1)
-	std	r30,-40(1)
-	std	r29,-48(1)
-	std	r28,-56(1)
-	std	r27,-64(1)
-	std	r26,-72(1)
-	std	r25,-80(1)
-	std	r24,-88(1)
-	std	r23,-96(1)
-	std	r22,-104(1)
-	std	r21,-112(1)
-	std	r20,-120(1)
-	li	r5,4096/32 - 1
-	addi	r3,r3,-8
-	li	r0,5
-0:	addi	r5,r5,-24
-	mtctr	r0
-exc;	ld	r22,640(4)
-exc;	ld	r21,512(4)
-exc;	ld	r20,384(4)
-exc;	ld	r11,256(4)
-exc;	ld	r9,128(4)
-exc;	ld	r7,0(4)
-exc;	ld	r25,648(4)
-exc;	ld	r24,520(4)
-exc;	ld	r23,392(4)
-exc;	ld	r10,264(4)
-exc;	ld	r8,136(4)
-exc;	ldu	r6,8(4)
-	cmpwi	r5,24
-1:
-exc;	std	r22,648(3)
-exc;	std	r21,520(3)
-exc;	std	r20,392(3)
-exc;	std	r11,264(3)
-exc;	std	r9,136(3)
-exc;	std	r7,8(3)
-exc;	ld	r28,648(4)
-exc;	ld	r27,520(4)
-exc;	ld	r26,392(4)
-exc;	ld	r31,264(4)
-exc;	ld	r30,136(4)
-exc;	ld	r29,8(4)
-exc;	std	r25,656(3)
-exc;	std	r24,528(3)
-exc;	std	r23,400(3)
-exc;	std	r10,272(3)
-exc;	std	r8,144(3)
-exc;	std	r6,16(3)
-exc;	ld	r22,656(4)
-exc;	ld	r21,528(4)
-exc;	ld	r20,400(4)
-exc;	ld	r11,272(4)
-exc;	ld	r9,144(4)
-exc;	ld	r7,16(4)
-exc;	std	r28,664(3)
-exc;	std	r27,536(3)
-exc;	std	r26,408(3)
-exc;	std	r31,280(3)
-exc;	std	r30,152(3)
-exc;	stdu	r29,24(3)
-exc;	ld	r25,664(4)
-exc;	ld	r24,536(4)
-exc;	ld	r23,408(4)
-exc;	ld	r10,280(4)
-exc;	ld	r8,152(4)
-exc;	ldu	r6,24(4)
-	bdnz	1b
-exc;	std	r22,648(3)
-exc;	std	r21,520(3)
-exc;	std	r20,392(3)
-exc;	std	r11,264(3)
-exc;	std	r9,136(3)
-exc;	std	r7,8(3)
-	addi	r4,r4,640
-	addi	r3,r3,648
-	bge	0b
-	mtctr	r5
-exc;	ld	r7,0(4)
-exc;	ld	r8,8(4)
-exc;	ldu	r9,16(4)
-3:
-exc;	ld	r10,8(4)
-exc;	std	r7,8(3)
-exc;	ld	r7,16(4)
-exc;	std	r8,16(3)
-exc;	ld	r8,24(4)
-exc;	std	r9,24(3)
-exc;	ldu	r9,32(4)
-exc;	stdu	r10,32(3)
-	bdnz	3b
-4:
-exc;	ld	r10,8(4)
-exc;	std	r7,8(3)
-exc;	std	r8,16(3)
-exc;	std	r9,24(3)
-exc;	std	r10,32(3)
-9:	ld	r20,-120(1)
-	ld	r21,-112(1)
-	ld	r22,-104(1)
-	ld	r23,-96(1)
-	ld	r24,-88(1)
-	ld	r25,-80(1)
-	ld	r26,-72(1)
-	ld	r27,-64(1)
-	ld	r28,-56(1)
-	ld	r29,-48(1)
-	ld	r30,-40(1)
-	ld	r31,-32(1)
-	li	r3,0
-	blr
-
-/*
- * on an exception, reset to the beginning and jump back into the
- * standard __copy_tofrom_user
- */
-.Labort:
-	ld	r20,-120(1)
-	ld	r21,-112(1)
-	ld	r22,-104(1)
-	ld	r23,-96(1)
-	ld	r24,-88(1)
-	ld	r25,-80(1)
-	ld	r26,-72(1)
-	ld	r27,-64(1)
-	ld	r28,-56(1)
-	ld	r29,-48(1)
-	ld	r30,-40(1)
-	ld	r31,-32(1)
-	ld	r3,-24(r1)
-	ld	r4,-16(r1)
-	li	r5,4096
-	b	.Ldst_aligned
-EXPORT_SYMBOL(__copy_tofrom_user)
+../../../../../arch/powerpc/lib/copyuser_64.S
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/testing/selftests/powerpc/copyloops/copyuser_power7.S linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/copyloops/copyuser_power7.S
--- linux-6.16.6/tools/testing/selftests/powerpc/copyloops/copyuser_power7.S	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/copyloops/copyuser_power7.S	2025-09-11 09:47:42.000000000 -0600
@@ -1,685 +1 @@
-/* SPDX-License-Identifier: GPL-2.0-or-later */
-/*
- *
- * Copyright (C) IBM Corporation, 2011
- *
- * Author: Anton Blanchard <anton@au.ibm.com>
- */
-#include <asm/ppc_asm.h>
-
-#ifndef SELFTEST_CASE
-/* 0 == don't use VMX, 1 == use VMX */
-#define SELFTEST_CASE	0
-#endif
-
-#ifdef __BIG_ENDIAN__
-#define LVS(VRT,RA,RB)		lvsl	VRT,RA,RB
-#define VPERM(VRT,VRA,VRB,VRC)	vperm	VRT,VRA,VRB,VRC
-#else
-#define LVS(VRT,RA,RB)		lvsr	VRT,RA,RB
-#define VPERM(VRT,VRA,VRB,VRC)	vperm	VRT,VRB,VRA,VRC
-#endif
-
-	.macro err1
-100:
-	EX_TABLE(100b,.Ldo_err1)
-	.endm
-
-	.macro err2
-200:
-	EX_TABLE(200b,.Ldo_err2)
-	.endm
-
-#ifdef CONFIG_ALTIVEC
-	.macro err3
-300:
-	EX_TABLE(300b,.Ldo_err3)
-	.endm
-
-	.macro err4
-400:
-	EX_TABLE(400b,.Ldo_err4)
-	.endm
-
-
-.Ldo_err4:
-	ld	r16,STK_REG(R16)(r1)
-	ld	r15,STK_REG(R15)(r1)
-	ld	r14,STK_REG(R14)(r1)
-.Ldo_err3:
-	bl	CFUNC(exit_vmx_usercopy)
-	ld	r0,STACKFRAMESIZE+16(r1)
-	mtlr	r0
-	b	.Lexit
-#endif /* CONFIG_ALTIVEC */
-
-.Ldo_err2:
-	ld	r22,STK_REG(R22)(r1)
-	ld	r21,STK_REG(R21)(r1)
-	ld	r20,STK_REG(R20)(r1)
-	ld	r19,STK_REG(R19)(r1)
-	ld	r18,STK_REG(R18)(r1)
-	ld	r17,STK_REG(R17)(r1)
-	ld	r16,STK_REG(R16)(r1)
-	ld	r15,STK_REG(R15)(r1)
-	ld	r14,STK_REG(R14)(r1)
-.Lexit:
-	addi	r1,r1,STACKFRAMESIZE
-.Ldo_err1:
-	ld	r3,-STACKFRAMESIZE+STK_REG(R31)(r1)
-	ld	r4,-STACKFRAMESIZE+STK_REG(R30)(r1)
-	ld	r5,-STACKFRAMESIZE+STK_REG(R29)(r1)
-	b	__copy_tofrom_user_base
-
-
-_GLOBAL(__copy_tofrom_user_power7)
-	cmpldi	r5,16
-	cmpldi	cr1,r5,3328
-
-	std	r3,-STACKFRAMESIZE+STK_REG(R31)(r1)
-	std	r4,-STACKFRAMESIZE+STK_REG(R30)(r1)
-	std	r5,-STACKFRAMESIZE+STK_REG(R29)(r1)
-
-	blt	.Lshort_copy
-
-#ifdef CONFIG_ALTIVEC
-test_feature = SELFTEST_CASE
-BEGIN_FTR_SECTION
-	bgt	cr1,.Lvmx_copy
-END_FTR_SECTION_IFSET(CPU_FTR_ALTIVEC)
-#endif
-
-.Lnonvmx_copy:
-	/* Get the source 8B aligned */
-	neg	r6,r4
-	mtocrf	0x01,r6
-	clrldi	r6,r6,(64-3)
-
-	bf	cr7*4+3,1f
-err1;	lbz	r0,0(r4)
-	addi	r4,r4,1
-err1;	stb	r0,0(r3)
-	addi	r3,r3,1
-
-1:	bf	cr7*4+2,2f
-err1;	lhz	r0,0(r4)
-	addi	r4,r4,2
-err1;	sth	r0,0(r3)
-	addi	r3,r3,2
-
-2:	bf	cr7*4+1,3f
-err1;	lwz	r0,0(r4)
-	addi	r4,r4,4
-err1;	stw	r0,0(r3)
-	addi	r3,r3,4
-
-3:	sub	r5,r5,r6
-	cmpldi	r5,128
-	blt	5f
-
-	mflr	r0
-	stdu	r1,-STACKFRAMESIZE(r1)
-	std	r14,STK_REG(R14)(r1)
-	std	r15,STK_REG(R15)(r1)
-	std	r16,STK_REG(R16)(r1)
-	std	r17,STK_REG(R17)(r1)
-	std	r18,STK_REG(R18)(r1)
-	std	r19,STK_REG(R19)(r1)
-	std	r20,STK_REG(R20)(r1)
-	std	r21,STK_REG(R21)(r1)
-	std	r22,STK_REG(R22)(r1)
-	std	r0,STACKFRAMESIZE+16(r1)
-
-	srdi	r6,r5,7
-	mtctr	r6
-
-	/* Now do cacheline (128B) sized loads and stores. */
-	.align	5
-4:
-err2;	ld	r0,0(r4)
-err2;	ld	r6,8(r4)
-err2;	ld	r7,16(r4)
-err2;	ld	r8,24(r4)
-err2;	ld	r9,32(r4)
-err2;	ld	r10,40(r4)
-err2;	ld	r11,48(r4)
-err2;	ld	r12,56(r4)
-err2;	ld	r14,64(r4)
-err2;	ld	r15,72(r4)
-err2;	ld	r16,80(r4)
-err2;	ld	r17,88(r4)
-err2;	ld	r18,96(r4)
-err2;	ld	r19,104(r4)
-err2;	ld	r20,112(r4)
-err2;	ld	r21,120(r4)
-	addi	r4,r4,128
-err2;	std	r0,0(r3)
-err2;	std	r6,8(r3)
-err2;	std	r7,16(r3)
-err2;	std	r8,24(r3)
-err2;	std	r9,32(r3)
-err2;	std	r10,40(r3)
-err2;	std	r11,48(r3)
-err2;	std	r12,56(r3)
-err2;	std	r14,64(r3)
-err2;	std	r15,72(r3)
-err2;	std	r16,80(r3)
-err2;	std	r17,88(r3)
-err2;	std	r18,96(r3)
-err2;	std	r19,104(r3)
-err2;	std	r20,112(r3)
-err2;	std	r21,120(r3)
-	addi	r3,r3,128
-	bdnz	4b
-
-	clrldi	r5,r5,(64-7)
-
-	ld	r14,STK_REG(R14)(r1)
-	ld	r15,STK_REG(R15)(r1)
-	ld	r16,STK_REG(R16)(r1)
-	ld	r17,STK_REG(R17)(r1)
-	ld	r18,STK_REG(R18)(r1)
-	ld	r19,STK_REG(R19)(r1)
-	ld	r20,STK_REG(R20)(r1)
-	ld	r21,STK_REG(R21)(r1)
-	ld	r22,STK_REG(R22)(r1)
-	addi	r1,r1,STACKFRAMESIZE
-
-	/* Up to 127B to go */
-5:	srdi	r6,r5,4
-	mtocrf	0x01,r6
-
-6:	bf	cr7*4+1,7f
-err1;	ld	r0,0(r4)
-err1;	ld	r6,8(r4)
-err1;	ld	r7,16(r4)
-err1;	ld	r8,24(r4)
-err1;	ld	r9,32(r4)
-err1;	ld	r10,40(r4)
-err1;	ld	r11,48(r4)
-err1;	ld	r12,56(r4)
-	addi	r4,r4,64
-err1;	std	r0,0(r3)
-err1;	std	r6,8(r3)
-err1;	std	r7,16(r3)
-err1;	std	r8,24(r3)
-err1;	std	r9,32(r3)
-err1;	std	r10,40(r3)
-err1;	std	r11,48(r3)
-err1;	std	r12,56(r3)
-	addi	r3,r3,64
-
-	/* Up to 63B to go */
-7:	bf	cr7*4+2,8f
-err1;	ld	r0,0(r4)
-err1;	ld	r6,8(r4)
-err1;	ld	r7,16(r4)
-err1;	ld	r8,24(r4)
-	addi	r4,r4,32
-err1;	std	r0,0(r3)
-err1;	std	r6,8(r3)
-err1;	std	r7,16(r3)
-err1;	std	r8,24(r3)
-	addi	r3,r3,32
-
-	/* Up to 31B to go */
-8:	bf	cr7*4+3,9f
-err1;	ld	r0,0(r4)
-err1;	ld	r6,8(r4)
-	addi	r4,r4,16
-err1;	std	r0,0(r3)
-err1;	std	r6,8(r3)
-	addi	r3,r3,16
-
-9:	clrldi	r5,r5,(64-4)
-
-	/* Up to 15B to go */
-.Lshort_copy:
-	mtocrf	0x01,r5
-	bf	cr7*4+0,12f
-err1;	lwz	r0,0(r4)	/* Less chance of a reject with word ops */
-err1;	lwz	r6,4(r4)
-	addi	r4,r4,8
-err1;	stw	r0,0(r3)
-err1;	stw	r6,4(r3)
-	addi	r3,r3,8
-
-12:	bf	cr7*4+1,13f
-err1;	lwz	r0,0(r4)
-	addi	r4,r4,4
-err1;	stw	r0,0(r3)
-	addi	r3,r3,4
-
-13:	bf	cr7*4+2,14f
-err1;	lhz	r0,0(r4)
-	addi	r4,r4,2
-err1;	sth	r0,0(r3)
-	addi	r3,r3,2
-
-14:	bf	cr7*4+3,15f
-err1;	lbz	r0,0(r4)
-err1;	stb	r0,0(r3)
-
-15:	li	r3,0
-	blr
-
-.Lunwind_stack_nonvmx_copy:
-	addi	r1,r1,STACKFRAMESIZE
-	b	.Lnonvmx_copy
-
-.Lvmx_copy:
-#ifdef CONFIG_ALTIVEC
-	mflr	r0
-	std	r0,16(r1)
-	stdu	r1,-STACKFRAMESIZE(r1)
-	bl	CFUNC(enter_vmx_usercopy)
-	cmpwi	cr1,r3,0
-	ld	r0,STACKFRAMESIZE+16(r1)
-	ld	r3,STK_REG(R31)(r1)
-	ld	r4,STK_REG(R30)(r1)
-	ld	r5,STK_REG(R29)(r1)
-	mtlr	r0
-
-	/*
-	 * We prefetch both the source and destination using enhanced touch
-	 * instructions. We use a stream ID of 0 for the load side and
-	 * 1 for the store side.
-	 */
-	clrrdi	r6,r4,7
-	clrrdi	r9,r3,7
-	ori	r9,r9,1		/* stream=1 */
-
-	srdi	r7,r5,7		/* length in cachelines, capped at 0x3FF */
-	cmpldi	r7,0x3FF
-	ble	1f
-	li	r7,0x3FF
-1:	lis	r0,0x0E00	/* depth=7 */
-	sldi	r7,r7,7
-	or	r7,r7,r0
-	ori	r10,r7,1	/* stream=1 */
-
-	DCBT_SETUP_STREAMS(r6, r7, r9, r10, r8)
-
-	beq	cr1,.Lunwind_stack_nonvmx_copy
-
-	/*
-	 * If source and destination are not relatively aligned we use a
-	 * slower permute loop.
-	 */
-	xor	r6,r4,r3
-	rldicl.	r6,r6,0,(64-4)
-	bne	.Lvmx_unaligned_copy
-
-	/* Get the destination 16B aligned */
-	neg	r6,r3
-	mtocrf	0x01,r6
-	clrldi	r6,r6,(64-4)
-
-	bf	cr7*4+3,1f
-err3;	lbz	r0,0(r4)
-	addi	r4,r4,1
-err3;	stb	r0,0(r3)
-	addi	r3,r3,1
-
-1:	bf	cr7*4+2,2f
-err3;	lhz	r0,0(r4)
-	addi	r4,r4,2
-err3;	sth	r0,0(r3)
-	addi	r3,r3,2
-
-2:	bf	cr7*4+1,3f
-err3;	lwz	r0,0(r4)
-	addi	r4,r4,4
-err3;	stw	r0,0(r3)
-	addi	r3,r3,4
-
-3:	bf	cr7*4+0,4f
-err3;	ld	r0,0(r4)
-	addi	r4,r4,8
-err3;	std	r0,0(r3)
-	addi	r3,r3,8
-
-4:	sub	r5,r5,r6
-
-	/* Get the desination 128B aligned */
-	neg	r6,r3
-	srdi	r7,r6,4
-	mtocrf	0x01,r7
-	clrldi	r6,r6,(64-7)
-
-	li	r9,16
-	li	r10,32
-	li	r11,48
-
-	bf	cr7*4+3,5f
-err3;	lvx	v1,0,r4
-	addi	r4,r4,16
-err3;	stvx	v1,0,r3
-	addi	r3,r3,16
-
-5:	bf	cr7*4+2,6f
-err3;	lvx	v1,0,r4
-err3;	lvx	v0,r4,r9
-	addi	r4,r4,32
-err3;	stvx	v1,0,r3
-err3;	stvx	v0,r3,r9
-	addi	r3,r3,32
-
-6:	bf	cr7*4+1,7f
-err3;	lvx	v3,0,r4
-err3;	lvx	v2,r4,r9
-err3;	lvx	v1,r4,r10
-err3;	lvx	v0,r4,r11
-	addi	r4,r4,64
-err3;	stvx	v3,0,r3
-err3;	stvx	v2,r3,r9
-err3;	stvx	v1,r3,r10
-err3;	stvx	v0,r3,r11
-	addi	r3,r3,64
-
-7:	sub	r5,r5,r6
-	srdi	r6,r5,7
-
-	std	r14,STK_REG(R14)(r1)
-	std	r15,STK_REG(R15)(r1)
-	std	r16,STK_REG(R16)(r1)
-
-	li	r12,64
-	li	r14,80
-	li	r15,96
-	li	r16,112
-
-	mtctr	r6
-
-	/*
-	 * Now do cacheline sized loads and stores. By this stage the
-	 * cacheline stores are also cacheline aligned.
-	 */
-	.align	5
-8:
-err4;	lvx	v7,0,r4
-err4;	lvx	v6,r4,r9
-err4;	lvx	v5,r4,r10
-err4;	lvx	v4,r4,r11
-err4;	lvx	v3,r4,r12
-err4;	lvx	v2,r4,r14
-err4;	lvx	v1,r4,r15
-err4;	lvx	v0,r4,r16
-	addi	r4,r4,128
-err4;	stvx	v7,0,r3
-err4;	stvx	v6,r3,r9
-err4;	stvx	v5,r3,r10
-err4;	stvx	v4,r3,r11
-err4;	stvx	v3,r3,r12
-err4;	stvx	v2,r3,r14
-err4;	stvx	v1,r3,r15
-err4;	stvx	v0,r3,r16
-	addi	r3,r3,128
-	bdnz	8b
-
-	ld	r14,STK_REG(R14)(r1)
-	ld	r15,STK_REG(R15)(r1)
-	ld	r16,STK_REG(R16)(r1)
-
-	/* Up to 127B to go */
-	clrldi	r5,r5,(64-7)
-	srdi	r6,r5,4
-	mtocrf	0x01,r6
-
-	bf	cr7*4+1,9f
-err3;	lvx	v3,0,r4
-err3;	lvx	v2,r4,r9
-err3;	lvx	v1,r4,r10
-err3;	lvx	v0,r4,r11
-	addi	r4,r4,64
-err3;	stvx	v3,0,r3
-err3;	stvx	v2,r3,r9
-err3;	stvx	v1,r3,r10
-err3;	stvx	v0,r3,r11
-	addi	r3,r3,64
-
-9:	bf	cr7*4+2,10f
-err3;	lvx	v1,0,r4
-err3;	lvx	v0,r4,r9
-	addi	r4,r4,32
-err3;	stvx	v1,0,r3
-err3;	stvx	v0,r3,r9
-	addi	r3,r3,32
-
-10:	bf	cr7*4+3,11f
-err3;	lvx	v1,0,r4
-	addi	r4,r4,16
-err3;	stvx	v1,0,r3
-	addi	r3,r3,16
-
-	/* Up to 15B to go */
-11:	clrldi	r5,r5,(64-4)
-	mtocrf	0x01,r5
-	bf	cr7*4+0,12f
-err3;	ld	r0,0(r4)
-	addi	r4,r4,8
-err3;	std	r0,0(r3)
-	addi	r3,r3,8
-
-12:	bf	cr7*4+1,13f
-err3;	lwz	r0,0(r4)
-	addi	r4,r4,4
-err3;	stw	r0,0(r3)
-	addi	r3,r3,4
-
-13:	bf	cr7*4+2,14f
-err3;	lhz	r0,0(r4)
-	addi	r4,r4,2
-err3;	sth	r0,0(r3)
-	addi	r3,r3,2
-
-14:	bf	cr7*4+3,15f
-err3;	lbz	r0,0(r4)
-err3;	stb	r0,0(r3)
-
-15:	addi	r1,r1,STACKFRAMESIZE
-	b	CFUNC(exit_vmx_usercopy)	/* tail call optimise */
-
-.Lvmx_unaligned_copy:
-	/* Get the destination 16B aligned */
-	neg	r6,r3
-	mtocrf	0x01,r6
-	clrldi	r6,r6,(64-4)
-
-	bf	cr7*4+3,1f
-err3;	lbz	r0,0(r4)
-	addi	r4,r4,1
-err3;	stb	r0,0(r3)
-	addi	r3,r3,1
-
-1:	bf	cr7*4+2,2f
-err3;	lhz	r0,0(r4)
-	addi	r4,r4,2
-err3;	sth	r0,0(r3)
-	addi	r3,r3,2
-
-2:	bf	cr7*4+1,3f
-err3;	lwz	r0,0(r4)
-	addi	r4,r4,4
-err3;	stw	r0,0(r3)
-	addi	r3,r3,4
-
-3:	bf	cr7*4+0,4f
-err3;	lwz	r0,0(r4)	/* Less chance of a reject with word ops */
-err3;	lwz	r7,4(r4)
-	addi	r4,r4,8
-err3;	stw	r0,0(r3)
-err3;	stw	r7,4(r3)
-	addi	r3,r3,8
-
-4:	sub	r5,r5,r6
-
-	/* Get the desination 128B aligned */
-	neg	r6,r3
-	srdi	r7,r6,4
-	mtocrf	0x01,r7
-	clrldi	r6,r6,(64-7)
-
-	li	r9,16
-	li	r10,32
-	li	r11,48
-
-	LVS(v16,0,r4)		/* Setup permute control vector */
-err3;	lvx	v0,0,r4
-	addi	r4,r4,16
-
-	bf	cr7*4+3,5f
-err3;	lvx	v1,0,r4
-	VPERM(v8,v0,v1,v16)
-	addi	r4,r4,16
-err3;	stvx	v8,0,r3
-	addi	r3,r3,16
-	vor	v0,v1,v1
-
-5:	bf	cr7*4+2,6f
-err3;	lvx	v1,0,r4
-	VPERM(v8,v0,v1,v16)
-err3;	lvx	v0,r4,r9
-	VPERM(v9,v1,v0,v16)
-	addi	r4,r4,32
-err3;	stvx	v8,0,r3
-err3;	stvx	v9,r3,r9
-	addi	r3,r3,32
-
-6:	bf	cr7*4+1,7f
-err3;	lvx	v3,0,r4
-	VPERM(v8,v0,v3,v16)
-err3;	lvx	v2,r4,r9
-	VPERM(v9,v3,v2,v16)
-err3;	lvx	v1,r4,r10
-	VPERM(v10,v2,v1,v16)
-err3;	lvx	v0,r4,r11
-	VPERM(v11,v1,v0,v16)
-	addi	r4,r4,64
-err3;	stvx	v8,0,r3
-err3;	stvx	v9,r3,r9
-err3;	stvx	v10,r3,r10
-err3;	stvx	v11,r3,r11
-	addi	r3,r3,64
-
-7:	sub	r5,r5,r6
-	srdi	r6,r5,7
-
-	std	r14,STK_REG(R14)(r1)
-	std	r15,STK_REG(R15)(r1)
-	std	r16,STK_REG(R16)(r1)
-
-	li	r12,64
-	li	r14,80
-	li	r15,96
-	li	r16,112
-
-	mtctr	r6
-
-	/*
-	 * Now do cacheline sized loads and stores. By this stage the
-	 * cacheline stores are also cacheline aligned.
-	 */
-	.align	5
-8:
-err4;	lvx	v7,0,r4
-	VPERM(v8,v0,v7,v16)
-err4;	lvx	v6,r4,r9
-	VPERM(v9,v7,v6,v16)
-err4;	lvx	v5,r4,r10
-	VPERM(v10,v6,v5,v16)
-err4;	lvx	v4,r4,r11
-	VPERM(v11,v5,v4,v16)
-err4;	lvx	v3,r4,r12
-	VPERM(v12,v4,v3,v16)
-err4;	lvx	v2,r4,r14
-	VPERM(v13,v3,v2,v16)
-err4;	lvx	v1,r4,r15
-	VPERM(v14,v2,v1,v16)
-err4;	lvx	v0,r4,r16
-	VPERM(v15,v1,v0,v16)
-	addi	r4,r4,128
-err4;	stvx	v8,0,r3
-err4;	stvx	v9,r3,r9
-err4;	stvx	v10,r3,r10
-err4;	stvx	v11,r3,r11
-err4;	stvx	v12,r3,r12
-err4;	stvx	v13,r3,r14
-err4;	stvx	v14,r3,r15
-err4;	stvx	v15,r3,r16
-	addi	r3,r3,128
-	bdnz	8b
-
-	ld	r14,STK_REG(R14)(r1)
-	ld	r15,STK_REG(R15)(r1)
-	ld	r16,STK_REG(R16)(r1)
-
-	/* Up to 127B to go */
-	clrldi	r5,r5,(64-7)
-	srdi	r6,r5,4
-	mtocrf	0x01,r6
-
-	bf	cr7*4+1,9f
-err3;	lvx	v3,0,r4
-	VPERM(v8,v0,v3,v16)
-err3;	lvx	v2,r4,r9
-	VPERM(v9,v3,v2,v16)
-err3;	lvx	v1,r4,r10
-	VPERM(v10,v2,v1,v16)
-err3;	lvx	v0,r4,r11
-	VPERM(v11,v1,v0,v16)
-	addi	r4,r4,64
-err3;	stvx	v8,0,r3
-err3;	stvx	v9,r3,r9
-err3;	stvx	v10,r3,r10
-err3;	stvx	v11,r3,r11
-	addi	r3,r3,64
-
-9:	bf	cr7*4+2,10f
-err3;	lvx	v1,0,r4
-	VPERM(v8,v0,v1,v16)
-err3;	lvx	v0,r4,r9
-	VPERM(v9,v1,v0,v16)
-	addi	r4,r4,32
-err3;	stvx	v8,0,r3
-err3;	stvx	v9,r3,r9
-	addi	r3,r3,32
-
-10:	bf	cr7*4+3,11f
-err3;	lvx	v1,0,r4
-	VPERM(v8,v0,v1,v16)
-	addi	r4,r4,16
-err3;	stvx	v8,0,r3
-	addi	r3,r3,16
-
-	/* Up to 15B to go */
-11:	clrldi	r5,r5,(64-4)
-	addi	r4,r4,-16	/* Unwind the +16 load offset */
-	mtocrf	0x01,r5
-	bf	cr7*4+0,12f
-err3;	lwz	r0,0(r4)	/* Less chance of a reject with word ops */
-err3;	lwz	r6,4(r4)
-	addi	r4,r4,8
-err3;	stw	r0,0(r3)
-err3;	stw	r6,4(r3)
-	addi	r3,r3,8
-
-12:	bf	cr7*4+1,13f
-err3;	lwz	r0,0(r4)
-	addi	r4,r4,4
-err3;	stw	r0,0(r3)
-	addi	r3,r3,4
-
-13:	bf	cr7*4+2,14f
-err3;	lhz	r0,0(r4)
-	addi	r4,r4,2
-err3;	sth	r0,0(r3)
-	addi	r3,r3,2
-
-14:	bf	cr7*4+3,15f
-err3;	lbz	r0,0(r4)
-err3;	stb	r0,0(r3)
-
-15:	addi	r1,r1,STACKFRAMESIZE
-	b	CFUNC(exit_vmx_usercopy)	/* tail call optimise */
-#endif /* CONFIG_ALTIVEC */
+../../../../../arch/powerpc/lib/copyuser_power7.S
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/testing/selftests/powerpc/copyloops/mem_64.S linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/copyloops/mem_64.S
--- linux-6.16.6/tools/testing/selftests/powerpc/copyloops/mem_64.S	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/copyloops/mem_64.S	2025-09-11 09:47:42.000000000 -0600
@@ -1,142 +1 @@
-/* SPDX-License-Identifier: GPL-2.0-or-later */
-/*
- * String handling functions for PowerPC.
- *
- * Copyright (C) 1996 Paul Mackerras.
- */
-#include <linux/export.h>
-#include <asm/processor.h>
-#include <asm/errno.h>
-#include <asm/ppc_asm.h>
-#include <asm/kasan.h>
-
-#ifndef CONFIG_KASAN
-_GLOBAL(__memset16)
-	rlwimi	r4,r4,16,0,15
-	/* fall through */
-
-_GLOBAL(__memset32)
-	rldimi	r4,r4,32,0
-	/* fall through */
-
-_GLOBAL(__memset64)
-	neg	r0,r3
-	andi.	r0,r0,7
-	cmplw	cr1,r5,r0
-	b	.Lms
-EXPORT_SYMBOL(__memset16)
-EXPORT_SYMBOL(__memset32)
-EXPORT_SYMBOL(__memset64)
-#endif
-
-_GLOBAL_KASAN(memset)
-	neg	r0,r3
-	rlwimi	r4,r4,8,16,23
-	andi.	r0,r0,7			/* # bytes to be 8-byte aligned */
-	rlwimi	r4,r4,16,0,15
-	cmplw	cr1,r5,r0		/* do we get that far? */
-	rldimi	r4,r4,32,0
-.Lms:	PPC_MTOCRF(1,r0)
-	mr	r6,r3
-	blt	cr1,8f
-	beq	3f			/* if already 8-byte aligned */
-	subf	r5,r0,r5
-	bf	31,1f
-	stb	r4,0(r6)
-	addi	r6,r6,1
-1:	bf	30,2f
-	sth	r4,0(r6)
-	addi	r6,r6,2
-2:	bf	29,3f
-	stw	r4,0(r6)
-	addi	r6,r6,4
-3:	srdi.	r0,r5,6
-	clrldi	r5,r5,58
-	mtctr	r0
-	beq	5f
-	.balign 16
-4:	std	r4,0(r6)
-	std	r4,8(r6)
-	std	r4,16(r6)
-	std	r4,24(r6)
-	std	r4,32(r6)
-	std	r4,40(r6)
-	std	r4,48(r6)
-	std	r4,56(r6)
-	addi	r6,r6,64
-	bdnz	4b
-5:	srwi.	r0,r5,3
-	clrlwi	r5,r5,29
-	PPC_MTOCRF(1,r0)
-	beq	8f
-	bf	29,6f
-	std	r4,0(r6)
-	std	r4,8(r6)
-	std	r4,16(r6)
-	std	r4,24(r6)
-	addi	r6,r6,32
-6:	bf	30,7f
-	std	r4,0(r6)
-	std	r4,8(r6)
-	addi	r6,r6,16
-7:	bf	31,8f
-	std	r4,0(r6)
-	addi	r6,r6,8
-8:	cmpwi	r5,0
-	PPC_MTOCRF(1,r5)
-	beqlr
-	bf	29,9f
-	stw	r4,0(r6)
-	addi	r6,r6,4
-9:	bf	30,10f
-	sth	r4,0(r6)
-	addi	r6,r6,2
-10:	bflr	31
-	stb	r4,0(r6)
-	blr
-EXPORT_SYMBOL(memset)
-EXPORT_SYMBOL_KASAN(memset)
-
-_GLOBAL_TOC_KASAN(memmove)
-	cmplw	0,r3,r4
-	bgt	backwards_memcpy
-	b	memcpy
-
-_GLOBAL(backwards_memcpy)
-	rlwinm.	r7,r5,32-3,3,31		/* r0 = r5 >> 3 */
-	add	r6,r3,r5
-	add	r4,r4,r5
-	beq	2f
-	andi.	r0,r6,3
-	mtctr	r7
-	bne	5f
-	.balign 16
-1:	lwz	r7,-4(r4)
-	lwzu	r8,-8(r4)
-	stw	r7,-4(r6)
-	stwu	r8,-8(r6)
-	bdnz	1b
-	andi.	r5,r5,7
-2:	cmplwi	0,r5,4
-	blt	3f
-	lwzu	r0,-4(r4)
-	subi	r5,r5,4
-	stwu	r0,-4(r6)
-3:	cmpwi	0,r5,0
-	beqlr
-	mtctr	r5
-4:	lbzu	r0,-1(r4)
-	stbu	r0,-1(r6)
-	bdnz	4b
-	blr
-5:	mtctr	r0
-6:	lbzu	r7,-1(r4)
-	stbu	r7,-1(r6)
-	bdnz	6b
-	subf	r5,r0,r5
-	rlwinm.	r7,r5,32-3,3,31
-	beq	2b
-	mtctr	r7
-	b	1b
-EXPORT_SYMBOL(memmove)
-EXPORT_SYMBOL_KASAN(memmove)
+../../../../../arch/powerpc/lib/mem_64.S
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/testing/selftests/powerpc/copyloops/memcpy_64.S linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/copyloops/memcpy_64.S
--- linux-6.16.6/tools/testing/selftests/powerpc/copyloops/memcpy_64.S	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/copyloops/memcpy_64.S	2025-09-11 09:47:42.000000000 -0600
@@ -1,230 +1 @@
-/* SPDX-License-Identifier: GPL-2.0-or-later */
-/*
- * Copyright (C) 2002 Paul Mackerras, IBM Corp.
- */
-#include <linux/export.h>
-#include <asm/processor.h>
-#include <asm/ppc_asm.h>
-#include <asm/asm-compat.h>
-#include <asm/feature-fixups.h>
-#include <asm/kasan.h>
-
-#ifndef SELFTEST_CASE
-/* For big-endian, 0 == most CPUs, 1 == POWER6, 2 == Cell */
-#define SELFTEST_CASE	0
-#endif
-
-	.align	7
-_GLOBAL_TOC_KASAN(memcpy)
-BEGIN_FTR_SECTION
-#ifdef __LITTLE_ENDIAN__
-	cmpdi	cr7,r5,0
-#else
-	std	r3,-STACKFRAMESIZE+STK_REG(R31)(r1)	/* save destination pointer for return value */
-#endif
-FTR_SECTION_ELSE
-#ifdef CONFIG_PPC_BOOK3S_64
-	b	memcpy_power7
-#endif
-ALT_FTR_SECTION_END_IFCLR(CPU_FTR_VMX_COPY)
-#ifdef __LITTLE_ENDIAN__
-	/* dumb little-endian memcpy that will get replaced at runtime */
-	addi r9,r3,-1
-	addi r4,r4,-1
-	beqlr cr7
-	mtctr r5
-1:	lbzu r10,1(r4)
-	stbu r10,1(r9)
-	bdnz 1b
-	blr
-#else
-	PPC_MTOCRF(0x01,r5)
-	cmpldi	cr1,r5,16
-	neg	r6,r3		# LS 3 bits = # bytes to 8-byte dest bdry
-	andi.	r6,r6,7
-	dcbt	0,r4
-	blt	cr1,.Lshort_copy
-/* Below we want to nop out the bne if we're on a CPU that has the
-   CPU_FTR_UNALIGNED_LD_STD bit set and the CPU_FTR_CP_USE_DCBTZ bit
-   cleared.
-   At the time of writing the only CPU that has this combination of bits
-   set is Power6. */
-test_feature = (SELFTEST_CASE == 1)
-BEGIN_FTR_SECTION
-	nop
-FTR_SECTION_ELSE
-	bne	.Ldst_unaligned
-ALT_FTR_SECTION_END(CPU_FTR_UNALIGNED_LD_STD | CPU_FTR_CP_USE_DCBTZ, \
-                    CPU_FTR_UNALIGNED_LD_STD)
-.Ldst_aligned:
-	addi	r3,r3,-16
-test_feature = (SELFTEST_CASE == 0)
-BEGIN_FTR_SECTION
-	andi.	r0,r4,7
-	bne	.Lsrc_unaligned
-END_FTR_SECTION_IFCLR(CPU_FTR_UNALIGNED_LD_STD)
-	srdi	r7,r5,4
-	ld	r9,0(r4)
-	addi	r4,r4,-8
-	mtctr	r7
-	andi.	r5,r5,7
-	bf	cr7*4+0,2f
-	addi	r3,r3,8
-	addi	r4,r4,8
-	mr	r8,r9
-	blt	cr1,3f
-1:	ld	r9,8(r4)
-	std	r8,8(r3)
-2:	ldu	r8,16(r4)
-	stdu	r9,16(r3)
-	bdnz	1b
-3:	std	r8,8(r3)
-	beq	3f
-	addi	r3,r3,16
-.Ldo_tail:
-	bf	cr7*4+1,1f
-	lwz	r9,8(r4)
-	addi	r4,r4,4
-	stw	r9,0(r3)
-	addi	r3,r3,4
-1:	bf	cr7*4+2,2f
-	lhz	r9,8(r4)
-	addi	r4,r4,2
-	sth	r9,0(r3)
-	addi	r3,r3,2
-2:	bf	cr7*4+3,3f
-	lbz	r9,8(r4)
-	stb	r9,0(r3)
-3:	ld	r3,-STACKFRAMESIZE+STK_REG(R31)(r1)	/* return dest pointer */
-	blr
-
-.Lsrc_unaligned:
-	srdi	r6,r5,3
-	addi	r5,r5,-16
-	subf	r4,r0,r4
-	srdi	r7,r5,4
-	sldi	r10,r0,3
-	cmpdi	cr6,r6,3
-	andi.	r5,r5,7
-	mtctr	r7
-	subfic	r11,r10,64
-	add	r5,r5,r0
-
-	bt	cr7*4+0,0f
-
-	ld	r9,0(r4)	# 3+2n loads, 2+2n stores
-	ld	r0,8(r4)
-	sld	r6,r9,r10
-	ldu	r9,16(r4)
-	srd	r7,r0,r11
-	sld	r8,r0,r10
-	or	r7,r7,r6
-	blt	cr6,4f
-	ld	r0,8(r4)
-	# s1<< in r8, d0=(s0<<|s1>>) in r7, s3 in r0, s2 in r9, nix in r6 & r12
-	b	2f
-
-0:	ld	r0,0(r4)	# 4+2n loads, 3+2n stores
-	ldu	r9,8(r4)
-	sld	r8,r0,r10
-	addi	r3,r3,-8
-	blt	cr6,5f
-	ld	r0,8(r4)
-	srd	r12,r9,r11
-	sld	r6,r9,r10
-	ldu	r9,16(r4)
-	or	r12,r8,r12
-	srd	r7,r0,r11
-	sld	r8,r0,r10
-	addi	r3,r3,16
-	beq	cr6,3f
-
-	# d0=(s0<<|s1>>) in r12, s1<< in r6, s2>> in r7, s2<< in r8, s3 in r9
-1:	or	r7,r7,r6
-	ld	r0,8(r4)
-	std	r12,8(r3)
-2:	srd	r12,r9,r11
-	sld	r6,r9,r10
-	ldu	r9,16(r4)
-	or	r12,r8,r12
-	stdu	r7,16(r3)
-	srd	r7,r0,r11
-	sld	r8,r0,r10
-	bdnz	1b
-
-3:	std	r12,8(r3)
-	or	r7,r7,r6
-4:	std	r7,16(r3)
-5:	srd	r12,r9,r11
-	or	r12,r8,r12
-	std	r12,24(r3)
-	beq	4f
-	cmpwi	cr1,r5,8
-	addi	r3,r3,32
-	sld	r9,r9,r10
-	ble	cr1,6f
-	ld	r0,8(r4)
-	srd	r7,r0,r11
-	or	r9,r7,r9
-6:
-	bf	cr7*4+1,1f
-	rotldi	r9,r9,32
-	stw	r9,0(r3)
-	addi	r3,r3,4
-1:	bf	cr7*4+2,2f
-	rotldi	r9,r9,16
-	sth	r9,0(r3)
-	addi	r3,r3,2
-2:	bf	cr7*4+3,3f
-	rotldi	r9,r9,8
-	stb	r9,0(r3)
-3:	ld	r3,-STACKFRAMESIZE+STK_REG(R31)(r1)	/* return dest pointer */
-	blr
-
-.Ldst_unaligned:
-	PPC_MTOCRF(0x01,r6)		# put #bytes to 8B bdry into cr7
-	subf	r5,r6,r5
-	li	r7,0
-	cmpldi	cr1,r5,16
-	bf	cr7*4+3,1f
-	lbz	r0,0(r4)
-	stb	r0,0(r3)
-	addi	r7,r7,1
-1:	bf	cr7*4+2,2f
-	lhzx	r0,r7,r4
-	sthx	r0,r7,r3
-	addi	r7,r7,2
-2:	bf	cr7*4+1,3f
-	lwzx	r0,r7,r4
-	stwx	r0,r7,r3
-3:	PPC_MTOCRF(0x01,r5)
-	add	r4,r6,r4
-	add	r3,r6,r3
-	b	.Ldst_aligned
-
-.Lshort_copy:
-	bf	cr7*4+0,1f
-	lwz	r0,0(r4)
-	lwz	r9,4(r4)
-	addi	r4,r4,8
-	stw	r0,0(r3)
-	stw	r9,4(r3)
-	addi	r3,r3,8
-1:	bf	cr7*4+1,2f
-	lwz	r0,0(r4)
-	addi	r4,r4,4
-	stw	r0,0(r3)
-	addi	r3,r3,4
-2:	bf	cr7*4+2,3f
-	lhz	r0,0(r4)
-	addi	r4,r4,2
-	sth	r0,0(r3)
-	addi	r3,r3,2
-3:	bf	cr7*4+3,4f
-	lbz	r0,0(r4)
-	stb	r0,0(r3)
-4:	ld	r3,-STACKFRAMESIZE+STK_REG(R31)(r1)	/* return dest pointer */
-	blr
-#endif
-EXPORT_SYMBOL(memcpy)
-EXPORT_SYMBOL_KASAN(memcpy)
+../../../../../arch/powerpc/lib/memcpy_64.S
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/testing/selftests/powerpc/copyloops/memcpy_power7.S linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/copyloops/memcpy_power7.S
--- linux-6.16.6/tools/testing/selftests/powerpc/copyloops/memcpy_power7.S	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/copyloops/memcpy_power7.S	2025-09-11 09:47:42.000000000 -0600
@@ -1,633 +1 @@
-/* SPDX-License-Identifier: GPL-2.0-or-later */
-/*
- *
- * Copyright (C) IBM Corporation, 2012
- *
- * Author: Anton Blanchard <anton@au.ibm.com>
- */
-#include <asm/ppc_asm.h>
-
-#ifndef SELFTEST_CASE
-/* 0 == don't use VMX, 1 == use VMX */
-#define SELFTEST_CASE	0
-#endif
-
-#ifdef __BIG_ENDIAN__
-#define LVS(VRT,RA,RB)		lvsl	VRT,RA,RB
-#define VPERM(VRT,VRA,VRB,VRC)	vperm	VRT,VRA,VRB,VRC
-#else
-#define LVS(VRT,RA,RB)		lvsr	VRT,RA,RB
-#define VPERM(VRT,VRA,VRB,VRC)	vperm	VRT,VRB,VRA,VRC
-#endif
-
-_GLOBAL(memcpy_power7)
-	cmpldi	r5,16
-	cmpldi	cr1,r5,4096
-	std	r3,-STACKFRAMESIZE+STK_REG(R31)(r1)
-	blt	.Lshort_copy
-
-#ifdef CONFIG_ALTIVEC
-test_feature = SELFTEST_CASE
-BEGIN_FTR_SECTION
-	bgt	cr1, .Lvmx_copy
-END_FTR_SECTION_IFSET(CPU_FTR_ALTIVEC)
-#endif
-
-.Lnonvmx_copy:
-	/* Get the source 8B aligned */
-	neg	r6,r4
-	mtocrf	0x01,r6
-	clrldi	r6,r6,(64-3)
-
-	bf	cr7*4+3,1f
-	lbz	r0,0(r4)
-	addi	r4,r4,1
-	stb	r0,0(r3)
-	addi	r3,r3,1
-
-1:	bf	cr7*4+2,2f
-	lhz	r0,0(r4)
-	addi	r4,r4,2
-	sth	r0,0(r3)
-	addi	r3,r3,2
-
-2:	bf	cr7*4+1,3f
-	lwz	r0,0(r4)
-	addi	r4,r4,4
-	stw	r0,0(r3)
-	addi	r3,r3,4
-
-3:	sub	r5,r5,r6
-	cmpldi	r5,128
-	blt	5f
-
-	mflr	r0
-	stdu	r1,-STACKFRAMESIZE(r1)
-	std	r14,STK_REG(R14)(r1)
-	std	r15,STK_REG(R15)(r1)
-	std	r16,STK_REG(R16)(r1)
-	std	r17,STK_REG(R17)(r1)
-	std	r18,STK_REG(R18)(r1)
-	std	r19,STK_REG(R19)(r1)
-	std	r20,STK_REG(R20)(r1)
-	std	r21,STK_REG(R21)(r1)
-	std	r22,STK_REG(R22)(r1)
-	std	r0,STACKFRAMESIZE+16(r1)
-
-	srdi	r6,r5,7
-	mtctr	r6
-
-	/* Now do cacheline (128B) sized loads and stores. */
-	.align	5
-4:
-	ld	r0,0(r4)
-	ld	r6,8(r4)
-	ld	r7,16(r4)
-	ld	r8,24(r4)
-	ld	r9,32(r4)
-	ld	r10,40(r4)
-	ld	r11,48(r4)
-	ld	r12,56(r4)
-	ld	r14,64(r4)
-	ld	r15,72(r4)
-	ld	r16,80(r4)
-	ld	r17,88(r4)
-	ld	r18,96(r4)
-	ld	r19,104(r4)
-	ld	r20,112(r4)
-	ld	r21,120(r4)
-	addi	r4,r4,128
-	std	r0,0(r3)
-	std	r6,8(r3)
-	std	r7,16(r3)
-	std	r8,24(r3)
-	std	r9,32(r3)
-	std	r10,40(r3)
-	std	r11,48(r3)
-	std	r12,56(r3)
-	std	r14,64(r3)
-	std	r15,72(r3)
-	std	r16,80(r3)
-	std	r17,88(r3)
-	std	r18,96(r3)
-	std	r19,104(r3)
-	std	r20,112(r3)
-	std	r21,120(r3)
-	addi	r3,r3,128
-	bdnz	4b
-
-	clrldi	r5,r5,(64-7)
-
-	ld	r14,STK_REG(R14)(r1)
-	ld	r15,STK_REG(R15)(r1)
-	ld	r16,STK_REG(R16)(r1)
-	ld	r17,STK_REG(R17)(r1)
-	ld	r18,STK_REG(R18)(r1)
-	ld	r19,STK_REG(R19)(r1)
-	ld	r20,STK_REG(R20)(r1)
-	ld	r21,STK_REG(R21)(r1)
-	ld	r22,STK_REG(R22)(r1)
-	addi	r1,r1,STACKFRAMESIZE
-
-	/* Up to 127B to go */
-5:	srdi	r6,r5,4
-	mtocrf	0x01,r6
-
-6:	bf	cr7*4+1,7f
-	ld	r0,0(r4)
-	ld	r6,8(r4)
-	ld	r7,16(r4)
-	ld	r8,24(r4)
-	ld	r9,32(r4)
-	ld	r10,40(r4)
-	ld	r11,48(r4)
-	ld	r12,56(r4)
-	addi	r4,r4,64
-	std	r0,0(r3)
-	std	r6,8(r3)
-	std	r7,16(r3)
-	std	r8,24(r3)
-	std	r9,32(r3)
-	std	r10,40(r3)
-	std	r11,48(r3)
-	std	r12,56(r3)
-	addi	r3,r3,64
-
-	/* Up to 63B to go */
-7:	bf	cr7*4+2,8f
-	ld	r0,0(r4)
-	ld	r6,8(r4)
-	ld	r7,16(r4)
-	ld	r8,24(r4)
-	addi	r4,r4,32
-	std	r0,0(r3)
-	std	r6,8(r3)
-	std	r7,16(r3)
-	std	r8,24(r3)
-	addi	r3,r3,32
-
-	/* Up to 31B to go */
-8:	bf	cr7*4+3,9f
-	ld	r0,0(r4)
-	ld	r6,8(r4)
-	addi	r4,r4,16
-	std	r0,0(r3)
-	std	r6,8(r3)
-	addi	r3,r3,16
-
-9:	clrldi	r5,r5,(64-4)
-
-	/* Up to 15B to go */
-.Lshort_copy:
-	mtocrf	0x01,r5
-	bf	cr7*4+0,12f
-	lwz	r0,0(r4)	/* Less chance of a reject with word ops */
-	lwz	r6,4(r4)
-	addi	r4,r4,8
-	stw	r0,0(r3)
-	stw	r6,4(r3)
-	addi	r3,r3,8
-
-12:	bf	cr7*4+1,13f
-	lwz	r0,0(r4)
-	addi	r4,r4,4
-	stw	r0,0(r3)
-	addi	r3,r3,4
-
-13:	bf	cr7*4+2,14f
-	lhz	r0,0(r4)
-	addi	r4,r4,2
-	sth	r0,0(r3)
-	addi	r3,r3,2
-
-14:	bf	cr7*4+3,15f
-	lbz	r0,0(r4)
-	stb	r0,0(r3)
-
-15:	ld	r3,-STACKFRAMESIZE+STK_REG(R31)(r1)
-	blr
-
-.Lunwind_stack_nonvmx_copy:
-	addi	r1,r1,STACKFRAMESIZE
-	b	.Lnonvmx_copy
-
-.Lvmx_copy:
-#ifdef CONFIG_ALTIVEC
-	mflr	r0
-	std	r4,-STACKFRAMESIZE+STK_REG(R30)(r1)
-	std	r5,-STACKFRAMESIZE+STK_REG(R29)(r1)
-	std	r0,16(r1)
-	stdu	r1,-STACKFRAMESIZE(r1)
-	bl	CFUNC(enter_vmx_ops)
-	cmpwi	cr1,r3,0
-	ld	r0,STACKFRAMESIZE+16(r1)
-	ld	r3,STK_REG(R31)(r1)
-	ld	r4,STK_REG(R30)(r1)
-	ld	r5,STK_REG(R29)(r1)
-	mtlr	r0
-
-	/*
-	 * We prefetch both the source and destination using enhanced touch
-	 * instructions. We use a stream ID of 0 for the load side and
-	 * 1 for the store side.
-	 */
-	clrrdi	r6,r4,7
-	clrrdi	r9,r3,7
-	ori	r9,r9,1		/* stream=1 */
-
-	srdi	r7,r5,7		/* length in cachelines, capped at 0x3FF */
-	cmpldi	r7,0x3FF
-	ble	1f
-	li	r7,0x3FF
-1:	lis	r0,0x0E00	/* depth=7 */
-	sldi	r7,r7,7
-	or	r7,r7,r0
-	ori	r10,r7,1	/* stream=1 */
-
-	DCBT_SETUP_STREAMS(r6, r7, r9, r10, r8)
-
-	beq	cr1,.Lunwind_stack_nonvmx_copy
-
-	/*
-	 * If source and destination are not relatively aligned we use a
-	 * slower permute loop.
-	 */
-	xor	r6,r4,r3
-	rldicl.	r6,r6,0,(64-4)
-	bne	.Lvmx_unaligned_copy
-
-	/* Get the destination 16B aligned */
-	neg	r6,r3
-	mtocrf	0x01,r6
-	clrldi	r6,r6,(64-4)
-
-	bf	cr7*4+3,1f
-	lbz	r0,0(r4)
-	addi	r4,r4,1
-	stb	r0,0(r3)
-	addi	r3,r3,1
-
-1:	bf	cr7*4+2,2f
-	lhz	r0,0(r4)
-	addi	r4,r4,2
-	sth	r0,0(r3)
-	addi	r3,r3,2
-
-2:	bf	cr7*4+1,3f
-	lwz	r0,0(r4)
-	addi	r4,r4,4
-	stw	r0,0(r3)
-	addi	r3,r3,4
-
-3:	bf	cr7*4+0,4f
-	ld	r0,0(r4)
-	addi	r4,r4,8
-	std	r0,0(r3)
-	addi	r3,r3,8
-
-4:	sub	r5,r5,r6
-
-	/* Get the desination 128B aligned */
-	neg	r6,r3
-	srdi	r7,r6,4
-	mtocrf	0x01,r7
-	clrldi	r6,r6,(64-7)
-
-	li	r9,16
-	li	r10,32
-	li	r11,48
-
-	bf	cr7*4+3,5f
-	lvx	v1,0,r4
-	addi	r4,r4,16
-	stvx	v1,0,r3
-	addi	r3,r3,16
-
-5:	bf	cr7*4+2,6f
-	lvx	v1,0,r4
-	lvx	v0,r4,r9
-	addi	r4,r4,32
-	stvx	v1,0,r3
-	stvx	v0,r3,r9
-	addi	r3,r3,32
-
-6:	bf	cr7*4+1,7f
-	lvx	v3,0,r4
-	lvx	v2,r4,r9
-	lvx	v1,r4,r10
-	lvx	v0,r4,r11
-	addi	r4,r4,64
-	stvx	v3,0,r3
-	stvx	v2,r3,r9
-	stvx	v1,r3,r10
-	stvx	v0,r3,r11
-	addi	r3,r3,64
-
-7:	sub	r5,r5,r6
-	srdi	r6,r5,7
-
-	std	r14,STK_REG(R14)(r1)
-	std	r15,STK_REG(R15)(r1)
-	std	r16,STK_REG(R16)(r1)
-
-	li	r12,64
-	li	r14,80
-	li	r15,96
-	li	r16,112
-
-	mtctr	r6
-
-	/*
-	 * Now do cacheline sized loads and stores. By this stage the
-	 * cacheline stores are also cacheline aligned.
-	 */
-	.align	5
-8:
-	lvx	v7,0,r4
-	lvx	v6,r4,r9
-	lvx	v5,r4,r10
-	lvx	v4,r4,r11
-	lvx	v3,r4,r12
-	lvx	v2,r4,r14
-	lvx	v1,r4,r15
-	lvx	v0,r4,r16
-	addi	r4,r4,128
-	stvx	v7,0,r3
-	stvx	v6,r3,r9
-	stvx	v5,r3,r10
-	stvx	v4,r3,r11
-	stvx	v3,r3,r12
-	stvx	v2,r3,r14
-	stvx	v1,r3,r15
-	stvx	v0,r3,r16
-	addi	r3,r3,128
-	bdnz	8b
-
-	ld	r14,STK_REG(R14)(r1)
-	ld	r15,STK_REG(R15)(r1)
-	ld	r16,STK_REG(R16)(r1)
-
-	/* Up to 127B to go */
-	clrldi	r5,r5,(64-7)
-	srdi	r6,r5,4
-	mtocrf	0x01,r6
-
-	bf	cr7*4+1,9f
-	lvx	v3,0,r4
-	lvx	v2,r4,r9
-	lvx	v1,r4,r10
-	lvx	v0,r4,r11
-	addi	r4,r4,64
-	stvx	v3,0,r3
-	stvx	v2,r3,r9
-	stvx	v1,r3,r10
-	stvx	v0,r3,r11
-	addi	r3,r3,64
-
-9:	bf	cr7*4+2,10f
-	lvx	v1,0,r4
-	lvx	v0,r4,r9
-	addi	r4,r4,32
-	stvx	v1,0,r3
-	stvx	v0,r3,r9
-	addi	r3,r3,32
-
-10:	bf	cr7*4+3,11f
-	lvx	v1,0,r4
-	addi	r4,r4,16
-	stvx	v1,0,r3
-	addi	r3,r3,16
-
-	/* Up to 15B to go */
-11:	clrldi	r5,r5,(64-4)
-	mtocrf	0x01,r5
-	bf	cr7*4+0,12f
-	ld	r0,0(r4)
-	addi	r4,r4,8
-	std	r0,0(r3)
-	addi	r3,r3,8
-
-12:	bf	cr7*4+1,13f
-	lwz	r0,0(r4)
-	addi	r4,r4,4
-	stw	r0,0(r3)
-	addi	r3,r3,4
-
-13:	bf	cr7*4+2,14f
-	lhz	r0,0(r4)
-	addi	r4,r4,2
-	sth	r0,0(r3)
-	addi	r3,r3,2
-
-14:	bf	cr7*4+3,15f
-	lbz	r0,0(r4)
-	stb	r0,0(r3)
-
-15:	addi	r1,r1,STACKFRAMESIZE
-	ld	r3,-STACKFRAMESIZE+STK_REG(R31)(r1)
-	b	CFUNC(exit_vmx_ops)		/* tail call optimise */
-
-.Lvmx_unaligned_copy:
-	/* Get the destination 16B aligned */
-	neg	r6,r3
-	mtocrf	0x01,r6
-	clrldi	r6,r6,(64-4)
-
-	bf	cr7*4+3,1f
-	lbz	r0,0(r4)
-	addi	r4,r4,1
-	stb	r0,0(r3)
-	addi	r3,r3,1
-
-1:	bf	cr7*4+2,2f
-	lhz	r0,0(r4)
-	addi	r4,r4,2
-	sth	r0,0(r3)
-	addi	r3,r3,2
-
-2:	bf	cr7*4+1,3f
-	lwz	r0,0(r4)
-	addi	r4,r4,4
-	stw	r0,0(r3)
-	addi	r3,r3,4
-
-3:	bf	cr7*4+0,4f
-	lwz	r0,0(r4)	/* Less chance of a reject with word ops */
-	lwz	r7,4(r4)
-	addi	r4,r4,8
-	stw	r0,0(r3)
-	stw	r7,4(r3)
-	addi	r3,r3,8
-
-4:	sub	r5,r5,r6
-
-	/* Get the desination 128B aligned */
-	neg	r6,r3
-	srdi	r7,r6,4
-	mtocrf	0x01,r7
-	clrldi	r6,r6,(64-7)
-
-	li	r9,16
-	li	r10,32
-	li	r11,48
-
-	LVS(v16,0,r4)		/* Setup permute control vector */
-	lvx	v0,0,r4
-	addi	r4,r4,16
-
-	bf	cr7*4+3,5f
-	lvx	v1,0,r4
-	VPERM(v8,v0,v1,v16)
-	addi	r4,r4,16
-	stvx	v8,0,r3
-	addi	r3,r3,16
-	vor	v0,v1,v1
-
-5:	bf	cr7*4+2,6f
-	lvx	v1,0,r4
-	VPERM(v8,v0,v1,v16)
-	lvx	v0,r4,r9
-	VPERM(v9,v1,v0,v16)
-	addi	r4,r4,32
-	stvx	v8,0,r3
-	stvx	v9,r3,r9
-	addi	r3,r3,32
-
-6:	bf	cr7*4+1,7f
-	lvx	v3,0,r4
-	VPERM(v8,v0,v3,v16)
-	lvx	v2,r4,r9
-	VPERM(v9,v3,v2,v16)
-	lvx	v1,r4,r10
-	VPERM(v10,v2,v1,v16)
-	lvx	v0,r4,r11
-	VPERM(v11,v1,v0,v16)
-	addi	r4,r4,64
-	stvx	v8,0,r3
-	stvx	v9,r3,r9
-	stvx	v10,r3,r10
-	stvx	v11,r3,r11
-	addi	r3,r3,64
-
-7:	sub	r5,r5,r6
-	srdi	r6,r5,7
-
-	std	r14,STK_REG(R14)(r1)
-	std	r15,STK_REG(R15)(r1)
-	std	r16,STK_REG(R16)(r1)
-
-	li	r12,64
-	li	r14,80
-	li	r15,96
-	li	r16,112
-
-	mtctr	r6
-
-	/*
-	 * Now do cacheline sized loads and stores. By this stage the
-	 * cacheline stores are also cacheline aligned.
-	 */
-	.align	5
-8:
-	lvx	v7,0,r4
-	VPERM(v8,v0,v7,v16)
-	lvx	v6,r4,r9
-	VPERM(v9,v7,v6,v16)
-	lvx	v5,r4,r10
-	VPERM(v10,v6,v5,v16)
-	lvx	v4,r4,r11
-	VPERM(v11,v5,v4,v16)
-	lvx	v3,r4,r12
-	VPERM(v12,v4,v3,v16)
-	lvx	v2,r4,r14
-	VPERM(v13,v3,v2,v16)
-	lvx	v1,r4,r15
-	VPERM(v14,v2,v1,v16)
-	lvx	v0,r4,r16
-	VPERM(v15,v1,v0,v16)
-	addi	r4,r4,128
-	stvx	v8,0,r3
-	stvx	v9,r3,r9
-	stvx	v10,r3,r10
-	stvx	v11,r3,r11
-	stvx	v12,r3,r12
-	stvx	v13,r3,r14
-	stvx	v14,r3,r15
-	stvx	v15,r3,r16
-	addi	r3,r3,128
-	bdnz	8b
-
-	ld	r14,STK_REG(R14)(r1)
-	ld	r15,STK_REG(R15)(r1)
-	ld	r16,STK_REG(R16)(r1)
-
-	/* Up to 127B to go */
-	clrldi	r5,r5,(64-7)
-	srdi	r6,r5,4
-	mtocrf	0x01,r6
-
-	bf	cr7*4+1,9f
-	lvx	v3,0,r4
-	VPERM(v8,v0,v3,v16)
-	lvx	v2,r4,r9
-	VPERM(v9,v3,v2,v16)
-	lvx	v1,r4,r10
-	VPERM(v10,v2,v1,v16)
-	lvx	v0,r4,r11
-	VPERM(v11,v1,v0,v16)
-	addi	r4,r4,64
-	stvx	v8,0,r3
-	stvx	v9,r3,r9
-	stvx	v10,r3,r10
-	stvx	v11,r3,r11
-	addi	r3,r3,64
-
-9:	bf	cr7*4+2,10f
-	lvx	v1,0,r4
-	VPERM(v8,v0,v1,v16)
-	lvx	v0,r4,r9
-	VPERM(v9,v1,v0,v16)
-	addi	r4,r4,32
-	stvx	v8,0,r3
-	stvx	v9,r3,r9
-	addi	r3,r3,32
-
-10:	bf	cr7*4+3,11f
-	lvx	v1,0,r4
-	VPERM(v8,v0,v1,v16)
-	addi	r4,r4,16
-	stvx	v8,0,r3
-	addi	r3,r3,16
-
-	/* Up to 15B to go */
-11:	clrldi	r5,r5,(64-4)
-	addi	r4,r4,-16	/* Unwind the +16 load offset */
-	mtocrf	0x01,r5
-	bf	cr7*4+0,12f
-	lwz	r0,0(r4)	/* Less chance of a reject with word ops */
-	lwz	r6,4(r4)
-	addi	r4,r4,8
-	stw	r0,0(r3)
-	stw	r6,4(r3)
-	addi	r3,r3,8
-
-12:	bf	cr7*4+1,13f
-	lwz	r0,0(r4)
-	addi	r4,r4,4
-	stw	r0,0(r3)
-	addi	r3,r3,4
-
-13:	bf	cr7*4+2,14f
-	lhz	r0,0(r4)
-	addi	r4,r4,2
-	sth	r0,0(r3)
-	addi	r3,r3,2
-
-14:	bf	cr7*4+3,15f
-	lbz	r0,0(r4)
-	stb	r0,0(r3)
-
-15:	addi	r1,r1,STACKFRAMESIZE
-	ld	r3,-STACKFRAMESIZE+STK_REG(R31)(r1)
-	b	CFUNC(exit_vmx_ops)		/* tail call optimise */
-#endif /* CONFIG_ALTIVEC */
+../../../../../arch/powerpc/lib/memcpy_power7.S
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/testing/selftests/powerpc/mce/vas-api.h linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/mce/vas-api.h
--- linux-6.16.6/tools/testing/selftests/powerpc/mce/vas-api.h	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/mce/vas-api.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,28 +1 @@
-/* SPDX-License-Identifier: GPL-2.0+ WITH Linux-syscall-note */
-/*
- * Copyright 2019 IBM Corp.
- */
-
-#ifndef _UAPI_MISC_VAS_H
-#define _UAPI_MISC_VAS_H
-
-#include <linux/types.h>
-
-#include <asm/ioctl.h>
-
-#define VAS_MAGIC	'v'
-#define VAS_TX_WIN_OPEN	_IOW(VAS_MAGIC, 0x20, struct vas_tx_win_open_attr)
-
-/* Flags to VAS TX open window ioctl */
-/* To allocate a window with QoS credit, otherwise use default credit */
-#define VAS_TX_WIN_FLAG_QOS_CREDIT	0x0000000000000001
-
-struct vas_tx_win_open_attr {
-	__u32	version;
-	__s16	vas_id;	/* specific instance of vas or -1 for default */
-	__u16	reserved1;
-	__u64	flags;
-	__u64	reserved2[6];
-};
-
-#endif /* _UAPI_MISC_VAS_H */
+../../../../../arch/powerpc/include/uapi/asm/vas-api.h
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/testing/selftests/powerpc/nx-gzip/include/vas-api.h linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/nx-gzip/include/vas-api.h
--- linux-6.16.6/tools/testing/selftests/powerpc/nx-gzip/include/vas-api.h	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/nx-gzip/include/vas-api.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,28 +1 @@
-/* SPDX-License-Identifier: GPL-2.0+ WITH Linux-syscall-note */
-/*
- * Copyright 2019 IBM Corp.
- */
-
-#ifndef _UAPI_MISC_VAS_H
-#define _UAPI_MISC_VAS_H
-
-#include <linux/types.h>
-
-#include <asm/ioctl.h>
-
-#define VAS_MAGIC	'v'
-#define VAS_TX_WIN_OPEN	_IOW(VAS_MAGIC, 0x20, struct vas_tx_win_open_attr)
-
-/* Flags to VAS TX open window ioctl */
-/* To allocate a window with QoS credit, otherwise use default credit */
-#define VAS_TX_WIN_FLAG_QOS_CREDIT	0x0000000000000001
-
-struct vas_tx_win_open_attr {
-	__u32	version;
-	__s16	vas_id;	/* specific instance of vas or -1 for default */
-	__u16	reserved1;
-	__u64	flags;
-	__u64	reserved2[6];
-};
-
-#endif /* _UAPI_MISC_VAS_H */
+../../../../../../arch/powerpc/include/uapi/asm/vas-api.h
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/testing/selftests/powerpc/primitives/asm/asm-compat.h linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/primitives/asm/asm-compat.h
--- linux-6.16.6/tools/testing/selftests/powerpc/primitives/asm/asm-compat.h	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/primitives/asm/asm-compat.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,68 +1 @@
-#ifndef _ASM_POWERPC_ASM_COMPAT_H
-#define _ASM_POWERPC_ASM_COMPAT_H
-
-#include <asm/asm-const.h>
-#include <asm/types.h>
-#include <asm/ppc-opcode.h>
-
-#ifdef __powerpc64__
-
-/* operations for longs and pointers */
-#define PPC_LL		stringify_in_c(ld)
-#define PPC_STL		stringify_in_c(std)
-#define PPC_STLU	stringify_in_c(stdu)
-#define PPC_LCMPI	stringify_in_c(cmpdi)
-#define PPC_LCMPLI	stringify_in_c(cmpldi)
-#define PPC_LCMP	stringify_in_c(cmpd)
-#define PPC_LONG	stringify_in_c(.8byte)
-#define PPC_LONG_ALIGN	stringify_in_c(.balign 8)
-#define PPC_TLNEI	stringify_in_c(tdnei)
-#define PPC_LLARX	stringify_in_c(ldarx)
-#define PPC_STLCX	stringify_in_c(stdcx.)
-#define PPC_CNTLZL	stringify_in_c(cntlzd)
-#define PPC_MTOCRF(FXM, RS) MTOCRF((FXM), RS)
-#define PPC_SRL		stringify_in_c(srd)
-#define PPC_LR_STKOFF	16
-#define PPC_MIN_STKFRM	112
-
-#ifdef __BIG_ENDIAN__
-#define LWZX_BE	stringify_in_c(lwzx)
-#define LDX_BE	stringify_in_c(ldx)
-#define STWX_BE	stringify_in_c(stwx)
-#define STDX_BE	stringify_in_c(stdx)
-#else
-#define LWZX_BE	stringify_in_c(lwbrx)
-#define LDX_BE	stringify_in_c(ldbrx)
-#define STWX_BE	stringify_in_c(stwbrx)
-#define STDX_BE	stringify_in_c(stdbrx)
-#endif
-
-#ifdef CONFIG_CC_IS_CLANG
-#define DS_FORM_CONSTRAINT "Z<>"
-#else
-#define DS_FORM_CONSTRAINT "YZ<>"
-#endif
-
-#else /* 32-bit */
-
-/* operations for longs and pointers */
-#define PPC_LL		stringify_in_c(lwz)
-#define PPC_STL		stringify_in_c(stw)
-#define PPC_STLU	stringify_in_c(stwu)
-#define PPC_LCMPI	stringify_in_c(cmpwi)
-#define PPC_LCMPLI	stringify_in_c(cmplwi)
-#define PPC_LCMP	stringify_in_c(cmpw)
-#define PPC_LONG	stringify_in_c(.long)
-#define PPC_LONG_ALIGN	stringify_in_c(.balign 4)
-#define PPC_TLNEI	stringify_in_c(twnei)
-#define PPC_LLARX	stringify_in_c(lwarx)
-#define PPC_STLCX	stringify_in_c(stwcx.)
-#define PPC_CNTLZL	stringify_in_c(cntlzw)
-#define PPC_MTOCRF	stringify_in_c(mtcrf)
-#define PPC_SRL		stringify_in_c(srw)
-#define PPC_LR_STKOFF	4
-#define PPC_MIN_STKFRM	16
-
-#endif
-
-#endif /* _ASM_POWERPC_ASM_COMPAT_H */
+../.././../../../../arch/powerpc/include/asm/asm-compat.h
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/testing/selftests/powerpc/primitives/asm/asm-const.h linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/primitives/asm/asm-const.h
--- linux-6.16.6/tools/testing/selftests/powerpc/primitives/asm/asm-const.h	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/primitives/asm/asm-const.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,15 +1 @@
-#ifndef _ASM_POWERPC_ASM_CONST_H
-#define _ASM_POWERPC_ASM_CONST_H
-
-#ifdef __ASSEMBLY__
-#  define stringify_in_c(...)	__VA_ARGS__
-#  define ASM_CONST(x)		x
-#else
-/* This version of stringify will deal with commas... */
-#  define __stringify_in_c(...)	#__VA_ARGS__
-#  define stringify_in_c(...)	__stringify_in_c(__VA_ARGS__) " "
-#  define __ASM_CONST(x)	x##UL
-#  define ASM_CONST(x)		__ASM_CONST(x)
-#endif
-
-#endif /* _ASM_POWERPC_ASM_CONST_H */
+../../../../../../arch/powerpc/include/asm/asm-const.h
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/testing/selftests/powerpc/primitives/asm/extable.h linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/primitives/asm/extable.h
--- linux-6.16.6/tools/testing/selftests/powerpc/primitives/asm/extable.h	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/primitives/asm/extable.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,44 +1 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef _ARCH_POWERPC_EXTABLE_H
-#define _ARCH_POWERPC_EXTABLE_H
-
-/*
- * The exception table consists of pairs of relative addresses: the first is
- * the address of an instruction that is allowed to fault, and the second is
- * the address at which the program should continue.  No registers are
- * modified, so it is entirely up to the continuation code to figure out what
- * to do.
- *
- * All the routines below use bits of fixup code that are out of line with the
- * main instruction path.  This means when everything is well, we don't even
- * have to jump over them.  Further, they do not intrude on our cache or tlb
- * entries.
- */
-
-#define ARCH_HAS_RELATIVE_EXTABLE
-
-#ifndef __ASSEMBLY__
-
-struct exception_table_entry {
-	int insn;
-	int fixup;
-};
-
-static inline unsigned long extable_fixup(const struct exception_table_entry *x)
-{
-	return (unsigned long)&x->fixup + x->fixup;
-}
-
-#endif
-
-/*
- * Helper macro for exception table entries
- */
-#define EX_TABLE(_fault, _target)		\
-	stringify_in_c(.section __ex_table,"a";)\
-	stringify_in_c(.balign 4;)		\
-	stringify_in_c(.long (_fault) - . ;)	\
-	stringify_in_c(.long (_target) - . ;)	\
-	stringify_in_c(.previous)
-
-#endif
+../../../../../../arch/powerpc/include/asm/extable.h
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/testing/selftests/powerpc/primitives/asm/feature-fixups.h linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/primitives/asm/feature-fixups.h
--- linux-6.16.6/tools/testing/selftests/powerpc/primitives/asm/feature-fixups.h	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/primitives/asm/feature-fixups.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,301 +1 @@
-/* SPDX-License-Identifier: GPL-2.0-or-later */
-#ifndef __ASM_POWERPC_FEATURE_FIXUPS_H
-#define __ASM_POWERPC_FEATURE_FIXUPS_H
-
-#include <asm/asm-const.h>
-
-/*
- */
-
-/*
- * Feature section common macros
- *
- * Note that the entries now contain offsets between the table entry
- * and the code rather than absolute code pointers in order to be
- * useable with the vdso shared library. There is also an assumption
- * that values will be negative, that is, the fixup table has to be
- * located after the code it fixes up.
- */
-#if defined(CONFIG_PPC64) && !defined(__powerpc64__)
-/* 64 bits kernel, 32 bits code (ie. vdso32) */
-#define FTR_ENTRY_LONG		.8byte
-#define FTR_ENTRY_OFFSET	.long 0xffffffff; .long
-#elif defined(CONFIG_PPC64)
-#define FTR_ENTRY_LONG		.8byte
-#define FTR_ENTRY_OFFSET	.8byte
-#else
-#define FTR_ENTRY_LONG		.long
-#define FTR_ENTRY_OFFSET	.long
-#endif
-
-#define START_FTR_SECTION(label)	label##1:
-
-#define FTR_SECTION_ELSE_NESTED(label)			\
-label##2:						\
-	.pushsection __ftr_alt_##label,"a";		\
-	.align 2;					\
-label##3:
-
-
-#ifndef CONFIG_CC_IS_CLANG
-#define CHECK_ALT_SIZE(else_size, body_size)			\
-	.ifgt (else_size) - (body_size);			\
-	.error "Feature section else case larger than body";	\
-	.endif;
-#else
-/*
- * If we use the ifgt syntax above, clang's assembler complains about the
- * expression being non-absolute when the code appears in an inline assembly
- * statement.
- * As a workaround use an .org directive that has no effect if the else case
- * instructions are smaller than the body, but fails otherwise.
- */
-#define CHECK_ALT_SIZE(else_size, body_size)			\
-	.org . + ((else_size) > (body_size));
-#endif
-
-#define MAKE_FTR_SECTION_ENTRY(msk, val, label, sect)		\
-label##4:							\
-	.popsection;						\
-	.pushsection sect,"a";					\
-	.align 3;						\
-label##5:							\
-	FTR_ENTRY_LONG msk;					\
-	FTR_ENTRY_LONG val;					\
-	FTR_ENTRY_OFFSET label##1b-label##5b;			\
-	FTR_ENTRY_OFFSET label##2b-label##5b;			\
-	FTR_ENTRY_OFFSET label##3b-label##5b;			\
-	FTR_ENTRY_OFFSET label##4b-label##5b;			\
-	CHECK_ALT_SIZE((label##4b-label##3b), (label##2b-label##1b)); \
-	.popsection;
-
-
-/* CPU feature dependent sections */
-#define BEGIN_FTR_SECTION_NESTED(label)	START_FTR_SECTION(label)
-#define BEGIN_FTR_SECTION		START_FTR_SECTION(97)
-
-#define END_FTR_SECTION_NESTED(msk, val, label) 		\
-	FTR_SECTION_ELSE_NESTED(label)				\
-	MAKE_FTR_SECTION_ENTRY(msk, val, label, __ftr_fixup)
-
-#define END_FTR_SECTION(msk, val)		\
-	END_FTR_SECTION_NESTED(msk, val, 97)
-
-#define END_FTR_SECTION_NESTED_IFSET(msk, label)	\
-	END_FTR_SECTION_NESTED((msk), (msk), label)
-
-#define END_FTR_SECTION_IFSET(msk)	END_FTR_SECTION((msk), (msk))
-#define END_FTR_SECTION_IFCLR(msk)	END_FTR_SECTION((msk), 0)
-
-/* CPU feature sections with alternatives, use BEGIN_FTR_SECTION to start */
-#define FTR_SECTION_ELSE	FTR_SECTION_ELSE_NESTED(97)
-#define ALT_FTR_SECTION_END_NESTED(msk, val, label)	\
-	MAKE_FTR_SECTION_ENTRY(msk, val, label, __ftr_fixup)
-#define ALT_FTR_SECTION_END_NESTED_IFSET(msk, label)	\
-	ALT_FTR_SECTION_END_NESTED(msk, msk, label)
-#define ALT_FTR_SECTION_END_NESTED_IFCLR(msk, label)	\
-	ALT_FTR_SECTION_END_NESTED(msk, 0, label)
-#define ALT_FTR_SECTION_END(msk, val)	\
-	ALT_FTR_SECTION_END_NESTED(msk, val, 97)
-#define ALT_FTR_SECTION_END_IFSET(msk)	\
-	ALT_FTR_SECTION_END_NESTED_IFSET(msk, 97)
-#define ALT_FTR_SECTION_END_IFCLR(msk)	\
-	ALT_FTR_SECTION_END_NESTED_IFCLR(msk, 97)
-
-/* MMU feature dependent sections */
-#define BEGIN_MMU_FTR_SECTION_NESTED(label)	START_FTR_SECTION(label)
-#define BEGIN_MMU_FTR_SECTION			START_FTR_SECTION(97)
-
-#define END_MMU_FTR_SECTION_NESTED(msk, val, label) 		\
-	FTR_SECTION_ELSE_NESTED(label)				\
-	MAKE_FTR_SECTION_ENTRY(msk, val, label, __mmu_ftr_fixup)
-
-#define END_MMU_FTR_SECTION(msk, val)		\
-	END_MMU_FTR_SECTION_NESTED(msk, val, 97)
-
-#define END_MMU_FTR_SECTION_NESTED_IFSET(msk, label)	\
-	END_MMU_FTR_SECTION_NESTED((msk), (msk), label)
-
-#define END_MMU_FTR_SECTION_NESTED_IFCLR(msk, label)	\
-	END_MMU_FTR_SECTION_NESTED((msk), 0, label)
-
-#define END_MMU_FTR_SECTION_IFSET(msk)	END_MMU_FTR_SECTION((msk), (msk))
-#define END_MMU_FTR_SECTION_IFCLR(msk)	END_MMU_FTR_SECTION((msk), 0)
-
-/* MMU feature sections with alternatives, use BEGIN_FTR_SECTION to start */
-#define MMU_FTR_SECTION_ELSE_NESTED(label)	FTR_SECTION_ELSE_NESTED(label)
-#define MMU_FTR_SECTION_ELSE	MMU_FTR_SECTION_ELSE_NESTED(97)
-#define ALT_MMU_FTR_SECTION_END_NESTED(msk, val, label)	\
-	MAKE_FTR_SECTION_ENTRY(msk, val, label, __mmu_ftr_fixup)
-#define ALT_MMU_FTR_SECTION_END_NESTED_IFSET(msk, label)	\
-	ALT_MMU_FTR_SECTION_END_NESTED(msk, msk, label)
-#define ALT_MMU_FTR_SECTION_END_NESTED_IFCLR(msk, label)	\
-	ALT_MMU_FTR_SECTION_END_NESTED(msk, 0, label)
-#define ALT_MMU_FTR_SECTION_END(msk, val)	\
-	ALT_MMU_FTR_SECTION_END_NESTED(msk, val, 97)
-#define ALT_MMU_FTR_SECTION_END_IFSET(msk)	\
-	ALT_MMU_FTR_SECTION_END_NESTED_IFSET(msk, 97)
-#define ALT_MMU_FTR_SECTION_END_IFCLR(msk)	\
-	ALT_MMU_FTR_SECTION_END_NESTED_IFCLR(msk, 97)
-
-/* Firmware feature dependent sections */
-#define BEGIN_FW_FTR_SECTION_NESTED(label)	START_FTR_SECTION(label)
-#define BEGIN_FW_FTR_SECTION			START_FTR_SECTION(97)
-
-#define END_FW_FTR_SECTION_NESTED(msk, val, label) 		\
-	FTR_SECTION_ELSE_NESTED(label)				\
-	MAKE_FTR_SECTION_ENTRY(msk, val, label, __fw_ftr_fixup)
-
-#define END_FW_FTR_SECTION(msk, val)		\
-	END_FW_FTR_SECTION_NESTED(msk, val, 97)
-
-#define END_FW_FTR_SECTION_IFSET(msk)	END_FW_FTR_SECTION((msk), (msk))
-#define END_FW_FTR_SECTION_IFCLR(msk)	END_FW_FTR_SECTION((msk), 0)
-
-/* Firmware feature sections with alternatives */
-#define FW_FTR_SECTION_ELSE_NESTED(label)	FTR_SECTION_ELSE_NESTED(label)
-#define FW_FTR_SECTION_ELSE	FTR_SECTION_ELSE_NESTED(97)
-#define ALT_FW_FTR_SECTION_END_NESTED(msk, val, label)	\
-	MAKE_FTR_SECTION_ENTRY(msk, val, label, __fw_ftr_fixup)
-#define ALT_FW_FTR_SECTION_END_NESTED_IFSET(msk, label)	\
-	ALT_FW_FTR_SECTION_END_NESTED(msk, msk, label)
-#define ALT_FW_FTR_SECTION_END_NESTED_IFCLR(msk, label)	\
-	ALT_FW_FTR_SECTION_END_NESTED(msk, 0, label)
-#define ALT_FW_FTR_SECTION_END(msk, val)	\
-	ALT_FW_FTR_SECTION_END_NESTED(msk, val, 97)
-#define ALT_FW_FTR_SECTION_END_IFSET(msk)	\
-	ALT_FW_FTR_SECTION_END_NESTED_IFSET(msk, 97)
-#define ALT_FW_FTR_SECTION_END_IFCLR(msk)	\
-	ALT_FW_FTR_SECTION_END_NESTED_IFCLR(msk, 97)
-
-#ifndef __ASSEMBLY__
-
-#define ASM_FTR_IF(section_if, section_else, msk, val)	\
-	stringify_in_c(BEGIN_FTR_SECTION)			\
-	section_if "; "						\
-	stringify_in_c(FTR_SECTION_ELSE)			\
-	section_else "; "					\
-	stringify_in_c(ALT_FTR_SECTION_END((msk), (val)))
-
-#define ASM_FTR_IFSET(section_if, section_else, msk)	\
-	ASM_FTR_IF(section_if, section_else, (msk), (msk))
-
-#define ASM_FTR_IFCLR(section_if, section_else, msk)	\
-	ASM_FTR_IF(section_if, section_else, (msk), 0)
-
-#define ASM_MMU_FTR_IF(section_if, section_else, msk, val)	\
-	stringify_in_c(BEGIN_MMU_FTR_SECTION)			\
-	section_if "; "						\
-	stringify_in_c(MMU_FTR_SECTION_ELSE)			\
-	section_else "; "					\
-	stringify_in_c(ALT_MMU_FTR_SECTION_END((msk), (val)))
-
-#define ASM_MMU_FTR_IFSET(section_if, section_else, msk)	\
-	ASM_MMU_FTR_IF(section_if, section_else, (msk), (msk))
-
-#define ASM_MMU_FTR_IFCLR(section_if, section_else, msk)	\
-	ASM_MMU_FTR_IF(section_if, section_else, (msk), 0)
-
-#endif /* __ASSEMBLY__ */
-
-/* LWSYNC feature sections */
-#define START_LWSYNC_SECTION(label)	label##1:
-#define MAKE_LWSYNC_SECTION_ENTRY(label, sect)		\
-label##2:						\
-	.pushsection sect,"a";				\
-	.align 2;					\
-label##3:					       	\
-	FTR_ENTRY_OFFSET label##1b-label##3b;		\
-	.popsection;
-
-#define STF_ENTRY_BARRIER_FIXUP_SECTION			\
-953:							\
-	.pushsection __stf_entry_barrier_fixup,"a";	\
-	.align 2;					\
-954:							\
-	FTR_ENTRY_OFFSET 953b-954b;			\
-	.popsection;
-
-#define STF_EXIT_BARRIER_FIXUP_SECTION			\
-955:							\
-	.pushsection __stf_exit_barrier_fixup,"a";	\
-	.align 2;					\
-956:							\
-	FTR_ENTRY_OFFSET 955b-956b;			\
-	.popsection;
-
-#define UACCESS_FLUSH_FIXUP_SECTION			\
-959:							\
-	.pushsection __uaccess_flush_fixup,"a";		\
-	.align 2;					\
-960:							\
-	FTR_ENTRY_OFFSET 959b-960b;			\
-	.popsection;
-
-#define ENTRY_FLUSH_FIXUP_SECTION			\
-957:							\
-	.pushsection __entry_flush_fixup,"a";		\
-	.align 2;					\
-958:							\
-	FTR_ENTRY_OFFSET 957b-958b;			\
-	.popsection;
-
-#define SCV_ENTRY_FLUSH_FIXUP_SECTION			\
-957:							\
-	.pushsection __scv_entry_flush_fixup,"a";	\
-	.align 2;					\
-958:							\
-	FTR_ENTRY_OFFSET 957b-958b;			\
-	.popsection;
-
-#define RFI_FLUSH_FIXUP_SECTION				\
-951:							\
-	.pushsection __rfi_flush_fixup,"a";		\
-	.align 2;					\
-952:							\
-	FTR_ENTRY_OFFSET 951b-952b;			\
-	.popsection;
-
-#define NOSPEC_BARRIER_FIXUP_SECTION			\
-953:							\
-	.pushsection __barrier_nospec_fixup,"a";	\
-	.align 2;					\
-954:							\
-	FTR_ENTRY_OFFSET 953b-954b;			\
-	.popsection;
-
-#define START_BTB_FLUSH_SECTION			\
-955:							\
-
-#define END_BTB_FLUSH_SECTION			\
-956:							\
-	.pushsection __btb_flush_fixup,"a";	\
-	.align 2;							\
-957:						\
-	FTR_ENTRY_OFFSET 955b-957b;			\
-	FTR_ENTRY_OFFSET 956b-957b;			\
-	.popsection;
-
-#ifndef __ASSEMBLY__
-#include <linux/types.h>
-
-extern long stf_barrier_fallback;
-extern long entry_flush_fallback;
-extern long scv_entry_flush_fallback;
-extern long __start___stf_entry_barrier_fixup, __stop___stf_entry_barrier_fixup;
-extern long __start___stf_exit_barrier_fixup, __stop___stf_exit_barrier_fixup;
-extern long __start___uaccess_flush_fixup, __stop___uaccess_flush_fixup;
-extern long __start___entry_flush_fixup, __stop___entry_flush_fixup;
-extern long __start___scv_entry_flush_fixup, __stop___scv_entry_flush_fixup;
-extern long __start___rfi_flush_fixup, __stop___rfi_flush_fixup;
-extern long __start___barrier_nospec_fixup, __stop___barrier_nospec_fixup;
-extern long __start__btb_flush_fixup, __stop__btb_flush_fixup;
-
-extern bool static_key_feature_checks_initialized;
-
-void apply_feature_fixups(void);
-void update_mmu_feature_fixups(unsigned long mask);
-void setup_feature_keys(void);
-#endif
-
-#endif /* __ASM_POWERPC_FEATURE_FIXUPS_H */
+../../../../../../arch/powerpc/include/asm/feature-fixups.h
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/testing/selftests/powerpc/primitives/asm/ppc_asm.h linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/primitives/asm/ppc_asm.h
--- linux-6.16.6/tools/testing/selftests/powerpc/primitives/asm/ppc_asm.h	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/primitives/asm/ppc_asm.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,906 +1 @@
-/*
- * Copyright (C) 1995-1999 Gary Thomas, Paul Mackerras, Cort Dougan.
- */
-#ifndef _ASM_POWERPC_PPC_ASM_H
-#define _ASM_POWERPC_PPC_ASM_H
-
-#include <linux/stringify.h>
-#include <asm/asm-compat.h>
-#include <asm/processor.h>
-#include <asm/ppc-opcode.h>
-#include <asm/firmware.h>
-#include <asm/feature-fixups.h>
-#include <asm/extable.h>
-
-#ifdef __ASSEMBLY__
-
-#define SZL			(BITS_PER_LONG/8)
-
-/*
- * This expands to a sequence of operations with reg incrementing from
- * start to end inclusive, of this form:
- *
- *   op  reg, (offset + (width * reg))(base)
- *
- * Note that offset is not the offset of the first operation unless start
- * is zero (or width is zero).
- */
-.macro OP_REGS op, width, start, end, base, offset
-	.Lreg=\start
-	.rept (\end - \start + 1)
-	\op	.Lreg, \offset + \width * .Lreg(\base)
-	.Lreg=.Lreg+1
-	.endr
-.endm
-
-/*
- * This expands to a sequence of register clears for regs start to end
- * inclusive, of the form:
- *
- *   li rN, 0
- */
-.macro ZEROIZE_REGS start, end
-	.Lreg=\start
-	.rept (\end - \start + 1)
-	li	.Lreg, 0
-	.Lreg=.Lreg+1
-	.endr
-.endm
-
-/*
- * Macros for storing registers into and loading registers from
- * exception frames.
- */
-#ifdef __powerpc64__
-#define SAVE_GPRS(start, end, base)	OP_REGS std, 8, start, end, base, GPR0
-#define REST_GPRS(start, end, base)	OP_REGS ld, 8, start, end, base, GPR0
-#define SAVE_NVGPRS(base)		SAVE_GPRS(14, 31, base)
-#define REST_NVGPRS(base)		REST_GPRS(14, 31, base)
-#else
-#define SAVE_GPRS(start, end, base)	OP_REGS stw, 4, start, end, base, GPR0
-#define REST_GPRS(start, end, base)	OP_REGS lwz, 4, start, end, base, GPR0
-#define SAVE_NVGPRS(base)		SAVE_GPRS(13, 31, base)
-#define REST_NVGPRS(base)		REST_GPRS(13, 31, base)
-#endif
-
-#define	ZEROIZE_GPRS(start, end)	ZEROIZE_REGS start, end
-#ifdef __powerpc64__
-#define	ZEROIZE_NVGPRS()		ZEROIZE_GPRS(14, 31)
-#else
-#define	ZEROIZE_NVGPRS()		ZEROIZE_GPRS(13, 31)
-#endif
-#define	ZEROIZE_GPR(n)			ZEROIZE_GPRS(n, n)
-
-#define SAVE_GPR(n, base)		SAVE_GPRS(n, n, base)
-#define REST_GPR(n, base)		REST_GPRS(n, n, base)
-
-/* macros for handling user register sanitisation */
-#ifdef CONFIG_INTERRUPT_SANITIZE_REGISTERS
-#define SANITIZE_SYSCALL_GPRS()			ZEROIZE_GPR(0);		\
-						ZEROIZE_GPRS(5, 12);	\
-						ZEROIZE_NVGPRS()
-#define SANITIZE_GPR(n)				ZEROIZE_GPR(n)
-#define SANITIZE_GPRS(start, end)		ZEROIZE_GPRS(start, end)
-#define SANITIZE_NVGPRS()			ZEROIZE_NVGPRS()
-#define SANITIZE_RESTORE_NVGPRS()		REST_NVGPRS(r1)
-#define HANDLER_RESTORE_NVGPRS()
-#else
-#define SANITIZE_SYSCALL_GPRS()
-#define SANITIZE_GPR(n)
-#define SANITIZE_GPRS(start, end)
-#define SANITIZE_NVGPRS()
-#define SANITIZE_RESTORE_NVGPRS()
-#define HANDLER_RESTORE_NVGPRS()		REST_NVGPRS(r1)
-#endif /* CONFIG_INTERRUPT_SANITIZE_REGISTERS */
-
-#define SAVE_FPR(n, base)	stfd	n,8*TS_FPRWIDTH*(n)(base)
-#define SAVE_2FPRS(n, base)	SAVE_FPR(n, base); SAVE_FPR(n+1, base)
-#define SAVE_4FPRS(n, base)	SAVE_2FPRS(n, base); SAVE_2FPRS(n+2, base)
-#define SAVE_8FPRS(n, base)	SAVE_4FPRS(n, base); SAVE_4FPRS(n+4, base)
-#define SAVE_16FPRS(n, base)	SAVE_8FPRS(n, base); SAVE_8FPRS(n+8, base)
-#define SAVE_32FPRS(n, base)	SAVE_16FPRS(n, base); SAVE_16FPRS(n+16, base)
-#define REST_FPR(n, base)	lfd	n,8*TS_FPRWIDTH*(n)(base)
-#define REST_2FPRS(n, base)	REST_FPR(n, base); REST_FPR(n+1, base)
-#define REST_4FPRS(n, base)	REST_2FPRS(n, base); REST_2FPRS(n+2, base)
-#define REST_8FPRS(n, base)	REST_4FPRS(n, base); REST_4FPRS(n+4, base)
-#define REST_16FPRS(n, base)	REST_8FPRS(n, base); REST_8FPRS(n+8, base)
-#define REST_32FPRS(n, base)	REST_16FPRS(n, base); REST_16FPRS(n+16, base)
-
-#define SAVE_VR(n,b,base)	li b,16*(n);  stvx n,base,b
-#define SAVE_2VRS(n,b,base)	SAVE_VR(n,b,base); SAVE_VR(n+1,b,base)
-#define SAVE_4VRS(n,b,base)	SAVE_2VRS(n,b,base); SAVE_2VRS(n+2,b,base)
-#define SAVE_8VRS(n,b,base)	SAVE_4VRS(n,b,base); SAVE_4VRS(n+4,b,base)
-#define SAVE_16VRS(n,b,base)	SAVE_8VRS(n,b,base); SAVE_8VRS(n+8,b,base)
-#define SAVE_32VRS(n,b,base)	SAVE_16VRS(n,b,base); SAVE_16VRS(n+16,b,base)
-#define REST_VR(n,b,base)	li b,16*(n); lvx n,base,b
-#define REST_2VRS(n,b,base)	REST_VR(n,b,base); REST_VR(n+1,b,base)
-#define REST_4VRS(n,b,base)	REST_2VRS(n,b,base); REST_2VRS(n+2,b,base)
-#define REST_8VRS(n,b,base)	REST_4VRS(n,b,base); REST_4VRS(n+4,b,base)
-#define REST_16VRS(n,b,base)	REST_8VRS(n,b,base); REST_8VRS(n+8,b,base)
-#define REST_32VRS(n,b,base)	REST_16VRS(n,b,base); REST_16VRS(n+16,b,base)
-
-#ifdef __BIG_ENDIAN__
-#define STXVD2X_ROT(n,b,base)		STXVD2X(n,b,base)
-#define LXVD2X_ROT(n,b,base)		LXVD2X(n,b,base)
-#else
-#define STXVD2X_ROT(n,b,base)		XXSWAPD(n,n);		\
-					STXVD2X(n,b,base);	\
-					XXSWAPD(n,n)
-
-#define LXVD2X_ROT(n,b,base)		LXVD2X(n,b,base);	\
-					XXSWAPD(n,n)
-#endif
-/* Save the lower 32 VSRs in the thread VSR region */
-#define SAVE_VSR(n,b,base)	li b,16*(n);  STXVD2X_ROT(n,R##base,R##b)
-#define SAVE_2VSRS(n,b,base)	SAVE_VSR(n,b,base); SAVE_VSR(n+1,b,base)
-#define SAVE_4VSRS(n,b,base)	SAVE_2VSRS(n,b,base); SAVE_2VSRS(n+2,b,base)
-#define SAVE_8VSRS(n,b,base)	SAVE_4VSRS(n,b,base); SAVE_4VSRS(n+4,b,base)
-#define SAVE_16VSRS(n,b,base)	SAVE_8VSRS(n,b,base); SAVE_8VSRS(n+8,b,base)
-#define SAVE_32VSRS(n,b,base)	SAVE_16VSRS(n,b,base); SAVE_16VSRS(n+16,b,base)
-#define REST_VSR(n,b,base)	li b,16*(n); LXVD2X_ROT(n,R##base,R##b)
-#define REST_2VSRS(n,b,base)	REST_VSR(n,b,base); REST_VSR(n+1,b,base)
-#define REST_4VSRS(n,b,base)	REST_2VSRS(n,b,base); REST_2VSRS(n+2,b,base)
-#define REST_8VSRS(n,b,base)	REST_4VSRS(n,b,base); REST_4VSRS(n+4,b,base)
-#define REST_16VSRS(n,b,base)	REST_8VSRS(n,b,base); REST_8VSRS(n+8,b,base)
-#define REST_32VSRS(n,b,base)	REST_16VSRS(n,b,base); REST_16VSRS(n+16,b,base)
-
-/*
- * b = base register for addressing, o = base offset from register of 1st EVR
- * n = first EVR, s = scratch
- */
-#define SAVE_EVR(n,s,b,o)	evmergehi s,s,n; stw s,o+4*(n)(b)
-#define SAVE_2EVRS(n,s,b,o)	SAVE_EVR(n,s,b,o); SAVE_EVR(n+1,s,b,o)
-#define SAVE_4EVRS(n,s,b,o)	SAVE_2EVRS(n,s,b,o); SAVE_2EVRS(n+2,s,b,o)
-#define SAVE_8EVRS(n,s,b,o)	SAVE_4EVRS(n,s,b,o); SAVE_4EVRS(n+4,s,b,o)
-#define SAVE_16EVRS(n,s,b,o)	SAVE_8EVRS(n,s,b,o); SAVE_8EVRS(n+8,s,b,o)
-#define SAVE_32EVRS(n,s,b,o)	SAVE_16EVRS(n,s,b,o); SAVE_16EVRS(n+16,s,b,o)
-#define REST_EVR(n,s,b,o)	lwz s,o+4*(n)(b); evmergelo n,s,n
-#define REST_2EVRS(n,s,b,o)	REST_EVR(n,s,b,o); REST_EVR(n+1,s,b,o)
-#define REST_4EVRS(n,s,b,o)	REST_2EVRS(n,s,b,o); REST_2EVRS(n+2,s,b,o)
-#define REST_8EVRS(n,s,b,o)	REST_4EVRS(n,s,b,o); REST_4EVRS(n+4,s,b,o)
-#define REST_16EVRS(n,s,b,o)	REST_8EVRS(n,s,b,o); REST_8EVRS(n+8,s,b,o)
-#define REST_32EVRS(n,s,b,o)	REST_16EVRS(n,s,b,o); REST_16EVRS(n+16,s,b,o)
-
-/* Macros to adjust thread priority for hardware multithreading */
-#define HMT_VERY_LOW	or	31,31,31	# very low priority
-#define HMT_LOW		or	1,1,1
-#define HMT_MEDIUM_LOW  or	6,6,6		# medium low priority
-#define HMT_MEDIUM	or	2,2,2
-#define HMT_MEDIUM_HIGH or	5,5,5		# medium high priority
-#define HMT_HIGH	or	3,3,3
-#define HMT_EXTRA_HIGH	or	7,7,7		# power7 only
-
-#ifdef CONFIG_PPC64
-#define ULONG_SIZE 	8
-#else
-#define ULONG_SIZE	4
-#endif
-#define __VCPU_GPR(n)	(VCPU_GPRS + (n * ULONG_SIZE))
-#define VCPU_GPR(n)	__VCPU_GPR(__REG_##n)
-
-#ifdef __KERNEL__
-
-/*
- * Used to name C functions called from asm
- */
-#if defined(__powerpc64__) && defined(CONFIG_PPC_KERNEL_PCREL)
-#define CFUNC(name) name@notoc
-#else
-#define CFUNC(name) name
-#endif
-
-/*
- * We use __powerpc64__ here because we want the compat VDSO to use the 32-bit
- * version below in the else case of the ifdef.
- */
-#ifdef __powerpc64__
-
-#define STACKFRAMESIZE 256
-#define __STK_REG(i)   (112 + ((i)-14)*8)
-#define STK_REG(i)     __STK_REG(__REG_##i)
-
-#ifdef CONFIG_PPC64_ELF_ABI_V2
-#define STK_GOT		24
-#define STK_PARAM_AREA	32
-#else
-#define STK_GOT		40
-#define STK_PARAM_AREA	48
-#endif
-
-#define __STK_PARAM(i)	(STK_PARAM_AREA + ((i)-3)*8)
-#define STK_PARAM(i)	__STK_PARAM(__REG_##i)
-
-#ifdef CONFIG_PPC64_ELF_ABI_V2
-
-#define _GLOBAL(name) \
-	.align 2 ; \
-	.type name,@function; \
-	.globl name; \
-name:
-
-#ifdef CONFIG_PPC_KERNEL_PCREL
-#define _GLOBAL_TOC _GLOBAL
-#else
-#define _GLOBAL_TOC(name) \
-	.align 2 ; \
-	.type name,@function; \
-	.globl name; \
-name: \
-0:	addis r2,r12,(.TOC.-0b)@ha; \
-	addi r2,r2,(.TOC.-0b)@l; \
-	.localentry name,.-name
-#endif
-
-#define DOTSYM(a)	a
-
-#else
-
-#define XGLUE(a,b) a##b
-#define GLUE(a,b) XGLUE(a,b)
-
-#define _GLOBAL(name) \
-	.align 2 ; \
-	.globl name; \
-	.globl GLUE(.,name); \
-	.pushsection ".opd","aw"; \
-name: \
-	.quad GLUE(.,name); \
-	.quad .TOC.@tocbase; \
-	.quad 0; \
-	.popsection; \
-	.type GLUE(.,name),@function; \
-GLUE(.,name):
-
-#define _GLOBAL_TOC(name) _GLOBAL(name)
-
-#define DOTSYM(a)	GLUE(.,a)
-
-#endif
-
-#else /* 32-bit */
-
-#define _GLOBAL(n)	\
-	.globl n;	\
-n:
-
-#define _GLOBAL_TOC(name) _GLOBAL(name)
-
-#define DOTSYM(a)	a
-
-#endif
-
-/*
- * __kprobes (the C annotation) puts the symbol into the .kprobes.text
- * section, which gets emitted at the end of regular text.
- *
- * _ASM_NOKPROBE_SYMBOL and NOKPROBE_SYMBOL just adds the symbol to
- * a blacklist. The former is for core kprobe functions/data, the
- * latter is for those that incdentially must be excluded from probing
- * and allows them to be linked at more optimal location within text.
- */
-#ifdef CONFIG_KPROBES
-#define _ASM_NOKPROBE_SYMBOL(entry)			\
-	.pushsection "_kprobe_blacklist","aw";		\
-	PPC_LONG (entry) ;				\
-	.popsection
-#else
-#define _ASM_NOKPROBE_SYMBOL(entry)
-#endif
-
-#define FUNC_START(name)	_GLOBAL(name)
-#define FUNC_END(name)
-
-/* 
- * LOAD_REG_IMMEDIATE(rn, expr)
- *   Loads the value of the constant expression 'expr' into register 'rn'
- *   using immediate instructions only.  Use this when it's important not
- *   to reference other data (i.e. on ppc64 when the TOC pointer is not
- *   valid) and when 'expr' is a constant or absolute address.
- *
- * LOAD_REG_ADDR(rn, name)
- *   Loads the address of label 'name' into register 'rn'.  Use this when
- *   you don't particularly need immediate instructions only, but you need
- *   the whole address in one register (e.g. it's a structure address and
- *   you want to access various offsets within it).  On ppc32 this is
- *   identical to LOAD_REG_IMMEDIATE.
- *
- * LOAD_REG_ADDR_PIC(rn, name)
- *   Loads the address of label 'name' into register 'run'. Use this when
- *   the kernel doesn't run at the linked or relocated address. Please
- *   note that this macro will clobber the lr register.
- *
- * LOAD_REG_ADDRBASE(rn, name)
- * ADDROFF(name)
- *   LOAD_REG_ADDRBASE loads part of the address of label 'name' into
- *   register 'rn'.  ADDROFF(name) returns the remainder of the address as
- *   a constant expression.  ADDROFF(name) is a signed expression < 16 bits
- *   in size, so is suitable for use directly as an offset in load and store
- *   instructions.  Use this when loading/storing a single word or less as:
- *      LOAD_REG_ADDRBASE(rX, name)
- *      ld	rY,ADDROFF(name)(rX)
- */
-
-/* Be careful, this will clobber the lr register. */
-#define LOAD_REG_ADDR_PIC(reg, name)		\
-	bcl	20,31,$+4;			\
-0:	mflr	reg;				\
-	addis	reg,reg,(name - 0b)@ha;		\
-	addi	reg,reg,(name - 0b)@l;
-
-#if defined(__powerpc64__) && defined(HAVE_AS_ATHIGH)
-#define __AS_ATHIGH high
-#else
-#define __AS_ATHIGH h
-#endif
-
-.macro __LOAD_REG_IMMEDIATE_32 r, x
-	.if (\x) >= 0x8000 || (\x) < -0x8000
-		lis \r, (\x)@__AS_ATHIGH
-		.if (\x) & 0xffff != 0
-			ori \r, \r, (\x)@l
-		.endif
-	.else
-		li \r, (\x)@l
-	.endif
-.endm
-
-.macro __LOAD_REG_IMMEDIATE r, x
-	.if (\x) >= 0x80000000 || (\x) < -0x80000000
-		__LOAD_REG_IMMEDIATE_32 \r, (\x) >> 32
-		sldi	\r, \r, 32
-		.if (\x) & 0xffff0000 != 0
-			oris \r, \r, (\x)@__AS_ATHIGH
-		.endif
-		.if (\x) & 0xffff != 0
-			ori \r, \r, (\x)@l
-		.endif
-	.else
-		__LOAD_REG_IMMEDIATE_32 \r, \x
-	.endif
-.endm
-
-#ifdef __powerpc64__
-
-#ifdef CONFIG_PPC_KERNEL_PCREL
-#define __LOAD_PACA_TOC(reg)			\
-	li	reg,-1
-#else
-#define __LOAD_PACA_TOC(reg)			\
-	ld	reg,PACATOC(r13)
-#endif
-
-#define LOAD_PACA_TOC()				\
-	__LOAD_PACA_TOC(r2)
-
-#define LOAD_REG_IMMEDIATE(reg, expr) __LOAD_REG_IMMEDIATE reg, expr
-
-#define LOAD_REG_IMMEDIATE_SYM(reg, tmp, expr)	\
-	lis	tmp, (expr)@highest;		\
-	lis	reg, (expr)@__AS_ATHIGH;	\
-	ori	tmp, tmp, (expr)@higher;	\
-	ori	reg, reg, (expr)@l;		\
-	rldimi	reg, tmp, 32, 0
-
-#ifdef CONFIG_PPC_KERNEL_PCREL
-#define LOAD_REG_ADDR(reg,name)			\
-	pla	reg,name@pcrel
-
-#else
-#define LOAD_REG_ADDR(reg,name)			\
-	addis	reg,r2,name@toc@ha;		\
-	addi	reg,reg,name@toc@l
-#endif
-
-#ifdef CONFIG_PPC_BOOK3E_64
-/*
- * This is used in register-constrained interrupt handlers. Not to be used
- * by BOOK3S. ld complains with "got/toc optimization is not supported" if r2
- * is not used for the TOC offset, so use @got(tocreg). If the interrupt
- * handlers saved r2 instead, LOAD_REG_ADDR could be used.
- */
-#define LOAD_REG_ADDR_ALTTOC(reg,tocreg,name)	\
-	ld	reg,name@got(tocreg)
-#endif
-
-#define LOAD_REG_ADDRBASE(reg,name)	LOAD_REG_ADDR(reg,name)
-#define ADDROFF(name)			0
-
-/* offsets for stack frame layout */
-#define LRSAVE	16
-
-/*
- * GCC stack frames follow a different pattern on 32 vs 64. This can be used
- * to make asm frames be consistent with C.
- */
-#define PPC_CREATE_STACK_FRAME(size)			\
-	mflr		r0;				\
-	std		r0,16(r1);			\
-	stdu		r1,-(size)(r1)
-
-#else /* 32-bit */
-
-#define LOAD_REG_IMMEDIATE(reg, expr) __LOAD_REG_IMMEDIATE_32 reg, expr
-
-#define LOAD_REG_IMMEDIATE_SYM(reg,expr)		\
-	lis	reg,(expr)@ha;		\
-	addi	reg,reg,(expr)@l;
-
-#define LOAD_REG_ADDR(reg,name)		LOAD_REG_IMMEDIATE_SYM(reg, name)
-
-#define LOAD_REG_ADDRBASE(reg, name)	lis	reg,name@ha
-#define ADDROFF(name)			name@l
-
-/* offsets for stack frame layout */
-#define LRSAVE	4
-
-#define PPC_CREATE_STACK_FRAME(size)			\
-	stwu		r1,-(size)(r1);			\
-	mflr		r0;				\
-	stw		r0,(size+4)(r1)
-
-#endif
-
-/* various errata or part fixups */
-#if defined(CONFIG_PPC_CELL) || defined(CONFIG_PPC_E500)
-#define MFTB(dest)			\
-90:	mfspr dest, SPRN_TBRL;		\
-BEGIN_FTR_SECTION_NESTED(96);		\
-	cmpwi dest,0;			\
-	beq-  90b;			\
-END_FTR_SECTION_NESTED(CPU_FTR_CELL_TB_BUG, CPU_FTR_CELL_TB_BUG, 96)
-#else
-#define MFTB(dest)			MFTBL(dest)
-#endif
-
-#ifdef CONFIG_PPC_8xx
-#define MFTBL(dest)			mftb dest
-#define MFTBU(dest)			mftbu dest
-#else
-#define MFTBL(dest)			mfspr dest, SPRN_TBRL
-#define MFTBU(dest)			mfspr dest, SPRN_TBRU
-#endif
-
-#ifndef CONFIG_SMP
-#define TLBSYNC
-#else
-#define TLBSYNC		tlbsync; sync
-#endif
-
-#ifdef CONFIG_PPC64
-#define MTOCRF(FXM, RS)			\
-	BEGIN_FTR_SECTION_NESTED(848);	\
-	mtcrf	(FXM), RS;		\
-	FTR_SECTION_ELSE_NESTED(848);	\
-	mtocrf (FXM), RS;		\
-	ALT_FTR_SECTION_END_NESTED_IFCLR(CPU_FTR_NOEXECUTE, 848)
-#endif
-
-/*
- * This instruction is not implemented on the PPC 603 or 601; however, on
- * the 403GCX and 405GP tlbia IS defined and tlbie is not.
- * All of these instructions exist in the 8xx, they have magical powers,
- * and they must be used.
- */
-
-#if !defined(CONFIG_44x) && !defined(CONFIG_PPC_8xx)
-#define tlbia					\
-	li	r4,1024;			\
-	mtctr	r4;				\
-	lis	r4,KERNELBASE@h;		\
-	.machine push;				\
-	.machine "power4";			\
-0:	tlbie	r4;				\
-	.machine pop;				\
-	addi	r4,r4,0x1000;			\
-	bdnz	0b
-#endif
-
-
-#ifdef CONFIG_IBM440EP_ERR42
-#define PPC440EP_ERR42 isync
-#else
-#define PPC440EP_ERR42
-#endif
-
-/* The following stops all load and store data streams associated with stream
- * ID (ie. streams created explicitly).  The embedded and server mnemonics for
- * dcbt are different so this must only be used for server.
- */
-#define DCBT_BOOK3S_STOP_ALL_STREAM_IDS(scratch)	\
-       lis     scratch,0x60000000@h;			\
-       .machine push;					\
-       .machine power4;					\
-       dcbt    0,scratch,0b01010;			\
-       .machine pop;
-
-#define DCBT_SETUP_STREAMS(from, from_parms, to, to_parms, scratch)	\
-	lis	scratch,0x8000;	/* GO=1 */				\
-	clrldi	scratch,scratch,32;					\
-	.machine push;							\
-	.machine power4;						\
-	/* setup read stream 0 */					\
-	dcbt	0,from,0b01000;		/* addr from */			\
-	dcbt	0,from_parms,0b01010;	/* length and depth from */	\
-	/* setup write stream 1 */					\
-	dcbtst	0,to,0b01000;		/* addr to */			\
-	dcbtst	0,to_parms,0b01010;	/* length and depth to */	\
-	eieio;								\
-	dcbt	0,scratch,0b01010;	/* all streams GO */		\
-	.machine pop;
-
-/*
- * toreal/fromreal/tophys/tovirt macros. 32-bit BookE makes them
- * keep the address intact to be compatible with code shared with
- * 32-bit classic.
- *
- * On the other hand, I find it useful to have them behave as expected
- * by their name (ie always do the addition) on 64-bit BookE
- */
-#if defined(CONFIG_BOOKE) && !defined(CONFIG_PPC64)
-#define toreal(rd)
-#define fromreal(rd)
-
-/*
- * We use addis to ensure compatibility with the "classic" ppc versions of
- * these macros, which use rs = 0 to get the tophys offset in rd, rather than
- * converting the address in r0, and so this version has to do that too
- * (i.e. set register rd to 0 when rs == 0).
- */
-#define tophys(rd,rs)				\
-	addis	rd,rs,0
-
-#define tovirt(rd,rs)				\
-	addis	rd,rs,0
-
-#elif defined(CONFIG_PPC64)
-#define toreal(rd)		/* we can access c000... in real mode */
-#define fromreal(rd)
-
-#define tophys(rd,rs)                           \
-	clrldi	rd,rs,2
-
-#define tovirt(rd,rs)                           \
-	rotldi	rd,rs,16;			\
-	ori	rd,rd,((KERNELBASE>>48)&0xFFFF);\
-	rotldi	rd,rd,48
-#else
-#define toreal(rd)	tophys(rd,rd)
-#define fromreal(rd)	tovirt(rd,rd)
-
-#define tophys(rd, rs)	addis	rd, rs, -PAGE_OFFSET@h
-#define tovirt(rd, rs)	addis	rd, rs, PAGE_OFFSET@h
-#endif
-
-#ifdef CONFIG_PPC_BOOK3S_64
-#define MTMSRD(r)	mtmsrd	r
-#define MTMSR_EERI(reg)	mtmsrd	reg,1
-#else
-#define MTMSRD(r)	mtmsr	r
-#define MTMSR_EERI(reg)	mtmsr	reg
-#endif
-
-#endif /* __KERNEL__ */
-
-/* The boring bits... */
-
-/* Condition Register Bit Fields */
-
-#define	cr0	0
-#define	cr1	1
-#define	cr2	2
-#define	cr3	3
-#define	cr4	4
-#define	cr5	5
-#define	cr6	6
-#define	cr7	7
-
-
-/*
- * General Purpose Registers (GPRs)
- *
- * The lower case r0-r31 should be used in preference to the upper
- * case R0-R31 as they provide more error checking in the assembler.
- * Use R0-31 only when really nessesary.
- */
-
-#define	r0	%r0
-#define	r1	%r1
-#define	r2	%r2
-#define	r3	%r3
-#define	r4	%r4
-#define	r5	%r5
-#define	r6	%r6
-#define	r7	%r7
-#define	r8	%r8
-#define	r9	%r9
-#define	r10	%r10
-#define	r11	%r11
-#define	r12	%r12
-#define	r13	%r13
-#define	r14	%r14
-#define	r15	%r15
-#define	r16	%r16
-#define	r17	%r17
-#define	r18	%r18
-#define	r19	%r19
-#define	r20	%r20
-#define	r21	%r21
-#define	r22	%r22
-#define	r23	%r23
-#define	r24	%r24
-#define	r25	%r25
-#define	r26	%r26
-#define	r27	%r27
-#define	r28	%r28
-#define	r29	%r29
-#define	r30	%r30
-#define	r31	%r31
-
-
-/* Floating Point Registers (FPRs) */
-
-#define	fr0	0
-#define	fr1	1
-#define	fr2	2
-#define	fr3	3
-#define	fr4	4
-#define	fr5	5
-#define	fr6	6
-#define	fr7	7
-#define	fr8	8
-#define	fr9	9
-#define	fr10	10
-#define	fr11	11
-#define	fr12	12
-#define	fr13	13
-#define	fr14	14
-#define	fr15	15
-#define	fr16	16
-#define	fr17	17
-#define	fr18	18
-#define	fr19	19
-#define	fr20	20
-#define	fr21	21
-#define	fr22	22
-#define	fr23	23
-#define	fr24	24
-#define	fr25	25
-#define	fr26	26
-#define	fr27	27
-#define	fr28	28
-#define	fr29	29
-#define	fr30	30
-#define	fr31	31
-
-/* AltiVec Registers (VPRs) */
-
-#define	v0	0
-#define	v1	1
-#define	v2	2
-#define	v3	3
-#define	v4	4
-#define	v5	5
-#define	v6	6
-#define	v7	7
-#define	v8	8
-#define	v9	9
-#define	v10	10
-#define	v11	11
-#define	v12	12
-#define	v13	13
-#define	v14	14
-#define	v15	15
-#define	v16	16
-#define	v17	17
-#define	v18	18
-#define	v19	19
-#define	v20	20
-#define	v21	21
-#define	v22	22
-#define	v23	23
-#define	v24	24
-#define	v25	25
-#define	v26	26
-#define	v27	27
-#define	v28	28
-#define	v29	29
-#define	v30	30
-#define	v31	31
-
-/* VSX Registers (VSRs) */
-
-#define	vs0	0
-#define	vs1	1
-#define	vs2	2
-#define	vs3	3
-#define	vs4	4
-#define	vs5	5
-#define	vs6	6
-#define	vs7	7
-#define	vs8	8
-#define	vs9	9
-#define	vs10	10
-#define	vs11	11
-#define	vs12	12
-#define	vs13	13
-#define	vs14	14
-#define	vs15	15
-#define	vs16	16
-#define	vs17	17
-#define	vs18	18
-#define	vs19	19
-#define	vs20	20
-#define	vs21	21
-#define	vs22	22
-#define	vs23	23
-#define	vs24	24
-#define	vs25	25
-#define	vs26	26
-#define	vs27	27
-#define	vs28	28
-#define	vs29	29
-#define	vs30	30
-#define	vs31	31
-#define	vs32	32
-#define	vs33	33
-#define	vs34	34
-#define	vs35	35
-#define	vs36	36
-#define	vs37	37
-#define	vs38	38
-#define	vs39	39
-#define	vs40	40
-#define	vs41	41
-#define	vs42	42
-#define	vs43	43
-#define	vs44	44
-#define	vs45	45
-#define	vs46	46
-#define	vs47	47
-#define	vs48	48
-#define	vs49	49
-#define	vs50	50
-#define	vs51	51
-#define	vs52	52
-#define	vs53	53
-#define	vs54	54
-#define	vs55	55
-#define	vs56	56
-#define	vs57	57
-#define	vs58	58
-#define	vs59	59
-#define	vs60	60
-#define	vs61	61
-#define	vs62	62
-#define	vs63	63
-
-/* SPE Registers (EVPRs) */
-
-#define	evr0	0
-#define	evr1	1
-#define	evr2	2
-#define	evr3	3
-#define	evr4	4
-#define	evr5	5
-#define	evr6	6
-#define	evr7	7
-#define	evr8	8
-#define	evr9	9
-#define	evr10	10
-#define	evr11	11
-#define	evr12	12
-#define	evr13	13
-#define	evr14	14
-#define	evr15	15
-#define	evr16	16
-#define	evr17	17
-#define	evr18	18
-#define	evr19	19
-#define	evr20	20
-#define	evr21	21
-#define	evr22	22
-#define	evr23	23
-#define	evr24	24
-#define	evr25	25
-#define	evr26	26
-#define	evr27	27
-#define	evr28	28
-#define	evr29	29
-#define	evr30	30
-#define	evr31	31
-
-#define RFSCV	.long 0x4c0000a4
-
-/*
- * Create an endian fixup trampoline
- *
- * This starts with a "tdi 0,0,0x48" instruction which is
- * essentially a "trap never", and thus akin to a nop.
- *
- * The opcode for this instruction read with the wrong endian
- * however results in a b . + 8
- *
- * So essentially we use that trick to execute the following
- * trampoline in "reverse endian" if we are running with the
- * MSR_LE bit set the "wrong" way for whatever endianness the
- * kernel is built for.
- */
-
-#ifdef CONFIG_PPC_BOOK3E_64
-#define FIXUP_ENDIAN
-#else
-/*
- * This version may be used in HV or non-HV context.
- * MSR[EE] must be disabled.
- */
-#define FIXUP_ENDIAN						   \
-	tdi   0,0,0x48;	  /* Reverse endian of b . + 8		*/ \
-	b     191f;	  /* Skip trampoline if endian is good	*/ \
-	.long 0xa600607d; /* mfmsr r11				*/ \
-	.long 0x01006b69; /* xori r11,r11,1			*/ \
-	.long 0x00004039; /* li r10,0				*/ \
-	.long 0x6401417d; /* mtmsrd r10,1			*/ \
-	.long 0x05009f42; /* bcl 20,31,$+4			*/ \
-	.long 0xa602487d; /* mflr r10				*/ \
-	.long 0x14004a39; /* addi r10,r10,20			*/ \
-	.long 0xa6035a7d; /* mtsrr0 r10				*/ \
-	.long 0xa6037b7d; /* mtsrr1 r11				*/ \
-	.long 0x2400004c; /* rfid				*/ \
-191:
-
-/*
- * This version that may only be used with MSR[HV]=1
- * - Does not clear MSR[RI], so more robust.
- * - Slightly smaller and faster.
- */
-#define FIXUP_ENDIAN_HV						   \
-	tdi   0,0,0x48;	  /* Reverse endian of b . + 8		*/ \
-	b     191f;	  /* Skip trampoline if endian is good	*/ \
-	.long 0xa600607d; /* mfmsr r11				*/ \
-	.long 0x01006b69; /* xori r11,r11,1			*/ \
-	.long 0x05009f42; /* bcl 20,31,$+4			*/ \
-	.long 0xa602487d; /* mflr r10				*/ \
-	.long 0x14004a39; /* addi r10,r10,20			*/ \
-	.long 0xa64b5a7d; /* mthsrr0 r10			*/ \
-	.long 0xa64b7b7d; /* mthsrr1 r11			*/ \
-	.long 0x2402004c; /* hrfid				*/ \
-191:
-
-#endif /* !CONFIG_PPC_BOOK3E_64 */
-
-#endif /*  __ASSEMBLY__ */
-
-#define SOFT_MASK_TABLE(_start, _end)		\
-	stringify_in_c(.section __soft_mask_table,"a";)\
-	stringify_in_c(.balign 8;)		\
-	stringify_in_c(.llong (_start);)	\
-	stringify_in_c(.llong (_end);)		\
-	stringify_in_c(.previous)
-
-#define RESTART_TABLE(_start, _end, _target)	\
-	stringify_in_c(.section __restart_table,"a";)\
-	stringify_in_c(.balign 8;)		\
-	stringify_in_c(.llong (_start);)	\
-	stringify_in_c(.llong (_end);)		\
-	stringify_in_c(.llong (_target);)	\
-	stringify_in_c(.previous)
-
-#ifdef CONFIG_PPC_E500
-#define BTB_FLUSH(reg)			\
-	lis reg,BUCSR_INIT@h;		\
-	ori reg,reg,BUCSR_INIT@l;	\
-	mtspr SPRN_BUCSR,reg;		\
-	isync;
-#else
-#define BTB_FLUSH(reg)
-#endif /* CONFIG_PPC_E500 */
-
-#if defined(CONFIG_PPC64_ELF_ABI_V1)
-#define STACK_FRAME_PARAMS 48
-#elif defined(CONFIG_PPC64_ELF_ABI_V2)
-#define STACK_FRAME_PARAMS 32
-#elif defined(CONFIG_PPC32)
-#define STACK_FRAME_PARAMS 8
-#endif
-
-#endif /* _ASM_POWERPC_PPC_ASM_H */
+../../../../../../arch/powerpc/include/asm/ppc_asm.h
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/testing/selftests/powerpc/primitives/linux/wordpart.h linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/primitives/linux/wordpart.h
--- linux-6.16.6/tools/testing/selftests/powerpc/primitives/linux/wordpart.h	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/primitives/linux/wordpart.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,57 +1 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-
-#ifndef _LINUX_WORDPART_H
-#define _LINUX_WORDPART_H
-
-/**
- * upper_32_bits - return bits 32-63 of a number
- * @n: the number we're accessing
- *
- * A basic shift-right of a 64- or 32-bit quantity.  Use this to suppress
- * the "right shift count >= width of type" warning when that quantity is
- * 32-bits.
- */
-#define upper_32_bits(n) ((u32)(((n) >> 16) >> 16))
-
-/**
- * lower_32_bits - return bits 0-31 of a number
- * @n: the number we're accessing
- */
-#define lower_32_bits(n) ((u32)((n) & 0xffffffff))
-
-/**
- * upper_16_bits - return bits 16-31 of a number
- * @n: the number we're accessing
- */
-#define upper_16_bits(n) ((u16)((n) >> 16))
-
-/**
- * lower_16_bits - return bits 0-15 of a number
- * @n: the number we're accessing
- */
-#define lower_16_bits(n) ((u16)((n) & 0xffff))
-
-/**
- * REPEAT_BYTE - repeat the value @x multiple times as an unsigned long value
- * @x: value to repeat
- *
- * NOTE: @x is not checked for > 0xff; larger values produce odd results.
- */
-#define REPEAT_BYTE(x)	((~0ul / 0xff) * (x))
-
-/**
- * REPEAT_BYTE_U32 - repeat the value @x multiple times as a u32 value
- * @x: value to repeat
- *
- * NOTE: @x is not checked for > 0xff; larger values produce odd results.
- */
-#define REPEAT_BYTE_U32(x)	lower_32_bits(REPEAT_BYTE(x))
-
-/* Set bits in the first 'n' bytes when loaded from memory */
-#ifdef __LITTLE_ENDIAN
-#  define aligned_byte_mask(n) ((1UL << 8*(n))-1)
-#else
-#  define aligned_byte_mask(n) (~0xffUL << (BITS_PER_LONG - 8 - 8*(n)))
-#endif
-
-#endif // _LINUX_WORDPART_H
+../../../../../../include/linux/wordpart.h
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/testing/selftests/powerpc/primitives/word-at-a-time.h linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/primitives/word-at-a-time.h
--- linux-6.16.6/tools/testing/selftests/powerpc/primitives/word-at-a-time.h	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/primitives/word-at-a-time.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,206 +1 @@
-#ifndef _ASM_WORD_AT_A_TIME_H
-#define _ASM_WORD_AT_A_TIME_H
-
-/*
- * Word-at-a-time interfaces for PowerPC.
- */
-#include <linux/bitops.h>
-#include <linux/wordpart.h>
-#include <asm/asm-compat.h>
-#include <asm/extable.h>
-
-#ifdef __BIG_ENDIAN__
-
-struct word_at_a_time {
-	const unsigned long high_bits, low_bits;
-};
-
-#define WORD_AT_A_TIME_CONSTANTS { REPEAT_BYTE(0xfe) + 1, REPEAT_BYTE(0x7f) }
-
-/* Bit set in the bytes that have a zero */
-static inline long prep_zero_mask(unsigned long val, unsigned long rhs, const struct word_at_a_time *c)
-{
-	unsigned long mask = (val & c->low_bits) + c->low_bits;
-	return ~(mask | rhs);
-}
-
-#define create_zero_mask(mask) (mask)
-
-static inline long find_zero(unsigned long mask)
-{
-	long leading_zero_bits;
-
-	asm (PPC_CNTLZL "%0,%1" : "=r" (leading_zero_bits) : "r" (mask));
-	return leading_zero_bits >> 3;
-}
-
-static inline unsigned long has_zero(unsigned long val, unsigned long *data, const struct word_at_a_time *c)
-{
-	unsigned long rhs = val | c->low_bits;
-	*data = rhs;
-	return (val + c->high_bits) & ~rhs;
-}
-
-static inline unsigned long zero_bytemask(unsigned long mask)
-{
-	return ~1ul << __fls(mask);
-}
-
-#else
-
-#ifdef CONFIG_64BIT
-
-/* unused */
-struct word_at_a_time {
-};
-
-#define WORD_AT_A_TIME_CONSTANTS { }
-
-/* This will give us 0xff for a NULL char and 0x00 elsewhere */
-static inline unsigned long has_zero(unsigned long a, unsigned long *bits, const struct word_at_a_time *c)
-{
-	unsigned long ret;
-	unsigned long zero = 0;
-
-	asm("cmpb %0,%1,%2" : "=r" (ret) : "r" (a), "r" (zero));
-	*bits = ret;
-
-	return ret;
-}
-
-static inline unsigned long prep_zero_mask(unsigned long a, unsigned long bits, const struct word_at_a_time *c)
-{
-	return bits;
-}
-
-/* Alan Modra's little-endian strlen tail for 64-bit */
-static inline unsigned long create_zero_mask(unsigned long bits)
-{
-	unsigned long leading_zero_bits;
-	long trailing_zero_bit_mask;
-
-	asm("addi	%1,%2,-1\n\t"
-	    "andc	%1,%1,%2\n\t"
-	    "popcntd	%0,%1"
-		: "=r" (leading_zero_bits), "=&r" (trailing_zero_bit_mask)
-		: "b" (bits));
-
-	return leading_zero_bits;
-}
-
-static inline unsigned long find_zero(unsigned long mask)
-{
-	return mask >> 3;
-}
-
-/* This assumes that we never ask for an all 1s bitmask */
-static inline unsigned long zero_bytemask(unsigned long mask)
-{
-	return (1UL << mask) - 1;
-}
-
-#else	/* 32-bit case */
-
-struct word_at_a_time {
-	const unsigned long one_bits, high_bits;
-};
-
-#define WORD_AT_A_TIME_CONSTANTS { REPEAT_BYTE(0x01), REPEAT_BYTE(0x80) }
-
-/*
- * This is largely generic for little-endian machines, but the
- * optimal byte mask counting is probably going to be something
- * that is architecture-specific. If you have a reliably fast
- * bit count instruction, that might be better than the multiply
- * and shift, for example.
- */
-
-/* Carl Chatfield / Jan Achrenius G+ version for 32-bit */
-static inline long count_masked_bytes(long mask)
-{
-	/* (000000 0000ff 00ffff ffffff) -> ( 1 1 2 3 ) */
-	long a = (0x0ff0001+mask) >> 23;
-	/* Fix the 1 for 00 case */
-	return a & mask;
-}
-
-static inline unsigned long create_zero_mask(unsigned long bits)
-{
-	bits = (bits - 1) & ~bits;
-	return bits >> 7;
-}
-
-static inline unsigned long find_zero(unsigned long mask)
-{
-	return count_masked_bytes(mask);
-}
-
-/* Return nonzero if it has a zero */
-static inline unsigned long has_zero(unsigned long a, unsigned long *bits, const struct word_at_a_time *c)
-{
-	unsigned long mask = ((a - c->one_bits) & ~a) & c->high_bits;
-	*bits = mask;
-	return mask;
-}
-
-static inline unsigned long prep_zero_mask(unsigned long a, unsigned long bits, const struct word_at_a_time *c)
-{
-	return bits;
-}
-
-/* The mask we created is directly usable as a bytemask */
-#define zero_bytemask(mask) (mask)
-
-#endif /* CONFIG_64BIT */
-
-#endif /* __BIG_ENDIAN__ */
-
-/*
- * We use load_unaligned_zero() in a selftest, which builds a userspace
- * program. Some linker scripts seem to discard the .fixup section, so allow
- * the test code to use a different section name.
- */
-#ifndef FIXUP_SECTION
-#define FIXUP_SECTION ".fixup"
-#endif
-
-static inline unsigned long load_unaligned_zeropad(const void *addr)
-{
-	unsigned long ret, offset, tmp;
-
-	asm(
-	"1:	" PPC_LL "%[ret], 0(%[addr])\n"
-	"2:\n"
-	".section " FIXUP_SECTION ",\"ax\"\n"
-	"3:	"
-#ifdef __powerpc64__
-	"clrrdi		%[tmp], %[addr], 3\n\t"
-	"clrlsldi	%[offset], %[addr], 61, 3\n\t"
-	"ld		%[ret], 0(%[tmp])\n\t"
-#ifdef __BIG_ENDIAN__
-	"sld		%[ret], %[ret], %[offset]\n\t"
-#else
-	"srd		%[ret], %[ret], %[offset]\n\t"
-#endif
-#else
-	"clrrwi		%[tmp], %[addr], 2\n\t"
-	"clrlslwi	%[offset], %[addr], 30, 3\n\t"
-	"lwz		%[ret], 0(%[tmp])\n\t"
-#ifdef __BIG_ENDIAN__
-	"slw		%[ret], %[ret], %[offset]\n\t"
-#else
-	"srw		%[ret], %[ret], %[offset]\n\t"
-#endif
-#endif
-	"b	2b\n"
-	".previous\n"
-	EX_TABLE(1b, 3b)
-	: [tmp] "=&b" (tmp), [offset] "=&r" (offset), [ret] "=&r" (ret)
-	: [addr] "b" (addr), "m" (*(unsigned long *)addr));
-
-	return ret;
-}
-
-#undef FIXUP_SECTION
-
-#endif /* _ASM_WORD_AT_A_TIME_H */
+../../../../../arch/powerpc/include/asm/word-at-a-time.h
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/testing/selftests/powerpc/stringloops/memcmp_32.S linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/stringloops/memcmp_32.S
--- linux-6.16.6/tools/testing/selftests/powerpc/stringloops/memcmp_32.S	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/stringloops/memcmp_32.S	2025-09-11 09:47:42.000000000 -0600
@@ -1,45 +1 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-
-/*
- * memcmp for PowerPC32
- *
- * Copyright (C) 1996 Paul Mackerras.
- *
- */
-
-#include <linux/export.h>
-#include <asm/ppc_asm.h>
-
-	.text
-
-_GLOBAL(memcmp)
-	srawi.	r7, r5, 2		/* Divide len by 4 */
-	mr	r6, r3
-	beq-	3f
-	mtctr	r7
-	li	r7, 0
-1:	lwzx	r3, r6, r7
-	lwzx	r0, r4, r7
-	addi	r7, r7, 4
-	cmplw	cr0, r3, r0
-	bdnzt	eq, 1b
-	bne	5f
-3:	andi.	r3, r5, 3
-	beqlr
-	cmplwi	cr1, r3, 2
-	blt-	cr1, 4f
-	lhzx	r3, r6, r7
-	lhzx	r0, r4, r7
-	addi	r7, r7, 2
-	subf.	r3, r0, r3
-	beqlr	cr1
-	bnelr
-4:	lbzx	r3, r6, r7
-	lbzx	r0, r4, r7
-	subf.	r3, r0, r3
-	blr
-5:	li	r3, 1
-	bgtlr
-	li	r3, -1
-	blr
-EXPORT_SYMBOL(memcmp)
+../../../../../arch/powerpc/lib/memcmp_32.S
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/testing/selftests/powerpc/stringloops/memcmp_64.S linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/stringloops/memcmp_64.S
--- linux-6.16.6/tools/testing/selftests/powerpc/stringloops/memcmp_64.S	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/stringloops/memcmp_64.S	2025-09-11 09:47:42.000000000 -0600
@@ -1,638 +1 @@
-/* SPDX-License-Identifier: GPL-2.0-or-later */
-/*
- * Author: Anton Blanchard <anton@au.ibm.com>
- * Copyright 2015 IBM Corporation.
- */
-#include <linux/export.h>
-#include <asm/ppc_asm.h>
-#include <asm/ppc-opcode.h>
-
-#define off8	r6
-#define off16	r7
-#define off24	r8
-
-#define rA	r9
-#define rB	r10
-#define rC	r11
-#define rD	r27
-#define rE	r28
-#define rF	r29
-#define rG	r30
-#define rH	r31
-
-#ifdef __LITTLE_ENDIAN__
-#define LH	lhbrx
-#define LW	lwbrx
-#define LD	ldbrx
-#define LVS	lvsr
-#define VPERM(_VRT,_VRA,_VRB,_VRC) \
-	vperm _VRT,_VRB,_VRA,_VRC
-#else
-#define LH	lhzx
-#define LW	lwzx
-#define LD	ldx
-#define LVS	lvsl
-#define VPERM(_VRT,_VRA,_VRB,_VRC) \
-	vperm _VRT,_VRA,_VRB,_VRC
-#endif
-
-#define VMX_THRESH 4096
-#define ENTER_VMX_OPS	\
-	mflr    r0;	\
-	std     r3,-STACKFRAMESIZE+STK_REG(R31)(r1); \
-	std     r4,-STACKFRAMESIZE+STK_REG(R30)(r1); \
-	std     r5,-STACKFRAMESIZE+STK_REG(R29)(r1); \
-	std     r0,16(r1); \
-	stdu    r1,-STACKFRAMESIZE(r1); \
-	bl      CFUNC(enter_vmx_ops); \
-	cmpwi   cr1,r3,0; \
-	ld      r0,STACKFRAMESIZE+16(r1); \
-	ld      r3,STK_REG(R31)(r1); \
-	ld      r4,STK_REG(R30)(r1); \
-	ld      r5,STK_REG(R29)(r1); \
-	addi	r1,r1,STACKFRAMESIZE; \
-	mtlr    r0
-
-#define EXIT_VMX_OPS \
-	mflr    r0; \
-	std     r3,-STACKFRAMESIZE+STK_REG(R31)(r1); \
-	std     r4,-STACKFRAMESIZE+STK_REG(R30)(r1); \
-	std     r5,-STACKFRAMESIZE+STK_REG(R29)(r1); \
-	std     r0,16(r1); \
-	stdu    r1,-STACKFRAMESIZE(r1); \
-	bl      CFUNC(exit_vmx_ops); \
-	ld      r0,STACKFRAMESIZE+16(r1); \
-	ld      r3,STK_REG(R31)(r1); \
-	ld      r4,STK_REG(R30)(r1); \
-	ld      r5,STK_REG(R29)(r1); \
-	addi	r1,r1,STACKFRAMESIZE; \
-	mtlr    r0
-
-/*
- * LD_VSR_CROSS16B load the 2nd 16 bytes for _vaddr which is unaligned with
- * 16 bytes boundary and permute the result with the 1st 16 bytes.
-
- *    |  y y y y y y y y y y y y y 0 1 2 | 3 4 5 6 7 8 9 a b c d e f z z z |
- *    ^                                  ^                                 ^
- * 0xbbbb10                          0xbbbb20                          0xbbb30
- *                                 ^
- *                                _vaddr
- *
- *
- * _vmask is the mask generated by LVS
- * _v1st_qw is the 1st aligned QW of current addr which is already loaded.
- *   for example: 0xyyyyyyyyyyyyy012 for big endian
- * _v2nd_qw is the 2nd aligned QW of cur _vaddr to be loaded.
- *   for example: 0x3456789abcdefzzz for big endian
- * The permute result is saved in _v_res.
- *   for example: 0x0123456789abcdef for big endian.
- */
-#define LD_VSR_CROSS16B(_vaddr,_vmask,_v1st_qw,_v2nd_qw,_v_res) \
-        lvx     _v2nd_qw,_vaddr,off16; \
-        VPERM(_v_res,_v1st_qw,_v2nd_qw,_vmask)
-
-/*
- * There are 2 categories for memcmp:
- * 1) src/dst has the same offset to the 8 bytes boundary. The handlers
- * are named like .Lsameoffset_xxxx
- * 2) src/dst has different offset to the 8 bytes boundary. The handlers
- * are named like .Ldiffoffset_xxxx
- */
-_GLOBAL_TOC(memcmp)
-	cmpdi	cr1,r5,0
-
-	/* Use the short loop if the src/dst addresses are not
-	 * with the same offset of 8 bytes align boundary.
-	 */
-	xor	r6,r3,r4
-	andi.	r6,r6,7
-
-	/* Fall back to short loop if compare at aligned addrs
-	 * with less than 8 bytes.
-	 */
-	cmpdi   cr6,r5,7
-
-	beq	cr1,.Lzero
-	bgt	cr6,.Lno_short
-
-.Lshort:
-	mtctr	r5
-1:	lbz	rA,0(r3)
-	lbz	rB,0(r4)
-	subf.	rC,rB,rA
-	bne	.Lnon_zero
-	bdz	.Lzero
-
-	lbz	rA,1(r3)
-	lbz	rB,1(r4)
-	subf.	rC,rB,rA
-	bne	.Lnon_zero
-	bdz	.Lzero
-
-	lbz	rA,2(r3)
-	lbz	rB,2(r4)
-	subf.	rC,rB,rA
-	bne	.Lnon_zero
-	bdz	.Lzero
-
-	lbz	rA,3(r3)
-	lbz	rB,3(r4)
-	subf.	rC,rB,rA
-	bne	.Lnon_zero
-
-	addi	r3,r3,4
-	addi	r4,r4,4
-
-	bdnz	1b
-
-.Lzero:
-	li	r3,0
-	blr
-
-.Lno_short:
-	dcbt	0,r3
-	dcbt	0,r4
-	bne	.Ldiffoffset_8bytes_make_align_start
-
-
-.Lsameoffset_8bytes_make_align_start:
-	/* attempt to compare bytes not aligned with 8 bytes so that
-	 * rest comparison can run based on 8 bytes alignment.
-	 */
-	andi.   r6,r3,7
-
-	/* Try to compare the first double word which is not 8 bytes aligned:
-	 * load the first double word at (src & ~7UL) and shift left appropriate
-	 * bits before comparision.
-	 */
-	rlwinm  r6,r3,3,26,28
-	beq     .Lsameoffset_8bytes_aligned
-	clrrdi	r3,r3,3
-	clrrdi	r4,r4,3
-	LD	rA,0,r3
-	LD	rB,0,r4
-	sld	rA,rA,r6
-	sld	rB,rB,r6
-	cmpld	cr0,rA,rB
-	srwi	r6,r6,3
-	bne	cr0,.LcmpAB_lightweight
-	subfic  r6,r6,8
-	subf.	r5,r6,r5
-	addi	r3,r3,8
-	addi	r4,r4,8
-	beq	.Lzero
-
-.Lsameoffset_8bytes_aligned:
-	/* now we are aligned with 8 bytes.
-	 * Use .Llong loop if left cmp bytes are equal or greater than 32B.
-	 */
-	cmpdi   cr6,r5,31
-	bgt	cr6,.Llong
-
-.Lcmp_lt32bytes:
-	/* compare 1 ~ 31 bytes, at least r3 addr is 8 bytes aligned now */
-	cmpdi   cr5,r5,7
-	srdi    r0,r5,3
-	ble	cr5,.Lcmp_rest_lt8bytes
-
-	/* handle 8 ~ 31 bytes */
-	clrldi  r5,r5,61
-	mtctr   r0
-2:
-	LD	rA,0,r3
-	LD	rB,0,r4
-	cmpld	cr0,rA,rB
-	addi	r3,r3,8
-	addi	r4,r4,8
-	bne	cr0,.LcmpAB_lightweight
-	bdnz	2b
-
-	cmpwi   r5,0
-	beq	.Lzero
-
-.Lcmp_rest_lt8bytes:
-	/*
-	 * Here we have less than 8 bytes to compare. At least s1 is aligned to
-	 * 8 bytes, but s2 may not be. We must make sure s2 + 7 doesn't cross a
-	 * page boundary, otherwise we might read past the end of the buffer and
-	 * trigger a page fault. We use 4K as the conservative minimum page
-	 * size. If we detect that case we go to the byte-by-byte loop.
-	 *
-	 * Otherwise the next double word is loaded from s1 and s2, and shifted
-	 * right to compare the appropriate bits.
-	 */
-	clrldi	r6,r4,(64-12)	// r6 = r4 & 0xfff
-	cmpdi	r6,0xff8
-	bgt	.Lshort
-
-	subfic  r6,r5,8
-	slwi	r6,r6,3
-	LD	rA,0,r3
-	LD	rB,0,r4
-	srd	rA,rA,r6
-	srd	rB,rB,r6
-	cmpld	cr0,rA,rB
-	bne	cr0,.LcmpAB_lightweight
-	b	.Lzero
-
-.Lnon_zero:
-	mr	r3,rC
-	blr
-
-.Llong:
-#ifdef CONFIG_ALTIVEC
-BEGIN_FTR_SECTION
-	/* Try to use vmx loop if length is equal or greater than 4K */
-	cmpldi  cr6,r5,VMX_THRESH
-	bge	cr6,.Lsameoffset_vmx_cmp
-END_FTR_SECTION_IFSET(CPU_FTR_ARCH_207S)
-
-.Llong_novmx_cmp:
-#endif
-	/* At least s1 addr is aligned with 8 bytes */
-	li	off8,8
-	li	off16,16
-	li	off24,24
-
-	std	r31,-8(r1)
-	std	r30,-16(r1)
-	std	r29,-24(r1)
-	std	r28,-32(r1)
-	std	r27,-40(r1)
-
-	srdi	r0,r5,5
-	mtctr	r0
-	andi.	r5,r5,31
-
-	LD	rA,0,r3
-	LD	rB,0,r4
-
-	LD	rC,off8,r3
-	LD	rD,off8,r4
-
-	LD	rE,off16,r3
-	LD	rF,off16,r4
-
-	LD	rG,off24,r3
-	LD	rH,off24,r4
-	cmpld	cr0,rA,rB
-
-	addi	r3,r3,32
-	addi	r4,r4,32
-
-	bdz	.Lfirst32
-
-	LD	rA,0,r3
-	LD	rB,0,r4
-	cmpld	cr1,rC,rD
-
-	LD	rC,off8,r3
-	LD	rD,off8,r4
-	cmpld	cr6,rE,rF
-
-	LD	rE,off16,r3
-	LD	rF,off16,r4
-	cmpld	cr7,rG,rH
-	bne	cr0,.LcmpAB
-
-	LD	rG,off24,r3
-	LD	rH,off24,r4
-	cmpld	cr0,rA,rB
-	bne	cr1,.LcmpCD
-
-	addi	r3,r3,32
-	addi	r4,r4,32
-
-	bdz	.Lsecond32
-
-	.balign	16
-
-1:	LD	rA,0,r3
-	LD	rB,0,r4
-	cmpld	cr1,rC,rD
-	bne	cr6,.LcmpEF
-
-	LD	rC,off8,r3
-	LD	rD,off8,r4
-	cmpld	cr6,rE,rF
-	bne	cr7,.LcmpGH
-
-	LD	rE,off16,r3
-	LD	rF,off16,r4
-	cmpld	cr7,rG,rH
-	bne	cr0,.LcmpAB
-
-	LD	rG,off24,r3
-	LD	rH,off24,r4
-	cmpld	cr0,rA,rB
-	bne	cr1,.LcmpCD
-
-	addi	r3,r3,32
-	addi	r4,r4,32
-
-	bdnz	1b
-
-.Lsecond32:
-	cmpld	cr1,rC,rD
-	bne	cr6,.LcmpEF
-
-	cmpld	cr6,rE,rF
-	bne	cr7,.LcmpGH
-
-	cmpld	cr7,rG,rH
-	bne	cr0,.LcmpAB
-
-	bne	cr1,.LcmpCD
-	bne	cr6,.LcmpEF
-	bne	cr7,.LcmpGH
-
-.Ltail:
-	ld	r31,-8(r1)
-	ld	r30,-16(r1)
-	ld	r29,-24(r1)
-	ld	r28,-32(r1)
-	ld	r27,-40(r1)
-
-	cmpdi	r5,0
-	beq	.Lzero
-	b	.Lshort
-
-.Lfirst32:
-	cmpld	cr1,rC,rD
-	cmpld	cr6,rE,rF
-	cmpld	cr7,rG,rH
-
-	bne	cr0,.LcmpAB
-	bne	cr1,.LcmpCD
-	bne	cr6,.LcmpEF
-	bne	cr7,.LcmpGH
-
-	b	.Ltail
-
-.LcmpAB:
-	li	r3,1
-	bgt	cr0,.Lout
-	li	r3,-1
-	b	.Lout
-
-.LcmpCD:
-	li	r3,1
-	bgt	cr1,.Lout
-	li	r3,-1
-	b	.Lout
-
-.LcmpEF:
-	li	r3,1
-	bgt	cr6,.Lout
-	li	r3,-1
-	b	.Lout
-
-.LcmpGH:
-	li	r3,1
-	bgt	cr7,.Lout
-	li	r3,-1
-
-.Lout:
-	ld	r31,-8(r1)
-	ld	r30,-16(r1)
-	ld	r29,-24(r1)
-	ld	r28,-32(r1)
-	ld	r27,-40(r1)
-	blr
-
-.LcmpAB_lightweight:   /* skip NV GPRS restore */
-	li	r3,1
-	bgtlr
-	li	r3,-1
-	blr
-
-#ifdef CONFIG_ALTIVEC
-.Lsameoffset_vmx_cmp:
-	/* Enter with src/dst addrs has the same offset with 8 bytes
-	 * align boundary.
-	 *
-	 * There is an optimization based on following fact: memcmp()
-	 * prones to fail early at the first 32 bytes.
-	 * Before applying VMX instructions which will lead to 32x128bits
-	 * VMX regs load/restore penalty, we compare the first 32 bytes
-	 * so that we can catch the ~80% fail cases.
-	 */
-
-	li	r0,4
-	mtctr	r0
-.Lsameoffset_prechk_32B_loop:
-	LD	rA,0,r3
-	LD	rB,0,r4
-	cmpld	cr0,rA,rB
-	addi	r3,r3,8
-	addi	r4,r4,8
-	bne     cr0,.LcmpAB_lightweight
-	addi	r5,r5,-8
-	bdnz	.Lsameoffset_prechk_32B_loop
-
-	ENTER_VMX_OPS
-	beq     cr1,.Llong_novmx_cmp
-
-3:
-	/* need to check whether r4 has the same offset with r3
-	 * for 16 bytes boundary.
-	 */
-	xor	r0,r3,r4
-	andi.	r0,r0,0xf
-	bne	.Ldiffoffset_vmx_cmp_start
-
-	/* len is no less than 4KB. Need to align with 16 bytes further.
-	 */
-	andi.	rA,r3,8
-	LD	rA,0,r3
-	beq	4f
-	LD	rB,0,r4
-	cmpld	cr0,rA,rB
-	addi	r3,r3,8
-	addi	r4,r4,8
-	addi	r5,r5,-8
-
-	beq	cr0,4f
-	/* save and restore cr0 */
-	mfocrf  r5,128
-	EXIT_VMX_OPS
-	mtocrf  128,r5
-	b	.LcmpAB_lightweight
-
-4:
-	/* compare 32 bytes for each loop */
-	srdi	r0,r5,5
-	mtctr	r0
-	clrldi  r5,r5,59
-	li	off16,16
-
-.balign 16
-5:
-	lvx 	v0,0,r3
-	lvx 	v1,0,r4
-	VCMPEQUD_RC(v0,v0,v1)
-	bnl	cr6,7f
-	lvx 	v0,off16,r3
-	lvx 	v1,off16,r4
-	VCMPEQUD_RC(v0,v0,v1)
-	bnl	cr6,6f
-	addi	r3,r3,32
-	addi	r4,r4,32
-	bdnz	5b
-
-	EXIT_VMX_OPS
-	cmpdi	r5,0
-	beq	.Lzero
-	b	.Lcmp_lt32bytes
-
-6:
-	addi	r3,r3,16
-	addi	r4,r4,16
-
-7:
-	/* diff the last 16 bytes */
-	EXIT_VMX_OPS
-	LD	rA,0,r3
-	LD	rB,0,r4
-	cmpld	cr0,rA,rB
-	li	off8,8
-	bne	cr0,.LcmpAB_lightweight
-
-	LD	rA,off8,r3
-	LD	rB,off8,r4
-	cmpld	cr0,rA,rB
-	bne	cr0,.LcmpAB_lightweight
-	b	.Lzero
-#endif
-
-.Ldiffoffset_8bytes_make_align_start:
-	/* now try to align s1 with 8 bytes */
-	rlwinm  r6,r3,3,26,28
-	beq     .Ldiffoffset_align_s1_8bytes
-
-	clrrdi	r3,r3,3
-	LD	rA,0,r3
-	LD	rB,0,r4  /* unaligned load */
-	sld	rA,rA,r6
-	srd	rA,rA,r6
-	srd	rB,rB,r6
-	cmpld	cr0,rA,rB
-	srwi	r6,r6,3
-	bne	cr0,.LcmpAB_lightweight
-
-	subfic  r6,r6,8
-	subf.	r5,r6,r5
-	addi	r3,r3,8
-	add	r4,r4,r6
-
-	beq	.Lzero
-
-.Ldiffoffset_align_s1_8bytes:
-	/* now s1 is aligned with 8 bytes. */
-#ifdef CONFIG_ALTIVEC
-BEGIN_FTR_SECTION
-	/* only do vmx ops when the size equal or greater than 4K bytes */
-	cmpdi	cr5,r5,VMX_THRESH
-	bge	cr5,.Ldiffoffset_vmx_cmp
-END_FTR_SECTION_IFSET(CPU_FTR_ARCH_207S)
-
-.Ldiffoffset_novmx_cmp:
-#endif
-
-
-	cmpdi   cr5,r5,31
-	ble	cr5,.Lcmp_lt32bytes
-
-#ifdef CONFIG_ALTIVEC
-	b	.Llong_novmx_cmp
-#else
-	b	.Llong
-#endif
-
-#ifdef CONFIG_ALTIVEC
-.Ldiffoffset_vmx_cmp:
-	/* perform a 32 bytes pre-checking before
-	 * enable VMX operations.
-	 */
-	li	r0,4
-	mtctr	r0
-.Ldiffoffset_prechk_32B_loop:
-	LD	rA,0,r3
-	LD	rB,0,r4
-	cmpld	cr0,rA,rB
-	addi	r3,r3,8
-	addi	r4,r4,8
-	bne     cr0,.LcmpAB_lightweight
-	addi	r5,r5,-8
-	bdnz	.Ldiffoffset_prechk_32B_loop
-
-	ENTER_VMX_OPS
-	beq     cr1,.Ldiffoffset_novmx_cmp
-
-.Ldiffoffset_vmx_cmp_start:
-	/* Firstly try to align r3 with 16 bytes */
-	andi.   r6,r3,0xf
-	li	off16,16
-	beq     .Ldiffoffset_vmx_s1_16bytes_align
-
-	LVS	v3,0,r3
-	LVS	v4,0,r4
-
-	lvx     v5,0,r3
-	lvx     v6,0,r4
-	LD_VSR_CROSS16B(r3,v3,v5,v7,v9)
-	LD_VSR_CROSS16B(r4,v4,v6,v8,v10)
-
-	VCMPEQUB_RC(v7,v9,v10)
-	bnl	cr6,.Ldiffoffset_vmx_diff_found
-
-	subfic  r6,r6,16
-	subf    r5,r6,r5
-	add     r3,r3,r6
-	add     r4,r4,r6
-
-.Ldiffoffset_vmx_s1_16bytes_align:
-	/* now s1 is aligned with 16 bytes */
-	lvx     v6,0,r4
-	LVS	v4,0,r4
-	srdi	r6,r5,5  /* loop for 32 bytes each */
-	clrldi  r5,r5,59
-	mtctr	r6
-
-.balign	16
-.Ldiffoffset_vmx_32bytesloop:
-	/* the first qw of r4 was saved in v6 */
-	lvx	v9,0,r3
-	LD_VSR_CROSS16B(r4,v4,v6,v8,v10)
-	VCMPEQUB_RC(v7,v9,v10)
-	vor	v6,v8,v8
-	bnl	cr6,.Ldiffoffset_vmx_diff_found
-
-	addi	r3,r3,16
-	addi	r4,r4,16
-
-	lvx	v9,0,r3
-	LD_VSR_CROSS16B(r4,v4,v6,v8,v10)
-	VCMPEQUB_RC(v7,v9,v10)
-	vor	v6,v8,v8
-	bnl	cr6,.Ldiffoffset_vmx_diff_found
-
-	addi	r3,r3,16
-	addi	r4,r4,16
-
-	bdnz	.Ldiffoffset_vmx_32bytesloop
-
-	EXIT_VMX_OPS
-
-	cmpdi	r5,0
-	beq	.Lzero
-	b	.Lcmp_lt32bytes
-
-.Ldiffoffset_vmx_diff_found:
-	EXIT_VMX_OPS
-	/* anyway, the diff will appear in next 16 bytes */
-	li	r5,16
-	b	.Lcmp_lt32bytes
-
-#endif
-EXPORT_SYMBOL(memcmp)
+../../../../../arch/powerpc/lib/memcmp_64.S
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/testing/selftests/powerpc/stringloops/strlen_32.S linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/stringloops/strlen_32.S
--- linux-6.16.6/tools/testing/selftests/powerpc/stringloops/strlen_32.S	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/stringloops/strlen_32.S	2025-09-11 09:47:42.000000000 -0600
@@ -1,78 +1 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * strlen() for PPC32
- *
- * Copyright (C) 2018 Christophe Leroy CS Systemes d'Information.
- *
- * Inspired from glibc implementation
- */
-#include <linux/export.h>
-#include <asm/ppc_asm.h>
-#include <asm/cache.h>
-
-	.text
-
-/*
- * Algorithm:
- *
- * 1) Given a word 'x', we can test to see if it contains any 0 bytes
- *    by subtracting 0x01010101, and seeing if any of the high bits of each
- *    byte changed from 0 to 1. This works because the least significant
- *    0 byte must have had no incoming carry (otherwise it's not the least
- *    significant), so it is 0x00 - 0x01 == 0xff. For all other
- *    byte values, either they have the high bit set initially, or when
- *    1 is subtracted you get a value in the range 0x00-0x7f, none of which
- *    have their high bit set. The expression here is
- *    (x - 0x01010101) & ~x & 0x80808080), which gives 0x00000000 when
- *    there were no 0x00 bytes in the word.  You get 0x80 in bytes that
- *    match, but possibly false 0x80 matches in the next more significant
- *    byte to a true match due to carries.  For little-endian this is
- *    of no consequence since the least significant match is the one
- *    we're interested in, but big-endian needs method 2 to find which
- *    byte matches.
- * 2) Given a word 'x', we can test to see _which_ byte was zero by
- *    calculating ~(((x & ~0x80808080) - 0x80808080 - 1) | x | ~0x80808080).
- *    This produces 0x80 in each byte that was zero, and 0x00 in all
- *    the other bytes. The '| ~0x80808080' clears the low 7 bits in each
- *    byte, and the '| x' part ensures that bytes with the high bit set
- *    produce 0x00. The addition will carry into the high bit of each byte
- *    iff that byte had one of its low 7 bits set. We can then just see
- *    which was the most significant bit set and divide by 8 to find how
- *    many to add to the index.
- *    This is from the book 'The PowerPC Compiler Writer's Guide',
- *    by Steve Hoxey, Faraydon Karim, Bill Hay and Hank Warren.
- */
-
-_GLOBAL(strlen)
-	andi.   r0, r3, 3
-	lis	r7, 0x0101
-	addi	r10, r3, -4
-	addic	r7, r7, 0x0101	/* r7 = 0x01010101 (lomagic) & clear XER[CA] */
-	rotlwi	r6, r7, 31 	/* r6 = 0x80808080 (himagic) */
-	bne-	3f
-	.balign IFETCH_ALIGN_BYTES
-1:	lwzu	r9, 4(r10)
-2:	subf	r8, r7, r9
-	and.	r8, r8, r6
-	beq+	1b
-	andc.	r8, r8, r9
-	beq+	1b
-	andc	r8, r9, r6
-	orc	r9, r9, r6
-	subfe	r8, r6, r8
-	nor	r8, r8, r9
-	cntlzw	r8, r8
-	subf	r3, r3, r10
-	srwi	r8, r8, 3
-	add	r3, r3, r8
-	blr
-
-	/* Missaligned string: make sure bytes before string are seen not 0 */
-3:	xor	r10, r10, r0
-	orc	r8, r8, r8
-	lwzu	r9, 4(r10)
-	slwi	r0, r0, 3
-	srw	r8, r8, r0
-	orc	r9, r9, r8
-	b	2b
-EXPORT_SYMBOL(strlen)
+../../../../../arch/powerpc/lib/strlen_32.S
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/testing/selftests/powerpc/vphn/asm/vphn.h linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/vphn/asm/vphn.h
--- linux-6.16.6/tools/testing/selftests/powerpc/vphn/asm/vphn.h	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/vphn/asm/vphn.h	2025-09-11 09:47:42.000000000 -0600
@@ -1,24 +1 @@
-/* SPDX-License-Identifier: GPL-2.0-or-later */
-#ifndef _ASM_POWERPC_VPHN_H
-#define _ASM_POWERPC_VPHN_H
-
-/* The H_HOME_NODE_ASSOCIATIVITY h_call returns 6 64-bit registers. */
-#define VPHN_REGISTER_COUNT 6
-
-/*
- * 6 64-bit registers unpacked into up to 24 be32 associativity values. To
- * form the complete property we have to add the length in the first cell.
- */
-#define VPHN_ASSOC_BUFSIZE (VPHN_REGISTER_COUNT*sizeof(u64)/sizeof(u16) + 1)
-
-/*
- * The H_HOME_NODE_ASSOCIATIVITY hcall takes two values for flags:
- * 1 for retrieving associativity information for a guest cpu
- * 2 for retrieving associativity information for a host/hypervisor cpu
- */
-#define VPHN_FLAG_VCPU	1
-#define VPHN_FLAG_PCPU	2
-
-long hcall_vphn(unsigned long cpu, u64 flags, __be32 *associativity);
-
-#endif // _ASM_POWERPC_VPHN_H
+../../../../../../arch/powerpc/include/asm/vphn.h
\ No newline at end of file
diff -Nrup linux-6.16.6/tools/testing/selftests/powerpc/vphn/vphn.c linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/vphn/vphn.c
--- linux-6.16.6/tools/testing/selftests/powerpc/vphn/vphn.c	2025-09-09 11:02:41.000000000 -0600
+++ linux-lenovo-x13s-linux-6.16.y/tools/testing/selftests/powerpc/vphn/vphn.c	2025-09-11 09:47:42.000000000 -0600
@@ -1,90 +1 @@
-// SPDX-License-Identifier: GPL-2.0
-#include <asm/byteorder.h>
-#include <asm/vphn.h>
-
-/*
- * The associativity domain numbers are returned from the hypervisor as a
- * stream of mixed 16-bit and 32-bit fields. The stream is terminated by the
- * special value of "all ones" (aka. 0xffff) and its size may not exceed 48
- * bytes.
- *
- *    --- 16-bit fields -->
- *  _________________________
- *  |  0  |  1  |  2  |  3  |   be_packed[0]
- *  ------+-----+-----+------
- *  _________________________
- *  |  4  |  5  |  6  |  7  |   be_packed[1]
- *  -------------------------
- *            ...
- *  _________________________
- *  | 20  | 21  | 22  | 23  |   be_packed[5]
- *  -------------------------
- *
- * Convert to the sequence they would appear in the ibm,associativity property.
- */
-static int vphn_unpack_associativity(const long *packed, __be32 *unpacked)
-{
-	__be64 be_packed[VPHN_REGISTER_COUNT];
-	int i, nr_assoc_doms = 0;
-	const __be16 *field = (const __be16 *) be_packed;
-	u16 last = 0;
-	bool is_32bit = false;
-
-#define VPHN_FIELD_UNUSED	(0xffff)
-#define VPHN_FIELD_MSB		(0x8000)
-#define VPHN_FIELD_MASK		(~VPHN_FIELD_MSB)
-
-	/* Let's fix the values returned by plpar_hcall9() */
-	for (i = 0; i < VPHN_REGISTER_COUNT; i++)
-		be_packed[i] = cpu_to_be64(packed[i]);
-
-	for (i = 1; i < VPHN_ASSOC_BUFSIZE; i++) {
-		u16 new = be16_to_cpup(field++);
-
-		if (is_32bit) {
-			/*
-			 * Let's concatenate the 16 bits of this field to the
-			 * 15 lower bits of the previous field
-			 */
-			unpacked[++nr_assoc_doms] =
-				cpu_to_be32(last << 16 | new);
-			is_32bit = false;
-		} else if (new == VPHN_FIELD_UNUSED)
-			/* This is the list terminator */
-			break;
-		else if (new & VPHN_FIELD_MSB) {
-			/* Data is in the lower 15 bits of this field */
-			unpacked[++nr_assoc_doms] =
-				cpu_to_be32(new & VPHN_FIELD_MASK);
-		} else {
-			/*
-			 * Data is in the lower 15 bits of this field
-			 * concatenated with the next 16 bit field
-			 */
-			last = new;
-			is_32bit = true;
-		}
-	}
-
-	/* The first cell contains the length of the property */
-	unpacked[0] = cpu_to_be32(nr_assoc_doms);
-
-	return nr_assoc_doms;
-}
-
-/* NOTE: This file is included by a selftest and built in userspace. */
-#ifdef __KERNEL__
-#include <asm/hvcall.h>
-
-long hcall_vphn(unsigned long cpu, u64 flags, __be32 *associativity)
-{
-	long rc;
-	long retbuf[PLPAR_HCALL9_BUFSIZE] = {0};
-
-	rc = plpar_hcall9(H_HOME_NODE_ASSOCIATIVITY, retbuf, flags, cpu);
-	if (rc == H_SUCCESS)
-		vphn_unpack_associativity(retbuf, associativity);
-
-	return rc;
-}
-#endif
+../../../../../arch/powerpc/platforms/pseries/vphn.c
\ No newline at end of file
